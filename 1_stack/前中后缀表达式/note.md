双栈解决通用「表达式计算」问题
numStack ： 存放所有的数字(有时也放哨兵左括号)
optStack ：存放所有的操作符(有时也放哨兵左括号)

1. 使用两个栈，numStack 用于存储操作数，optStack 用于存储操作符
2. 从左往右扫描，遇到操作数入栈 numStack
3. 遇到操作符时，如果当前优先级**低于或等于**栈顶操作符优先级，则从 numStack 弹出两个元素，从 optStack 弹出一个操作符，进行计算，将结果并压入 numStack，继续与栈顶操作符的比较优先级。
4. 如果遇到操作符高于栈顶操作符优先级，则直接入栈 optStack
5. 遇到左括号，直接入栈 optStack。
6. 遇到右括号，则从 numStack 弹出两个元素，从 optStack 弹出一个操作符进行计算，并将结果加入到 numStack 中，重复这步直到遇到左括号 最后弹出左括号

`数字/操作符/左括号(操作结束的哨兵)/右括号(狼来了!)`

想清楚

1. 左括号放哪个栈
2. 操作符的权重分配

**前缀表达式**：运算符在操作数之前，也叫波兰表达式
**&(t,f)**
`1106. 解析布尔表达式-前缀表达式`

**中缀表达式**：运算符在操作数之间，计算器、人识别的一般的语法
**1|1|(0&0)&1**
`224. 基本计算器-带括号`
`1597. 根据中缀表达式构造二叉表达式树`
`1896. 反转表达式值的最少操作次数-构造二叉表达式树`

**后缀表达式**：运算符在操作数之后，也叫逆波兰表达式
**['4', '13', '5', '/', '+']**
`150_逆波兰表达式求值-后缀表达式`

实现逆波兰式的算法，难度并不大，但为什么要将看似简单的中缀表达式转换为复杂的逆波兰式？原因就在于这个简单是相对人类的思维结构来说的，对计算机而言中序表达式是非常复杂的结构。相对的，逆波兰式在计算机看来却是比较简单易懂的结构。因为计算机普遍采用的`内存结构是栈式结构，它执行先进后出的顺序`。
