标志：**统计所有区间的最值，暴力枚举会超时**

“笛卡尔树启发式枚举”是一种把“对所有子区间做统计”变成“分而治之＋枚举较小一侧”的技巧，核心思路如下：

1. 用笛卡尔树（Cartesian Tree）把数组 A 建成一棵二叉树，这棵树满足：

   - 堆序性质：每个节点 A[i] 都是其子树中的极值（最大值或最小值）。
   - 中序遍历还原原序列顺序。
     建树时间 O(N)。

2. 在笛卡尔树中，对任意一个节点 mid， 它代表区间 \[L, R)（由建树时单调栈求出的左/右边界）内的最值位置。所有“包含 mid 的子区间”都可以写成 a…b，其中
   L ≤ a ≤ mid < b ≤ R。

3. `要统计或累加这些子区间对答案的贡献时，需要对 a 和 b 做双重枚举。直接双重枚举会退化到 O(N²)。`

4. **启发式枚举**：对 a…b 的双重枚举，只枚举“小的一侧”，并对另一侧做数据结构查询／前缀和／二分查找。  
   例如，如果左侧长度 mid−L+1 小于右侧长度 R−mid，则

   - 枚举 a ∈ [L…mid]（O(mid−L+1) 次），
   - 对每个 a 在右侧用 O(log N) 或 O(1) 时间算出 b 的可行范围／累加量。  
     反之，则枚举右侧 b，再在左侧用查询。

5. 这样每个节点花费 O(min(size(left), size(right)))，全树复杂度满足  
   T(n) = T(left) + T(right) + O(min(|left|,|right|))  
   最坏情况是 O(N log N) 或 O(N log² N)。

总结：  
– 笛卡尔树把“子区间最值”分治化到每个节点。  
– 在“过 mid 的子区间”合并阶段，只枚举较小一侧，另一侧用高效查询／前缀和。  
– 整体做到 N 级别的分治＋“启发式”枚举，降低暴力双重枚举的复杂度。
