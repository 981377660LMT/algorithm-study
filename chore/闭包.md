## 核心理解

### 1. JsQuery 是字符串，通过 new Function 执行

从 runJs.ts 可以看到核心实现：

```typescript
export function execJavaScript(expression: string, ctx: AnyObject, superCtx = {}) {
  // 🔑 用户代码是字符串，通过 new Function 动态创建函数
  const fn = new Function(
    'context',
    'superCtx',
    'shim',
    // 🔑 使用 with 语句注入作用域
    `with(shim) { with(superCtx) { with(context) { return ${expression}; } } }`
  )
  const result = fn(ctx, superCtx, shim)
  return result
}
```

**执行流程图解：**

```
┌────────────────────────────────────────────────────────────────┐
│  用户在编辑器写的 JsQuery（存储为字符串）                          │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │ let user = 1;                                            │  │
│  │ return () => { user++; console.log(user); };             │  │
│  └──────────────────────────────────────────────────────────┘  │
│                              ↓                                  │
│              保存到 schema/数据库（JSON 字符串）                  │
└────────────────────────────────────────────────────────────────┘
                               ↓
┌────────────────────────────────────────────────────────────────┐
│  运行时执行                                                     │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │ new Function(                                            │  │
│  │   'context', 'superCtx', 'shim',                         │  │
│  │   `with(shim) {                                          │  │
│  │      with(superCtx) {                                    │  │
│  │        with(context) {            ← 注入全局上下文        │  │
│  │          return (() => {                                 │  │
│  │            let user = 1;                                 │  │
│  │            return () => { user++; console.log(user); };  │  │
│  │          })();                                           │  │
│  │        }                                                 │  │
│  │      }                                                   │  │
│  │   }`                                                     │  │
│  │ )                                                        │  │
│  └──────────────────────────────────────────────────────────┘  │
└────────────────────────────────────────────────────────────────┘
```

**with 的作用：**

```javascript
// context 包含全局上下文（组件、state、其他 query 等）
const context = {
  table1: { data: [...] },
  state1: { value: 123 },
  query1: { data: {...} },
  // ...
};

// 在 with(context) 中，可以直接访问这些变量
with(context) {
  console.log(table1.data);  // 等价于 context.table1.data
  console.log(state1.value); // 等价于 context.state1.value
}
```

---

### 2. 返回值是运行时实例，闭包引用内存变量

**关键点：返回的函数是"活的"对象，不是字符串！**

```
┌─────────────────────────────────────────────────────────────┐
│  执行 JsQuery1                                               │
│  ┌─────────────────────────────────────────────────────────┐│
│  │ let user = 1;        ← 在 JS 引擎堆内存中分配             ││
│  │ return () => {                                          ││
│  │   user++;            ← 闭包捕获 user 变量的引用           ││
│  │   console.log(user);                                    ││
│  │ };                                                      ││
│  └─────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────┐
│  内存中的状态                                                 │
│  ┌─────────────────────────────────────────────────────────┐│
│  │  堆内存                                                  ││
│  │  ┌─────────────┐      ┌─────────────────────────┐       ││
│  │  │ user: 1     │ ←──── │ function() { user++ }   │       ││
│  │  │ (闭包变量)   │       │ (闭包函数对象)           │       ││
│  │  └─────────────┘      └─────────────────────────┘       ││
│  │                              ↓                          ││
│  │                    存入 jsQuery1.data                    ││
│  └─────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────┐
│  在 JsQuery2 中调用                                          │
│  ┌─────────────────────────────────────────────────────────┐│
│  │ jsQuery1.data();  // user 变成 2，输出 2                 ││
│  │ jsQuery1.data();  // user 变成 3，输出 3                 ││
│  │ jsQuery1.data();  // user 变成 4，输出 4                 ││
│  └─────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────┘
```

**对比：字符串 vs 运行时实例**

| 方面          | 字符串（代码存储）                   | 运行时实例（执行结果）               |
| ------------- | ------------------------------------ | ------------------------------------ |
| **本质**      | `"let user = 1; return () => {...}"` | `function() { user++ }` 真实函数对象 |
| **存储位置**  | 数据库/schema JSON                   | JS 引擎堆内存                        |
| **状态**      | 静态文本                             | 带闭包环境的活对象                   |
| **user 变量** | 只是字符 `u`,`s`,`e`,`r`             | 内存中的数值，可累加                 |

---

## 完整生命周期

```
┌─────────────────────────────────────────────────────────────────┐
│ 1. 编辑时：代码是字符串，存储在 schema 中                          │
│    schema.flowList[x].content.script = "let user = 1; ..."      │
└─────────────────────────────────────────────────────────────────┘
                                ↓
┌─────────────────────────────────────────────────────────────────┐
│ 2. 运行时：new Function + with 执行字符串                        │
│    const fn = new Function(..., `with(ctx) { return ... }`)     │
│    const result = fn(globalContext)  ← result 是函数对象         │
└─────────────────────────────────────────────────────────────────┘
                                ↓
┌─────────────────────────────────────────────────────────────────┐
│ 3. 存储结果：函数对象存入 GlobalContext                           │
│    globalContext.jsQuery1.data = result  ← 运行时实例            │
│    │                                                            │
│    │  ┌──────────────────────────────────────┐                  │
│    └─▶│ 闭包环境：{ user: 1 }                 │                  │
│       │ 函数体：() => { user++; ... }        │                  │
│       └──────────────────────────────────────┘                  │
└─────────────────────────────────────────────────────────────────┘
                                ↓
┌─────────────────────────────────────────────────────────────────┐
│ 4. 调用时：直接执行内存中的函数对象                                │
│    jsQuery1.data()  ← 修改闭包中的 user                          │
│    jsQuery1.data()  ← user 持续累加                              │
└─────────────────────────────────────────────────────────────────┘
                                ↓
┌─────────────────────────────────────────────────────────────────┐
│ 5. 重新执行 JsQuery1：创建新的闭包环境                            │
│    ┌──────────────────────────────────────┐                     │
│    │ 新闭包环境：{ user: 1 }  ← 重新初始化  │                     │
│    │ 新函数体：() => { user++; ... }      │                     │
│    └──────────────────────────────────────┘                     │
│    旧闭包被 GC 回收（如果没有其他引用）                            │
└─────────────────────────────────────────────────────────────────┘
```

---

## 总结

| 概念                   | 说明                                                                   |
| ---------------------- | ---------------------------------------------------------------------- |
| **JsQuery 是字符串**   | 用户代码以文本形式存储，通过 `new Function` 动态编译执行               |
| **with 传 scope**      | 将 `globalContext`（组件、state、query）注入执行环境，让代码能直接访问 |
| **返回值是运行时实例** | 执行结果是真正的 JS 对象（包括函数），存在于堆内存中                   |
| **闭包引用内存变量**   | 返回的函数会"捕获"定义时的词法环境，变量是活的、可修改的               |
