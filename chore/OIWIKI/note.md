## 贪心

- 贪心算法在有最优子结构的问题中尤为有效。最优子结构的意思是问题能够分解成子问题来解决，子问题的最优解能递推到最终问题的最优解 `(dp)`
- 常见的贪心有两种
  离线的，先处理后选择:「我们将 XXX 按照某某`顺序排序`，然后按某种顺序（例如从小到大）选择。」
  在线的，边处理边选择:「我们每次都取 XXX 中`最大/小的东西`，并更新 XXX。」（有时「XXX 中最大/小的东西」可以优化，比如用优先队列维护(`后悔`)）

## 排序应用

- 使用排序预处理可以降低求解问题所需要的时间复杂度。
- 作为二分查找的预处理

## 前缀和与差分

- 基于 DP 计算高维前缀和
- 树上前缀和
  设 sum;表示结点 i 到根节点的权值总和。然后:
  1. 若是点权，x, y 路径上的和为 sumX + sumY - sumlca-sumfalca
  2. 若是边权，x, y 路径上的和为 sumX+ sumY - 2`*` sumlca
- 树上差分(点差分 与 边差分)
  ` 找公共祖先`
  1. 对树上的一些路径(u,v)进行访问，`问一条路径(qu,qv)上的点被访问的次数。`
     对于一次(u,v)的访问，需要找到 u 与 v 的公共祖先
     然后对这条路径上的点进行访问
     因为要区间更新，所以使用差分
     https://oi-wiki.org/basic/prefix-sum/

## 二分

- 三分法可以用来查找凸函数的最大（小）值
  如果 lmid 和 rmid 在最大（小）值的`同一侧`：由于单调性，一定是二者中较大（小）的那个离最值近一些，较远的那个点对应的区间不可能包含最值，所以可以舍弃。
  如果在`两侧`：由于最值在二者中间，我们舍弃两侧的一个区间后，也不会影响最值，所以可以舍弃。
  ```Python
  lmid = left + (right - left >> 1)
  rmid = lmid + (right - lmid >> 1)  # 对右侧区间取半
  if cal(lmid) > cal(rmid):
    right = rmid
  else:
    left = lmid
  ```
- 分数规划
  分数规划可以用二分法来解决

## 倍增(binary lifting)

它能够使线性的处理转化为对数级的处理，大大地优化时间复杂度。

- RMQ 的 ST 表
- 树上倍增求 LCA
- 例子
  如何用尽可能少的砝码称量出 0 到 31 之间的所有重量？

## dp

dp 优化(转移表达式变形+合并项+观察)

- `单调队列/单调栈/有序集合优化`:当前状态的所有值可以从上一个状态的某个连续的段的值得到，要对这个连续的段进行 RMQ 操作，相邻状态的段的左右区间满足非降的关系。
  **从仓库到码头搬运箱子**
- `状态设计优化`
  **LCP 守护太空城**
- 斜率优化/四边形不等式优化(太难了)

## 字符串

- hash

  1.  允许 k 次失配的字符串匹配
      哈希 + 二分可以快速找到第一个不同的位置，重复 k 次

  2.  最长回文子串 nlogn
      二分答案，判断是否可行时枚举回文中心（对称轴），哈希判断两侧是否相等。需要分别预处理正着和倒着的哈希值
  3.  最长公共子字符串
      哈希+二分
  4.  确定字符串中不同子字符串的数量

- ac 自动机:在 trie 上的 kmp 就是 ac 自动机
- kmp/z 函数应用：求字符串整周期
- 自动机:自动机是一个对`信号序列`进行判定的数学模型
  有时我们需要对一个信号序列进行判定。一个简单的例子就是判定一个二进制数是奇数还是偶数，较复杂的例子例如判定一个字符串是否回文，判定一个字符串是不是某个特定字符串的子序列等等。
- 后缀数组：O(n)解决`字符串的不同子字符串个数`问题

## 图

- 斯坦纳树
  最小生成树是在给定的点集和边中寻求最短网络使所有点连通。而最小斯坦纳树允许在给定点外增加额外的点，使生成的最短网络开销最小。
- 最小树形图
  有向图上的最小生成树（Directed Minimum Spanning Tree）称为最小树形图。
  常用的算法是朱刘算法（也称 Edmonds 算法），可以在 O(VE) 时间内解决最小树形图问题
- 最小环
  给出一个图，问其中的有 n(n>=3) 个节点构成的`边权和最小的环` 是多大
  图的最小环也称围长。
  设 u 和 v 之间有一条边长为 w 的边， dist(u,v)表示删除 u 和 v 之间的连边之后， u 和 v 之间的最短路。
  那么无向图中的最小环是 `dist(u,v)+w`
  `枚举所有边，每一次求删除一条边(边权变为无穷大)之后对这条边的起点跑一次 Dijkstra`
  O(E(V+E)logV)

## 在一台机器上规划任务

你有 n 个任务，要求你找到一个代价最小的的顺序执行他们。第 i 个任务花费的时间是 cost[i] ，而第 i 个任务等待 t 的时间会花费`wait[i]*t` 的代价

按照`wait[i]/cost[i]排序`即可
https://oi-wiki.org/misc/job-order/
考虑微扰后的变换情况，排序，贪心地选取最优解
