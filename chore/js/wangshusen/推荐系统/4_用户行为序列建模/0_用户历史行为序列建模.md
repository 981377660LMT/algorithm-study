用户最近 n 次点击、点赞、收藏、转发等行为都是推荐系统中重要的特征，可以帮助召回和排序变得更精准。这节课介绍最简单的方法——对用户行为取简单的平均，作为特征输入召回、排序模型。

---

这节课开启了一个新的重要章节：**行为序列建模 (User Behavior Sequence Modeling)**。这是推荐系统中最核心、提分最显著的模块之一。

这节课作为开篇，介绍了最基础的 **LastN 行为序列** 及其建模方法（即 Pooling / Averaging）。

以下是对这节课内容的深度逻辑拆解与总结：

### 1. 什么是 LastN 行为序列？

- **定义**：用户最近 $N$ 次产生过交互（Interaction）的物品序列。
- **物理意义**：它是用户**短期兴趣**最直接的体现。
  - _例子_：你刚才连续点击了 3 个“红烧肉”的视频，那你的 LastN 序列里就有 3 个美食类物品。即使你的用户画像里写着“科技爱好者”，系统也知道你现在的兴趣是“做饭”。
- **交互类型**：不仅仅是点击序列，还可以细分为：
  - 最近 $N$ 次 **点击 (Click)** 的物品。
  - 最近 $N$ 次 **点赞 (Like)** 的物品。
  - 最近 $N$ 次 **收藏 (Collect)** 的物品。
  - ... 每种行为都可以构成一个独立的序列特征。

### 2. 如何对 LastN 进行建模？(基础版)

王树森老师在这节课介绍了最简单粗暴、也是工业界最常用的 **Average Pooling (平均池化)** 方法。

#### 操作步骤：

1.  **Lookup (查表)**：拿到用户最近点击的 $N$ 个物品 ID，去 Embedding Table 里查出对应的 $N$ 个向量。
    - _进阶_：不光查 ID Embedding，还可以把物品的类目 (Category)、标签 (Tag) 的 Embedding 也查出来拼在一起，信息量更大。
2.  **Average (取平均)**：将这 $N$ 个向量相加后除以 $N$，得到**一个向量**。
    - $$ \mathbf{v}_{user_history} = \frac{1}{N} \sum_{i=1}^{N} \mathbf{v}\_{item_i} $$
3.  **Concat (拼接)**：将这个压缩后的向量，和用户 ID、年龄、性别等其他 User 特征拼在一起，作为最终的用户表示输入模型。

#### 优点：

- **计算极快**：只是简单的加法运算，几乎不增加推理耗时。
- **工程友好**：不论序列长度 $N$ 是 10 还是 100，最后都变成固定长度的一个向量，方便模型处理。
- **效果显著**：相比于只用静态画像，引入 Recent History 带来的提升是巨大的（Often "All Metrics Skyrocket"）。

#### 缺点：

- **信息丢失**：把所有历史行为“揉成一团”，丢掉了**时序信息**（先看 A 再看 B vs 先看 B 再看 A）和**具体的兴趣点**。
- **无差别对待**：比如你在看一个“手机”商品，你的历史记录里有“手机壳”和“衣服”。显然“手机壳”对当前的预测更重要，但 Average Pooling 认为它们权重一样。这引出了后续课程要讲的高级方法（Attention / DIN）。

### 3. 应用场景

- **全链路通用**：
  - **召回 (Double Tower)**：User Tower 的输入里非常依赖这个 pooled vector。
  - **粗排 (Three Tower)**：User Tower 同样依赖它。
  - **精排 (Ranking)**：更是必不可少的强特征。

### 4. 总结

这节课奠定了序列建模的基调：**序列特征是推荐系统的金矿**。最简单的挖掘方式就是把石头（Item Vectors）捡起来，打磨一下（Embedding），然后堆在一起（Average），就已经非常值钱了。后续的 DIN、BST、SIM 等模型，都是为了更精细地挖掘这座金矿。
