### 16.1 蒙特卡罗算法 (Monte Carlo Algorithms)

蒙特卡罗算法是一类在**确定时间内**运行，但其输出有一定概率错误的随机算法。

- **核心特征**：运行时间是固定的，但结果的正确性是概率性的。
- **错误减少**：通过多次独立运行算法并采取“多数表决”或“取平均值”的方法，可以将错误概率指数级降低。
- **典型示例**：
  - **Miller-Rabin 素性测试**：判断一个大数是否为素数。
  - **Freivalds 算法**：在 $O(n^2)$ 时间内验证矩阵乘法 $AB=C$ 的正确性（标准做法需 $O(n^{2.81})$ 或以上）。
- **对比**：与拉斯维加斯算法（Las Vegas Algorithms）不同，后者总是返回正确结果，但运行时间是随机变量（如快速排序）。

### 16.2 集中不等式 (Concentration Inequalities)

集中不等式用于量化随机变量偏离其期望值的程度，是分析随机算法性能的核心工具。

- **马尔可夫不等式 (Markov's Inequality)**：
  对于非负随机变量 $X$， $P(X \ge a) \le \frac{E[X]}{a}$。仅需知道期望，约束最弱。
- **切比雪夫不等式 (Chebyshev's Inequality)**：
  $P(|X - E[X]| \ge k\sigma) \le \frac{1}{k^2}$。利用方差来约束偏离程度。
- **切诺夫界 (Chernoff Bounds)**：
  针对独立随机变量之和。它提供了指数级衰减的概率上界，是证明随机算法“高概率成功”最常用的工具。

### 16.3 伪随机数生成器 (Pseudo Random Number Generators, PRNG)

计算机无法产生真正的随机数，因此使用确定性算法生成模拟随机性的序列。

- **线性同余生成器 (LCG)**：
  公式：$X_{n+1} = (aX_n + c) \pmod m$。简单但周期短，统计特性一般。
- **梅森旋转算法 (Mersenne Twister)**：
  目前最广泛使用的 PRNG（如 Python 的 `random` 库），周期极长（$2^{19937}-1$）且具有良好的高维均匀分布特性。
- **密码学安全 PRNG (CSPRNG)**：
  要求即使给定部分序列，也无法在多项式时间内预测后续数字。

### 16.4 随机打乱 (Random Shuffling)

目标是将一个序列随机排列，使得 $n!$ 种排列出现的概率完全相等（均为 $1/n!$）。

- **Fisher-Yates (Knuth) 洗牌算法**：
  这是最有效且正确的 $O(n)$ 算法。
  1.  从后向前遍历数组（从 $i = n-1$ 到 $1$）。
  2.  生成一个随机整数 $j$，其中 $0 \le j \le i$。
  3.  交换元素 `array[i]` 和 `array[j]`。
- **常见错误**：
  使用 `swap(i, rand(0, n-1))`。这种做法会产生 $n^n$ 种可能的交换路径，而排列只有 $n!$ 种。由于 $n^n$ 通常不能被 $n!$ 整除，导致某些排列出现的概率高于其他排列，分布不均匀。

#### 示例：Fisher-Yates 洗牌代码

```python
import random

def shuffle(arr):
    n = len(arr)
    for i in range(n - 1, 0, -1):
        # 选择一个 0 到 i 之间的随机索引
        j = random.randint(0, i)
        # 交换
        arr[i], arr[j] = arr[j], arr[i]
    return arr
```
