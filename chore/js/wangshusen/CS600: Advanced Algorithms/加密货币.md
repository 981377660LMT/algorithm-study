### 19.1 去中心化支付系统 (Decentralized Payment System)

去中心化支付系统的核心目标是在没有中央权威（如银行）的情况下，实现安全、可靠的价值转移。

- **核心挑战**：
  - **双花攻击 (Double Spending)**：确保同一笔钱不会被支付两次。
  - **拜占庭容错 (BFT)**：在分布式网络中，部分节点可能恶意或失效，系统仍需达成一致。
- **解决方案**：
  - **分布式账本 (Distributed Ledger)**：所有节点共同维护一份完整的交易历史。
  - **共识机制**：通过工作量证明 (PoW) 或权益证明 (PoS) 决定谁有权记账，并奖励诚实节点。
  - **UTXO 模型**：比特币使用的模型，交易由输入和输出组成，通过追踪资金来源防止双花。

### 19.2 区块链 (Blockchain)

区块链是去中心化支付系统的底层数据结构，是一个只允许追加（`Append-only`）的分布式数据库。

- **区块结构**：
  - **区块头**：包含版本号、前一区块哈希（形成链式结构）、**默克尔根**、时间戳、难度目标和随机数（Nonce）。
  - **区块体**：包含该区块记录的所有交易列表。
- **不可篡改性**：
  - 每个区块都包含前一个区块的哈希值。若修改区块 $i$ 的内容，其哈希会改变，导致区块 $i+1$ 中存储的“前一区块哈希”失效，从而产生连锁反应。
  - 在 PoW 机制下，篡改历史需要重算后续所有区块的功耗，这在计算上是极其困难的。

### 19.3 默克尔树 (Merkle Tree)

默克尔树是一种哈希二叉树，用于高效地验证大规模数据的完整性。

- **构造方式**：
  1.  将每笔交易进行哈希处理，作为叶子节点。
  2.  两两成对进行哈希，生成上一层节点。
  3.  重复此过程，直到产生唯一的根节点，称为 **默克尔根 (Merkle Root)**。
- **核心优势**：
  - **轻客户端验证 (SPV)**：用户无需下载整个区块，只需获取默克尔根和一条从特定交易到根的**路径（Merkle Proof）**，即可在 $O(\log n)$ 时间内验证该交易是否存在于区块中。
  - **空间效率**：区块头只需存储 32 字节的根哈希，即可代表成千上万笔交易。

#### 示例：默克尔树路径验证逻辑

```python
import hashlib

def hash_pair(a, b):
    return hashlib.sha256((a + b).encode()).hexdigest()

# 假设有 4 笔交易的哈希
tx_hashes = ['tx1', 'tx2', 'tx3', 'tx4']

# 计算默克尔根
level1_0 = hash_pair(tx_hashes[0], tx_hashes[1])
level1_1 = hash_pair(tx_hashes[2], tx_hashes[3])
merkle_root = hash_pair(level1_0, level1_1)

# 验证 tx1 是否在树中，只需提供 tx2 和 level1_1 (Merkle Proof)
def verify_proof(tx_hash, proof, root):
    # proof = [tx2_hash, level1_1_hash]
    current = tx_hash
    for p in proof:
        current = hash_pair(current, p) # 实际需根据左右位置决定顺序
    return current == root
```
