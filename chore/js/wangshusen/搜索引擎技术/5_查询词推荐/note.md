# 深度解析：搜索引擎中的查询词推荐体系

查询词推荐（Query Recommendation, QR）在现代搜索引擎中已不再单纯是降低用户输入成本的“辅助工具”，而是演变为**流量分发**与**搜索意图激发**的核心引擎。

从架构上看，搜索链路决定了“用户搜 $q$ 之后看到什么文档”，而查询词推荐则决定了“用户到底会搜什么 $q$”。它控制了搜索系统的入口流量构成，直接对搜索日活（Search DAU）与搜索渗透率负责。

## 一、 业务场景的本质解构

文档将查询词推荐明确划分为四个核心场景，这四个场景并非简单的位置不同，其背后的**产品意志**与**算法目标**存在本质差异：

### 1. 搜前推词（Pre-Search Recommendation）

- **本质**：**“激发”**。这是一个标准的个性化推荐系统（RecSys），区别在于推荐的 Item 不是视频或商品，而是“搜索意图”。
- **场景**：搜索框底纹、猜你想搜、热榜。
- **核心逻辑**：将用户从“被动浏览”转化为“主动搜索”。这是提升 APP 搜索渗透率（Search DAU / App DAU）的关键战场。
- **洞察**：单纯追求推荐词的点击率（CTR）是短视的。如果用户点击了推荐词，但在后续的搜索结果页（SERP）无点击离开，则是一次失败的推荐。因此，搜前推词必须为**全链路转化**负责。

### 2. 搜中建议（SUG - Suggestion）

- **本质**：**“工具”**。与搜前的高个性化不同，SUG 追求极致的**效率**与**准确性**。
- **核心逻辑**：实时补全、纠错。
- **评价体系**：不同于其他场景看重“逛一逛”的属性，SUG 考核“使用率”和“输入长度”。输入越短，点击位置越靠前，说明工具属性越强。

### 3. 搜后扩展（Related Search）

- **本质**：**“延伸”**。基于当前查询词 $q$ 推荐 $q'$。
- **核心逻辑**：Item-to-Item (Query-to-Query) 的关联。目标是**加深消费深度**和**拓宽兴趣宽度**。
- **差异点**：这里的“相关”不是语义重复，而是逻辑上的从属或关联（例如搜“日料”推“寿司之神”，而不是推无意义的同义词）。

### 4. 文档内推词（In-Document Recommendation）

- **本质**：**“发现”**。基于文档 $d$ 推荐查询词 $q$。
- **核心逻辑**：Document-to-Query (D2Q)。
- **商业价值**：在内容消费平台（如抖音、小红书），这是将内容流量转化为搜索流量的重要手段，形成“看-搜-看”的闭环。

---

## 二、 核心召回技术的演进与壁垒

文档中详细阐述了从规则到深度学习的召回体系，其中**行为协同**与**语义理解**的结合是技术难点。

### 1. SUG 召回的精细化

SUG 绝非简单的字符串前缀匹配。成熟的 SUG 系统包含多层漏斗：

- **基础层**：前缀匹配（汉字/拼音）、分词包含（“迪士尼”召回“上海迪士尼”）。
- **智能层**：
  - **核心词提取**：当长句无法匹配时，提取核心词（如“如何制作蛋挞”提取“蛋挞”）进行泛化召回。
  - **生成式召回**：跨越文本匹配的限制（如“日语慢速”生成“日语慢速**教学视频**”），这通常需要 Bigram 关联矩阵来校验生成的合理性。

### 2. Query-to-Query (Q2Q) 的算法博弈

Q2Q 是搜后推荐和搜前推荐（基于历史 $q$）的基石。文档提到了三种关键范式：

- **ItemCF (基于物品的协同过滤)**
  - **原理**：$q_1$ 和 $q_2$ 相似，是因为搜过它们的用户集合 $W_1$ 与 $W_2$ 重合度高。
  - **缺陷**：容易受热门词影响，且无法区分“真正兴趣相似”与“噪声数据”。

- **Swing 算法 (阿里提出，核心亮点)**
  - **洞察**：ItemCF 容易被“小圈子”（Cliques）误导。如果一群用户互相之间非常相似（例如某个刷单群、或者极小众的固化圈子），他们共同搜索的行为不应被过度放大。
  - **改进**：在计算相似度时，引入用户重合度 $overlap(u_1, u_2)$ 作为惩罚项。
  - **公式精髓**：
    $$sim(q_1, q_2) = \sum_{u_1 \in V} \sum_{u_2 \in V} \frac{1}{\alpha + overlap(u_1, u_2)}$$
    若 $u_1$ 和 $u_2$ 重合度极高（历史行为高度一致），则他们共同贡献的相似度权重会被 **降权**。这是工业界处理协同过滤噪声的**真知灼见**。

- **双塔模型 (Vector Retrieval)**
  - 解决协同过滤无法处理“冷启动”和“语义相关”的问题。通过构建 Query 向量，计算 Cosine 相似度。

### 3. Document-to-Query (D2Q) 的生成与检索

如何从一篇文档推荐查询词？

- **生成式 (Generative)**：利用 Transformer/LLM 阅读文档生成 $q$。由于算力昂贵，通常采用**近线 (Near-line)** 计算，即文档发布后进入队列异步生成，而非实时。
- **行为式 (Behavioral)**：利用 ItemCF 思想，计算“点击文档 $d$ 后 $t$ 时间内搜索 $q$”的共现概率。这种方法召回的词通常具有极强的**引导性**。

---

## 三、 关键洞察：推荐与搜索的“对抗”与“协同”

文档中并未止步于算法介绍，而是提出了一个极具深度的业务观点：**推词系统的边界**。

### 1. 推荐质量的终极试金石：SERP 承接能力

推词系统推得准（点击率高）并不代表成功。

- **案例**：如果推荐“免费领取 iPhone 15”，用户点击率极高（诈骗式诱导），但跳转到搜索结果页主要为辟谣或无相关内容，导致用户失望离开。
- **结论**：推词模型不仅仅要预测 $P(click|query)$，更要隐式地预测后续搜索结果的质量。**“不推生僻词、不推无供给词、不推历史转化差的词”**应成为推词系统的负向过滤准则。

### 2. 长尾与头部

- **热榜/底纹**：聚集头部流量，非个性化，用于兜底。
- **个性化推荐**：负责长尾流量的分发。
- **Swing vs ItemCF**：Swing 的引入正是为了解决协同过滤在处理各种异常流量和非真实兴趣关联时的鲁棒性问题。

### 3. DAU 的杠杆

- **搜索渗透率**是核心北极星指标。
- 搜前推词和文档内推词是**做大蛋糕**（创造新的搜索需求）。
- SUG 和 搜后推词是**切分蛋糕**（提升现有搜索的体验）。

## 总结

这两份文档揭示了搜索引擎中“主动推荐”侧的完整技术栈。核心难点不在于模型结构的复杂性，而在于：

1.  **数据清洗与噪声抑制**（如 Swing 算法的应用）。
2.  **跨场景的意图理解**（用户看什么文档 -> 转化为什么搜索词）。
3.  **全链路的指标对齐**（推词点击率 vs 搜索满意度）。

这是从“被动检索”向“主动信息分发”转型的关键技术体系。

---

## 📚 查询词推荐技术深度解析

这两份材料构成了一个完整的查询词推荐系统知识体系：**第21章讲场景和指标**，**第22章讲召回技术**。让我用逻辑化的方式帮你理解。

---

## 一、核心概念：查询词推荐的本质

### 🎯 为什么需要查询词推荐？

文档中有个关键洞察：

> **"大部分的搜索请求来自于推荐的查询词、而非用户完整输入的查询词"**

这说明查询词推荐不是锦上添花，而是**搜索引擎的核心流量入口**。它解决了三个问题：

1. **激发需求**：用户原本不知道搜什么 → 看到推荐词产生兴趣
2. **提高效率**：减少输入成本（SUG使用率>50%）
3. **拓展兴趣**：让用户发现更多相关内容

---

## 二、四大应用场景深度剖析

### 1️⃣ **搜索前推词**（猜你想搜）

**场景特点**：

- 用户还没想好搜什么，甚至没打开搜索框
- 完全基于**个性化**（用户历史+画像）
- 包括：底纹词、猜你想搜、热榜

**技术挑战**：

```
用户意图 = ∅  →  需要从历史行为预测兴趣点
```

**评价指标**：

- **SearchDAU/DAU比值** ← 核心指标（提升搜索渗透率）
- 有点比（点击率）
- 转化指标（搜索结果页表现）

**关键逻辑**：这个场景的目标是**创造搜索行为**，所以用搜索渗透率衡量。

---

### 2️⃣ **查询建议**（SUG - Suggestion）

**场景特点**：

- 用户**正在输入**查询词
- 实时补全和纠错
- 工具属性强（效率优先）

**技术特点**：

```
输入: "苹果"
↓
实时召回: ["苹果手机", "苹果官方商城", "苹果iPad新款", ...]
```

**评价指标**：

- **SUG使用率**（通常>50%）← 说明工具有用
- **点击位置**（越靠前越好）← 唯一关注位置的场景
- 输入长度（越短越好）

**为什么SUG特别关注点击位置？**

> SUG是**工具**，其他推词是**推荐**。工具需要精准高效，推荐可以"逛一逛"。

---

### 3️⃣ **搜索结果页推词**（相关搜索）

**场景特点**：

- 用户已经搜了查询词`q`
- 基于`q`推荐相关的`q'`
- 插入在搜索结果文档之间

**技术挑战**：

```
原查询: q = "日料"
相关搜索: q' = ["上海自助餐", "寿司之神"]  ✅
不相关: q' = ["灌篮高手结局"]  ❌
```

**评价指标**：

- **消费深度**（用户搜索的查询词数量）
- **兴趣宽度**（查询词类目的多样性）

**本质**：这是用`q`找`q'`，类似于搜索引擎，但检索对象是查询词而非文档。

---

### 4️⃣ **文档内推词**

**场景特点**：

- 用户正在阅读文档`d`
- 基于`d`推荐查询词`q`
- 目标是深挖和扩展兴趣

**关键洞察**：

> "推荐的目标并不是找出d最相关的q，而是继续深挖和扩展"

**案例分析**：

```
文档d: 介绍寿司类型的文章
❌ q = "寿司种类" （最相关但用户已经在看）
✅ q = "上海寿司店"、"寿司的做法"（深挖和扩展）
```

**评价指标**：

- 查询词点击率
- SearchDAU/DAU比值（创造搜索行为）

---

## 三、评价指标体系的深层逻辑

### 📊 指标矩阵

| 场景       | 有点比 | 点击位置 | 转化率 | 搜索渗透率 |
| ---------- | ------ | -------- | ------ | ---------- |
| 搜前推词   | ✅     | -        | ✅     | ✅         |
| SUG        | ✅     | ✅       | ✅     | -          |
| 搜索结果页 | ✅     | -        | ✅     | -          |
| 文档内推词 | ✅     | -        | ✅     | ✅         |

### 🔍 转化率的特殊性

文档提出了一个深刻问题：

> "推词链路无法控制搜索结果页曝光什么文档，那如何控制转化率？"

**答案**：通过**查询词质量判断**

```python
# 伪代码逻辑
def should_recommend(query):
    # 基于历史统计预测转化率
    if is_rare(query):  # 生僻词
        return False
    if related_docs_count(query) < threshold:  # 相关文档少
        return False
    if historical_ctr(query) < threshold:  # 历史点击率低
        return False
    return True
```

**关键**：推词系统通过避免推荐"转化率低的查询词"来控制转化。

---

## 四、召回技术深度解析

### 🎯 召回依据总结

| 场景       | 召回依据       |
| ---------- | -------------- |
| 搜前推词   | 用户兴趣       |
| SUG        | 当前查询词片段 |
| 搜索结果页 | 当前查询词     |
| 文档内推词 | 当前文档       |

---

### 1️⃣ **SUG召回**（3种基于拼写的方法）

#### **前缀召回**

```
输入: "上海"  → "上海迪士尼"
输入: "美j"   → "美甲" (拼音前缀)
```

#### **分词召回**

```
通用分词: "迪士尼" → "上海迪士尼" (包含关系)
首字召回: "上迪士尼" → "上海迪士尼"
核心词召回: "如何制作蛋挞" → "蛋挞做法"
```

#### **拼写召回**

```
拼音简写: "shdsn" → "上海迪士尼"
同音字: "喜皮士" → ["喜啤士", "西皮士", "嬉皮士"]
```

**技术特点**：SUG完全不同于其他场景，强调**实时性**和**文本匹配**。

---

### 2️⃣ **Q2Q召回**（用查询词召回查询词）

这是除SUG外其他场景的核心召回方法。

#### **方法1：ItemCF（协同过滤）**

**核心思想**：如果多个用户同时搜索了`q₁`和`q₂`，则这两个词相似。

**公式**：

```
sim(q₁, q₂) = |V| / √(|W₁| · |W₂|)

其中：
- V = 同时搜过q₁和q₂的用户集合
- W₁ = 搜过q₁的用户集合
- W₂ = 搜过q₂的用户集合
```

**案例**：

```
搜"梅西"的用户，很可能也搜：
- "阿根廷国家队"
- "巴萨"
- "巴黎圣日耳曼"
```

**优点**：能捕捉**语义不相关但兴趣一致**的查询词。

---

#### **方法2：Swing（阿里巴巴2020）**

**ItemCF的问题**：小圈子用户会导致虚高的相似度

```
例子：薅羊毛微信群
- 几百人今天搜q₁，明天搜q₂
- ItemCF会认为q₁和q₂高度相关
- 但实际上两个词可能毫无关系
```

**Swing的改进**：考虑用户兴趣的广泛程度

**公式**：

```
sim(q₁, q₂) = Σ Σ 1 / (α + overlap(u₁, u₂))
             u₁∈V u₂∈V

其中：
- overlap(u₁, u₂) = 两用户搜过的查询词交集大小
- 重合度越高 → 权重越低（避免小圈子）
```

**关键洞察**：

- V中用户数量多 ✅
- 用户两两不相似 ✅
- → q₁和q₂相似度高

---

#### **方法3：向量召回（双塔模型）**

**模型结构**：

```
查询词 → BERT Embedding → 全连接层 → 向量
         ↓
    文本 + 类目 + 核心词
```

**训练样本**：

```
正样本：用户搜q后点击的推荐词q'  → (q, q')
负样本：随机抽样 / batch内负样本 / 困难负样本
```

**关键点**：样本构造比模型结构更重要！

---

### 3️⃣ **D2Q召回**（用文档召回查询词）

用于搜前推词和文档内推词。

#### **方法1：生成式召回**

```
文档文本 → Transformer → 生成查询词 → BERT判别 → 过滤低分词
```

**特点**：

- 算力需求大
- 适合离线/近线计算（消息队列+延迟几分钟）

#### **方法2：向量召回**

```
复用相关性双塔模型
文档 → 向量 → 检索相似查询词 → BERT过滤
```

#### **方法3：ItemCF（基于行为）**

**核心思想**：用户先点击文档`d`，然后搜索查询词`q` → d和q相关

**公式**：

```
sim(d → q) = |V| / √(|U| · |W|)

其中：
- V = 点击d后搜q的用户
- U = 点击过d的用户
- W = 搜过q的用户
```

**限制条件**：

- 时间窗口：t = 2天内
- 序列长度：前l = 3条查询词

**原因**：这样的查询词可能是受文档激发的。

---

### 4️⃣ **各场景的召回策略组合**

#### **搜前推词**：完全基于用户兴趣

```
U2Q2Q: 用户历史查询词 → Q2Q → 召回查询词
U2D2Q: 用户交互文档 → D2Q → 召回查询词
```

**实现细节**：

```python
# U2Q2Q
recent_queries = get_recent_n1_queries(user)
random_queries = random_sample_n2_queries(user)
seed_queries = recent_queries + random_queries  # n条种子
for q in seed_queries:
    召回m条相关查询词  # Q2Q
# 最多召回 m×n 条
```

#### **搜索结果页推词**：基于当前查询词

```
当前查询词q → Q2Q → 召回相关查询词
```

#### **文档内推词**：基于当前文档

```
D2Q: 文档d → 召回n条查询词
D2Q2Q: 文档d → D2Q召回qi → Q2Q召回qi' → 合并结果
```

---

## 五、技术架构的系统性思考

### 🏗️ 整体架构

```
              词库（精品词库 + 热门1000万 + 外网词）
                          ↓
        ┌─────────────────┴─────────────────┐
        │                                   │
   离线索引构建                        在线召回
        │                                   │
  ├─ q→List<q'> (Q2Q)                  触发场景
  ├─ d→List<q> (D2Q)                       ↓
  └─ u→List<q>, u→List<d>          召回 → 排序 → 展示
```

### 🔄 召回-排序分离

```
召回：快速返回候选集（数百-数千）
      ├─ 基于规则（SUG）
      ├─ 基于索引（ItemCF, Swing）
      └─ 基于向量（双塔模型）

排序：精准打分排序（最终展示几条-十几条）
      ├─ 个性化模型
      ├─ 多目标优化
      └─ 业务规则调控
```

---

## 六、关键技术点总结

### ✨ 核心洞察

1. **SUG是工具，其他推词是推荐** → 评价指标不同
2. **推词需要为转化负责** → 通过预测查询词质量控制
3. **小圈子问题** → Swing通过用户重合度解决
4. **文本相关≠兴趣相关** → ItemCF捕捉行为模式
5. **样本质量>模型结构** → 双塔模型的关键在正负样本

### 🎓 学习建议

1. **理解业务逻辑**：每个场景的目标不同，技术服务于业务
2. **掌握召回技术**：ItemCF/Swing/双塔是基础，可迁移到其他推荐场景
3. **关注指标设计**：指标反映了对问题的理解深度
4. **实践优化方向**：
   - 召回：多路召回+去重
   - 排序：多目标模型（点击+转化+多样性）
   - 样本：正负样本构造、难例挖掘
