# 16 文本召回：成熟但不可忽视的“第一性工程”，核心在倒排索引与召回策略

本章信息量不大，但非常关键：

- 文本召回是**最基础、最稳定、最便宜**的召回通道
- 工业界通常不会在“倒排索引本身”上花大量算法资源（更多是工程/系统优化）
- 算法工程师真正能影响效果的地方在：**召回逻辑、松弛策略、词距/短语约束、与上游 QP（分词/改写/词权重）的联动**

你可以把文本召回看成：

> 用倒排索引把候选集从“数亿文档”缩小到“数万候选”，并尽量别把真正相关的文档漏掉。

---

## 16.1 倒排索引：不仅是“词→文档列表”，还要为打分存信息

倒排索引的最简形式是：

- **index term（词）** $t$ → **posting list（倒排表）** $\langle d\rangle$

但真实系统里，文本召回之后还要算 BM25、词距（proximity）等匹配分数，所以 posting 中通常至少要包含：

- $tf_{t,d}$：词 $t$ 在文档 $d$ 中出现次数
- $L_{t,d}$：词 $t$ 在文档 $d$ 中出现的位置列表

因此可理解为：

- $t \to \{(d, tf_{t,d}, L_{t,d})\}$

这点非常重要：**“索引结构设计”直接决定了“你线上能算什么分数”**。如果索引不存位置，后面就很难做短语/近邻约束；如果索引不存词频，BM25 就要额外查别的结构或退化。

---

## 16.1.1 建索引：三种经典套路对应三种资源约束

本章提了三种经典算法，可以用“内存是否装得下”来理解：

- **两次遍历算法**：
  - 第一次遍历统计规模，估算每个 term 的存储需求
  - 第二次遍历真正填充 posting
  - 优点：结构清晰、性能好；缺点：需要内存支撑、两次扫全量

- **排序算法（Sort-based）**：
  - 先生成大量四元组 $(t,d,tf,L)$
  - 内存满了就按 $(t,d)$ 排序落盘
  - 最后把多个有序段归并
  - 关键工程点：需要一直维护词典（term→id）

- **归并算法（Merge-based / Blocked）**：
  - 每次处理一块文档，块内建局部倒排
  - 局部倒排满了就落盘，最后多路归并成全量索引
  - 优点：天然可并行，适合 MapReduce；而且不一定要一直维护全量词典

工程直觉：

- 当你上规模（海量文档、分布式）时，**归并思路更自然**：块内局部、块间归并。

---

## 16.1.2 索引更新：删除最难，常用“后置过滤”兜底

线上文档不断新增/删除/修改。

- **新增**：常用“内存临时索引”（增量段）保证新文档可检索；再定时把增量并入主索引。
- **删除**：从每个 term 的 posting list 删除该文档代价太高。
  - 常见做法：维护一张“有效文档 ID 哈希表”，召回后做过滤（post-filter）。
- **修改**：工程上常近似为“旧文档删除 + 新文档新增”。

这套策略背后其实是一个现实：

- 倒排索引擅长追加写（append）和批量构建
- 对 posting 做随机删除/插入，代价和复杂度都非常高

---

## 16.1.3 分布式索引：工业界更偏爱“按文档划分”

两种划分：

- **按词划分（term-partitioned）**：每台机器只存一部分词的完整 posting。
  - 查询时每个词只命中某一台机器，但多词查询要发往多台。

- **按文档划分（document-partitioned）**：每台机器几乎有完整词典，但只覆盖 $n/k$ 文档。
  - 查询时对每台机器独立检索并行返回结果，再汇总。

本章强调实践更常见“按文档划分”，原因很工程化：

- 易并行、节点间几乎无通信
- 节点挂掉影响小（召回量减少但用户感知弱）
- 负载更均衡

---

## 16.2 文本召回：布尔检索 + 词距约束 + 松弛（丢词）

### 16.2.1 布尔检索：同义扩展会把 AND 变成“OR 扩展再 AND”

典型流程：

1. 分词得到 $Q=\{t_1,\dots,t_m\}$
2. 做同义词/别名扩展：$t_i \Rightarrow (t_i^1 \lor t_i^2 \lor \cdots)$
3. 做布尔检索：组内 OR，组间 AND

这会显著扩大候选集：

- 召回更足
- 但噪声也更大

所以文本召回从来不是“命中就相关”。

### 16.2.2 词距（proximity）：解决“词都出现但语义无关”

本章给了经典反例：“亚马逊雨林”命中“亚马逊网购 + 热带雨林”这种拼接文本。

如果索引存了位置 $L_{t,d}$，就可以加约束：

- 两个词距离 $\le k$ 才召回（短语/近邻检索的雏形）

工程理解：

- 词距约束本质是在召回阶段做一层“更强的匹配”，把明显不相关的候选砍掉，减轻下游排序压力。

### 16.2.3 松弛召回：当“少结果/无结果”时，按词权重丢词

当 query 很长或很生僻，AND 约束太强导致候选不足，就要松弛：

- 例如 $m\ge 4$ 时只要求命中 75% 的词
- 如果召回量仍低于阈值（如 45），继续丢更多非核心词

关键前提：**你得知道哪些词是核心/非核心**。

这直接依赖第 12 章的“词权重”。也就是说：

- 文本召回要做得稳，离不开上游 QP 给出的“词必要性信号”。

---

## 16.3 工程检查清单（真正会踩坑的点）

- 索引未存位置：做不了词距/短语约束，噪声召回只能丢给排序处理，成本更高
- 删除不做后置过滤：会频繁召回无效文档，用户体验/稳定性显著变差
- 分布式按词划分但缺少良好的路由与超时治理：多词查询容易拖垮尾延迟
- 松弛策略不看词权重：一旦丢错核心词，召回会“量上去但意图变了”，排序很难救

---

## 16.4 练习（建议动手）

1. 任选 100 个 query，手工判断“哪些词必须 AND、哪些词可 OR、哪些词可丢”，写出你自己的松弛策略。
2. 为常见二词 query 设计一个词距约束（如 $\pm 5$），观察对噪声召回的影响（可用人工抽样评估）。
3. 结合第 15 章改写：对每个 query 生成若干改写，再比较“改写前后文本召回候选集的规模与相关性”。

---

## 16.5 与其它章节的连接

- 与第 11/12 章：分词正确性 + 词权重直接决定布尔逻辑与丢词策略
- 与第 15 章：改写会改变召回逻辑（OR 扩展），需要与词距/松弛联动
- 与第 17 章：向量召回解决语义鸿沟；文本召回解决精确匹配与稳定供给
- 与第 19–20 章：召回阶段做得越“干净”，下游排序越省成本、越稳定
