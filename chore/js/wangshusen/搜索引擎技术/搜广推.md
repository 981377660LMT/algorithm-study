“搜广推”是互联网核心变现和流量分发技术的三驾马车：**搜索 (Search)**、**广告 (Advertising)** 和 **推荐 (Recommendation)**。

尽管业务目标不同，但它们在底层技术架构、算法模型和数据流处理上有着极高的一致性。以下是针对这三个领域的深入讲解，涵盖架构、核心流程和关键技术。

### 1. 核心业务差异与共性

- **搜索 (Search)**：用户主动表达意图（Query），系统返回最相关的结果。指标关注相关性（Relevance）、点击率（CTR）和满足度。
- **推荐 (Recommendation)**：用户无明确意图，系统基于用户历史行为猜测其兴趣。指标关注留存、时长、CTR。
- **广告 (Ads)**：即商业化，流量的变现。既可以在搜索中出现（SEM），也可以在推荐流中出现（信息流广告）。指标关注 eCPM (effective Cost Per Mille)、收入、ROI。

**共性**：本质都是**匹配问题 (Matching)**，即在海量候选集（Item）中找到最匹配用户（User）的内容，并进行排序。

### 2. 通用技术架构：漏斗模型

为了在毫秒级处理海量数据，这三个系统通常采用多阶段的**漏斗架构**：

1.  **召回 (Matching/Retrieval)**：

    - **目标**：从亿级候选集中快速筛选出几千个候选。
    - **技术**：
      - **倒排索引**（搜索核心）：基于关键词匹配。
      - **协同过滤**（ItemCF/UserCF）：基于行为相似度。
      - **双塔模型 (DSSM)**：分别为 User 和 Item 生成 Embedding 向量，通过 ANN（近似最近邻搜索，如 Faiss）进行向量检索。
      - **图神经网络 (Graph Embedding)**：DeepWalk, Node2Vec。

2.  **粗排 (Pre-Ranking)**：

    - **目标**：对召回的几千个结果进行轻量级排序，筛选出几百个。
    - **技术**：使用简单的双塔模型或逻辑回归（LR），计算速度快。

3.  **精排 (Ranking)**：

    - **目标**：对剩下的几百个结果进行精确打分，决定由于展示顺序。这是算力消耗最大、模型最复杂的环节。
    - **技术**：
      - **特征工程**：用户画像、上下文、物品特征、交叉特征。
      - **模型**：Wide & Deep, DeepFM, DIN (Deep Interest Network), MMOE (多目标学习)。

4.  **重排 (Re-Ranking)**：
    - **目标**：业务规则干预和多样性打散。
    - **技术**：去除重复内容（强规则）、MMR（最大边际相关性）、流量扶持、广告混排。

### 3. 核心算法模型演进

模型的发展主要致力于解决特征交叉和序列建模问题：

- **逻辑回归 (LR) + GBDT**：也就是传统的机器学习时代，特征工程主要靠人工。
- **Wide & Deep (Google)**：深度学习时代的开山之作。Wide 侧负责记忆（记忆历史组合），Deep 侧负责泛化（探索未知）。
- **DeepFM**：自动进行特征交叉，不再依赖人工构造组合特征。
- **DIN (Deep Interest Network) / DIEN**：阿里提出的模型，引入 **Attention 机制**。它认为用户对不同商品的兴趣权重是不同的，根据当前候选商品去“激活”用户的历史行为序列。
- **多目标学习 (Multi-Task Learning, MTL)**：如 **MMoE (Multi-gate Mixture-of-Experts)** 和 **PLE**。解决既要高点击率（CTR），又要高转化率（CVR），甚至还要看时长等多个冲突目标的平衡问题。

### 4. 数据流与工程架构

除了算法，工程架构同样关键：

- **离线训练 (Offline Training)**：

  - 使用 Spark/Flink 处理日志（Impression, Click, Conversion）。
  - 生成样本（TFRecord/Parquet），存入 HDFS/S3。
  - 全量更新模型参数。

- **在线服务 (Online Serving)**：

  - TensorFlow Serving / TorchScript / Triton Inference Server。
  - 要求极高的低延迟（Latency < 50ms）。

- **近线/实时流 (Nearline/Real-time)**：
  - **ODL (Online Deep Learning)**：用户刚点的行为，秒级更新到模型中。
  - 利用 Kafka + Flink 实时更新 Feature Store (Redis/Cassandra) 中的用户特征。

### 5. 代码示例：双塔召回模型 (TensorFlow/Keras)

这是一个简化的双塔模型结构代码，常用于召回阶段。

```python
import tensorflow as tf
from tensorflow.keras import layers, Model

def create_two_tower_model(user_vocab_size, item_vocab_size, embedding_dim=64):
    """
    创建一个简单的双塔模型用于召回
    """
    # --- User Tower ---
    user_input = layers.Input(shape=(1,), name='user_id')
    # User Embedding
    user_embedding = layers.Embedding(input_dim=user_vocab_size, output_dim=embedding_dim)(user_input)
    user_embedding = layers.Flatten()(user_embedding)
    # User Dense Layers
    user_vec = layers.Dense(128, activation='relu')(user_embedding)
    user_vec = layers.Dense(64, activation='relu', name='user_embedding_final')(user_vec)

    # --- Item Tower ---
    item_input = layers.Input(shape=(1,), name='item_id')
    # Item Embedding
    item_embedding = layers.Embedding(input_dim=item_vocab_size, output_dim=embedding_dim)(item_input)
    item_embedding = layers.Flatten()(item_embedding)
    # Item Dense Layers
    item_vec = layers.Dense(128, activation='relu')(item_embedding)
    item_vec = layers.Dense(64, activation='relu', name='item_embedding_final')(item_vec)

    # --- Interaction (Dot Product) ---
    # 计算用户向量和物品向量的点积，作为相似度分数
    dot_product = layers.Dot(axes=1)([user_vec, item_vec])
    output = layers.Dense(1, activation='sigmoid')(dot_product)

    model = Model(inputs=[user_input, item_input], outputs=output)

    model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])
    return model

# 示例使用
if __name__ == "__main__":
    model = create_two_tower_model(user_vocab_size=10000, item_vocab_size=5000)
    model.summary()
```

### 总结

学习“搜广推”，建议的学习路径为：

1.  **基础**：熟悉 LR, SVM, 协同过滤，理解准确率、召回率、AUC 等指标。
2.  **深度模型**：精读 Wide&Deep, DeepFM, DIN, DSSM 等经典论文。
3.  **工程落地**：学习 Feature Store 的设计，了解 Faiss 向量检索，熟悉 TensorFlow Serving 或 C++ 推理引擎的优化。

---

既然你已经掌握了**搜索（Search）**和**推荐（RecSys）**，你实际上已经完成了广告技术（AdTech）**70%** 的技术储备。

因为：

- **架构一致**：都是 召回 -> 粗排 -> 精排 -> 重排 的漏斗。
- **模型通用**：DeepFM, DIN, MMOE 等 CTR 预估模型在广告里也是核心。
- **工程相似**：都需要高并发、低延迟、Feature Store、流式计算。

你需要补齐的剩下的 **30%**，主要集中在**商业逻辑、机制设计**和**转化链路**上。

以下是针对这类人群的“差异化”学习路径：

### 1. 核心思维转变：从“两方”到“三方”博弈

- **搜/推**：是 **用户（User）** 和 **平台（Platform）** 的两方博弈。目标是 User Satisfaction (时长、点击)。
- **广告**：是 **用户**、**平台**、**广告主（Advertiser）** 的三方博弈。
  - 用户要体验（不反感）。
  - 广告主要 ROI（投产比）。
  - 平台要收入（Revenue）。

**核心公式变化：**
搜推排序依据通常是 $Score = pCTR$。
广告排序依据是 **eCPM (千次展示收益)**：
$$eCPM = pCTR \times pCVR \times Bid$$

### 2. 第一课：机制设计 (Mechanism Design)

这是广告独有的，你需要理解“怎么扣费”和“怎么出价”。

- **拍卖机制 (Auction)**：
  - **GSP (Generalized Second Price)**：广义第二计费。目前主流机制。赢家不用付自己的出价，只付**第二名出价 + 0.01 元**。
    - _原理_：为了鼓励广告主说真话（Truthful Bidding），按心理价位出价。
  - **VCG**：Facebook 等在使用，基于社会福利损失计费，理论更优但解释成本高。
- **计费模式**：
  - **CPC** (Cost Per Click)：按点击结算。平台承担点击率风险。
  - **CPM** (Cost Per Mille)：按展示结算。广告主承担点击率风险（品牌广告多用）。
  - **oCPM / oCPC** (Optimized Cost Per ...)：智能出价。**这是目前的绝对主流**。广告主设置目标成本（如一个转化 50 元），平台自动调整 Bid 使得最终成本接近 50 元。

### 3. 第二课：深层转化建模 (CVR Modeling)

搜推看重点击（CTR），但广告主看重**转化（CVR - Conversion Rate）**，即“购买”、“下载”、“表单提交”。

CVR 建模比 CTR 难得多，痛点如下：

- **样本稀疏 (Sparsity)**：点击的人多，购买的人极少。
- **样本偏差 (Sample Selection Bias)**：模型只在点击过的样本上训练，却要在全量样本上预测。
- **延迟反馈 (Delayed Feedback)**：用户今天点击，可能三天后才购买。

**必学模型：ESMM (Entire Space Multi-Task Model)**
这是阿里提出的经典模型，解决 CVR 的稀疏和偏差问题。

- **思路**：引入两个辅助任务，预测 CTR 和 CTCVR (Click-Through & Conversion Rate)。
- $pCTCVR = pCTR \times pCVR$。
- 在整个样本空间训练，而不是只在点击样本里训练。

### 4. 第三课：智能出价 (Smart Bidding) & 流量平滑

广告主要求预算花得“匀”，且成本要“稳”。

- **PID 控制算法**：用于预算平滑（Budget Pacing）。如果早上花太快，PID 控制器会降低出价概率；花太慢则提高。
- **强化学习 (RL)**：在实时竞价（RTB）中，利用 RL 决定何时出高价抢量。

### 5. 广告特有的重排策略

在“重排”阶段，广告和搜推的逻辑不同：

- **广告混排 (Ad Allocation)**：
  - 广告和自然内容（Organic）混在一起，怎么排？
  - 如果广告 eCPM 很高，但特别丑，会伤害用户体验。
  - 通常使用公式：$Score = \alpha \cdot eCPM + \beta \cdot UserUtility$ (用户体验折算成钱)。
- **频控 (Frequency Capping)**：同一个广告主对同一个用户，一天最多展示 N 次。
- **强插 (Insertion)**：固定位置（如第 3 位）必须出广告。

### 代码演示：GSP 计费逻辑与混合排序

这是一段简化的 Python 代码，展示广告系统中核心的计费和混排逻辑。

```python
class AdItem:
    def __init__(self, ad_id, bid_price, p_ctr, p_cvr, quality_score):
        self.ad_id = ad_id
        self.bid_price = bid_price # 广告主出价
        self.p_ctr = p_ctr         # 模型预测点击率
        self.p_cvr = p_cvr         # 模型预测转化率
        self.quality_score = quality_score # 广告质量分（体验相关）

    def get_ecpm(self):
        # 智能出价场景(oCPC): Bid通常指 '目标转化成本' (CPA)
        # eCPM = pCTR * pCVR * TargetCPA * 1000
        return self.p_ctr * self.p_cvr * self.bid_price * 1000

def gsp_auction_and_rank(ads):
    """
    广义第二价格拍卖 (GSP) + 排序
    """
    # 1. 计算 eCPM 并排序
    # Python的sort是稳定的，按 eCPM 降序
    ranked_ads = sorted(ads, key=lambda x: x.get_ecpm(), reverse=True)

    results = []

    for i in range(len(ranked_ads)):
        current_ad = ranked_ads[i]

        # 2. 计算计费价格 (Charging Price)
        # 价格 = (下一名的 eCPM / 当前广告的质量分因子) + 0.01
        # 注意：实际公式通常不仅除以质量分，这里是简化版
        # 核心逻辑：你付的价格主要由你的竞争对手决定

        if i < len(ranked_ads) - 1:
            next_ad = ranked_ads[i+1]
            next_ecpm = next_ad.get_ecpm()
        else:
            # 只有这一个广告，或最后一名，通常设为底价
            next_ecpm = 10 # 假设底价 eCPM

        # 反解出 CPC (点击扣费)
        # eCPM_next = pCTR_current * pCVR_current * Cost_current * 1000
        # Cost_current = eCPM_next / (pCTR_current * pCVR_current * 1000)

        denominator = (current_ad.p_ctr * current_ad.p_cvr * 1000)
        if denominator == 0:
            charged_price = 0
        else:
            charged_price = next_ecpm / denominator + 0.01

        # 确保扣费不超过出价(Bid)
        final_price = min(charged_price, current_ad.bid_price)

        results.append({
            "id": current_ad.ad_id,
            "rank": i + 1,
            "ecpm": current_ad.get_ecpm(),
            "charged_price": round(final_price, 2)
        })

    return results

# 测试
if __name__ == "__main__":
    # 模拟三个广告
    # 广告A: 出价高，主要靠转化
    ad_a = AdItem("Ad_A", bid_price=50.0, p_ctr=0.02, p_cvr=0.1, quality_score=0.8)
    # 广告B: 点击率高，出价低
    ad_b = AdItem("Ad_B", bid_price=20.0, p_ctr=0.05, p_cvr=0.15, quality_score=0.9)
    # 广告C: 质量差
    ad_c = AdItem("Ad_C", bid_price=100.0, p_ctr=0.005, p_cvr=0.05, quality_score=0.3)

    final_rank = gsp_auction_and_rank([ad_a, ad_b, ad_c])

    import json
    print(json.dumps(final_rank, indent=2))
```

### 总结：你的学习清单

1.  **业务与术语**：弄懂 SSP, DSP, ADX, DMP, RTB, oCPC, ROI 是什么。
2.  **模型**：重点攻克 **ESMM**（全空间多任务）和 **DIN/DIEN**（如果还没掌握）。
3.  **机制**：深入理解 **GSP** 拍卖原理和 **PID** 流量平滑。
4.  **数据**：了解 **归因（Attribution）**，即如何判断一个转化是由哪个广告带来的（Last Click / Time Decay）。
