12. 关于内存虚拟化的对话
    用户程序生成的每个地址都是虚拟地址（every address generated by a user program is a virtual address）。
    为什么要这么做？
    - `主要是为了易于使用(ease of use)。`操作系统会让每个程序觉得，它有一个很大的连续地址空间（address space）来放入其代码和数据。
    - 其次是为了`隔离（isolation）和保护（protection）`。
13. Address Spaces (抽象：地址空间)

- 多道程序和时分共享
- 地址空间
  - 是运行的程序看到的系统中的内存，是物理内存的抽象。
  - 一个进程的地址空间包含运行的程序的所有`内存状态`。
    现在假设只有这 3 个部分：`代码、栈和堆。`
    ![alt text](image-2.png)
- 目标
  - 透明（transparency），对程序无感知。
  - 效率（efficiency）。
  - 保护（protection）。每个进程都应该在自己的独立环境中运行，避免其他出错或恶意进程的影响。
- `你看到的所有地址都不是真的`
  只有操作系统，通过精妙的虚拟化内存技术，知道这些指令和数据所在的物理内存的位置。所以永远不要忘记：如果你在一个程序中打印出一个地址，那就是一个虚拟的地址。虚拟地址只是提供地址如何在内存中分布的假象，只有操作系统（和硬件）才知道物理地址。

14. Memory API (内存 API)
    接口简洁。
    主要讨论堆内存。

    - malloc：传入要申请的堆空间的大小，它成功就返回一个指向新申请空间的指针，失败就返回 NULL(值为 0 的宏)

      ```c
      int *y = malloc(10 * sizeof(int));
      malloc(strlen("hello") + 1);  // +1 是为了存放字符串结束符
      ```

    - free：传入一个指针，它会释放这个指针指向的内存。

      ```c
      free(y);
      ```

    `内存管理常见错误:`

    - 忘记分配内存。例如 segmenation fault 段错误。
    - 没有分配足够的内存。缓冲区溢出(buffer overflow)。
    - 忘记初始化分配的内存。可能会导致未定义的行为。
    - 忘记释放内存。内存泄露（memory leak）。
    - 在用完之前释放内存 ：垂悬指针（dangling pointer）。
    - 反复释放内存：双重释放（double free）。
    - 错误地调用 free.

    为什么在你的进程退出时没有内存泄露？
    **系统中实际存在两级内存管理。**
    第一级是操作系统的内存管理，第二级是进程的内存管理。
    `无论进程如何，操作系统也会在程序结束运行时，收回进程的所有内存（包括用于代码、栈，以及相关堆的内存页）。`

    `底层操作系统支持：`
    malloc 和 free 不是系统调用，而是库调用，建立在底层系统调用之上。
    底层系统调用是`brk和mmap。`
    brk 用来改变程序分断（break）的位置：堆结束的位置。
    mmap()可以在程序中创建一个匿名（anonymous）内存区域。

15. Address Translation (地址转换)
    TODO

CPU 虚拟化的原则：LDE(受限直接执行)。
操作系统应该尽量让程序自己运行，同时通过在关键点的及时介入（interposing），来保持对硬件的控制。
**高效和控制**是现代操作系统的两个主要目标。

## 机制：基于硬件的地址转换（hardware-based address translation）

关键是硬件支持。硬件快速地将所有内存访问操作中的虚拟地址（进程自己看到的内存位置）转换为物理地址（实际位置）。

## 实现：`基址加界限`的动态重定位（base and bounds dynamic relocation）：

该技术通过`基址寄存器`和`界限寄存器`来实现地址转换和内存保护。
物理地址 = 基址寄存器 + 虚拟地址
缺点：块内存区域中大量的空间被浪费(内部碎片)。已经分配的内存单元内部有未使用的空间（即碎片）。

16. Segmentation (分段)
    TODO

    > MMU: 内存管理单元

    - 分段（Segmentation）是操作系统中的一种内存管理技术，用于更有效地组织和管理进程的地址空间。`它将进程的地址空间划分为若干不同大小的逻辑段，每个段都有自己的起始地址和长度，并且通常对应于程序中的逻辑单元，如代码段、数据段和栈段。`
    - 段的定义：一个段是地址空间里的一个连续定长的区域，在典型的地址空间里有 3 个逻辑不同的段：代码、栈和堆。

    > 段错误：`在支持分段的机器上发生了非法的内存访问`。

    - 段的表示:
      14位虚拟地址由两部分组成：`段号和段内偏移量。`
      `段号为 2 位，段内偏移量为 12 位。`
    - 挑战：
      解决`内部碎片问题`。
    - 分段避免了地址空间的逻辑段之间的大量潜在的内存浪费，能更好地支持稀疏地址空间。
    - 现代操作系统通常结合**分页（Paging）**和**分段**，或者采用纯分页的方式来管理内存，以发挥各自的优势。

17. Free Space Management (空闲空间管理)

    如何管理空闲空间，让碎片最小化。
    空闲列表（free list）：一种常见的管理空闲空间的方法。

    结构： merge and split (珂朵莉树)

    算法：

    - 最优匹配（best fit）：选择最小的合适的块。
    - 首次匹配（first fit）：从头开始找到第一个合适的块。
    - 下次匹配 （next fit）：从上次找到的地方开始找。多维护一个指针，指向上一次查找结束的位置。

    优化：

    - 分离空闲列表（segregated list）：
      如果某个应用程序经常申请一种（或几种）大小的内存空间，`那就用一个独立的列表，只管理这样大小的对象。`其他大小的请求都一给更通用的内存分配程序。
    - 伙伴系统 (buddy system)：
      将内存分成大小为 2 的幂的块，当有一个内存分配请求时，空闲空间被递归地一分为二，直到刚好可以满足请求的大小

18. Introduction to Paging (分页简介)

```py
PAGE_SIZE = 4096  # 页大小

class PageTable:
    """页表.
    记录地址空间的每个虚拟页放在物理内存中的位置.
    """
    def __init__(self):
        self.pages = {}

    def add_page(self, page_number, frame_number):
        self.pages[page_number] = frame_number

    def get_physical_address(self, page_number, offset):
        frame_number = self.pages.get(page_number)
        if frame_number is not None and offset < PAGE_SIZE:
            return frame_number * PAGE_SIZE + offset
        else:
            raise Exception("Invalid page number or offset")

# 示例使用
page_table = PageTable()
page_table.add_page(0, 5)  # 页0映射到页帧5
page_table.add_page(1, 10) # 页1映射到页帧10

# 获取物理地址
try:
    physical_address = page_table.get_physical_address(0, 100)
    print(f"Physical Address: {physical_address}")
except Exception as e:
    print(e)

```

## 思想

**将空间分割成固定长度的分片**

分页不是将一个进程的地址空间分割成几个不同长度的逻辑段（即代码、堆、段），而是分割成固定大小的单元，每个单元称为一页(页帧，page frame)。
`类似前端开发中的分页加载。`
映射信息存储在页表(Page Table)中。页表是每一个进程的数据结构。

## 优点

- 不会导致外部碎片，因为每个页都是固定大小的。
- 它非常灵活，支持稀疏虚拟地址空间

## **缺点**

- 访问内存较慢 => 解决方案：TLB(硬件缓存)
- 页表太大 => 解决方案：多级页表

19. Translation Lookaside Buffers (TLB，快速地址转换)

### 快速地址转换（TLB，Translation Lookaside Buffers）

**Translation Lookaside Buffer (TLB)**，即快速地址转换缓冲区，是一种用于加速虚拟地址到物理地址转换的`硬件缓存`。
TLB在分页机制中起着关键作用，通过缓存最近使用的页表项，减少内存访问延迟，提高系统性能。

#### TLB 的工作原理

1. **TLB 缓存**：

   - TLB 是一个小型的、快速的缓存，存储最近使用的虚拟页号和对应的物理页帧号。
   - 当 CPU 需要转换虚拟地址时，首先在 TLB 中查找。如果 TLB 命中，直接返回物理页帧号；否则，继续访问内存页表。

2. 为什么需要TLB，访问内存页表很慢吗
   是的。
   访问内存页表的延迟来源：
   - `内存访问`延迟：内存访问速度相对 CPU 较慢，需要几百个时钟周期。每次指令获取、显式加载或保存，都要额外读一次内存以得到转换信息，这慢得无法接受
   - 多级页表：现代操作系统通常使用多级页表（如二级或三级页表）来管理虚拟内存。

#### TLB 的优点

- **提高性能**：通过缓存最近使用的页表项，减少了访问内存页表的次数，从而提高了地址转换的速度。
- **降低延迟**：TLB 命中时，地址转换几乎是瞬时完成的，显著降低了内存访问延迟。

#### TLB 的实现

`TLB 通常由硬件实现，集成在 CPU 中。`以下是一个简单的 TLB 工作流程的伪代码示例：

```python
class TLB:
    """LRU TLB 缓存."""
    def __init__(self, size):
        self.size = size
        self.cache = {}  # 使用字典模拟 TLB 缓存
        self.order = []  # 记录访问顺序，用于替换策略

    def lookup(self, page_number):
        if page_number in self.cache:
            # TLB 命中
            self.order.remove(page_number)
            self.order.append(page_number)
            return self.cache[page_number]
        else:
            # TLB 未命中
            return None

    def add_entry(self, page_number, frame_number):
        if len(self.cache) >= self.size:
            # TLB 满了，使用 FIFO 替换策略
            oldest_page = self.order.pop(0)
            del self.cache[oldest_page]
        self.cache[page_number] = frame_number
        self.order.append(page_number)

# 示例使用
tlb = TLB(size=4)  # 创建一个大小为 4 的 TLB

# 添加页表项
tlb.add_entry(0, 5)
tlb.add_entry(1, 10)
tlb.add_entry(2, 15)
tlb.add_entry(3, 20)

# 查找页表项
frame_number = tlb.lookup(1)  # TLB 命中
if frame_number is not None:
    print(f"TLB Hit: Frame Number = {frame_number}")
else:
    print("TLB Miss")

# 添加新页表项，触发替换
tlb.add_entry(4, 25)
```

### 代码解释

1. **TLB 类**：

   - `__init__`方法：初始化 TLB，设置缓存大小，使用字典模拟缓存，列表记录访问顺序。
   - `lookup`方法：查找页号对应的页帧号，如果命中则返回页帧号，否则返回 `None`。
   - `add_entry`方法：添加页表项，如果 TLB 满了，使用 FIFO 替换策略移除最旧的页表项。

2. **示例使用**：
   - 创建一个大小为 4 的 TLB。
   - 添加页表项。
   - 查找页表项，演示 TLB 命中和未命中。
   - 添加新页表项，演示替换策略。

通过上述解释和示例代码，可以更好地理解 TLB 的工作原理及其在分页机制中的重要作用。TLB 通过缓存最近使用的页表项，显著提高了地址转换的效率，优化了系统性能。

20. Advanced Page Tables (高级页表)

- hybrid
  分页和分段的结合
- **多级页表**
  为了解决单页表太大的问题
  每个级别的页表只包含部分地址空间的映射。只有在需要时才分配下一级页表，从而减少了内存开销

21. Swapping: Mechanisms (交换：机制)

22. Swapping: Policies (交换：策略)

23. Complete VM Systems (完整的虚拟机系统)

24. Summary
