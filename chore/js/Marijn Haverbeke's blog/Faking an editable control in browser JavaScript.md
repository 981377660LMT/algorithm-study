# Faking an editable control in browser JavaScript

https://marijnhaverbeke.nl/blog/browser-input-reading.html

下面是一篇简要的总结，描述了 **CodeMirror** 如何在浏览器中“伪造”一个看似原生可编辑的文本控件，从而实现完整的文本编辑体验。

---

## 1. 关键思路：隐藏的 textarea

- **核心做法**  
  CodeMirror 在页面上放置一个看不见的 `textarea` 元素，并将其包装在一个高度为 0、`overflow: hidden` 的容器内，使其既不可见又可被聚焦 (focusable)。

  - 由于某些浏览器会拒绝聚焦 `display: none` 或 `visibility: hidden` 的元素，故使用“缩小后+隐藏溢出”的容器可让浏览器仍然把它视作可聚焦控件。
  - 为避免在一些浏览器中出现聚焦时的可视高亮，CodeMirror 还会设置 `outline: none` 等样式。

- **位置同步**  
  当用户在编辑器中移动光标时，CodeMirror 会将这个隐藏的容器通过绝对定位移到和“文本光标”一致的位置上，以符合浏览器“自动滚动到输入焦点”的行为。同时还可以借此利用浏览器的默认滚动逻辑来帮助将“真实”光标滚动到可见区域。

---

## 2. 维护选择与复制 / 剪切 (copy/cut)

- **隐藏域中始终放置当前选中的文本**  
  为了让浏览器原生的复制、剪切功能工作，**textarea 的内容**会被设置为选中的文本，并且处于被选中状态。这样：

  - 当用户执行 `copy` 或 `cut` 命令时，系统会将隐藏域中的选中内容复制 / 剪切到剪贴板。
  - 如果文本量巨大（如 `select all` 大文档），设置 / 获取 `textarea.value` 会变得缓慢。为此，CodeMirror 做了一些优化来尽量减少对 `textarea.value` 的频繁操作（例如，只有当拖拽选择结束时才一次性更新）。

- **只在触发事件时注入大段文本**  
  一些编辑器（如 ACE）会在监听到 `copy` / `cut` 事件的瞬间，才把大文本插入到 textarea 中、并选中它，从而避免频繁更新 textarea。但这对兼容性(例如 Opera、Linux 上的中键粘贴) 可能有影响。  
  CodeMirror 后来也引入了混合策略：当选区很小时，直接保持在 textarea；当选区很大且浏览器支持 `copy` / `cut` 事件，就只在真正需要复制 / 剪切时才把文本全部放进去。

---

## 3. 侦测键入与粘贴 (input detection)

- **事件监听 + 定时轮询 (polling)**  
  在理想状况下，可以依赖 `keypress`、`input`、`paste` 等事件来判断 textarea 是否有新输入。但在某些浏览器（例如旧版 Opera）中，`paste` 事件不一定触发；或 IME 输入在部分浏览器里不会触发任何可监听事件。

  - CodeMirror 兼用“事件监听”与“定时轮询”策略：聚焦时高频轮询，一旦 textarea 的内容发生改变，就读取差异并插入到编辑器内。在失焦后，则停止轮询。
  - 如果 textarea 里当前有一段已选中的文本（通常是所选文本），则**输入**会覆盖掉原内容，这一点易于检测，因此可以尽量减少对大文本的读取操作。

- **IME（输入法）支持**  
  当用户使用 IME 输入（如中文、日文等），浏览器会在 textarea 中显示组合状态的文字。CodeMirror 不能每次都清空 textarea，否则会打断 IME 的输入过程。
  - 解决办法：当 textarea 中没有选区（处于 IME 组合中），CodeMirror 留存其当前值，每次“轮询”或触发事件后，都对比新旧值以计算插入文本（即找出新值与旧值的公共前缀和被替换的部分），从而兼容输入法的中间状态。

---

## 4. 处理右键菜单与拖放 (contextmenu & drag/drop)

- **右键菜单 (Context Menu)**  
  一个标准编辑控件被右键点击时，应该出现包含“复制/剪切/粘贴/全选”等功能的系统上下文菜单。

  - 浏览器没有提供修改原生菜单的直接 API。
  - CodeMirror 通过“临时取消隐藏并把 textarea 放到鼠标位置”的技巧，让浏览器以为用户在点击一个原生可编辑文本域，从而弹出系统菜单且支持真正的复制/粘贴。
  - 不同浏览器事件触发机制不同：如 Firefox 在打开菜单后才发送 `contextmenu` 事件，因此需要在 `mousedown` 阶段就完成这步“临时解除隐藏”的操作。
  - “全选” 也类似，用一个开头空格的技巧，监听浏览器是否自动把这个空格选中了，如果确实出现了“select all”的情况，则在编辑器中执行真正的全选。

- **拖放 (Drag & Drop)**
  - 默认情况下，设置 `draggable=true` 可能导致浏览器认为整个编辑器都可被拖拽。
  - 为此，CodeMirror 在检测到真正的文本拖拽时，手动给外层 DOM 设置/取消 `draggable` 属性，确保仅选中的文本被拖拽。
  - 在 `dragstart` 事件中，通过 `e.dataTransfer.setData("Text", 选中文本)` 来把实际选中的文本传给剪贴板。
  - 处理 `drop` 事件时，可用 `FileReader` 等 API 进一步支持文件拖拽。

---

## 5. 放弃让浏览器原生处理所有光标移动

- **早期尝试**  
  CodeMirror 2 的早期版本曾尝试将光标附近几行文本都放到 textarea 中，让浏览器原生处理光标移动、选区变化等。这样可以自动支持浏览器本身的各种快捷键、双击选词等操作。

  - 但不同浏览器在设置选区时的“锚点 (anchor) 位置”存在差异，想让浏览器精确跟踪“倒置选区”或复杂光标操作，需要大量 hack，而且兼容性不好。

- **现行模式**  
  后续版本放弃了对浏览器原生选区/光标移动的依赖，改为完全自行管理“内部选区”。textarea 的唯一职责是承载剪贴板相关的内容与 IME 状态。
  - 对于上下、左右、Home、End 等非文本输入的按键，CodeMirror 直接侦听键盘事件，并在其内部的文档模型或选区模型上做移动操作。
  - 这样避免了浏览器不一致的文本选区实现，大幅简化了复杂场景的兼容性问题。

---

## 6. 总结

**CodeMirror** 要在一个普通网页中实现近似原生的文本输入体验，主要技巧可归纳为：

1. **使用隐藏 textarea**：

   - 让浏览器把它当作真正的可编辑控件，用以获取焦点、触发剪贴板、支持 IME、右键菜单等功能。

2. **管理自身选区和光标**：

   - 并不依赖 textarea 来进行光标移动或文本显示；所有渲染、选区绘制都由编辑器自己完成。

3. **事件与轮询结合检测输入**：

   - 监听 `input` / `paste` / `cut` / `copy` / `keypress` 等事件，配合 IME 场景下的“值对比”，保证能捕获来自用户的任何输入。

4. **巧妙处理复制/剪切/粘贴**：

   - textarea 中始终（或在需要时）保持所选文本，以便系统 clipboard 菜单“看得见”，也能原生处理“Ctrl+C / Ctrl+V / 右键粘贴”。

5. **上下文菜单和拖拽**：
   - 通过在右键点击时、拖拽开始前等关键时刻“短暂调整”隐藏域，使浏览器原生菜单和拖拽行为可以照常生效。

依托这些机制，CodeMirror 成功地“欺骗”了浏览器，让它认为有一个真正的文本输入框存在，继而让用户获得完整的编辑交互、剪贴板功能、IME 输入以及可视化渲染的体验。这为在网页上自定义高度可控的文本编辑器铺平了道路。
