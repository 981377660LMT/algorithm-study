https://g6.antv.antgroup.com/manual/graph/graph

# G6 主要概念

元素、交互、布局、色板、插件

扩展 (Extension) 是 G6 中的一个重要概念，它是 G6 中所有可扩展部分的统称，包括以下几种：

- 动画 (Animation)
- 交互 (Behavior)
- 元素 (Element)
- 节点 (Node)
- 边 (Edge)
- 组合 (Combo)
- 布局 (Layout)
- 色板 (Palette)
- 插件 (Plugin)
- 主题 (Theme)
- 数据转换 (Transform)

## 图

在 G6 中，Graph 对象是图的载体，它包含了图上的所有元素（节点、边等），同时挂载了图的相关操作（如交互监听、元素操作、渲染等）。

Graph 对象的完整生命周期包括：

- 创建: 通过 new Graph(options) 实例化
- 初始化: 在创建时进行内部初始化
- 渲染: 调用 graph.render() 进行首次渲染
- 更新: 通过各种 API 更新图的数据和配置
- 销毁: 调用 graph.destroy() 销毁实例并释放资源

## [数据](https://g6.antv.antgroup.com/manual/data#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)

- 数据结构
  图数据包含三部分：nodes（节点数据）、edges（边数据）、combos（组合数据）

  > 通过组合，可以为多个节点创建一个逻辑单元，用于图形的分层、分组或其他结构化需求。组合可以包含子节点或其他组合，从而形成嵌套层次。

- 数据操作
  api 支持批量(重载实现)
- 数据组织与最佳实践
  为了确保图的正确渲染和交互，建议按照 G6 标准数据结构组织数据。
  **每个元素（节点、边、组合）应包含一个 data 字段，用于存放业务数据和自定义属性。**
  避免使用与 G6 内部字段名称相同的标识符，如 id、type、style 等，防止发生命名冲突。
  将业务数据（如用户信息、社交网络关系等）存储在 data 字段中，这样可以确保数据的灵活性和可扩展性。
  **使用样式映射来根据业务数据动态设置视觉属性，而不是直接修改样式对象。**

  - 数据与样式分离
    良好的做法是将数据和样式分离，`通过映射函数将数据属性转换为视觉属性`

    ```ts
    import { Graph } from '@antv/g6'

    // 使用数据驱动样式
    const graph = new Graph({
      container: 'container',
      data: {
        nodes: [
          { id: 'node1', data: { value: 10, category: 'A' } },
          { id: 'node2', data: { value: 5, category: 'B' } }
        ]
      },
      node: {
        style: {
          // 根据数据中的 value 字段动态设置节点大小
          size: node => 20 + node.data.value * 2,
          // 根据数据中的 category 字段设置不同颜色
          fill: node => {
            const categoryColors = { A: '#F6BD16', B: '#5B8FF9' }
            return categoryColors[node.data.category] || '#CCC'
          }
        }
      }
    })
    ```

## 元素

- G6 5.x 采用扁平化的配置结构，所有元素的配置都在同一层级，便于查找和管理

## 布局

- G6 提供了多种布局算法，用户可以根据自己的需求选择合适的布局算法

## 交互

- 交互(Behavior)是指用户与图表元素之间的互动操作，如拖拽画布、选择节点、缩放视图等。良好的交互设计能让用户更直观地探索和理解图数据。合理配置交互是构建高效可用图表的关键环节。

## 插件

- 插件(Plugin)是 G6 中最灵活的扩展机制，用户可以通过插件来扩展 G6 的功能，例如在画布中额外挂载图形组件、实现撤销重做等功能。

绝大多数的定制需求都可以通过插件来实现，G6 内置了一些常用的插件，例如：Tooltip、Grid、History。

## 数据处理

- 数据处理（ transform ），也叫数据转换器，是 G6 提供的支持在 渲染前( beforeDraw ) 或者 布局后( afterLayout ) `对绘制数据进行转化处理的机制`，用户可以通过数据处理很方便地对数据处理逻辑进行封装解耦。

## 主题

## 动画

---

# Api

https://g6.antv.antgroup.com/api/canvas

## 绘制与渲染

G6 提供了一系列绘制和渲染相关的 API，用于控制图形元素的显示过程。在 G6 中，绘制和渲染是两个不同的概念：

绘制(draw): 仅负责将图形元素绘制到画布上，`不涉及布局计算`
渲染(render): 完整的渲染流程，包括数据处理、布局计算和最终绘制

- 使用 draw() 当:
  仅修改了元素样式或状态，不需要重新计算位置
  性能敏感，希望避免不必要的布局计算
- 使用 render() 当:
  初始化图表
  更改了布局配置
  添加或删除了大量节点/边
  需要重新计算所有元素位置

---

好的，下面我将以架构为主线，结合 G6 的核心设计思想、主要模块、扩展机制和实际开发细节，系统性、逻辑性地深入讲解 G6。

---

# 一、整体架构设计

G6 的架构可以分为四大层次：

1. **数据层**  
   负责数据结构定义、数据转换、数据驱动渲染。
2. **元素层**  
   包括节点、边、组合等图形元素的定义、样式、状态管理。
3. **交互与扩展层**  
   行为（Behavior）、动画、插件、主题等扩展机制。
4. **渲染层**  
   Canvas/SVG 渲染、布局算法、性能优化。

---

# 二、核心模块详解

## 1. 数据层

### 数据结构

- **nodes**：节点数组，每个节点包含 id、data、样式等。
- **edges**：边数组，包含 source、target、data、样式等。
- **combos**：组合数组，实现分组、层次结构。

### 数据驱动

- 推荐将业务数据放在 data 字段，样式与数据分离，通过映射函数动态生成视觉属性。
- 支持数据批量操作、增量更新、数据变换（transform）。

### 数据转换器（Transform）

- 渲染前（beforeDraw）或布局后（afterLayout）对数据进行处理。
- 典型场景：数据归一化、属性补全、业务数据转视觉属性。

```ts
const graph = new Graph({
  data: rawData,
  transforms: [
    {
      type: 'custom-transform',
      beforeDraw: data => {
        // 数据预处理逻辑
        return processData(data)
      }
    }
  ]
})
```

---

## 2. 元素层

### 元素类型

- **节点（Node）**：支持多种形状、可自定义、可扩展。
- **边（Edge）**：支持直线、曲线、虚线、箭头等多种样式。
- **组合（Combo）**：实现分组、嵌套、层次结构。
- **插件（Plugin）**：如 Minimap、Toolbar、Grid、History。

### 配置结构

- G6 5.x 采用扁平化配置，所有元素配置在同一层级，便于查找和管理。
- 支持样式映射、状态样式、事件绑定。

### 状态管理

- 元素支持多种状态（selected、hover、active、disabled），可配置不同状态下的样式。
- 状态切换通过 API 或交互行为实现。

```ts
graph.setItemState(nodeId, 'selected', true)
```

---

## 3. 交互与扩展层

### 行为（Behavior）

- 内置行为：拖拽画布、缩放、节点拖拽、框选、点击选中等。
- 支持自定义行为，通过注册扩展。
- 行为与模式（mode）绑定，可动态切换。

```ts
graph.setMode('edit')
```

### 动画（Animation）

- 支持元素动画、布局动画、状态切换动画。
- 可配置动画时长、缓动函数、触发条件。

### 插件（Plugin）

- 插件是 G6 最灵活的扩展机制，支持功能增强、UI 组件挂载、历史管理等。
- 内置插件如 Tooltip、Grid、History，也支持自定义插件。

### 主题（Theme）

- 主题用于统一管理视觉风格，支持全局样式配置和动态切换。
- 可自定义主题，也可使用官方主题。

---

## 4. 渲染层

### 绘制与渲染流程

- **draw()**：仅绘制元素，不涉及布局计算，适合样式或状态变更。
- **render()**：完整渲染流程，包含数据处理、布局计算、元素绘制，适合数据或布局变更。

### 布局算法

- 内置多种布局：力导向、层次布局、网格布局、圆形布局等。
- 支持自定义布局算法，布局过程可插入数据处理逻辑。

### 性能优化

- 支持虚拟化渲染、局部渲染、视口优化。
- 推荐使用 Canvas 渲染大数据量场景，合理配置渲染参数。

---

# 三、扩展机制与最佳实践

## 扩展机制

- 所有核心模块均可扩展：节点、边、行为、动画、布局、插件、主题、数据转换器。
- 扩展通过注册机制实现，支持按需加载和动态切换。

## 最佳实践

1. **数据与样式分离**：业务数据放 data 字段，视觉属性通过映射函数生成。
2. **状态驱动交互**：所有交互通过状态切换实现，便于统一管理和扩展。
3. **插件化开发**：功能增强优先通过插件实现，保持主流程简洁。
4. **性能优化**：大数据量场景下采用虚拟化、局部渲染、合理布局算法。
5. **生命周期管理**：及时销毁实例，避免内存泄漏。

---

# 四、实际开发流程举例

1. **数据准备**：整理 nodes、edges、combos，业务数据放 data 字段。
2. **实例化 Graph**：配置容器、数据、元素样式、布局、行为、插件等。
3. **渲染流程**：调用 render() 完成首次渲染，后续通过 API 更新数据或样式。
4. **交互扩展**：根据需求注册自定义行为、插件、动画等。
5. **性能与体验优化**：根据数据量和业务场景调整渲染参数和布局算法。

---

# 五、总结

G6 通过高度模块化、可扩展的架构，覆盖了关系数据可视化的全流程。其数据驱动、元素状态、行为扩展、插件机制、主题系统和高性能渲染能力，使其成为前端图可视化领域的专业级解决方案。开发者可根据实际业务需求灵活组合和扩展各模块，实现高效、可维护、可定制的图应用。

---

以下要点概括了 G6 在架构设计与工程实践上值得借鉴的核心思想，可作为开发任何大型前端可视化库的参考。

## 1. 数据驱动 + 扁平化配置

- 单一 Graph 实例持有全部数据与配置，做到“数据即状态”。
- 元素（节点 / 边 / Combo）统一放在同一层级，用映射函数将业务字段转成视觉样式，解耦数据与呈现。
- 优势：减少上下文切换，天然支持响应式更新；配合 graph.changeData 即可实现增量渲染。

## 2. 分层架构清晰

1. 数据层：数据结构、Transform、批量操作。
2. 元素层：节点 / 边 / Combo 的声明式定义与状态管理。
3. 行为与扩展层：Behavior、动画、插件、主题。
4. 渲染层：Canvas/SVG 渲染管线与布局调度。

- 每层只暴露极少 API，其他细节通过注册机制扩展，降低耦合度。

## 3. 万物可扩展（Extension）

- registerNode / registerEdge / registerBehavior / registerLayout / registerPlugin…
- 扩展都走同一套注册中心，调用成本恒定、心智模型统一。
- 典型模式：策略 + 工厂。任何新能力都只是向注册表塞一条记录。

## 4. 行为 (Behavior) + 模式 (Mode)

- 行为描述“输入 → 状态”的映射（拖拽、缩放、框选…），模式是行为组合的别名。
- graph.setMode(​'edit'​) 一行切换整套交互，利于产品分权限或多工作流场景。

## 5. Transform 数据管线

- beforeDraw / afterLayout 两个时机钩子，将“渲染逻辑”前移到管线，业务方写纯函数即可。
- 类似 React hooks 中的 useEffect，把副作用包进可控生命周期，避免散落在回调里。

## 6. 插件生态

- 插件拥有独立容器 / 独立配置，生命周期与 Graph 对齐（init → destroy）。
- 内置 MiniMap / Grid / History 等示例即最佳实践，方便开发者“照猫画虎”做业务插件。

## 7. 状态驱动渲染

- setItemState(id, 'selected', true) 只改状态，不改具体样式；样式映射在 stateStyles。
- 明确分离“状态变更”与“视效表现”，可快速全局换肤、无痛动画。

## 8. 布局调度器

- 布局与绘制拆分：render() 全流程 / draw() 仅重绘。
- 所有布局都是独立 worker/step，可并发、可复用；重心在“数据 → 坐标”的纯函数。

## 9. 性能与可观测性

- 支持局部渲染、虚拟化视口、WebGL FBO 批量绘制。
- 提供事件 'viewportchange'、渲染耗时统计，方便埋点与调优。

## 10. 统一主题系统

- 主题即全局 Token（颜色、字体、间距等）+ 部件级覆盖。
- 动态切换时只需 graph.updateTheme(themeName)；利于多品牌、暗黑模式。

## 11. 生命周期一致性

- new Graph → render → changeXxx → destroy，全链出参都是 Promise/void，接口稳定。
- 避免“谁来释放内存”不清晰的问题，框架层保证清理事件与 DOM。

---

通过以上机制，G6 在“高可扩展 + 低学习成本”之间取得平衡。  
在自研可视化或大型组件库时，可重点模仿以下做法：

1. 采用统一注册中心，所有扩展共用一套 API。
2. 用“数据管线 + 生命周期钩子”代替散落回调。
3. 状态 → 样式映射的声明式范式，方便主题 / 动画 / 性能优化。
4. 行为解耦 + 模式组合，实现交互层无侵入切换。

---

# 从根本上理解 G6 - 用"盖房子"来类比

## 一、核心理念：图就是一个"数据驱动的可交互画布"

想象你在盖一栋智能大楼：

```
数据 → 图纸（设计）
元素 → 建材（砖块）
布局 → 施工（排列）
交互 → 功能（开关）
渲染 → 完工（呈现）
```

## 二、记住 5 个核心概念（手掌记忆法）

### 👍 大拇指 - Graph（图实例）

- 整个项目的"总包工头"
- 管理所有资源和流程
- 生命周期：创建 → 渲染 → 更新 → 销毁

### 👆 食指 - Data（数据）

- 图的"设计图纸"
- 三要素：nodes（点）、edges（线）、combos（组）
- 业务数据放 `data` 字段，样式用函数映射

### 🖕 中指 - Element（元素）

- 图的"建筑材料"
- 节点像房间、边像走廊、组合像楼层
- 每个元素都有状态（正常/悬停/选中）

### 💍 无名指 - Layout（布局）

- 图的"施工方案"
- 决定元素怎么排列（力导向/层次/圆形等）
- 布局是纯函数：输入坐标 → 输出位置

### 👌 小指 - Extension（扩展）

- 图的"装修升级"
- 万物皆可扩展：行为/插件/主题/动画
- 统一注册机制：`G6.register*()`

## 三、记住 3 个设计模式

### 1. 数据驱动模式

```javascript
// 数据变了，图就变了
数据 → 映射函数 → 视觉样式
     ↓
graph.changeData(newData) // 一切自动更新
```

### 2. 状态分离模式

```javascript
// 状态是什么 vs 状态怎么表现
graph.setItemState(node, 'hover', true)
                    ↑        ↑       ↑
                  元素    状态名   开关

// 样式在配置里定义
stateStyles: {
  hover: { fill: 'red' }
}
```

### 3. 管线处理模式

```javascript
原始数据 → Transform → 布局计算 → 渲染绘制
         ↓           ↓          ↓
    beforeDraw   afterLayout   draw()
```

## 四、记住 2 个关键区别

### render() vs draw()

- **render()** = 翻新重建（数据变了/布局变了）
- **draw()** = 重新粉刷（样式变了/状态变了）

### 数据 vs 样式

- **数据**：业务逻辑，放 `data` 字段
- **样式**：视觉表现，用映射函数生成

## 五、1 个终极口诀

> **"数据驱动、状态分离、万物可扩展"**

- **数据驱动**：改数据不改代码
- **状态分离**：改状态不改样式
- **万物可扩展**：改功能不改框架

## 六、实战记忆卡片

```javascript
// 1. 创建图 - 记住基础配置
const graph = new G6.Graph({
  container: 'div', // 在哪画
  data: {}, // 画什么
  layout: {}, // 怎么排
  modes: {}, // 怎么玩
  defaultNode: {} // 长啥样
})

// 2. 更新图 - 记住核心 API
graph.changeData() // 换数据
graph.setItemState() // 换状态
graph.updateItem() // 换属性
graph.setMode() // 换交互
graph.render / draw() // 重新画

// 3. 扩展图 - 记住注册方法
G6.registerNode() // 自定义节点
G6.registerBehavior() // 自定义交互
G6.registerLayout() // 自定义布局
```

## 七、类比记忆法

把 G6 想象成一个"智能画图机器人"：

1. **你给它数据**（nodes + edges）= 告诉它画什么
2. **它自动布局**（layout）= 它决定怎么排版
3. **它响应交互**（behavior）= 它能跟你互动
4. **它支持插件**（plugin）= 你能给它加装备
5. **它主题换肤**（theme）= 它能换不同画风

记住：**G6 = 数据进，图出来，还能玩！**
