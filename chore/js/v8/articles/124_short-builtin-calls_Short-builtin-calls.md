# 短跳转内建函数调用：榨取微架构性能

# Short builtin calls: Squeezing micro-architectural performance

这是一篇关于如何通过优化指令物理距离（Code Distance）来突破 64 位寻址瓶颈的硬核解析。

### 1. 底层困境：远距离跳转的代价

在 64 位架构上，JIT 生成的内存区域与 Chrome 二进制加载的内存区域可能相距数 GB。

- **间接调用 (Indirect Call)**：远距离跳转必须通过寄存器或读取内存地址。
- **性能惩罚**：现代 CPU 的分支预测器（Branch Predictor）对这种间接跳转有显著的性能惩罚。在开启 Spectre 缓解措施后，这种开销尤为明显。

### 2. 解决方案：空间换时间 (Builtins Copying)

V8 采取了一个看似激进的策略：

- **重拷贝**：将最常用的内建函数（Builtins）重新拷贝一份到指针压缩笼（Cage）中。
- **本地化**：通过物理上的靠近，确保 JIT 代码与 Builtins 的距离在 32 位带符号偏移（4GB）之内。
- **直接调用 (Direct Call)**：编译器现在可以使用更轻量的直接跳转指令，极大地降低了 CPU 预测器的负担和流水线停顿。

### 3. 一针见血的见解

`Short builtin calls` 展示了 V8 对底层硬件微架构的极致尊重。当地址空间的辽阔变成了性能的阻碍，V8 选择在 64 位大地的局部重塑一个紧凑的“32 位微缩盆景”，通过物理上的“邻里关系”赢回了执行效率。
