## 扩展 SharedArrayBuffer 的容量上限 | Extending the SharedArrayBuffer limit

V8 官方博客近期详细介绍了对 `SharedArrayBuffer` (SAB) 容量限制的重大突破。这不仅是一个技术参数的调整，更是 Web 平台迈向高性能计算（HPC）领域的重要一步。

### 1. 背景：`SharedArrayBuffer` 的 2GB 壁垒

在较长的一段时间内，`SharedArrayBuffer` 的最大容量被严格限制在 **2GB** ($2^{31} - 1$ 字节)。

- **实现复杂度**：V8 内部在处理 `TypedArray` 和 `ArrayBuffer` 的时，许多底层逻辑（如偏移量计算、长度表示）曾广泛使用 32 位有符号整数 (`int32_t`)。这导致 2GB 成为一个天然的硬上限。
- **安全性考量**：自 2018 年 **Spectre** 漏洞曝光后，SAB 因为能提供高精度的计时能力而成为侧信道攻击的利器。为了降低风险，SAB 曾被一度禁用，重新开启后也伴随着严苛的隔离策略（Site Isolation）和较低的容量限制。

### 2. 改进：为什么 Web 需要更大的共享内存？

随着 WebAssembly (Wasm) 的崛起，浏览器正在承载日益沉重的生产力工具：

- **并行计算瓶颈**：在多线程图像处理、视频渲染或大型 3D 场景控制中，2GB 的共享内存在处理高清纹理或大规模点云数据时瞬间就会告罄。
- **Node.js 与多核能力**：Node.js 的 `worker_threads` 依赖 SAB 进行零拷贝数据共享。小容量限制迫使开发者不得不进行频繁的数据切片或昂贵的克隆操作，严重降低了多核 CPU 的利用率。
- **数据库引擎**：在浏览器运行 SQL 数据库（如 DuckDB、SQLite VFS）时，共享内存作为缓冲区（Buffer Pool），其大小直接决定了查询性能。

### 3. 技术挑战：内存追踪与垃圾回收 (GC)

将上限从 2GB 扩展到 4GB 甚至更高，并非修改一个数值那么简单，它涉及 V8 内核深处的重新建模：

- **跨 Isolation 的生命周期管理**：SAB 的内存（Backing Store）是由多个 `Isolation`（隔离的执行环境，如主线程和 Worker）共同引用的。V8 必须确保在所有引用都消失前，这块巨大的物理内存不会被回收。
- **GC 追踪的压力**：在大容量内存场景下，内存标记（Marking）和记账（Accounting）的成本呈指数级增加。V8 需要在保证不阻塞 JS 执行（Concurrent Marking）的前提下，精确追踪这些跨线程共享的内存块。
- **虚拟内存映射**：在 64 位系统上，虽然地址空间充足，但在 Windows 等平台上，大规模连续虚拟内存的预留和提交（Commit）机制与 V8 的“按需分配”策略存在摩擦，需要更精细的页面映射管理。

### 4. 成果：向 ArrayBuffer 对齐，跨越 GB 时代

目前的改进已经让 `SharedArrayBuffer` 的上限与普通 `ArrayBuffer` 对齐，在各主流 64 位平台上：

- **容量跨越**：在 64 位系统上，最大容量从 **2GB 扩展到了 4GB**（受限于 32 位无符号偏移量），并正向更大的地址空间迈进。
- **平台协同**：Chrome 120+ 已经默认启用这一改进，支持在 Windows、macOS (M1/M2/Intel) 和 Linux 上分配更大的共享区域。
- **Wasm 联动**：配合 `Memory64` 提案，WebAssembly 现在可以寻址超过 4GB 的内存，这意味着整个 Web 生态正式解锁了 GB 级数据交换的能力。

---

### 💡 一针见血的技术洞察

**从“谨慎试验”到“全面开放”的历史性转折**：
这次升级标志着 V8 团队对 **Site Isolation（站点隔离）** 安全架构的信心已趋于成熟。过去，出于对漏洞的畏惧，共享内存像是被锁在“2GB 笼子”里的困兽；而现在，通过完善的内存隔离与地址随机化技术，V8 终于解开了枷锁。

**Web 共享内存正式进入“工业级”应用阶段**：
扩大 SAB 上限不仅是配置项的改变，它是 V8 对现代硬件**多核并行与大内存能力**的进一步释放。配合 `memory64`，这标志着 Web 平台不再只是“文档查看器”或“轻应用容器”，它已经具备了运行企业级数据库、专业级 CAD 软件和 3A 级云游戏引擎的**基建能力**。**Web 即操作系统**的愿景，正在由这块巨大的共享缓冲区变成现实。
