# 使用可变堆数字为 V8 加速：打破不可变性的枷锁

## Turbocharging V8 with mutable heap numbers

- **Original Link**: [https://v8.dev/blog/mutable-heap-number](https://v8.dev/blog/mutable-heap-number)
- **Publication Date**: 2025-02-25
- **Summary**: V8 引入了 **Mutable HeapNumber** 技术，通过打破长期以来堆对象（HeapObject）不可变的假设，允许在特定场景下（如闭包变量）原地更新浮点数。这一改进能将数值计算密集的 JS 代码性能提升高达 2.5 倍，大幅减轻了 GC 压力。

---

### 1. 痛点的本质：为什么 JS 浮点数是性能杀手？

在 JavaScript 引擎中，数字的存储一直处于两极分化状态：

- **SMI (Small Integers)**：直接嵌入在指针里的 31/32 位整数。它们不占堆内存，零分配，快如闪电。
- **HeapNumber (Boxed Doubles)**：一旦数字带有小数或超过 SMI 范围，V8 就必须在堆上分配一个对象来“包装”这 64 位浮点数。

**“装箱（Boxing）”与“不可变性”导致的灾难：**
在旧架构中，`HeapNumber` 是**不可变**的。这意味着如果你在闭包里更新一个计数器 `count += 0.5`，V8 并不是修改内存里的那个数字，而是：

1. **分配**一个全新的 `HeapNumber` 对象。
2. 将计算结果写入新对象。
3. 把旧对象标为垃圾。
   这种“分配-丢弃”的循环在数值计算（如游戏逻辑、加密算法、科学计算）中会导致极高的内存带宽消耗，并引发高频的新生代 GC 停顿。

---

### 2. “一针见血”的改进：私有化与原地更新

Mutable HeapNumber 的核心洞见在于：**如果我们能证明这个数字只有一个人在用，那为什么要限制它不可变？**

- **所有权隔离 (Ownership)**：V8 现在可以追踪 `ScriptContext`（存储闭包和全局变量的容器）中的槽位。如果一个槽位被识别为专门存储特定数值，V8 就会为其分配一个“可变”的 HeapNumber。
- **不泄露原则 (The Non-leaking Guarantee)**：这是安全的基石。这种可变数字的**内存地址永远不会暴露给外部用户代码**。如果用户试图将这个数字赋给另一个对象的属性或传入另一个函数，V8 会立即进行“防震处理”——创建一个常规的不可变副本传出去。由于它是私有的、受控的，V8 就可以放心地在原处进行二进制覆盖。

---

### 3. 技术挑战：既然变了，GC 和并发怎么办？

这种从“函数式不可变”向“命令式原地更新”的转变，带来了底层的复杂挑战：

- **写屏障 (Write Barrier) 的规避**：常规堆对象更新需要触发“写屏障”以维护 GC 的引用图。但由于 `HeapNumber` 内部存的是原始二进制位（Raw Bits）而非指针，更新它**不需要通知 GC**。这使得这种优化几乎没有额外运行时开销。
- **并发读写的“撕裂”风险**：V8 拥有并发 GC 和后台优化编译器。如果主线程正在原地改写 64 位数据，而后台线程正在读，可能会读到一半是旧值、一半是新值的“撕裂”数据。
  - **V8 的方案**：利用其严格的执行上下文追踪，确保优化编译器生成的机器码在特定 Safe Point 之外不会触碰到这些正在变化的私有槽位，从而避免了昂贵的原子操作或锁。

---

### 4. 实战意义：数值密集型 JS 的阶跃

这对开发者意味着什么？

- **闭包计数器不再是 GC 炸弹**：在高性能循环中，通过闭包维护的浮点数状态（如 `TWEEN` 动画、粒子位置）现在可以实现零垃圾分配。
- **Int32 溢出的性能平滑化**：以前当整数加法超过 31 位溢出到浮点数时，性能会断崖式下跌。现在，Mutable HeapNumber 充当了“性能缓冲垫”，使这种转换在机器指令级别依然保持高效。
- **针对性改进**：据官方数据，在 `async-fs`（高度依赖闭包存储状态）等基准测试中，吞吐量直接提升了 **150%**。

### 洞见总结

Mutable HeapNumber 是 V8 针对 **“数字分配开销”** 进行的一次极其克制的局部突围。它没有破坏 JS 语言的语义，也没有全局放开堆的可变性，而是通过**精准识别高频更新的私有槽位**，用最底层的二进制原地改写，换取了巨大的性能红利。这告诉我们：**在极致优化的路径上，打破理论上的优雅（不可变假设）往往是解决工程瓶颈的唯一出路。**
