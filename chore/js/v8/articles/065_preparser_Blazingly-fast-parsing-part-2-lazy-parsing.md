# 极致解析（二）：延迟解析的深度剖析

# Blazingly fast parsing, part 2: lazy parsing

深入 V8 解析器的核心，理解它是如何“偷懒”以换取极速启动的。

### 1. 核心挑战：闭包与作用域

当 JavaScript 引擎看到一个函数定义时，如果立即完整解析（Eager Parse），会浪费大量 CPU 资源在可能永远不会执行的代码上。但如果仅仅跳过，又无法得知该函数内部是否引用了外部变量（会导致闭包问题）。

### 2. 解决方案：Preparser (预解析器)

V8 使用了一个轻量级的“预解析器”。它不生成完整的抽象语法树（AST），只进行最低限度的语法校验。
**重点在于：** 预解析器必须正确标记哪些变量被内部函数“捕获”。V8 通过一种称为“逃逸分析”的简版实现，只记录必要的 ScopeInfo，从而实现了 $O(n)$ 时间复杂度的快速预览。

### 3. "Skipping inner functions" 优化

文章介绍了如何通过记录函数边界，在二次加载或懒解析时直接跳过已经扫描过的内部函数体。这一改动在包含大量深层嵌套函数的 JS 文件中，启动性能提升了约 15%-25%。

### 4. 一针见血的见解

良好的软件系统应当“能拖就拖”。V8 延迟解析的成功在于它找到了一条窄路：在不丢失关键语义信息（作用域）的前提下，尽可能推迟最耗时的操作（AST 构建和代码生成）。这种对计算时机的精准掌控是其快如闪电的秘诀。
