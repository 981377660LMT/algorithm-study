# V8 中的指针压缩：节省 40% 内存的黑科技

## Pointer compression in V8

- **Original Link**: [https://v8.dev/blog/pointer-compression](https://v8.dev/blog/pointer-compression)
- **Publication Date**: 2020-03-30
- **Summary**: 指针压缩（Pointer Compression）是 V8 近年最重要的内存优化之一。通过在 64 位系统上使用 32 位偏移量来表示指针，V8 设法减少了高达 40% 的堆内存占用，同时通过精妙的编码技巧保持了性能。

---

### 1. 为什么需要指针压缩？

2014 年 Chrome 转向 64 位。虽然带来了性能和安全性，但代价是：**每一个指针从 4 字节增加到了 8 字节**。
在典型的 JS 应用中，堆内存约 70% 存储的是“标记值”（Tagged Values，即对象指针或小整数 Smi）。这意味着大量的内存被浪费在存储高位的 0 或是相同的基地址信息上。

### 2. 核心原理：4GB 的“隔离笼” (Cage)

V8 意识到，虽然 64 位地址空间巨大，但单个 V8 实例（Isolate）的堆大小通常被限制在 4GB 以内。

- **基地址 (Base)**：V8 在内存中预留一个连续的 4GB 区域。
- **32 位偏移量 (Offset)**：在堆内存储时，不再存完整的 64 位地址，只存该对象相对于基地址的 32 位偏移量。
- **解压 (Decompression)**：当 CPU 需要读取数据时，将 32 位偏移量与 64 位的基地址相加（`uncompressed_ptr = base + compressed_ptr`），即可还原回物理地址。

### 3. 技术挑战与优化

#### A. 零停损负载 (Zero-overhead access)

为了保证解压不拖慢速度，V8 做了多项尝试：

- **分支预测逻辑**：初期尝试过无分支代码，但发现现代 CPU 的分支预测器非常强大，带分支的代码反而因为指令数更少而更快。
- **寄存器优化**：保留一个专用寄存器（r13 或是 root register）用于存储基地址，使得加法操作能在一个 CPU 周期内完成。

#### B. Smi（小整数）的处理

为了区分指针和整数，V8 使用最低位作为 Tag。在 64 位下，Smi 可以有 32 位。但在压缩模式下，Smi 必须也被压缩到 32 位以内。

- **Smi 破坏性解压 (Smi-corrupting)**：V8 发现，如果解压时无脑加上基地址而不检查是否是 Smi，虽然 Smi 的高位会被“弄脏”，但如果所有计算指令只看低 32 位，这种方法能节省一次判定分支，进一步提升性能。

### 4. 影响与结果

- **内存减少**：在 Windows 10 等平台上，V8 堆内存减少了约 **43%**。
- **性能甚至有提升**：虽然多了解压步骤，但由于数据变小，**CPU 缓存（L1/L2 Cache）的命中率显著提高**，导致在实际场景下性能反而提升了 5-10%。

### 5. 结论

指针压缩证明了：在现代计算中，内存带宽和缓存命中率往往比单纯的 CPU 计算周期更珍贵。它是权衡计算机体系结构限制与软件逻辑的工程杰作。
