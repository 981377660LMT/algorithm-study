# 79. Concurrent marking in V8 | V8 中的并发标记：Orinoco 的飞跃

垃圾回收（GC）的停顿时间一直是性能优化的瓶颈。Orinoco 项目通过并发标记（Concurrent Marking）技术在 V8 v6.4 中初现雏形，并在后续版本中趋于完善。

## 1. 核心挑战：并发环境下的对象图一致性

传统的标记清除 GC 需要 "Stop-The-World"。并发标记允许在 JS 执行的同时进行标记，但这会引入**竞争条件**：如果 JS 修改了已经被 GC 扫描过的对象的指针，GC 可能会漏掉某些存活对象（造成悬挂指针及崩溃）。

## 2. 解决方案：三色标记法 (Tri-color Marking)

V8 将对象标记为三种状态：

- **白色**：尚未发现的对象。
- **灰色**：已发现其存在，但其子对象尚未扫描。
- **黑色**：已发现且其引用的子对象也已全部扫描并标记。

由于 JS 线程和 GC 线程并发操作，必须保证：**黑色对象不能指向白色对象**。

## 3. 写屏障 (Write Barrier) 与 Dijkstra 协议

为了维护一致性，V8 引入了 **Dijkstra 写屏障**。每当 JS 线程执行 `obj.field = value` 且 `obj` 是黑色而 `value` 是白色时，写屏障会立即将 `value` 标记为灰色。

- **性能开销**：写屏障会略微降低 JS 执行速度。V8 通过高度优化的代码路径（汇编/CSA）尽量减小这一开销。

## 4. 快照协议 (Snapshotting Protocol)

在处理对象布局改变（如修改 Hidden Class）时，V8 使用了快照协议。标记任务并不是直接在对象上操作，而是基于一组工作项（Worklist）。

- 当对象结构发生变化时，V8 会确保标记任务能够看到一致的对象视图，或者触发重新标记。

## 5. 收益：9ms 到 1ms 的跨越

在实际测试（如 Chrome 的渲染进程）中，并发标记将主线程的标记工作量减少了 **60% 到 90%**，使得用户感知的停顿时间大幅缩减。
