# 嵌入式数据库逻辑

基于[CMU 15-445/645 数据库系统](https://15445.courses.cs.cmu.edu/fall2022/slides/)课程，本文档涵盖了将应用程序逻辑嵌入数据库系统的概念、技术和使用场景。

## 一、传统数据库交互模型

传统上，应用程序逻辑位于应用层，与 DBMS 进行"对话"式交互：

1. 应用程序通过网络协议与数据库通信
2. 使用客户端 API（如 JDBC、ODBC）发送 SQL 语句
3. 每个数据库操作都可能需要单独的网络往返

这种对话式 API 的工作流程：

- 开始事务
- 执行 SQL
- 应用程序处理逻辑
- 执行更多 SQL
- 提交事务

## 二、嵌入式数据库逻辑的优势

将应用程序逻辑移入 DBMS 可以提供多项潜在好处：

1. 减少网络往返次数
2. 数据变更的即时通知
3. DBMS 在事务期间减少等待时间
4. 开发人员无需重新实现功能
5. 鼓励模块化和代码重用

## 三、用户定义函数(User-defined Functions, UDFs)

### 定义与类型

UDF 是由应用程序开发人员编写的函数，用于扩展系统的内置功能：

- **返回类型**：

  - 标量函数：返回单个数据值
  - 表函数：返回结果表

- **计算定义方式**：
  - SQL 函数
  - 外部编程语言

### SQL 函数示例

```sql
CREATE FUNCTION get_foo(int)
RETURNS foo
LANGUAGE SQL AS $$
  SELECT * FROM foo WHERE foo.id = $1;
$$;

-- 使用方式
SELECT get_foo(1);
SELECT * FROM get_foo(1);
```

### PL/pgSQL 示例

```sql
CREATE OR REPLACE FUNCTION sum_foo(i int)
RETURNS int AS $$
DECLARE
  foo_rec RECORD;
  out INT;
BEGIN
  out := 0;
  FOR foo_rec IN SELECT id FROM foo WHERE id > i LOOP
    out := out + foo_rec.id;
  END LOOP;
  RETURN out;
END;
$$ LANGUAGE plpgsql;
```

### UDF 的优缺点

**优点**：

- 鼓励模块化和代码重用
- 减少网络往返
- 某些应用逻辑使用 UDF 比 SQL 更易表达和阅读

**缺点**：

1. 查询优化器将 UDF 视为黑盒

   - 无法估计 UDF 的成本

2. UDF 难以并行化

   - 包含 UDF 的查询可能被限制为单线程执行
   - 有些 UDF 会增量构建查询

3. 复杂 UDF 在 SELECT/WHERE 子句中使用会导致逐行执行

   - "RBAR" = "Row By Agonizing Row"（痛苦的逐行处理）
   - 如果 UDF 调用查询，性能问题更严重

4. DBMS 无法对 UDF 内语句进行跨语句优化

**性能影响示例**：

- TPC-H Q12 查询使用 UDF(SF=1)：
  - 原始查询：0.8 秒
  - 含 UDF 查询：13 小时 30 分钟

## 四、存储过程(Stored Procedures)

存储过程是在 DBMS 内执行更复杂逻辑的自包含函数：

- 可以有多个输入/输出参数
- 可以修改数据库表/结构
- 通常不在 SQL 查询中使用
- 某些 DBMS 区分 UDF 和存储过程，但并非所有都如此

### 存储过程示例

```sql
CREATE OR REPLACE PROCEDURE transfer(sender INT, receiver INT, amount FLOAT)
LANGUAGE plpgsql AS $$
DECLARE
  sndr_bal INT;
  sndr_name VARCHAR;
BEGIN
  SELECT name, balance INTO sndr_name, sndr_bal
  FROM accounts WHERE id = sender;

  IF sndr_bal < amount THEN
    RAISE EXCEPTION '% does not have enough money!', sndr_name;
  END IF;

  UPDATE accounts SET balance = balance - amount WHERE id = sender;
  UPDATE accounts SET balance = balance + amount WHERE id = receiver;
  COMMIT;
END;
$$;

-- 调用方式
CALL transfer(1, 2, 50);
```

### 存储过程与 UDF 比较

- UDF 旨在执行只读计算的子集
- 存储过程旨在执行独立于查询的完整计算

## 五、数据库触发器(Triggers)

触发器指示 DBMS 在发生某些数据库事件时调用 UDF：

- 需要定义：
  - 什么类型的事件会触发它
  - 事件的范围
  - 相对于该事件何时触发

### 触发器示例

```sql
-- 创建主表
CREATE TABLE foo (
  id INT PRIMARY KEY,
  val VARCHAR(16)
);

-- 创建审计表
CREATE TABLE foo_audit (
  id SERIAL PRIMARY KEY,
  foo_id INT REFERENCES foo (id),
  orig_val VARCHAR,
  cdate TIMESTAMP
);

-- 创建触发函数
CREATE OR REPLACE FUNCTION log_foo_updates()
RETURNS trigger AS $$
BEGIN
  IF NEW.val <> OLD.val THEN
    INSERT INTO foo_audit
      (foo_id, orig_val, cdate)
    VALUES (OLD.id, OLD.val, NOW());
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 创建触发器
CREATE TRIGGER foo_updates
BEFORE UPDATE ON foo FOR EACH ROW
EXECUTE PROCEDURE log_foo_updates();
```

### 触发器定义

1. **事件类型**：

   - INSERT, UPDATE, DELETE, TRUNCATE
   - CREATE, ALTER, DROP

2. **事件范围**：

   - TABLE, DATABASE, VIEW, SYSTEM

3. **触发时机**：
   - 查询执行之前
   - 查询执行之后
   - 查询影响的每一行之前
   - 查询影响的每一行之后
   - 替代查询

## 六、变更通知(Change Notifications)

变更通知类似于触发器，但 DBMS 会向外部实体发送消息，通知数据库中发生了值得注意的事件：

- 类似于"发布-订阅"系统
- 可以与触发器链接，传递变更

### 通知示例

```sql
CREATE OR REPLACE FUNCTION notify_foo_updates()
RETURNS trigger AS $$
DECLARE notification JSON;
BEGIN
  notification = row_to_json(NEW);
  PERFORM pg_notify('foo_update',
            notification::text);
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 创建通知触发器
CREATE TRIGGER foo_notify
AFTER INSERT ON foo_audit FOR EACH ROW
EXECUTE PROCEDURE notify_foo_updates();
```

## 七、用户定义类型(User-defined Types)

### 复杂类型处理

处理复杂数据类型的方法：

1. **属性拆分**：

   ```sql
   INSERT INTO locations (x, y, label)
   VALUES (10, 20, "OTB");
   ```

2. **应用程序序列化**：
   ```sql
   INSERT INTO location (coord)
   VALUES ('{x:10, y:20, label:"OTB"}');
   ```

### 用户定义类型

用户定义类型是应用程序开发人员定义的特殊数据类型，DBMS 可以原生存储：

- 最初由 Postgres 在 1980 年代引入
- 添加到 SQL:1999 标准作为"对象关系数据库"扩展的一部分

```sql
-- Oracle语法
CREATE TYPE coordinates AS OBJECT (
  x INT NOT NULL,
  y INT NOT NULL,
  label VARCHAR(32) NOT NULL
);

-- PostgreSQL语法
CREATE TYPE coordinates AS (
  x INT,
  y INT,
  label VARCHAR(32)
);
```

## 八、视图(Views)

视图创建一个包含 SELECT 查询输出的"虚拟"表，可以像实表一样访问：

- 允许程序员简化经常执行的复杂查询
- 常用作隐藏表的某些属性的机制

### 视图示例

```sql
-- 创建计算机科学学生记录视图
CREATE VIEW cs_students AS
SELECT sid, name, login
FROM student
WHERE login LIKE '%@cs';

-- 创建学生平均年龄视图
CREATE VIEW cs_gpa AS
SELECT AVG(gpa) AS avg_gpa
FROM student
WHERE login LIKE '%@cs';
```

### 视图与 SELECT INTO 比较

- **视图**：动态结果仅在需要时实现
- **SELECT INTO**：创建不随 student 表更新而更新的静态表

### 更新视图

SQL-92 标准指定，如果视图具有以下属性，应用程序可以修改：

- 仅包含一个基表
- 不包含分组、去重、联合或聚合

### 物化视图

创建包含 SELECT 查询输出的视图，但结果被保留（不需要每次访问时重新计算）：

```sql
CREATE MATERIALIZED VIEW cs_gpa AS
SELECT AVG(gpa) AS avg_gpa
FROM student
WHERE login LIKE '%@cs';
```

- 某些 DBMS 在底层表更改时自动更新物化视图
- 其他 DBMS（如 PostgreSQL）需要手动刷新

## 九、总结

将应用程序逻辑移入 DBMS 具有许多好处：

- 更好的效率
- 跨应用程序可重用

但也存在问题：

- 不可移植
- DBA 不喜欢经常变更
- 可能需要维护不同版本

---

嵌入式数据库逻辑为开发人员提供了强大的工具，可以在保持数据库完整性的同时优化性能和功能。了解这些概念对于设计高效、可维护的数据库应用程序至关重要。

找到具有 1 个许可证类型的类似代码
