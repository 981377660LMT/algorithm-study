# CMU15445 并发控制的其他关键问题

## 1. 并发控制协议实现

### 1.1 基于锁的并发控制 (Lock-Based Concurrency Control)

**两阶段锁协议 (Two-Phase Locking, 2PL)**

- **获取阶段**：事务只能获取锁，不能释放锁
- **释放阶段**：事务只能释放锁，不能获取锁
- **变种**：
  - **严格两阶段锁 (Strict 2PL)**：事务持有所有排他锁直到提交
  - **保守两阶段锁 (Conservative 2PL)**：事务在开始时获取所有需要的锁

**锁的类型**

- **共享锁 (S-Lock)**：允许多个事务同时读取数据
- **排他锁 (X-Lock)**：只允许一个事务修改数据
- **意向锁 (Intention Locks)**：用于层次化锁定，提高效率

**死锁处理**

- **死锁检测**：周期性构建等待图并检查环
- **死锁预防**：使用时间戳排序或优先级方法
- **死锁避免**：使用Wait-Die或Wound-Wait算法

### 1.2 基于时间戳的并发控制 (Timestamp-Based)

- 每个事务分配唯一时间戳
- 按时间戳顺序执行事务
- 维护读时间戳和写时间戳，拒绝"过时"的操作
- Thomas写规则：忽略过时的写操作，提高并发性

### 1.3 多版本并发控制 (MVCC)

- 每次写操作创建数据项的新版本
- 读操作选择适当版本而非阻塞
- 优点：读不阻塞写，写不阻塞读
- 流行实现：PostgreSQL, Oracle, MySQL InnoDB

## 2. 隔离级别与并发异常

### 2.1 标准隔离级别

1. **读未提交 (READ UNCOMMITTED)**

   - 最低级别，允许脏读
   - 无锁定

2. **读已提交 (READ COMMITTED)**

   - 防止脏读
   - 可能出现不可重复读和幻读
   - 实现：读操作获取共享锁，语句执行后释放

3. **可重复读 (REPEATABLE READ)**

   - 防止脏读和不可重复读
   - 可能出现幻读
   - 实现：事务持有读锁直到提交

4. **可串行化 (SERIALIZABLE)**
   - 最高级别，防止所有并发异常
   - 实现：完全的两阶段锁或谓词锁

### 2.2 常见并发异常

1. **脏读 (Dirty Read)**

   - 读取未提交的数据
   - 例如：事务A修改某行，事务B读取新值，然后事务A回滚

2. **不可重复读 (Non-repeatable Read)**

   - 同一事务中，两次读取同一数据得到不同结果
   - 例如：事务A读取某行，事务B修改并提交该行，事务A再次读取得到不同结果

3. **幻读 (Phantom Read)**

   - 同一事务中，两次查询返回不同的行集合
   - 例如：事务A查询满足条件的所有行，事务B插入新行并提交，事务A再次查询发现新行

4. **丢失更新 (Lost Update)**
   - 两个并发事务覆盖彼此的更改
   - 例如：事务A和B同时读取同一行，然后都更新该行

## 3. 基于谓词的锁定

- **谓词锁 (Predicate Locking)**：锁定满足特定条件的所有数据
- **索引范围锁 (Index-Range Locking)**：锁定索引范围，作为谓词锁的近似实现
- 解决幻读问题的关键技术

## 4. 分布式事务与共识协议

- **两阶段提交 (2PC)**：协调多节点事务的原子性
- **三阶段提交 (3PC)**：2PC的改进版，解决协调者单点故障问题
- **Paxos/Raft**：分布式共识算法，确保副本一致性

## 5. 乐观并发控制

- 假设冲突很少，在提交时检测冲突
- **阶段**：
  1. 读阶段：记录读集和写集
  2. 验证阶段：检查是否有冲突
  3. 写阶段：如无冲突则提交更改
- 适合读密集型工作负载

## 6. 实际应用中的问题与优化

### 6.1 热点数据问题

- 频繁访问的数据成为性能瓶颈
- 解决方案：分区、缓存、特殊处理

### 6.2 长事务处理

- 长时间运行的事务增加冲突可能性
- 解决方案：分解事务、调整隔离级别

### 6.3 实现权衡

- **内存开销**：版本存储、锁表等结构占用内存
- **CPU开销**：冲突检测、死锁检测消耗CPU
- **伸缩性**：不同并发控制机制在高并发下的表现差异

## 7. 恢复机制与并发控制的关系

- **ARIES恢复算法**：写前日志(WAL)保证事务的原子性和持久性
- **检查点技术**：减少恢复时间
- 恢复过程与并发控制的协同工作确保ACID特性

## 8. 现代数据库系统中的实践

- **PostgreSQL**：使用MVCC和SSI(可串行化快照隔离)
- **MySQL InnoDB**：结合MVCC和锁机制
- **Oracle**：基于MVCC的读一致性机制
- **SQL Server**：使用锁管理器和多种隔离级别
