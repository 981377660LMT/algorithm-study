以下是一份**通俗易懂、便于记忆**的 CMU 15-445/645 课程「Lecture 13：查询执行 I – 逻辑计划与执行器架构 (Query Execution I)」学习笔记，主要介绍数据库从逻辑计划到物理执行的过程，以及在 BusTub 里是如何将“执行器”通过一个统一框架组合起来完成 SQL 查询的。希望帮助你快速理解并记住这些知识点！

---

## 1. 为什么要分“逻辑计划”和“执行器架构”？

- **逻辑计划**：数据库将 SQL 解析后，得到一颗“关系代数”风格的逻辑运算树（比如 `Join(Scan(A), Scan(B))`），这只是“干了些什么”的抽象，并没有指定用什么算法（Hash Join？Sort-Merge Join？）。
- **物理执行**：数据库最终要**选择具体算子**（哈希连接、索引扫描或顺序扫描等等）在系统中真正跑起来，并产出结果。为了让这些算子能“拼接”在一起，必须定义一个清晰的“执行器接口”和运行模型——也就是**执行器架构**。

简而言之：

> **逻辑计划**解决“做哪些操作”，  
> **执行器架构**解决“怎么组织代码与算子，让查询真正跑起来”。

---

## 2. 查询从 SQL 到执行：大概流程

1. **SQL 解析 (Parser)**：把 SQL 字符串转成一棵语法树 AST。
2. **语义绑定 (Binder)**：确认表、列名称含义，检查列是否存在、类型是否匹配。
3. **逻辑计划 (Logical Plan)**：将 AST 转成更高级的关系代数运算，比如 `Projection`, `Filter`, `Join`, `Aggregation` 等。
4. **优化器 (Optimizer)**：基于逻辑计划和统计信息，决定使用哪种物理算法（Index Scan / Hash Join 等），生成**物理计划**。
5. **执行器 (Executor)**：具体跑这些算子，把数据读进来、处理后输出结果。

**Lecture 13** 主要聚焦**物理执行**这一层，尤其是 **BusTub** 内部的“执行器架构”设计。

---

## 3. Volcano 模型：数据库“迭代器”风格

数据库里广泛采用**Volcano 模型**（也称“迭代器模型”）：

- 每个算子（operator）都提供统一接口：
  - `Init()`: 做初始化。
  - `Next(Tuple* out_tuple)`: 获取下一个输出行，直到返回 false 表示数据跑完。
- 上层算子通过不断调用下层算子的 `Next()` 方法来拉数据，然后做自己的工作，再往上层算子输出。

一个**简单比喻**：

> **想象连表算子**像个“水桶”，要不断从“下游水桶”的 `Next()` 里提水，再在自己桶里做混合过滤，最后再被上游“拉”走。  
> 这就是**pull-based**的“Volcano”执行风格，直观易懂。

---

## 4. 在 BusTub 中：PlanNode + Executor

### 4.1 PlanNode（物理计划节点）

- BusTub 里，每种算子都有对应的 **PlanNode**（如 `SeqScanPlanNode`, `IndexScanPlanNode`, `AggregationPlanNode` 等）。
- **PlanNode** 里会存放一些“配置信息”，如：
  - 要扫描哪个表（table_oid）
  - 要不要用索引
  - 要做哪些列投影
  - JOIN 的连接条件等

**PlanNode** 不做实际的数据处理逻辑，只是表示“**我是谁**、**要做啥**、**我的输入是谁**”。

### 4.2 Executor（执行器类）

- 对应每个 PlanNode，BusTub 有个 **Executor** 类（如 `SeqScanExecutor`, `InsertExecutor`, `JoinExecutor` 等）。
- `Executor` 实现了：
  1. `Init()`: 初始化资源；
  2. `Next()`：获取下一条满足输出条件的元组。
- 在**计划树**最底层，常见的就是一些“表扫描”执行器，或者“索引扫描”执行器；上层可组合连接、聚合等执行器；顶层把结果输出给调用者。

简单记住：

> “**PlanNode** = 做什么；**Executor** = 怎么做 + 真正执行。”

---

## 5. 关键组件：Catalog、Schema、Transaction

在执行时，还会用到以下几个要素：

1. **Catalog**：存放数据库元信息，如表的模式（schema）、索引信息、列信息等。执行器要访问 `catalog->GetTable(...)`，拿到真正的表指针（`TableHeap`）等。
2. **Schema**：列的名字、类型、偏移等，用来对输出的数据进行编码解码。
3. **Transaction**：保证事务一致性和并发控制，执行器在取数据时要知道当前事务 id、锁粒度、隔离级别等，以免读到不该读的或造成冲突。

---

## 6. 典型执行器举例：SeqScanExecutor

**以顺序扫描执行器（SeqScanExecutor）为例**：

- 它**继承** `AbstractExecutor`，并且对应 PlanNode 中 `SeqScanPlanNode`：
  1. 在 `Init()` 里，打开表的迭代器（如 TableHeap 的 `Begin()`）；
  2. 在 `Next()` 中，不断取下一个元组，对比 PlanNode 内的谓词（条件）是否满足，如果满足就投影输出，不满足就跳过；
  3. 直到扫描到表末尾就返回 false。

**所有执行器都相同模式**：

> - `Init()` → “准备开始干活”
> - `Next()` → “取下一条符合要求的输出”
> - 当 no more data 时返回 false

这些执行器可以互相**组合**：

- **例如**：JoinExecutor 的内表可能是一个 SeqScanExecutor，用来获取右表的数据；外表也可能是另一个执行器。
- **最顶层**执行器由**执行引擎**调它的 `Init()`，然后循环调用 `Next()` 把结果收集并返回给客户端。

---

## 7. 大脑 + 四肢：优化器 vs. 执行器

- 数据库的“**大脑**”是优化器，它根据统计信息选择最优物理算子并拼装成计划树；
- “**四肢**”就是执行器，实现具体算子的逻辑。
- 二者合起来就让 SQL 真正跑在系统上。

---

## 8. 课程总结要点

1. **从逻辑到物理**：逻辑计划描述要做哪些关系操作（Scan, Filter, Join, Project...），物理计划则具体落到（Index Scan, Hash Join, etc.）。
2. **Volcano 模型**：`Init() + Next()` 的 pull-based 迭代器设计，使得算子之间可以像乐高一样拼接，模块化且可维护。
3. **PlanNode vs. Executor**：PlanNode 记录“我是什么、有什么参数”；Executor 实现“如何真正执行”，需要访问 Catalog、表、索引，并与事务系统交互。
4. **BusTub 架构**：封装整洁，每个算子有各自的 Executor 派生类；顶层调度器负责实例化并串起所有执行器，以 `Next()` 流式产出数据。

**一句话记忆**：

> **“编译器式两步走：逻辑计划决定做什么，物理执行器负责怎么做；Volcano 模型让算子像乐高一样拼接。”**

---

## 9. 总结

- **Lecture 13** 展示了数据库查询执行的**核心思想**：从一个“逻辑层面”的操作树，转到真正的执行算子，并在系统中以**迭代器（Volcano）**模式连接起来工作。
- 在 BusTub，`PlanNode + Executor` 模式相当典型：PlanNode 表示执行计划（不碰数据），Executor 决定如何访问表、索引、执行连接或聚合等操作。
- 这样的架构，使得数据库可以灵活添加新算子，也方便优化器在编译阶段挑选算子，把他们组合成高效的物理计划。

**理解这一点，就可以更好地明白：为什么 SQL 解析完会先生成一个“执行计划”，然后才能进入到真正的“执行阶段”。**
