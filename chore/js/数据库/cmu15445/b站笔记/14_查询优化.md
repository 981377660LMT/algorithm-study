## 1. 为什么要有查询优化？

- **查询优化**的目标是：在可能的多种执行方式中，挑选出**运行代价最小**的一种（或近似最优）。因为同样一条 SQL，不同执行策略（索引使用、连接顺序、连接算法等）会导致数倍甚至上千倍的性能差异。
- 商业数据库（如 Oracle、MySQL、PostgreSQL）通常采用**Cost-Based Optimizer (CBO)**，通过一系列算法寻找**可串行化**的、尽量高效的执行计划。没有优化器，数据库就只能盲目扫描或使用固定算法，性能难以保证。

---

## 2. 查询优化的主要步骤

### 2.1 解析与逻辑计划

1. **SQL 解析 (Parser)**：将文本 SQL 转为语法树。
2. **语义绑定 (Binder)**：校验表名、列名、数据类型等。
3. **生成逻辑计划**：将语法树转换成关系代数表达式（Scan、Filter、Join、Projection、GroupBy 等），**不**指定具体算法。

### 2.2 物理计划与优化

1. **物理算子选择**：如选择顺序扫描 (`SeqScan`) 还是索引扫描 (`IndexScan`)，选择哈希连接或排序-合并连接等。
2. **连接顺序优化**：多表连接时决定先连哪两个表、以何种算法连接，这对性能影响极大。
3. **谓词下推 & 投影下推**：尽量提早过滤数据、减少数据流量；只保留需要的列。
4. **子查询改写**：将子查询改造成连接或半连接，以减少重复计算。
5. **基数 & 代价估算**：基于表大小、索引选择性、列分布等统计信息，评估每步消耗的 I/O 和 CPU，使优化器可选择较优路径。
6. **结果**：输出一个具体的物理执行计划（例如 IndexScan + HashJoin + HashAggregate 等），数据库执行器按照此计划来操作底层数据。

---

## 3. 常见的优化技术

### 3.1 连接顺序优化

- **多表连接**有多种可能顺序，如 (A ⨝ B) ⨝ C vs. A ⨝ (B ⨝ C)。在 3 表以上时，组合呈指数增长。
- 优化器常用**动态规划**：从单表开始算最优子计划，逐步扩展到n表连接；或使用**启发式**、**规则**剪枝。
- 正确选择“外表/内表”、以及连接算法（Hash Join、Index Join、Sort-Merge Join）可以大幅提升性能。

### 3.2 谓词下推 (Predicate Pushdown)

- 目标：**尽量早地筛选**掉无关数据，减小下游算子的处理量。
- 例如：`SELECT ... FROM (A JOIN B) WHERE A.x > 10`，把 `A.x > 10` 谓词尽量在扫描表 A 阶段就过滤掉行数，而不是等连接完再过滤。

### 3.3 投影下推 (Projection Pushdown)

- 若只需要部分列，不要拖着所有列一路传。
- 尽量在靠近数据源时就**只取需要的列**，减少 I/O 和中间结果大小。

### 3.4 变形子查询 (Subquery rewrite)

- 如将 `SELECT ... WHERE col IN (subquery)` 转成半连接；
- 将 `EXISTS` 转成更直接的 join 或 distinct 方式，提高效率。

### 3.5 聚合优化 (Aggregation Optimization)

- 若有索引，可用索引加速 MIN/MAX；
- GROUP BY 前先过滤无用数据；
- 选择哈希聚合或排序聚合，看数据规模和是否需要排序结果。

---

## 4. 代价估算：Cost-Based Optimizer (CBO)

- 核心是**估算每一步操作的代价**：
  - I/O 次数（磁盘访问）
  - CPU 时间
  - 网络传输（在分布式DB中）
- 基于**基数估计**：对每个谓词可能剩下多少行进行估算，需要表的元信息（行数、索引、直方图分布、列上NDV等）。
- 通过**动态规划**或其他搜索算法，在所有可能的物理计划中选一个**估计代价最小**的进行执行。

---

## 5. Rule-Based Optimizer (RBO) 与启发式优化

- 较简单的系统或教学系统（如早期 MySQL 或 BusTub）往往没有复杂的 CBO，而是根据**固定规则**做决定，如：
  - “等值连接就用哈希连接”
  - “有索引就改成索引扫描”
  - “将投影和过滤往下推”
- 尽管简单，但不能保证绝对最优，仅能在常见场景下获得不错的性能。

---

## 6. 性能案例

- **错误连接顺序**：4 张大表做连接，如果先连接两张最大表，可能产生巨大中间结果；若先过滤其中一张表或连小表优先，中间结果大幅减少，性能提升数百倍。
- **索引使用**：若查询只返回极少数行，则索引扫描是极优，否则大范围访问时反而顺序扫描更快。
- **谓词下推**：若不推下去，可能在 JOIN 后才过滤掉大量数据；多浪费几十万行的无谓处理。

---

## 7. 总结

1. **查询优化**是数据库系统“智能”的核心，极大地影响查询性能。
2. **Cost-Based**方法能在统计信息的支持下找较优执行计划；**Rule-Based**则根据已有启发式规则进行变换。
3. 核心优化手段：**连接顺序选择**、**谓词/投影下推**、**索引利用**、**聚合和子查询改写**等。
4. 现代优化器在多表连接、大规模数据、并行/分布式场景下会更复杂，但思路仍相通：**减少无效数据处理，选择最优算法并尽量减少中间结果。**

**一句话记忆**：

> “SQL 本质是一种声明式语言，数据库通过查询优化器，  
> 把它翻译成最优物理操作序列，才能拿到高性能。”

这样，我们就能理解为什么数据库能“自动”选用索引、改变连接顺序，以及为什么同一条 SQL 改写一下可能性能爆炸式提升——都源于**查询优化器**在幕后做了许多工作。祝你学习顺利！
