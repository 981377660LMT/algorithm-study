# 查询优化

## 一、查询优化基础

### 查询优化的目标

查询优化是DBMS中最复杂的模块之一，目标是：

- 为给定查询找到**执行代价最低**的正确执行计划
- 已被证明是NP完全问题（计算复杂度非常高）
- 实际实现中没有优化器能够真正找到"最优"计划
  - 使用估计技术猜测计划实际代价
  - 使用启发式方法限制搜索空间

### 逻辑计划与物理计划

- **逻辑计划**：表示查询的抽象操作，独立于执行细节
- **物理计划**：定义具体执行策略，包含访问路径和算法细节
  - 物理算子依赖于数据的物理格式（排序、压缩等）
  - 逻辑算子到物理算子不一定是1:1映射

### 查询优化架构

1. **解析器**：SQL转换为抽象语法树
2. **绑定器**：名称解析（表名、列名→内部ID）
3. **重写器**：基于规则优化
4. **优化器**：基于代价优化
5. **物理计划生成**：最终确定执行计划

## 二、基于规则/启发式的优化

基于规则的优化通过模式匹配将逻辑计划转换为等价的更高效计划，无需检查数据内容：

### 1. 逻辑查询优化技术

- **拆分连接谓词**：将复合谓词分解为最简单形式
  ```sql
  WHERE A.id=B.id AND B.val>10 AND C.name='xyz'
  ```
  拆分为独立谓词，便于优化器移动
- **谓词下推**：将过滤条件尽可能推到查询树的底层
  - 越早过滤数据，中间结果越小
  - 减少后续操作需处理的数据量
- **替换笛卡尔积**：用内连接替换笛卡尔积
  - 从 `A × B WHERE A.id = B.id`
  - 变为 `A ⋈ B ON A.id = B.id`
- **投影下推**：在管道中断前消除冗余属性
  - 减少物化成本和内存使用

### 2. 嵌套子查询处理

处理嵌套子查询的两种方法：

- **重写方法**：去相关化或扁平化嵌套查询
  ```sql
  -- 从这个:
  SELECT name FROM sailors WHERE EXISTS (
    SELECT * FROM reserves WHERE sailors.sid = reserves.sid
  )
  -- 重写为:
  SELECT name FROM sailors, reserves
  WHERE sailors.sid = reserves.sid
  ```
- **分解方法**：将查询分解为块，专注于一次处理一个块
  - 子查询写入临时表，查询完成后丢弃

### 3. 表达式重写

优化器转换查询表达式，实现方式：

- 基于if/then/else子句
- 基于模式匹配规则引擎

常见重写规则：

- **不可能/不必要谓词**：`WHERE 1=0` → `false`
- **合并谓词**：`val BETWEEN 1 AND 100 OR val BETWEEN 50 AND 150` → `val BETWEEN 1 AND 150`

## 三、查询代价模型

DBMS使用代价模型预测给定数据库状态下查询计划的行为：

### 代价模型组成

1. **物理代价**：预测CPU周期、I/O、缓存未命中等
2. **逻辑代价**：估算每个操作符输出大小
3. **算法代价**：操作符算法实现的复杂度

例如，PostgreSQL代价模型使用加权的CPU和I/O代价：

- 内存中处理元组比从磁盘读取快400倍
- 顺序I/O比随机I/O快4倍

### 统计信息与选择率

数据库收集和维护表格、属性和索引的统计信息，用于估计查询代价：

- **选择率**是满足谓词的元组比例：
  - 等值谓词：`selectivity(A=constant) = 出现次数/表大小`
  - 范围谓词：基于分布估计
  - 否定：`1 - 原谓词选择率`
  - 合取(AND)：各谓词选择率相乘（假设独立）
  - 析取(OR)：`P1 + P2 - (P1 * P2)`（假设独立）

### 数据分布统计

为提高选择率估计准确性，DBMS使用：

1. **直方图**：维护列值的分布信息

   - 等宽直方图：每个桶宽度相同
   - 等深直方图：每个桶包含大致相同数量的值

2. **草图(Sketches)**：概率性数据结构，提供近似统计

   - Count-Min Sketch：近似频率计数
   - HyperLogLog：近似不同元素数量

3. **采样**：维护表格的小子集估计选择率

## 四、基于代价的优化

基于代价的优化枚举查询的多个等价计划，并选择代价最低的：

### 1. 单关系查询规划

- 选择最佳访问方法：
  - 顺序扫描
  - 二分查找（聚集索引）
  - 索引扫描
- 谓词评估顺序优化
- OLTP查询通常简单，仅需选择最佳索引

### 2. 多关系查询规划

两种主要方法：

#### 自底向上优化 (System R风格)

- 先用静态规则进行初始优化
- 使用动态规划确定最佳连接顺序
- 迭代构建"左深"连接树
- 步骤：
  1. 选择每个表的最佳访问路径
  2. 枚举所有可能的连接顺序
  3. 确定代价最低的连接顺序

#### 自顶向下优化 (Cascades框架)

- 从逻辑计划开始，执行分支限界搜索
- 将逻辑算子转换为物理算子
- 在搜索中跟踪全局最佳计划
- 优势：
  - 将数据的物理属性作为规划中的一等公民
  - 支持更灵活的搜索策略
  - 可以处理复杂的物理属性要求（如排序）

## 总结

查询优化结合两大策略：

1. **基于规则的优化**：无需理解数据库内容就能提高效率
2. **基于代价的优化**：使用统计信息和成本模型选择最高效的执行计划

实际系统中，优化器使用启发式方法和剪枝技术限制搜索空间，在优化质量和优化时间之间取得平衡。由于NP完全的复杂性，查询优化仍是数据库研究的活跃领域。
