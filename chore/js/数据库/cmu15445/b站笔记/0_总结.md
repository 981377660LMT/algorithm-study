https://www.jianshu.com/p/aaf708b422ea

RDBMS 有3个硬骨头，分别是`查询优化`，`并发控制`，`失败恢复`
三个关键：`存储`、`查询`、`事务`

## 为什么需要数据库系统？

- **管理大数据**：能管理超过内存大小的数据。
- **高效读写**：优化磁盘I/O，避免长时间停顿和性能退化。
- **事务保障**：支持ACID，保证数据安全和一致性。

---

## 数据库底层存储结构

### 1. 存储管理器（Storage Manager）

- 负责磁盘页（Page）的读写，优化空间和时间局部性。

### 2. 数据文件组织

- **Heap File**：无序存储，插入快。
- **聚集索引（B树）**：有序存储，查找快。
- **Hash File**：按哈希分布，适合等值查找。

### 3. Heap File 组织方式

- **链表法**：有Page头，指向free page list和data page list。
- **目录法**：用字典文件记录所有数据页及其free slot数量。

### 4. 数据页结构

- 页头：存页大小、校验和、版本、事务可见性等元数据。
- Slot数组：指向每个tuple的offset，slot从前往后增，tuple从后往前存。

### 5. LSM（Log-Structured Merge）存储

- 存操作日志，读时重放日志恢复数据，配合索引和布隆过滤器加速。

### 6. Tuple 存储

- 只存实际数据，唯一定位方式为(page_id, slot/offset)。

### 7. 存储模型

- **行存储**：适合OLTP，插入/更新快。
- **列存储**：适合OLAP，压缩好，扫描快。

---

## Buffer Pool 管理

- **Buffer Pool Manager**：数据库自管缓存，能做更智能的淘汰、预取、刷盘。
- **Page Table**：内存中维护page_id到内存页的映射。
- **Page Directory**：硬盘上维护page_id到文件位置的映射。
- **优化**：预取、共享扫描、顺序扫描绕过、O_DIRECT跳过OS缓存。
- **淘汰策略**：用LRU-K防止顺序扫描污染缓存。

---

## Hash表

- 关注哈希函数选择和冲突处理（如链表法、线性探测、Cuckoo Hash）。
- 静态哈希需预估元素数，动态哈希（如extendible hashing）可自动扩容。

---

## B树

- 完美平衡，所有叶子同深度，非根节点至少半满。
- 聚集索引叶子存tuple，非聚集索引存record_id。
- 优化：前缀压缩、后缀截断、指针优化、批量插入。
  后缀截断：如果后缀的信息没有区分度，则在中间节点的时候可以砍掉
- 可变key：用指针、可变节点、padding、间接key map。
- 重复key：key数组+value数组或key->value组。
- 插入分裂：叶子复制key，内部推key到父节点。

---

## 索引类型

- 隐式索引：如主键、唯一约束自动建。
- 局部索引：只索引表的部分数据。
- 覆盖索引：联合索引覆盖所有查询字段，无需回表。
- 包含索引：部分字段只在叶子节点存储。

---

## Latch Crabbing（锁攀爬）

- 先锁父节点，再锁子节点，子节点安全后释放父锁。
- 查找时读锁，插删时写锁，安全时释放祖先锁。
- 可先假设叶子安全，错了再重试。

---

## 外排序与分组

- 外排序：分批排序写磁盘，K路归并。
- 分组/去重：分区落盘，分批读入内存hash去重。

---

## Join算法

- Nested Loop Join：小表做外层，内存缓存外表，内表用索引。
- Sort-Merge Join：先排序再合并，适合有序输出。
- Hash Join：分区后hash join，内存不够可多轮分区。

---

## 执行计划

- 迭代模型：每个算子实现next，流式处理。
- 物化模型：一次性处理返回。
- 矢量模型：批量处理。

---

## 并发

- 进程并发：隔离好，切换慢。
- 线程并发：快，需自管调度。

---

## 并行

- Intra-query：单个查询内部并行，减少慢SQL延迟。
  一种类似 map-reduce，另一种pipeline式的。
- Inter-query：多个查询并行，提升吞吐量。

---

## 事务与调度

- ACID：原子性、一致性、隔离性、持久性。
- 操作冲突：不同事务对同一对象的读写。
- Conflict Serializability：依赖图无环即等价串行。
- View Serializability：更宽松，实际很少用。

---

## 锁协议

- 二阶段锁（2PL）：先拿锁后还锁，可能级联abort和死锁。
- 严格2PL：只在事务结束时释放锁，防脏读。
- 死锁检测：依赖图找环，选事务回滚。
- 死锁预防：wait-die（老等新死），wound-wait（老抢新等）。
- 锁粒度：意向锁、锁升级。

---

## 乐观并发控制

- TO（Timestamp Ordering）：按时间戳判冲突，易饥饿。
- OCC（Optimistic CC）：读-校验-写，低冲突时高效。
- MVCC：多版本并发控制，读写互不阻塞，需GC和索引管理。

---

## 恢复机制

- REDO log：恢复已提交事务。
- UNDO log：回滚未提交事务。
- WAL：先写日志再写数据，保证崩溃恢复。
- Checkpoint：定期刷盘，回收日志。
- Shadow Paging：无日志，切换指针，性能差。

---

## ARIES 恢复算法

- 适用STEAL+NO-FORCE策略，配合WAL。
- 日志有LSN，刷盘需保证pageLSN ≤ flushedLSN。
- 提交时刷日志，回滚写CLR。
- Checkpoint记录ATT（活跃事务表）和DPT（脏页表）。
- 恢复分三步：
  1. 分析：恢复ATT和DPT。
  2. 重做：从DPT最小LSN开始redo。
  3. 撤销：undo未完成事务。

---

**一句话总结**：  
数据库系统通过精细的存储管理、并发控制和崩溃恢复机制，实现了高效、安全、可扩展的数据管理。
