# 数据库事务与ACID特性详解

## 一、事务基础

### 1.1 什么是事务？

事务是数据库管理系统中执行的一系列操作（如SQL查询）的序列，它作为数据库变化的基本单位，具有以下特性：

- 要么全部执行成功，要么一条也不执行
- 一个事务可能包含多个读写操作，但对DBMS而言，只关心哪些数据被读取/写入

### 1.2 事务的SQL表示

```sql
BEGIN;        -- 开始事务
-- 操作语句...
COMMIT;       -- 提交事务（保存所有更改）
-- 或者
ABORT/ROLLBACK; -- 中止事务（撤销所有更改）
```

## 二、ACID特性

### 2.1 原子性（Atomicity）

**定义**：事务中的所有操作要么全部执行，要么全部不执行。

**实现机制**：

1. **日志机制（Logging）**

   - DBMS记录所有操作以便于撤销中止事务的操作
   - 在内存和磁盘上维护撤销记录
   - 几乎所有现代DBMS都采用此方法

2. **影子分页（Shadow Paging）**
   - DBMS复制页面，事务在这些副本上进行更改
   - 只有在事务提交时，这些页面才对其他事务可见
   - 应用较少（如CouchDB、LMDB等）

### 2.2 一致性（Consistency）

分为两种一致性概念：

1. **数据库一致性**

   - 数据库准确地模拟现实世界并遵循完整性约束
   - 未来的事务能看到过去已提交事务的效果

2. **事务一致性**
   - 如果数据库开始时是一致的，且事务保持一致性，则结束后仍是一致的
   - 这是应用程序的责任，DBMS无法控制

### 2.3 隔离性（Isolation）

**定义**：每个事务的执行，看起来就像它是系统中唯一运行的事务。

#### 2.3.1 并发问题与冲突

**冲突操作**：两个操作满足以下条件时发生冲突：

- 来自不同事务
- 作用于同一对象
- 至少有一个是写操作

**三种主要冲突类型**：

1. **读-写冲突**：不可重复读（同一事务多次读取同一数据得到不同结果）
2. **写-读冲突**：脏读（事务读取了另一个未提交事务修改的数据）
3. **写-写冲突**：丢失更新（一个事务覆盖了另一个未提交事务的更改）

#### 2.3.2 可串行化调度

**基本概念**：

- **串行调度**：不同事务的操作不交错执行
- **等价调度**：对任何初始数据库状态，两个调度执行的结果相同
- **可串行化调度**：与某种串行执行等价的调度

**冲突可串行化**：

- 两个调度冲突等价：如果它们包含相同事务的相同操作，且每对冲突操作的顺序相同
- 调度S是冲突可串行化的，如果S与某个串行调度冲突等价
- 直观理解：可以通过交换连续的非冲突操作将S转换为串行调度

**依赖图（优先图）算法**：

- 每个节点表示一个事务
- 如果事务Ti的操作Oi与事务Tj的操作Oj冲突，且Oi在调度中早于Oj，则从Ti到Tj画一条边
- 一个调度是冲突可串行化的当且仅当其依赖图无环

**视图可串行化**：

- 比冲突可串行化更宽松的概念
- 两个调度视图等价：相同事务读取相同的初始值和修改值，写入相同的最终值
- 允许所有冲突可串行化的调度，外加"盲写"（写入但从不读取的数据）
- 实际上难以高效实现，几乎不被DBMS采用

### 2.4 持久性（Durability）

**定义**：一旦事务提交，其更改就应该是持久的，即使系统崩溃。

**实现机制**：

- 日志记录
- 影子分页

## 三、关键概念理解

### 3.1 串行化与并发

- 虽然用户希望事务像串行执行一样，但为了高性能，DBMS会交错执行事务
- 并发控制协议决定了操作的适当交错方式，分为悲观和乐观两种策略
- 在实践中，为了提高并发性，DBMS仅支持冲突可串行化，并在应用层面单独处理特殊情况

### 3.2 调度关系示意图

```
所有可能的调度
   ↓
视图可串行化调度（难以实现）
   ↓
冲突可串行化调度（实际实现）
   ↓
串行调度
```

串行化是DBMS处理并发操作的核心机制，通过保证事务执行结果等价于某种串行执行，从而在保证正确性的前提下提高系统的并发性和吞吐量。
