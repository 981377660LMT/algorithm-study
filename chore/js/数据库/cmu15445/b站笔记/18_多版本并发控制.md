# 多版本并发控制（Multi-Version Concurrency Control, MVCC）

## 1. MVCC 基本概念

多版本并发控制是一种并发控制技术，数据库系统为单个逻辑对象维护多个物理版本：

- 当事务写入对象时，数据库创建该对象的新版本
- 当事务读取对象时，它读取事务开始时存在的最新版本

### MVCC 的历史

- 该协议最早于 1978 年在 MIT 博士论文中提出
- 第一个实现是 DEC 公司在 1980 年代早期的 Rdb/VMS 和 InterBase
  - 两者都由 Jim Starkey（NuoDB 联合创始人）开发
  - DEC Rdb/VMS 现在是 "Oracle Rdb"
  - InterBase 被开源为 Firebird

### MVCC 的主要优势

- 写操作不会阻塞读操作
- 读操作不会阻塞写操作
- 只读事务可以读取一致性快照而无需获取锁
  - 使用时间戳确定版本可见性
- 轻松支持时间旅行查询（查看历史数据）

## 2. MVCC 工作原理

### 基本示例

**示例 1：读写不冲突**

假设有两个事务 T1(TS=1) 和 T2(TS=2)，初始数据库中只有版本 A0：

```
T1                 T2
BEGIN
R(A) -> 读取版本A0
                  BEGIN
                  W(A) -> 创建版本A1，设置A0结束时间戳
R(A) -> 读取版本A0
COMMIT             COMMIT
```

**示例 2：写冲突处理**

```
T1                 T2
BEGIN
R(A)
W(A) -> 创建版本A1
                  BEGIN
                  R(A) -> 读取版本A0（T1尚未提交）
                  W(A) -> 必须等待T1提交
R(A) -> 读取自己写入的A1
COMMIT
                  创建版本A2
                  COMMIT
```

### 快照隔离（Snapshot Isolation, SI）

当事务启动时，它会看到一个一致的数据库快照（事务开始时的状态）：

- 不存在活跃事务的部分写入
- 如果两个事务更新相同的对象，则第一个写入者获胜

快照隔离容易受到写偏差异常（Write Skew Anomaly）的影响。

### 写偏差异常示例

两个事务可能会因为基于不完全信息做出决策而导致不一致的结果：

- 事务 1 将白色弹珠改为黑色
- 事务 2 将黑色弹珠改为白色
- 虽然两个事务都满足各自的约束，但最终状态可能违反系统全局约束

## 3. MVCC 设计决策

MVCC 不仅是一种并发控制协议，它完全影响数据库如何管理事务和数据库。主要设计决策包括：

1. 并发控制协议
2. 版本存储方案
3. 垃圾回收机制
4. 索引管理
5. 删除处理

## 4. 并发控制协议

### 方法一：时间戳排序（Timestamp Ordering）

- 为事务分配时间戳，确定串行顺序

### 方法二：乐观并发控制（Optimistic Concurrency Control）

- 采用三阶段协议
- 使用私有工作区存储新版本

### 方法三：两阶段锁定（Two-Phase Locking）

- 事务在读/写逻辑元组前先获取物理版本的适当锁

## 5. 版本存储方案

数据库使用元组的指针字段为每个逻辑元组创建版本链：

- 这允许数据库在运行时找到对特定事务可见的版本
- 索引始终指向链的"头部"

不同的存储方案决定了在哪里/存储什么作为每个版本：

### Append-Only 存储

- 新版本附加到相同的表空间
- 所有版本都存储在同一表中，版本被混合存储
- 每次更新时，将元组的新版本附加到表中的空白位置

**版本链顺序**：

- 最旧到最新（O2N）：将新版本附加到链尾，查找时必须遍历链
- 最新到最旧（N2O）：每个新版本都需要更新索引指针，查找时无需遍历链

### Time-Travel 存储

- 旧版本被复制到单独的表空间
- 每次更新时，将当前版本复制到时间旅行表，更新指针
- 在主表中覆盖主版本，并更新指针

### Delta 存储

- 只复制被修改属性的原始值到单独的增量记录空间
- 每次更新时，只复制修改的值到增量存储，并覆盖主版本
- 事务可以通过反向应用增量来重建旧版本

## 6. 垃圾回收

数据库需要随时间从数据库中移除可回收的物理版本：

- 当系统中没有活跃事务可以"看到"该版本（快照隔离）
- 当版本由已中止事务创建

### 元组级垃圾回收

**背景清理（Background Vacuuming）**：

- 单独的线程定期扫描表并查找可回收版本
- 适用于任何存储方案
- 可使用脏块位图优化扫描

**协作清理（Cooperative Cleaning）**：

- 工作线程在遍历版本链时识别可回收版本
- 仅适用于最旧到最新（O2N）链顺序

### 事务级垃圾回收

- 每个事务跟踪其读/写集
- 提交/中止时，事务将此信息提供给中央清理工作线程
- 数据库定期确定由已完成事务创建的版本何时不再可见

## 7. 索引管理

### 主键索引

- 指向版本链头部
- 数据库更新主键索引的频率取决于系统是否在更新元组时创建新版本
- 如果事务更新元组的主键属性，则视为删除后插入操作

### 二级索引

**方法一：逻辑指针**

- 使用每个元组的固定标识符（不变）
- 需要额外的间接层
- 可以是主键或元组 ID

**方法二：物理指针**

- 使用指向版本链头部的物理地址

### MVCC 索引的重复键问题

- MVCC 数据库索引通常不随键存储元组的版本信息（例外：索引组织表，如 MySQL）
- 每个索引必须支持不同快照中的重复键
- 同一键可能在不同快照中指向不同的逻辑元组
- 索引的底层数据结构必须支持存储非唯一键
- 需要额外的执行逻辑来为主键/唯一索引执行条件插入
- 工作线程可能会为单个获取操作获得多个条目，需要跟踪指针找到适当的物理版本

## 8. 删除处理

数据库只有在逻辑删除元组的所有版本都不可见时才会从数据库物理删除元组：

- 如果元组被删除，则在最新版本之后不能有该元组的新版本
- 没有写-写冲突/第一个写入者获胜

我们需要一种方法来表示元组在某个时间点被逻辑删除：

### 方法一：删除标志

- 维护一个标志，指示逻辑元组在最新物理版本后已被删除
- 可以在元组头或单独的列中

### 方法二：墓碑元组（Tombstone Tuple）

- 创建一个空的物理版本，表示逻辑元组已删除
- 使用单独的池存储墓碑元组，版本链指针中只有特殊位模式，以减少存储开销

## 9. MVCC 实现对比

| 数据库系统    | 协议         | 版本存储    | 垃圾回收    | 索引 |
| ------------- | ------------ | ----------- | ----------- | ---- |
| Oracle        | MV2PL        | Delta       | Vacuum      | 逻辑 |
| Postgres      | MV-2PL/MV-TO | Append-Only | Vacuum      | 物理 |
| MySQL-InnoDB  | MV-2PL       | Delta       | Vacuum      | 逻辑 |
| HYRISE        | MV-OCC       | Append-Only | -           | 物理 |
| Hekaton       | MV-OCC       | Append-Only | Cooperative | 物理 |
| MemSQL (2015) | MV-OCC       | Append-Only | Vacuum      | 物理 |
| SAP HANA      | MV-2PL       | Time-travel | Hybrid      | 逻辑 |
| NuoDB         | MV-2PL       | Append-Only | Vacuum      | 逻辑 |
| HyPer         | MV-OCC       | Delta       | Txn-level   | 逻辑 |
| CockroachDB   | MV-2PL       | Delta (LSM) | Compaction  | 逻辑 |

## 总结

- MVCC 是数据库系统中广泛使用的方案
- 即使不支持多语句事务的系统（如 NoSQL）也使用它
- MVCC 提供了出色的并发性能，同时保持数据一致性
- 各数据库系统根据自身需求实现不同变体的 MVCC
