## 1. 回顾：执行器架构与基础算子

在上一节（Lecture 13）我们了解到，数据库的**查询执行器**采用了类似 **Volcano**（迭代器）模型的设计，每个算子都有 `Init()` 和 `Next()` 接口，通过彼此调用组成一个执行树。

- 例：`SeqScanExecutor`、`InsertExecutor`、`DeleteExecutor` 等**基础算子**负责最简单的数据操作；
- 每个算子都通过继承 `AbstractExecutor` 来提供统一的 `Init()` 和 `Next()`。

在「Lecture 14」中，我们继续这个话题，讨论更多**高级执行器**和数据库执行层常见的**优化技巧**。

---

## 2. 高级执行器：JOIN、SORT、LIMIT 等

### 2.1 JOIN 执行器

数据库典型会实现 **NestLoopJoinExecutor**、**HashJoinExecutor** 等，以支持不同连接算法：

1. **NestedLoopJoinExecutor**

   - 外表一次取一行，再遍历内表（可能用索引）以寻找匹配行；实现比较直接，但大表时性能可能欠佳。
   - 在 BusTub 里，要先 `Init()` 左表，再对左表每一条记录去跑内表的执行器获取匹配。

2. **HashJoinExecutor**
   - 先**构建哈希表**（Build 阶段）存储一侧（通常是较小的表）的全部元组，按连接键映射到链表/向量；
   - 再**探测**（Probe 阶段）：遍历另一表，对每条元组算哈希在表中找匹配行。
   - 大规模等值连接时非常高效。

**外连接 (Outer Join)** 可能需要多一些逻辑，如**左外连接**要输出左表没匹配到的那部分行，对 BusTub 实现来说，也是在哈希表中标记匹配情况，最后输出没被匹配的行并用 NULL 填充另一侧列。

### 2.2 排序执行器 (SortExecutor)

- 实现 **`ORDER BY`**。若数据量非常大，需要外部排序；若数据在内存放得下则普通排序就行。
- 在 BusTub 中，`SortExecutor` 通常先把子算子的所有输出都读进来缓存在某个临时结构中，然后用 `std::sort()` 或外排序方法排好，再 `Next()` 时按序一个个吐出去。
- 需要注意内存管理：如果超出内存则要分块 + 归并。

### 2.3 LimitExecutor

- SQL 中的 `LIMIT X OFFSET Y` 只要从子算子拿若干行就行，不需要处理完所有输出。可以在 `Next()` 里做计数，达到 X 就停止。
- 很简单，但对性能可能很重要（尤其在 web 场景下只拿前几十行）。

---

## 3. 查询执行的进一步优化

### 3.1 计划级别优化

- 前面说过数据库会在生成物理计划时选择不同的算子 (Index Scan / Hash Join / Sort-Merge Join)。
- 在执行器的层面，如果发现某些情况可以优化，通常通过**规则**或**启发式**方式改写：
  - 例如 **“NLJ 变为 Hash Join”**（在等值连接时，更高效）；
  - 例如 **“SeqScan 变为 IndexScan”**（如果存在可用索引且谓词合适）；
  - 例如谓词下推 (Predicate Pushdown)、投影下推 (Projection Pushdown) 等，以减少不必要的数据处理。

### 3.2 动态计划改写

- 数据库在执行过程中也可以根据中间结果做一些**动态优化**——不过一般商业系统里才会比较常见，如**自适应执行 (Adaptive Execution)**。
- 在 BusTub 中则主要是**编译期**定好执行计划，不太做运行时修改。

### 3.3 Cost-Based Optimizer vs. Rule-Based Optimizer

- 大型数据库常用**成本模型**来估算各种算法的代价，选出最优或近似最优计划；
- 小型或教学系统（如 BusTub）常采用**简单规则**（如果是等值连接就用 Hash Join，如果内表有索引就用 Index Join 等）。

---

## 4. 整体执行流程与常见算子组合

1. **投影算子 (Projection)**：只取所需的列，可能放在扫描或者连接之后来减少数据量；
2. **过滤算子 (Filter)**：可以把过滤条件下推到扫描或连接里，提高效率；
3. **连接算子 (Join)**：选择合适的连接算法；需要考虑外连接之类的处理；
4. **聚合算子 (Aggregation)**：哈希聚合或排序聚合，也可带有 `HAVING` 子句过滤；
5. **排序算子 (Sort)**：若 `ORDER BY`；要注意外部排序场景；
6. **Limit 算子**：只拿前 X 行。

这些算子通过**执行器框架**拼成一个树形结构，顶层执行器拉数据、一路往下，最终从最底层的表扫描或索引扫描拿到原始行，层层加工后得到结果。

---

## 5. 课程要点 & 记忆要点

1. **高级算子**：

   - **连接**：Nested Loop、Hash Join (BusTub HashJoinExecutor)；外连接要额外处理未匹配行；
   - **排序**：可能一次性加载子执行器所有行并排序，或外部多路归并；
   - **限制 / 分页 (LIMIT)**：用计数器轻松实现。

2. **执行阶段优化**：

   - 如把 NLJ 替换为 Hash Join；把 SeqScan 替换为 IndexScan；
   - 一些优化器规则可在**生成计划**时就完成，也可在执行时做简单判断（但通常不常见）。

3. **结合前面“执行器基础”**：
   - Volcano 模型：`Init() -> Next() -> Next()...`
   - 各算子都要实现同样接口，才能跟别的算子组合。

**一段话记**：

> “Join、Sort、Limit 等算子都在执行器里实现；数据库可以在优化阶段把简单算法替换成更高效的方法。所有算子遵守 `Init()+Next()`，因此能像拼图一样组合。”

---

## 6. 总结

- **Lecture 14** 继续了查询执行主题，从实现常见高级算子（Join / Sort / Limit / 聚合等）的细节切入，并讲到数据库如何对这些算子进一步优化。
- 在实际系统中，这些算子也可能由**更复杂**的策略来配合，如多线程并行执行、分布式执行等，但核心思想相同：
  - 保持**可组合**（迭代器接口），
  - 根据**计划**决定用哪种算法（HashJoin vs. NLJ vs. Sort vs. Index...）。

**理解这一点，有助于我们在编写或阅读数据库内核代码时，理清“哪种执行器”负责做“哪一步操作”，并怎样通过接口互相拼接、实现完整 SQL 查询。**
