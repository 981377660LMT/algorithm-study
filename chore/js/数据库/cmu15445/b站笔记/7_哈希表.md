# 数据库中的哈希表详解

## 一、哈希表基础

### 基本概念

- 哈希表实现了一个无序关联数组，将键映射到值
- 使用哈希函数计算键在数组中的偏移量，从而找到相应的值
- 复杂度：空间 O(n)，时间平均 O(1)，最坏 O(n)

### 应用场景

- 数据库内部元数据管理
- 核心数据存储
- 临时数据结构
- 表索引

## 二、设计决策

1. **数据组织**

   - 数据结构在内存/页面中的布局方式
   - 存储哪些信息以支持高效访问

2. **并发控制**
   - 如何允许多线程同时访问数据结构而不出问题

## 三、哈希函数

### 理想特性

- 将大键空间映射到更小的域
- 快速计算
- 低碰撞率

### 常用哈希函数

- CRC-64 (1975)：网络错误检测
- MurmurHash (2008)：通用目的哈希
- Google CityHash (2011)：短键优化
- Facebook XXHash (2012)：高性能
- Google FarmHash (2014)：改进的CityHash，碰撞率更低

哈希函数选择是速度与碰撞率之间的权衡，数据库通常选择非加密哈希函数。

## 四、静态哈希方案

### 1. 线性探测哈希 (Linear Probe Hashing)

**基本原理**：

- 单个大表存储键值对
- 当位置发生碰撞时，线性搜索下一个空闲槽
- 必须存储键以确定何时停止扫描

**删除处理**：

- 方法1：重新哈希（实际很少使用）
- 方法2：墓碑标记（标记逻辑删除，可重用空间）

### 2. 罗宾汉哈希 (Robin Hood Hashing)

**基本原理**：

- 线性探测的变种
- 每个键跟踪它距离最佳位置的距离
- 当新键距离最佳位置更远时，可以"抢夺"已有键的位置
- "劫富济贫"思想：从"富有"键拿槽位给"贫穷"键

### 3. 布谷鸟哈希 (Cuckoo Hashing)

**基本原理**：

- 使用多个具有不同哈希种子的哈希表
- 插入时，检查每个表并选择任何有空闲槽的表
- 如果没有空闲槽，驱逐一个元素并重新哈希它
- 查找和删除始终是O(1)，因为每个哈希表只检查一个位置

## 五、动态哈希方案

当数据量不确定时，需要能够自动调整大小的哈希表。

### 1. 链式哈希 (Chained Hashing)

**基本原理**：

- 为哈希表中每个槽维护一个链表（桶）
- 具有相同哈希键的所有元素放入同一个桶
- 通过哈希到桶然后扫描来确定元素是否存在

### 2. 可扩展哈希 (Extendible Hashing)

**基本原理**：

- 链式哈希的改进，当链表过长时分裂桶
- 多个槽位置可以指向同一个桶链
- 分裂时重新分配桶条目并增加检查的位数
- 数据移动仅限于分裂的链

**关键概念**：

- 全局深度：目录中使用的位数
- 局部深度：桶中使用的位数

### 3. 线性哈希 (Linear Hashing)

**基本原理**：

- 维护一个指向下一个要分裂的桶的指针
- 当任何桶溢出时，分裂指针位置的桶
- 使用多个哈希函数找到给定键的正确桶
- 溢出标准可以是空间利用率或溢出链的平均长度

**工作流程**：

1. 溢出发生时，不分裂溢出的桶，而是分裂指针指向的桶
2. 分裂后移动指针
3. 当指针到达最后一个槽时，删除第一个哈希函数并移回开始位置

## 总结

- 哈希表是贯穿DBMS内部的快速数据结构，支持O(1)查找
- 静态哈希表适合已知元素数量的场景
- 动态哈希表能随需调整大小，适合未知或变化的数据量
- 哈希表通常不是表索引的最佳选择（这里暗示B+树可能更适合）
- 不同哈希方案在速度和灵活性之间做权衡
