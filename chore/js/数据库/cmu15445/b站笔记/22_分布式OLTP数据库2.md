## 核心问题：分布式事务如何保证原子性？

在分布式系统中，一个事务可能涉及多个节点。如何确保这些节点要么**一起成功提交**，要么**一起失败回滚**？这就是**原子提交协议**要解决的问题。

**前提假设**：我们信任系统内的所有节点都是“好人(well-behaved)”，不会故意捣乱（非拜占庭错误）。

If you do not trust the other nodes in a distributed DBMS, then you need to use a `Byzantine Fault Tolerant protocol` for txns (`blockchain`)

---

## 解决方案 1：两阶段提交 (Two-Phase Commit, 2PC)

**核心思想**：引入一个**协调者 (Coordinator)** 和多个**参与者 (Participant)**。分两步走：

1.  **准备阶段 (Prepare Phase)**：
    - 协调者问所有参与者：“你们准备好提交了吗？”
    - 参与者检查自己是否能提交：
      - 如果可以，记录“准备就绪”日志，并回复“OK”。
      - 如果不可以（比如本地冲突），记录“中止”日志，并回复“ABORT”。
2.  **提交/中止阶段 (Commit/Abort Phase)**：
    - **如果所有参与者都回复“OK”**：协调者决定“提交”，记录“提交”日志，并通知所有参与者“提交”。参与者收到后提交事务，记录“提交”日志，并回复“完成”。
    - **如果任何一个参与者回复“ABORT”或超时**：协调者决定“中止”，记录“中止”日志，并通知所有参与者“中止”。参与者收到后中止事务，记录“中止”日志，并回复“完成”。

**记忆口诀**：**一问准备，二发指令 (提交或中止)**。

**优点**：简单直观。

**缺点 (致命)**：

- **同步阻塞**：在等待所有参与者回复时，资源被锁定。
- **协调者单点故障**：
  - 如果在第二阶段发出指令前挂了，所有参与者都卡在“准备就绪”状态，不知道该提交还是中止，系统**阻塞**。
- **参与者单点故障**：
  - 如果在第一阶段回复前挂了，协调者会认为它中止。
  - 如果在第一阶段回复“OK”后挂了，需要等待恢复后询问协调者最终决定。

**优化**：

- **Early Ack (常用)**：只要协调者收到所有“OK”，就可以**提前**告诉客户端“成功了”，然后在后台慢慢执行第二阶段的 Commit 指令。

---

## 解决方案 2：Paxos (及其变种 Raft, ZAB 等)

**核心思想**：基于**少数服从多数**的共识协议。一个**提议者 (Proposer)** 提出一个值（比如“提交”或“中止”），需要获得**大多数接受者 (Acceptor)** 的同意才能最终确定。

**流程简化理解 (Multi-Paxos/Raft 类似)**：

1.  **选主 (Leader Election)**：先选出一个 Leader (相当于 Proposer)。
2.  **提案 (Propose)**：Leader 收到请求后，向其他节点 (Followers/Acceptors) 发送提案（比如“提交事务 T”）。
3.  **确认 (Acknowledge/Accept)**：**大多数**节点确认收到并同意提案后，记录日志。
4.  **应用 (Commit/Apply)**：Leader 确认提案已被大多数节点接受后，通知所有节点应用该提案（真正执行提交）。

**记忆口诀**：**选老大，老大提议，多数同意，最终执行**。

**优点**：

- **非阻塞 (容错性好)**：只要集群中**超过一半**的节点存活，系统就能继续工作（选举新 Leader，达成共识）。解决了 2PC 的阻塞问题。
- **性能**：在稳定状态下（Leader 不变），流程可以简化，效率较高。

**缺点**：

- **理解和实现复杂**。

**2PC vs. Paxos**：

- **2PC**：简单，但协调者挂了可能阻塞。
- **Paxos**：复杂，但只要多数节点活着就不阻塞。

---

## 数据复制 (Replication)

**目的**：提高数据可用性和读取性能。

**关键设计点**：

1.  **副本配置 (Replica Configuration)**：
    - **主从复制 (Primary-Replica)**：只有一个主节点 (Primary) 接受写操作，然后把变更同步给从节点 (Replica)。读操作可以分摊到从节点。主节点挂了需要选举新主。**简单常用**。
    - **多主复制 (Multi-Primary)**：多个节点都可以接受写操作，节点间需要用原子提交协议（如 Paxos）同步数据。**复杂，易冲突**。
2.  **K-Safety**：系统至少需要 K 个副本存活才能正常工作。
3.  **传播方案 (Propagation Scheme)**：
    - **同步 (Synchronous)**：主节点写操作必须等待**所有/指定数量**的从节点确认收到更新后，才返回成功给客户端。**强一致性，但慢**。
    - **异步 (Asynchronous)**：主节点写操作**立即**返回成功给客户端，然后在后台慢慢同步给从节点。**最终一致性，快，但可能读到旧数据**。
4.  **传播时机 (Propagation Timing)**：
    - **连续 (Continuous)**：产生一条日志就发一条。
    - **提交时 (On Commit)**：事务提交后才把该事务的所有日志一起发。
5.  **更新方法 (Active vs. Passive)**：
    - **Active-Active**：每个副本独立执行事务（不常用，难保证一致）。
    - **Active-Passive**：只有一个节点执行事务，然后把结果或日志同步给其他副本（常用）。

**记忆口诀**：**主从/多主定结构，同步/异步定快慢，K-Safety 保底线**。

---

## CAP 定理

**核心思想 (Brewer 提出)**：在一个分布式系统中，**一致性 (Consistency)**、**可用性 (Availability)**、**分区容忍性 (Partition Tolerance)** 这三者，你**不可能同时完美拥有**，最多只能三选二。

- **C - 一致性 (Consistency)**：所有节点在同一时刻看到的数据是完全一致的。（强一致性/线性一致性）
- **A - 可用性 (Availability)**：每次请求都能得到响应（不保证数据最新）。
- **P - 分区容忍性 (Partition Tolerance)**：即使节点间的网络通信中断（发生网络分区），系统仍能继续运行。

**关键理解**：在现代分布式系统中，网络分区 (P) 是**必须容忍**的。因此，你真正的选择是在发生网络分区时，牺牲 C 还是牺牲 A？

- **选择 CP (牺牲 A)**：保证数据一致性，但分区发生时，部分节点可能拒绝服务（写操作或需要强一致性的读操作）以避免数据不一致。**传统关系型数据库常用**。
- **选择 AP (牺牲 C)**：保证服务可用性，即使分区发生，各节点仍能响应请求，但可能返回旧数据，接受写操作后需要后续处理冲突。**很多 NoSQL 系统选择**。

**记忆口诀**：**网络分区必选 P，剩下 C 和 A 二选一**。

**注意**：CAP 定理有些过于简化，忽略了延迟 (Latency) 的影响。PACELC 定理是对其的补充（P 时 C/A 选，Else 时 L/C 选）。

---

## Google Spanner 案例

- **目标**：全球分布、强一致性、高可用的数据库。
- **核心技术**：
  - **TrueTime API**：利用 GPS 和原子钟提供有界的、全局同步的时钟，为事务分配全局唯一且单调递增的时间戳。这是实现**外部一致性**（External Consistency，比强一致性更强，事务顺序与真实物理时间一致）的关键。
  - **并发控制**：MVCC + 严格 2PL + Wound-Wait 死锁预防。
  - **共识与提交**：
    - 数据分片叫 Tablet，每个 Tablet 的副本组成一个 Paxos Group，用 Paxos 选举 Leader 并同步日志。
    - 跨 Tablet 的事务使用 2PC 提交。
- **CAP 选择**：通常被认为是 **CP** 系统，优先保证强一致性。

**记忆口诀**：**原子钟定序，Paxos 管分片内，2PC 管跨分片，强一致全球可用**。

---

- `Byzantine Fault Tolerant protocol` for txns (`blockchain`)

  **核心问题**：分布式系统里有“坏节点”（拜占庭节点），它们可能说谎、捣乱、不按规则出牌。

  **BFT 协议目标**：即使有一定比例的“坏节点”存在，系统里的“好节点”们仍然能够就事务的顺序和结果达成**正确且一致**的共识。

  **区块链 (Blockchain)**：是应用 BFT 协议的一种**著名技术**。它通过工作量证明 (PoW)、权益证明 (PoS) 或实用拜占庭容错 (PBFT) 等共识机制，确保所有参与者（即使部分是恶意的）最终能`认同同一份不可篡改的交易账本`。

  **记忆口诀**：**防坏人捣乱，保大家一致，区块链就用它。**

  ***

  简单讲讲区块链原理：

  1.  **分布式账本 (Distributed Ledger)**：

      - 想象一个公开的、大家共享的记账本。
      - 这个账本不是由一个人或一个中心机构保管，而是复制并分发给网络中的许多参与者（节点）。

  2.  **区块 (Block)**：

      - 交易（比如转账记录）不是一条条直接记，而是打包成一个个“区块”。
      - 每个区块包含了一段时间内的多条交易记录。

  3.  **链 (Chain)**：

      - 区块之间按时间顺序链接起来，形成一条“链”。
      - **关键**：每个新区块都包含上一个区块内容的“指纹”（哈希值）。如果有人试图篡改前面任何一个区块的内容，它的“指纹”就会改变，导致后面所有区块的链接都对不上，篡改行为立刻会被发现。

  4.  **共识机制 (Consensus Mechanism)**：

      - **问题**：谁有权记账（创建新区块）？如何保证大家认同的是同一条链？
      - **解决**：通过特定规则（共识机制，如 PoW、PoS、PBFT 等，很多基于 BFT 思想）让节点竞争或协商来决定下一个区块由谁创建以及哪个区块是合法的。
      - **目标**：确保即使有节点想作恶（比如创建假区块），大多数诚实的节点也能达成一致，维护唯一、正确的链。

  5.  **不可篡改与透明 (Immutable & Transparent)**：
      - 一旦区块被大多数节点确认并添加到链上，就极难被修改（因为要修改后面所有区块的链接，且需要获得大多数节点认同）。
      - 账本通常是公开透明的，任何人都可以查看交易记录（但身份可能是匿名的）。

  **总结口诀**：**交易打包成区块，区块按序连成链；密码学保证难篡改，共识机制防作弊；大家共享一本账，公开透明又安全。**
