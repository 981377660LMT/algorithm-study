prosemirror-history 为 ProseMirror 编辑器提供撤销（undo）和重做（redo）功能。它的实现非常精妙，因为其历史记录是**选择性**的，而不仅仅是回滚到之前的某个完整状态。这种设计对于支持协同编辑至关重要，因为需要撤销自己的操作，同时保留其他协作者在此期间提交的更改。

### 1. 核心概念

- **`history`**: 这是模块的主要导出，一个 `Plugin` 工厂函数。你需要将这个插件添加到编辑器的 state 中来启用历史记录功能。它可以接受 `depth`（历史深度）和 `newGroupDelay`（新事件组的延迟时间）作为配置。

- **`HistoryState`**: 这是历史插件所管理的状态对象。它主要包含两个部分：`done`（一个用于撤销的 `Branch`）和 `undone`（一个用于重做的 `Branch`）。

- **`Branch`**: 代表一个历史分支（撤销栈或重做栈）。它不是一个简单的步骤数组，而是一个 `RopeSequence`（一种高效的序列数据结构），其中包含了一系列的 `Item`。

- **`Item`**: 这是历史记录中的原子单元。一个 `Item` 可以包含：
  - 一个可逆的 `Step`（实际的文档变更）。
  - 一个 `StepMap`（用于在应用历史步骤时，将其变换（map）到当前文档的正确位置）。
  - 一个 `SelectionBookmark`（标记一个“事件”的开始，即一组应被一起撤销/重做的变更）。

### 2. 工作原理

1.  **事件分组**: ProseMirror 会将连续的、短时间内的修改（由 `newGroupDelay` 控制）组合成一个“撤销事件”。例如，连续输入文本会被视为一个事件，一次撤销就会全部删除。你也可以通过 `closeHistory` 命令强制开启一个新的事件组。

2.  **记录变更**: 当一个事务（`Transaction`）被应用时，如果它包含可被记录的步骤，历史插件的 `applyTransaction` 逻辑会启动。它会计算出该事务的**反向步骤**（inverted steps），并将这些步骤连同映射信息打包成 `Item`，存入 `done` 栈（`Branch`）中。

3.  **执行撤销 (`undo`)**:

    - 当 `undo` 命令被触发时，插件会从 `done` 栈中取出最近的一个事件。
    - 它将这个事件中的步骤应用到一个新的 `Transaction` 中。**关键在于**：这些步骤在应用前，会通过存储的 `StepMap` 进行变换，以适应在原始操作之后发生的、但不应被撤销的其他变更（例如来自协作者的变更）。
    - 执行撤销后，被撤销的事件（及其反向操作）会被移入 `undone` 栈，以备重做。

4.  **协同编辑 (`collab`) 集成**:
    - 当协同编辑模块接收到远程变更并将其 rebase 到本地时，它会通知历史插件。
    - 历史插件会调用其 `Branch` 上的 `rebased` 方法。这个方法不会丢弃历史记录，而是将远程变更的 `Mapping` 添加到历史 `Item` 中。
    - 这样，**即使用户的文档因为协同操作发生了很大变化，历史记录中的步骤在未来执行撤销时，依然能通过这些累积的映射被正确地应用到文档的最新位置上。**

### 3. 主要 API

- **`history(config?: HistoryOptions)`**: 创建历史插件实例。
- **`undo` / `redo`**: 用于撤销和重做的命令。
- **[`undoDepth(state: EditorState)`](prosemirror-history/src/history.ts)**: 返回当前可撤销的事件数量。
- **[`redoDepth(state: EditorState)`](prosemirror-history/src/history.ts)**: 返回当前可重做的事件数量。

总而言之，prosemirror-history 通过将变更分解为带映射信息的 `Item`，并利用 prosemirror-transform 的映射（Mapping）和变换（Transform）能力，实现了一个强大且支持协同编辑的选择性历史记录系统。

---

好的，我们来对 `prosemirror-history` 进行一次彻底的、深入的剖析。这个包虽然 API 简单（主要就是 `undo` 和 `redo`），但其内部实现完美地展示了 ProseMirror 架构的优雅与强大。它是一个教科书级别的插件，演示了如何利用 `prosemirror-state` 和 `prosemirror-transform` 来实现复杂的功能。

我们将从以下四个关键角度来解构它：

1.  **核心思想：不存快照，只存“逆操作”**
2.  **`HistoryState`：插件的核心状态机**
3.  **事件压缩：智能的用户体验**
4.  **协同编辑中的挑战与解决方案**

---

### 1. 核心思想：不存快照，只存“逆操作”

一个最直观但低效的撤销实现是：每当用户操作时，都将整个文档状态（`EditorState`）的快照存入一个栈中。撤销时，只需从栈中取回上一个快照即可。这种方法简单，但当文档很大时，会消耗巨量的内存。

`prosemirror-history` 采用了远为高效的策略：**它只存储变更本身及其逆操作。**

这个策略完全依赖于 `prosemirror-transform` 的两个核心特性：

- **`Step`**: 任何文档变更都可以被分解为一系列原子化的、可序列化的 `Step`。
- **`step.invert(doc)`**: 每个 `Step` 都可以根据它所应用的文档，计算出一个能完全抵消其效果的“逆向 `Step`”。

**工作流程简介**：

- 当用户执行一个操作（如输入文本）时，`prosemirror-history` 会捕获这个操作产生的 `Step` 序列。
- 它同时计算出这些 `Step` 的**逆向 `Step` 序列**。
- 它将这一对（原始 `Step` 和逆向 `Step`）作为一个“历史事件”存入**撤销栈（Undo Stack）**。
- 当用户请求**撤销**时，它从撤销栈中取出最近的事件，并将该事件的**逆向 `Step`** 应用到当前文档上，从而恢复到之前的状态。同时，它将这个事件移入**重做栈（Redo Stack）**。
- 当用户请求**重做**时，它从重做栈中取出事件，并将事件的**原始 `Step`** 再次应用到文档上。

这种方法只存储增量变更，内存占用极小，性能非常高。

---

### 2. `HistoryState`：插件的核心状态机

`prosemirror-history` 本质上是一个 `Plugin`，其所有逻辑都围绕着它自己的内部状态 `HistoryState` 运转。

#### a. `HistoryState` 的构成

一个 `HistoryState` 对象主要包含两个部分，都是“历史事件”的栈：

- **`done: readonly HistEvent[]`**: **撤销栈**。存储了已经发生、可以被撤销的事件。
- **`undone: readonly HistEvent[]`**: **重做栈**。存储了已经被撤销、可以被重做的事件。

一个 `HistEvent`（历史事件）大致包含：

- `steps: Step[]`: 原始操作的 `Step` 序列。
- `inverted: Step[]`: 逆操作的 `Step` 序列。
- `selection: Selection`: 操作发生前的选区信息。

#### b. `apply` 方法：状态的演变

`HistoryState` 的 `apply` 方法是整个插件的大脑。每当一个 `Transaction` 在编辑器中发生时，这个方法就会被调用，以决定如何更新 `done` 和 `undone` 栈。

其内部逻辑如下：

1.  **检查元数据 (`tr.getMeta(historyKey)`)**:

    - **是撤销/重做事务吗？** 如果事务的元数据标记为 `"undo"` 或 `"redo"`，则执行相应的撤销/重做逻辑（从一个栈弹出，应用 `Step`，推入另一个栈），然后返回新的 `HistoryState`。
    - **是“不记录历史”的事务吗？** 如果事务的元数据标记为 `addToHistory: false`，则插件完全忽略此事务，直接返回原有的 `HistoryState`。这对于那些不应被用户撤销的程序化修改（如协同编辑中来自他人的变更）至关重要。

2.  **处理普通编辑事务**:
    - 如果是一个普通的、需要记录的用户编辑操作，插件会：
      a. 从事务中提取 `steps`。
      b. 计算出逆向 `steps` (`inverted`)。
      c. 将 `{ steps, inverted }` 作为一个新的历史事件。
      d. **清空 `undone`（重做）栈**。这是标准行为：任何新的编辑都会使之前的“重做”历史失效。
      e. 将新事件推入 `done`（撤销）栈。
      f. 返回包含更新后 `done` 栈和空 `undone` 栈的新 `HistoryState`。

---

### 3. 事件压缩：智能的用户体验

如果用户快速输入 "hello"，他们期望按一次 `Ctrl+Z` 就能撤销整个单词，而不是只撤销最后一个字母 "o"。这就是**事件压缩（Event Compression）**或**事件合并（Event Merging）**。

`prosemirror-history` 通过以下规则实现这一点：

1.  **时间阈值 (`newGroupDelay`)**:

    - 插件在创建时可以配置一个 `newGroupDelay` 选项（默认为 500 毫秒）。
    - 当一个新的事务到来时，如果距离上一个被记录的事务的时间间隔**小于**这个阈值，并且它们之间没有发生光标移动，那么这个新事务的 `Step` 会被**合并**到 `done` 栈顶的最后一个事件中，而不是创建一个全新的事件。
    - 这就是为什么快速连续输入会被视为单个历史记录的原因。

2.  **中断事件**:
    - 如果一个新的事务到来时，距离上一个事务的时间间隔**大于** `newGroupDelay`，它会无条件地创建一个新的历史事件。
    - 如果用户在两次输入之间**移动了光标**（即 `selection` 发生了变化），即使时间间隔很短，这也会被视为一次中断，并强制创建一个新的历史事件。

通过这种智能的合并策略，`prosemirror-history` 提供的撤销/重做体验非常符合用户的直觉。

---

### 4. 协同编辑中的挑战与解决方案

在协同编辑环境中，简单地使用 `prosemirror-history` 会遇到问题。

**问题**: 用户的撤销栈中混合了**自己的操作**和**来自他人的操作**。当用户按下 `Ctrl+Z` 时，他可能会意外地撤销掉一个刚刚由同事做出的修改，这会造成混乱。

**解决方案**:
`prosemirror-history` 的设计者预见到了这一点，并提供了解决方案，这通常在协同编辑的绑定库（如 `y-prosemirror`）中实现：

1.  **区分本地与远程变更**:

    - 当协同编辑客户端接收到来自远程的变更时，它会将这些变更包装在一个 `Transaction` 中，并附加上 `addToHistory: false` 的元数据。
    - `tr.setMeta('addToHistory', false)`
    - 这样，`prosemirror-history` 插件在处理这个事务时，就会直接忽略它，不会将其计入本地的撤销/重做历史。

2.  **独立的撤销管理器**:
    - 更高级的协同编辑解决方案（如 Yjs）会提供自己独立的、基于 CRDT 的撤销管理器（`Y.UndoManager`）。
    - 在这种模式下，`prosemirror-history` 插件会被**禁用**。
    - 取而代之的是，当用户按下 `Ctrl+Z` 时，会调用 `Y.UndoManager.undo()`。这个管理器知道哪些操作是本地用户做出的，因此只会撤销本地用户的操作，而不会影响他人的修改。

### 总结

`prosemirror-history` 不仅仅是一个简单的功能包，它是对 ProseMirror 核心架构（不可变状态、事务、可逆 `Step`、插件系统）的一次完美应用。它通过高效的**增量存储**、智能的**事件压缩**以及对**元数据的响应**，以极低的成本提供了强大、直观且可扩展的撤销/重做功能，并为在更复杂的协同编辑场景下被正确集成或替换提供了必要的接口。

---

## 为什么 不存快照，只存“逆操作”

**快照本身不包含任何关于“如何适应其他变更”的信息。(快照丢失意图)**

我认为不是文档很大时，会消耗巨量的内存，因为 prosemirror 的 doc 是复用结构的

您提出了一个非常深刻且精准的观点！您完全正确，因为 ProseMirror 的 `doc` 采用了**持久化数据结构（Persistent Data Structures）**和**结构共享（Structural Sharing）**，所以存储完整的文档快照远比在传统可变数据结构中高效得多。

然而，即使考虑了结构共享，‘只存逆操作’的策略在内存和功能上依然具有**决定性**的优势。原因比单纯的“文档很大”更深一层：

### 1. “快照”的真实成本：不只是 `doc`

一个完整的历史快照需要存储的是整个 `EditorState`，而不仅仅是 `doc`。一个 `EditorState` 对象包含：

- `doc`: 文档内容（得益于结构共享）。
- `selection`: 选区信息。
- `storedMarks`: 存储的标记（例如，加粗后输入文本时）。
- **所有插件的状态**: 每个插件都有自己的状态，这些状态也需要被快照。

当您进行 1000 次编辑时：

- **快照方法**: 您需要存储 **1000 个 `EditorState` 对象**。虽然这些对象中的 `doc` 属性会共享大量底层节点，但您依然创建了 1000 个 `EditorState` 实例、1000 个 `Selection` 实例，以及 1000 份所有插件的状态。这会产生大量的小对象，给垃圾回收（GC）带来压力，并且累积的内存占用依然可观。
- **逆操作方法**: 您存储的只是 **1000 个 `Step` 对象**（或者更少，因为事件会被合并）。一个 `Step` 是一个非常轻量、可序列化的纯数据对象，只描述了变更本身。其内存占用远小于一个完整的 `EditorState` 快照。

**结论**：结构共享极大地优化了 `doc` 的快照成本，但无法优化 `EditorState` 及其所有关联状态的快照成本。

### 2. 协同编辑：这才是决定性因素

这才是 `prosemirror-history` 采用“逆操作”策略的**根本原因**，其重要性远超内存考量。

想象一下协同编辑的场景：

1.  **你 (User A)** 在文档开头输入了 "Hello"。你的历史记录是 `H -> He -> Hel -> Hell -> Hello`。
2.  **同时，你的同事 (User B)** 在文档末尾添加了一个段落。
3.  现在，你想撤销你输入的 "Hello"。

- **如果用快照**: 你的撤销栈里存的是你输入 "Hello" 之前的文档快照。如果你直接回滚到那个快照，**你同事的修改就会被抹掉！** 这是协同编辑中的灾难。快照本身不包含任何关于“如何适应其他变更”的信息。

- **如果用逆操作**:
  - 你的撤销栈里存的是一系列“删除字符”的逆向 `Step`。
  - 当同事的变更（一个“插入段落”的 `Step`）应用到你的文档时，`prosemirror-history` 会通过 `prosemirror-transform` 的 `map` 方法，**更新**你历史记录中所有 `Step` 的位置信息。
  - 现在你执行撤销，插件会取出那些已经被“变换”过的“删除字符”`Step`。这些 `Step` 的位置已经自动适应了同事的修改，所以它们会精确地删除你输入的 "Hello"，而完全不影响同事在文末添加的段落。

**结论**：**“逆操作 + 变换”是唯一能在协同编辑环境中正确实现撤销/重做的方式。** 快照模型在这种动态、多源变更的环境中是完全无效的。

### 总结

所以，您对结构共享的理解是完全正确的，它确实降低了快照的成本。但 `prosemirror-history` 不使用快照，主要是基于以下两点，且第二点是决定性的：

1.  **内存效率**: 存储轻量级的 `Step` 对象比存储完整的 `EditorState` 快照（即使 `doc` 共享结构）在内存上依然高效得多，尤其是在编辑历史很长时。
2.  **功能需求 (协同编辑)**: **快照模型无法与协同编辑兼容**。只有基于 `Step` 和 `Mapping` 的增量变更模型，才能在保留他人修改的同时，精确地撤销自己的操作。

因此，我之前笔记中的“文档很大时，会消耗巨量的内存”这句话，虽然在宏观上是正确的，但您的思考使其变得更精确了：**即使有结构共享，快照的累积成本依然显著，但更重要的是，快照模型在功能上无法满足 ProseMirror 的核心设计目标——强大的协同编辑能力。**
