在 Web 编辑器中处理中文输入法（IME）的核心挑战在于：**区分“输入法选词过程中的按键/变化”与“最终文本上屏后的按键/变化”**。

基于你当前项目中的代码 (`src/components/Input/TextArea/index.tsx`)，以下是处理中文输入法的思路、最佳实践和解决方案。

### 1. 核心思路：状态锁 (Composition Lock)

利用浏览器原生的 `composition` 事件系列，维护一个布尔值标记（Flag），用来判断当前用户是否正在使用输入法。

- **`compositionstart`**: 输入法弹窗出现，标记 `isComposing = true`。
- **`compositionupdate`**: 输入法选词框内容变化，保持 `isComposing = true`。
- **`compositionend`**: 输入法选词完成（文字上屏），标记 `isComposing = false`。

### 2. 你的项目中的解决方案

在 index.tsx 中，使用了 **CodeMirror** 的 `domEventHandlers` 结合 **React Ref** 来实现这一机制。

#### A. 状态定义

使用 `useRef` 来同步状态，避免闭包问题；使用 `useState` 来触发必要的 UI 更新。

```typescript
// ...existing code...
const [isComposing, setIsComposing] = useState(false)
const composingRef = useRef(false) // Ref 用于在事件回调中实时获取最新状态
// ...existing code...
```

#### B. 事件监听与状态切换

通过 `EditorView.domEventHandlers` 监听原生 DOM 事件：

```typescript
// ...existing code...
EditorView.domEventHandlers({
  compositionstart: () => {
    composingRef.current = true
    setIsComposing(true)
    return false
  },
  compositionupdate: () => {
    composingRef.current = true
    return false
  },
  compositionend: () => {
    // 关键点：使用 setTimeout 确保在当前事件循环结束后再重置状态
    // 这样可以避免 compositionend 紧接着的 keydown/input 事件误判
    setTimeout(() => {
      composingRef.current = false
      setIsComposing(false)

      // 输入法结束后，手动触发一次逻辑（如 @提及 的搜索查询）
      const currentEditor = editorRef.current
      if (currentEditor?.$view) {
        // ...重新计算搜索查询...
      }
    }, 50)
    return false
  }
})
// ...existing code...
```

#### C. 拦截 Enter 键提交

在处理 `Enter` 发送消息时，检查 `composingRef.current`。如果为 `true`，说明用户只是在确认输入法的选词，而不是想发送消息。

```typescript
// ...existing code...
<Renderer
  onKeydown={(e) => {
    // 如果是 Enter 键，且没有在使用输入法，且没有打开下拉菜单 -> 执行提交
    if (e.key === 'Enter' && !composingRef.current && !open) {
      e.preventDefault();
      onSubmit(value);
      resetHistory();
    }
  }}
// ...existing code...
```

### 3. 最佳实践总结

1.  **使用 `useRef` 跟踪状态**:
    在 `keydown` 或 `onChange` 等高频触发的闭包回调中，`useState` 的值可能不是最新的。使用 `useRef` (`composingRef`) 可以保证在任何回调中都能读到实时的输入法状态。

2.  **`compositionend` 的延时处理**:
    浏览器事件触发顺序通常是 `compositionend` -> `input` -> `keydown` (Enter)。为了防止逻辑冲突，通常在 `compositionend` 中使用 `setTimeout(() => { ... }, 0)` 或小延时（如 50ms）来重置状态。这能确保输入法产生的“尾部事件”被正确忽略。

3.  **避免在 Composing 期间触发重计算**:
    在 `handleChange` 中，如果 `composingRef.current` 为 `true`，可以跳过复杂的逻辑（如解析 Markdown、提取胶囊/标签），只做简单的状态更新，等到 `compositionend` 再做一次完整的解析。这能显著提升输入性能。

    ```typescript
    // 你的代码示例
    const handleChange = useCallback((nextValue: string) => {
        onChange(nextValue);
        // 只有不在输入法状态时，才去解析胶囊/标签
        if (!composingRef.current) {
          const capsules = extractAllCapsules(nextValue, allCommands);
          // ...
        }
    }, ...);
    ```

4.  **处理 Safari/Chrome 的差异**:
    不同浏览器对 `composition` 事件和 `keydown` 事件的触发顺序略有不同（尤其是 Enter 键）。上述的“Flag + 延时重置”方案是兼容性最好的做法。
