# On null and undefined in JavaScript

- 这是一篇简短的文章，解释为什么我的 JavaScript 代码里充满了 == null 比较表达式，尽管代码检查工具往往不赞成这样做。
- 把 null 和 undefined 区分开大多没有用——一种没有价值的认知负担

好的，遵照您的要求，我将倾尽所学，对 Marijn Haverbeke 这篇关于在 JavaScript 中使用 `null` 和 `undefined` 的博文进行一次深入、详细、透彻的讲解。

这篇短文虽然篇幅极小，却堪称 JavaScript 实用主义编程哲学的典范之作。它直接挑战了当时（乃至现在）被许多人奉为圭臬的“始终使用 `===`”的教条，提出了一个在特定场景下更简洁、更符合意图的解决方案。理解这篇文章，就是理解一位务实的库作者是如何在语言的“怪癖”与工程的“便利”之间做出权衡的。

我们将从以下几个角度，层层递进，来彻底剖析这篇文章：

1.  **问题的背景：一场 JavaScript 的“圣战”**: 为什么 `== null` 会引起争议？这背后是怎样的编程思想之争？
2.  **核心论点：无用的区分**: 深入剖析作者为何认为 `null` 和 `undefined` 的区别是“没有价值的认知负担”。
3.  **务实的解决方案：`== null` 的五大优势**: 逐一解读作者列出的五个理由，并从 JavaScript 语言规范的角度解释其背后的原理。
4.  **作者的编程策略：输入与输出的分离**: 分析作者“对输入宽容，对输出严格”的策略，以及这背后对社区生态的体谅。
5.  **思想的延伸：超越教条的实用主义**: 这篇文章对我们日常编程有何启示？

---

### 1. 问题的背景：一场 JavaScript 的“圣战”

要理解这篇文章的重要性，必须先了解它所处的背景。在 JavaScript 社区，关于 `==` (抽象相等) 和 `===` (严格相等) 的使用，长期存在一场“圣战”。

- **主流教条 (以 JSLint/JSHint 为代表)**: 以 Douglas Crockford 的名著《JavaScript: The Good Parts》为代表的思想流派，强烈建议**永远不要使用 `==`**。因为 `==` 会进行隐式的类型转换，导致许多难以预料的行为（如 `"" == 0` 为 `true`, `"0" == 0` 为 `true`），是 bug 的温床。因此，JSLint 等静态检查工具默认会禁止使用 `==`。
- **Marijn 的挑战**: 作者在这篇文章中，公开为 `== null` 这一特定用法辩护，声称“我的代码里充满了 `== null` 的比较表达式”。这在当时无异于一种“异端”宣言。

这篇文章的目的，就是解释他为何要“冒天下之大不韪”，坚持使用这个被 linter 普遍反对的模式。

---

### 2. 核心论点：无用的区分

作者开门见山，直指问题的核心：

> "I have found the distinction between null and undefined to be mostly useless—a cognitive burden without merit."
> (我发现 `null` 和 `undefined` 之间的区别基本上是无用的——一个没有价值的认知负担。)

- **`undefined` 的来源**: 语言核心的多种构造都会产生 `undefined`。
  - 未初始化的变量 (`let x;`)
  - 未传入的函数参数 (`function f(a){...}; f();`)
  - 对象上不存在的属性 (`{}.foo`)
  - 没有返回值的函数调用 (`function f(){}; let x = f();`)
- **`null` 的来源**: 通常被用作一个**有意的、被赋值的“空值”**，常见于各种库的接口（尤其是 DOM API）。
  - DOM 节点没有子节点时，`firstChild` 为 `null`。
  - `getElementById` 找不到元素时，返回 `null`。

作者认为，在绝大多数业务逻辑中，我们关心的并不是“这个值为什么是空的”（是因为没定义，还是被显式设为 null？），我们只关心“**它是不是一个实际有意义的值**”。

> "The interesting distinction is usually between 'non-values' and actual values."
> (真正有趣的区分，通常是在‘非值’和实际值之间。)

这就是他立论的基石：**将 `null` 和 `undefined` 统一视为“非值 (non-value)”**，可以简化逻辑，减轻开发者的心智负担。

---

### 3. 务实的解决方案：`== null` 的五大优势

基于上述论点，作者提出了 `x == null` 这个模式，并列举了它的五大优势。这个模式之所以能工作，其魔法在于 JavaScript 的**抽象相等比较算法**，其中明确规定：

`null == undefined` 的结果是 `true`。
`null` 和 `undefined` 与任何其他值（除了它们自身）进行 `==` 比较时，结果都是 `false`。

因此，`x == null` 等价于 `x === null || x === undefined`。

现在我们来逐一分析这五大优势：

1.  **比 `== undefined` 更短**: 纯粹是字符数量上的优势，`null` 是 4 个字符，`undefined` 是 9 个。
2.  **比 `typeof X == "undefined"` 短得多**: `typeof X == "undefined"` 是检查一个可能未声明的全局变量而不抛出 `ReferenceError` 的传统方法。但在现代 JavaScript (ES6+) 中，由于块级作用域和模块的普及，这种场景已大大减少。在明确变量已声明的情况下，`x == null` 显然更简洁。
3.  **对 `undefined` 和 `null` 都为真**: 这是**最核心的优势**。它完美地实现了作者“将两者视为统一的‘非值’”的哲学。使用者无需再写 `if (x === null || x === undefined)` 这样的冗长代码。
4.  **只比 `=== null` 慢一点点**: 作者在这里主动回应了可能的性能质疑。`==` 因为要考虑类型转换，理论上比 `===` 慢。但这种差异是纳秒级别的微优化，在实际应用中完全可以忽略不计。过早地为这种级别的性能担忧是不可取的。
5.  **比 `_.isNull` 等辅助函数更快、更清晰**: 很多项目会引入 Lodash 等工具库，并使用 `_.isNull(x)` 或 `_.isNil(x)` (`isNil` 相当于 `== null`)。作者认为，直接使用语言内置的、简洁明了的 `== null`，不仅避免了引入外部依赖，而且执行速度更快，代码意图也同样清晰。

---

### 4. 作者的编程策略：输入与输出的分离

文章的最后，作者给出了一个非常成熟的工程实践策略：

> "(For output, I tend to stick to null, so as to not force my sins on the poor souls who have to code under the tyrannical eye of JSLint.)"
> (至于输出，我倾向于坚持返回 `null`，这样我就不会把我的‘罪过’强加给那些不得不在 JSLint 的暴虐之眼下编码的可怜人。)

这是一个充满了同理心和幽默感的声明，体现了作为一名库作者的责任感：

- **对输入宽容 (Be liberal in what you accept)**: 在接收参数时，使用 `== null` 来同时处理 `null` 和 `undefined`，让库的使用者更方便，不用去纠结到底该传哪个“空值”。
- **对输出严格 (Be conservative in what you produce)**: 在函数返回值时，统一返回 `null`。因为 `null` 是一个更明确的、被赋值的“空值”，并且不会触发 JSLint 等工具的警报。这样，即使库的使用者遵循着最严格的编码规范，他们在使用你的库时也不会遇到麻烦。

这种“输入宽容，输出严格”的原则（又称“波斯特尔定律”），是构建健壮、易用的 API 的黄金法则。

### 总结与启示

Marijn Haverbeke 的这篇短文，是一次精彩的“第一性原理”思考。他没有盲从于“永远使用 `===`”的社区教条，而是回归到问题的本质：**在检查空值这个特定场景下，我们的真实意图是什么？**

他的答案是：我们的意图是检查一个值是否为“非值”，而 `null` 和 `undefined` 的区别在这种意图下是噪音。`== null` 这个模式，恰好以最简洁、最高效的方式精确地表达了这个意图。

这篇文章给我们的启示是：

1.  **理解规则背后的“为什么”**: 不要盲目遵守任何编码规范或“最佳实践”。要去理解它们试图解决什么问题，以及它们在哪些场景下可能不适用。
2.  **代码意图至上**: 选择最能清晰表达你真实意图的代码。`x == null` 在“检查任何类型的空值”这个意图上，比 `x === null || x === undefined` 更直接。
3.  **拥抱实用主义**: 在教条的“纯洁性”和工程的“便利性”之间，要学会做出明智的权衡。
4.  **保持同理心**: 在设计 API 或编写共享代码时，要考虑到使用者的处境和他们可能遵循的规范，做出体贴的设计。
