# 在浏览器 JavaScript 中模拟一个可编辑控件

- CodeMirror 通过将（做得很小的）**textarea 包裹在一个 overflow: hidden; height: 0 元素中（ div ）来规避此问题。这样它既不可见又可聚焦。** div 元素采用绝对定位，并将其移动以始终与光标对齐。这样一来，它实际上有助于将真实光标滚动到可见区域。

- **当一个可编辑控件获取焦点后，浏览器每次检测到该控件有活动时，都会将其滚动到可见区域**。这意味着，如果隐藏的 textarea 仅仅放在编辑器的顶部，而且由于你在编辑靠近编辑器底部的内容而将顶部滚出视野，那么每次你输入一个字符时，窗口都会向上滚动。

---

正在收集工作区信息好的，我们来对 Marijn Haverbeke 这篇关于“在浏览器中伪造一个可编辑控件”的博客文章进行一次系统且深入的分析讲解。这篇文章写于 2012 年，是理解 CodeMirror 早期版本（以及许多其他现代编辑器）如何巧妙地绕过浏览器限制，实现自定义编辑体验的奠基之作。

这篇分析将从以下几个角度展开：

1.  **核心问题**: 为什么不能直接用 `contentEditable`？我们到底想从浏览器“偷”什么？
2.  **关键技巧：隐藏的 `textarea`**: 如何实现一个既不可见又能接收输入的“幽灵”控件？
3.  **剪贴板的秘密**: 如何让复制、剪切、粘贴功能在自定义的视图上正常工作？
4.  **捕获用户输入**: 如何在不打断输入法（IME）的情况下，可靠地侦测到用户的每一次击键或粘贴？
5.  **原生交互的模拟**: 如何处理拖放和右键上下文菜单这些“原生”体验？
6.  **一次失败的尝试**: 作者曾尝试过另一种更“原生”的方案，为什么最终放弃了？

---

### 1. 核心问题：自定义渲染 vs. 原生输入

文章开篇就指出了根本矛盾：

- **我们想要自己画出所有东西**：包括文本、光标、选区高亮等，以获得对编辑器外观和行为的完全控制。
- **但我们又需要浏览器的原生功能**：如元素聚焦、接收键盘输入、响应复制/剪切/粘贴命令、支持输入法（IME）、屏幕阅读器等。

直接使用 `contentEditable` 会导致失控，正如你在 index.md 中读到的，浏览器会产生混乱的 DOM，难以实现高级功能。因此，CodeMirror 走上了一条“欺骗”浏览器的道路。

### 2. 关键技巧：隐藏的 `textarea`

这是整个方案的基石，正如这篇博文 [`chore/js/Marijn Haverbeke's blog/Faking an editable control in browser JavaScript.md`](chore/js/Marijn Haverbeke's blog/Faking an editable control in browser JavaScript.md) 所述。

- **目的**: 在页面上创建一个浏览器认为是“当前焦点”的真实输入控件。
- **实现**:
  1.  创建一个 `<textarea>` 元素。
  2.  不能使用 `display: none` 或 `visibility: hidden`，因为这会导致浏览器拒绝聚焦它。
  3.  **解决方案**: 将 `textarea` 包装在一个 `height: 0; overflow: hidden;` 的 `<div>` 中，使其在视觉上消失，但对浏览器来说仍然是可聚焦的。
- **副作用与妙用**:
  - **问题**: 浏览器会自动滚动以确保聚焦的元素可见。
  - **解决方案**: 通过绝对定位，**始终将这个隐藏的 `textarea` 移动到编辑器虚拟光标的位置**。这样一来，浏览器的原生滚动行为反而帮助我们将真实的光标滚动到视图中，化弊为利。

### 3. 剪贴板的秘密 (复制/剪切/粘贴)

- **问题**: 当用户按下 `Ctrl+C` 时，浏览器如何知道要复制什么？
- **答案**: 浏览器会复制隐藏 `textarea` 中被选中的内容。
- **实现策略**:
  1.  **CodeMirror 的早期策略 (稳健但慢)**: **始终**将编辑器中当前选中的文本放入隐藏的 `textarea` 并选中它。
      - **优点**: 兼容性好，能处理不支持 `copy`/`cut` 事件的旧浏览器（如 Opera）和 Linux 的中键粘贴。
      - **缺点**: 当选中大段文本时（如全选），频繁读写 `textarea.value` 会导致性能问题，甚至卡顿。
  2.  **ACE 编辑器的策略 (聪明但有兼容性问题)**: 监听 `copy`/`cut` 事件，仅在事件触发的瞬间才将选中的文本放入 `textarea`。
  3.  **最终的混合策略**: CodeMirror 后来采纳了 ACE 的思想，并做了优化：
      - 当选区很**小**时，继续使用旧策略，保证兼容性。
      - 当选区很**大**时，并且浏览器支持 `copy`/`cut` 事件，则切换到“按需放入”的策略，解决了性能瓶 ăpadă。

### 4. 捕获用户输入 (打字/粘贴/IME)

- **问题**: 如何知道用户在隐藏的 `textarea` 中输入了内容？
- **挑战**:
  - `paste` 事件在某些浏览器或某些场景下（如菜单粘贴）不会触发。
  - 输入法（IME）的组词过程可能不会触发任何标准事件。
- **解决方案：事件监听 + 轮询 (Polling)**
  1.  监听 `keypress`, `paste`, `input` 等事件来“猜测”可能发生的输入。
  2.  在编辑器获得焦点时，进行高频轮询，检查 `textarea` 的内容是否变化。
  3.  **轮询优化**: 检查 `textarea` 是否有选区是廉价的。如果 `textarea` 中有选中的文本（即之前放入的选区），那么任何输入都会覆盖它，此时无需读取其庞大的 `value`，轮询成本极低。
- **兼容 IME**:
  - 如果每次读取后都清空 `textarea`，会打断 IME 的组词过程。
  - **策略**: 当 `textarea` 中没有选区时（通常意味着 IME 正在组词），CodeMirror 会保留其内容。在下一次轮询时，通过**比较新旧值的差异**来计算出用户实际输入的字符，从而实现对 IME 中间状态的兼容。

### 5. 原生交互的模拟

- **拖放 (Drag & Drop)**:
  - 通过监听 `dragstart` 事件，并使用 `e.dataTransfer.setData("Text", ...)` 将当前选中的文本放入拖拽数据中。
  - 通过监听 `drop` 事件，并结合 `FileReader` API，可以处理拖入的文本或文件。
- **右键上下文菜单**:
  - 浏览器没有提供修改原生菜单的 API。
  - **骇客技巧**: 监听 `mousedown` (针对 Firefox) 或 `contextmenu` 事件，**临时取消隐藏 `textarea` 并将其移动到鼠标下方**。浏览器会认为用户右击了一个真实的可编辑区域，从而弹出包含“复制/剪切/粘贴”的原生菜单。操作完成后再将 `textarea` 隐藏。

### 6. 一次失败的尝试：放弃原生光标移动

文章最后提到，CodeMirror 2 的早期版本曾尝试让浏览器处理光标移动。

- **旧思路**: 将光标周围的几行文本都放入 `textarea`，让浏览器原生处理方向键、选区等。
- **放弃原因**:
  1.  **实现复杂且脆弱**: 无法直接控制选区的“锚点”（即选区从哪一端开始），导致反向选区的行为难以模拟，需要大量 hack。
  2.  **需求变化**: 开发者更关心为 CodeMirror 自定义快捷键，而不是依赖浏览器不统一的默认行为。

最终，CodeMirror 放弃了这个方案，改为**完全由自己处理所有非输入类型的键盘事件（如光标移动）**，`textarea` 的职责被进一步缩减，主要只负责承载输入和剪贴板内容。这虽然增加了工作量，但换来了跨浏览器的一致性和强大的可控性，正如在 index.md 中所强调的，这是 CodeMirror 6 设计哲学的一部分。
