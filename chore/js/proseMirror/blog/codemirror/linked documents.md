# Shared documents in CodeMirror

- 编写能解决当前问题的代码，而不是为未来可能有人遇到的一堆类似问题预先写一大堆代码。
- 与其以一种让代码对未来情况足够灵活的方式来编写，我更专注于**让代码保持小而简单，以便在未来扩展时不需太多努力。**

---

好的，遵照您的要求，我将倾尽所学，对 Marijn Haverbeke 这篇关于 CodeMirror “共享文档”的博客文章进行一次深入、详细、透彻的讲解。

这篇文章是 CodeMirror 架构演进史上的一座分水岭。它标志着 CodeMirror 从一个“增强的文本框”向一个能够支持复杂应用（如现代 IDE）的“编辑器框架”的转变。作者在文中不仅阐述了技术方案，更分享了他关于**软件架构、API 设计和抽象演进**的深刻哲学思考。

我们将从以下几个角度，层层递进，来彻底剖析这篇文章：

1.  **核心哲学：“零未使用的抽象”**
2.  **问题的根源：为什么要拆分文档与编辑器？**
3.  **第一次非直觉设计：合并“文档”与“视图”**
4.  **第二次非直觉设计：没有“多视图”，只有“链接文档”**
5.  **撤销历史的困境与解决方案：共享历史与 Rebase**
6.  **子视图的实现与难题：坐标系与裁剪**
7.  **总结：一次务实而深刻的架构重构**

---

### 1. 核心哲学：“零未使用的抽象”

文章开篇，作者就阐述了他极为推崇的编程信条：

> "write code that solves the current problem you have, and not a bunch of other, similar problems that you can imagine someone may have in the future."
> (`只编写解决当前问题的代码，而不是去解决那些你想象中未来可能会有的类似问题。`)

这个信条的核心是**演进式设计**和**YAGNI (You Ain't Gonna Need It)** 原则。

- **反对过度设计**: 作者认为，再天才的架构师也无法准确预测未来。预先构建的、过于通用的抽象，不仅会增加代码量和复杂性，更会成为未来演进的“惯性”阻力。
- **拥抱变化**: 所有代码本质上都是“可抛弃的”。与其追求一次性的“灵活”，不如保持代码的**小而简单**，以便在未来需要时能毫不费力地扩展或重构。
- **价值驱动的抽象**: 只有当真实世界的需求出现时，才去构建抽象。这样的抽象才有明确的价值，并且如果它被证明是错误的，也可以“无情地废弃和替换”。

这个哲学直接导致了 CodeMirror 最初的一个“令人惊讶”的设计决定。

---

### 2. 问题的根源：为什么要拆分文档与编辑器？

- **初始设计 (Doc/Editor 合一)**: 基于“零未使用的抽象”原则，CodeMirror 最初并**没有**将“文档 (Document)”和“编辑器 (Editor)”作为两个独立的概念。一个编辑器实例就代表了一个文档。
  - **优点**: API 极其简单直接。没有 `editor.getView().getDocument().getValue()` 这种冗长的调用链，只有 `editor.getValue()`。
- **新需求的出现**: 随着 CodeMirror 被用于像 Light Table 和 Brackets 这样的全功能 IDE 项目，新的需求浮现了：
  1.  **多视图 (Split View)**: 需要在多个视图中显示**同一个**文档，而不仅仅是同步的副本。这意味着它们必须共享**同一个撤销历史**。
  2.  **子视图 (Sub-view)**: 需要在一个小编辑器中显示一个大文档的一部分（例如，在一个小窗口中显示函数定义）。

这些需求迫使作者必须打破“文档/编辑器合一”的旧模型，将文档作为一个可以被共享和链接的独立实体。

---

### 3. 第一次非直觉设计：合并“文档”与“视图”

在拆分文档和编辑器的过程中，一个看似“显而易见”的设计是：

- **文档 (Document)**: 只包含纯文本内容。
- **视图 (View)**: 包含滚动位置、光标位置，并引用一个文档。

但作者**放弃**了这个方案，选择了将两者**合并**。

- **原因**:
  1.  **建立不变量 (Invariants)**: 合并后，可以确保一个“文档”对象**总是**有关联的光标位置。不变量是好东西，它能减少系统的状态复杂性。
  2.  **简化 API**: 减少了一层用户必须处理的间接关系。
  3.  **成本极低**: 唯一的代价是，在极少数不需要光标的场景下，会多分配几个几乎不占内存的对象。

这个决定体现了作者对“恰到好处的抽象”的追求：**宁愿牺牲一点点理论上的纯粹性，也要换取实践中的简单和健壮**。

---

### 4. 第二次非直觉设计：没有“多视图”，只有“链接文档”

这是整篇文章最核心、最反直觉的设计。当被问及“如果光标在文档上，如何实现多视图？”时，作者的回答是：

> "There are no multiple views on a single document. Instead, there are 'linked' documents"
> (不存在对单一文档的多个视图。取而代之的是‘链接的’文档。)

- **核心思想**: 当你想创建第二个视图时，你实际上是创建了一个**全新的文档对象**，然后将它与原始文档“`链接`”起来。当一个文档发生变化时，变化会传播给所有与它链接的文档，以确保它们 100% 同步。
- **为什么不共享一个中央数据结构？**
  - 听起来创建多个文档对象很浪费，但回顾一下 CodeMirror 的文档表示法（B-Tree），它的设计核心是为了**根据垂直偏移量索引行**。
  - 垂直偏移量取决于行的**视觉高度**（是否换行、折叠等）。
  - **无法保证**多个视图会以完全相同的方式渲染行（例如，它们的宽度不同）。
  - 因此，每个视图**无论如何都需要自己独立的高度索引**。
  - 既然如此，拥有一个不包含高度信息的“中央数据结构”反而是一种额外的内存浪费。`让每个“文档”对象都拥有自己的 B-Tree，并共享底层的字符串内容，是更高效的方案。`

这个设计再次体现了作者对底层实现的深刻理解，他没有被表面的概念（“多视图”）所迷惑，而是从数据结构的实际需求出发，做出了最务实的选择。

---

### 5. 撤销历史的困境与解决方案：共享历史与 Rebase

- **共享历史**: 对于典型的分屏视图，用户的期望是共享一个撤销历史。在 `linkedDoc` 时，可以指定 `sharedHist: true`。
- **独立历史的难题**: 对于子视图（如函数定义弹窗），用户通常不希望在子视图中撤销一个在主视图中、且在子视图中不可见的操作。
- **解决方案：Rebase (变基)**
  - 当两个链接的文档不共享历史时，如果一个变化从 A 传播到 B，这个变化**不会**被加入 B 的撤销历史中。
  - 这会导致 B 的当前状态与 B 的撤销历史的“顶端”不一致，就像 Git 中本地有了新提交后，无法直接应用旧的补丁一样。
  - 为了解决这个问题，CodeMirror 借用了 Git 的术语 `rebase`：当一个外部变化到来时，它会尝试更新（“变基”）本地的撤销历史。
  - 这个过程是“破坏性的”：如果历史补丁与新变化不冲突（例如，只是行号变了），就更新补丁；如果冲突（例如，在同一行编辑），就**直接丢弃**旧的撤销历史。

---

### 6. 子视图的实现与难题：坐标系与裁剪

- **统一坐标系**: 作者选择让子视图的行号与其父文档保持一致。例如，一个显示父文档 100-120 行的子视图，其第一行的行号是 100，而不是 0。这虽然打破了“第一行总是 0”的不变量，但极大地简化了变化在不同文档间传播时的坐标转换。
- **裁剪的难题 (Underconstrained Problem)**: 当一个跨越子视图边界的修改发生时，如何裁剪是一个“欠约束问题”，没有唯一的正确答案。
  - **例子**: 子视图显示 100-120 行。在父视图中，有人选中 0-110 行，并粘贴了 20 行。
  - **结果**: 子视图的前 10 行（100-110）肯定被删除了。但新粘贴的 20 行是否应该进入子视图？
  - **作者的武断决定**: 不包含。基于“`一个在子视图外部开始或结束的修改，可能与子视图无关`”的直觉。他承认这是武断的，但幸运的是这种情况很少见。

---

### 7. 总结：一次务实而深刻的架构重构

这篇文章是软件工程领域关于**演进式架构**的绝佳案例。

1.  **始于简单**: 从一个极其简单的、文档/编辑器合一的模型开始，完美地解决了最初的问题。
2.  **需求驱动演进**: 当真实且复杂的需求（多视图、子视图）出现时，才开始进行重构。
3.  **深刻的权衡**: 在重构过程中，作者没有选择理论上最“纯粹”的方案，而是基于对底层数据结构和用户体验的深刻理解，做出了一系列非直觉但极其务实的设计决策（合并文档/视图、链接文档模型）。
4.  **拥抱不完美**: 在面对无法完美解决的问题（如历史冲突、裁剪）时，承认其本质，并选择一个简单、可预测、破坏性最小的方案。

最终，CodeMirror 获得了一个既能向后兼容简单用例，又能支持未来复杂应用的、健壮且灵活的新架构。这整个过程，完美地诠释了作者开篇所阐述的“零未使用的抽象”的编程哲学。
