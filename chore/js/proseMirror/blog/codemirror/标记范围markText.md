正在收集工作区信息好的，我们来对 Marijn Haverbeke 这篇关于 CodeMirror “标记范围 (marked ranges)” 的博客文章进行一次系统且深入的分析讲解。这篇文章写于 2012 年，是理解 CodeMirror 如何从一个纯粹的文本高亮工具，演变为一个能够承载复杂交互界面的“文本操作系统”雏形的关键。

这篇分析将从以下几个角度展开：

1.  **核心概念：什么是“重载纯文本”？**
2.  **功能的演进：从简单样式到“激进的扩展”**
3.  **最大的技术挑战：打破“行”的边界**
4.  **巨大的回报：统一与强大的新能力**
5.  **终极野心：“用文本作为用户界面”**
6.  **历史意义：从 CodeMirror 到 ProseMirror 的思想传承**

---

### 1. 核心概念：什么是“重载纯文本”？

文章开篇就点明了 `markText` 的初衷：**以编程方式为文本片段添加样式**。

然而，这篇文章的核心思想远不止于此。“重载纯文本 (Overloading plain text)”意味着在不改变底层纯文本内容的前提下，为其附加一层或多层额外的**行为**和**表现**。这些标记范围就像是贴在文本上的“透明贴纸”，它们可以：

- 改变文本的**外观**（如 CSS 类）。
- 改变文本的**行为**（如只读、原子化）。
- 改变文本的**存在形式**（如折叠、替换为小部件）。

这与你在 prosemirror-changeset.md 中看到的“追踪修订”功能一脉相承，都是通过在文档模型之上附加信息（装饰器/标记）来实现复杂的可视化效果。

### 2. 功能的演进：从简单样式到“激进的扩展”

`markText` 的发展历程，是 CodeMirror 功能逐步强大的缩影：

- **阶段一 (v2 早期)**: 实现了基本功能，即给一段文本 `(from, to)` 加上一个 CSS 类。
- **阶段二 (v2.16)**: 实现了**健壮性**。用户可以在标记范围的周围甚至内部进行编辑，而不会破坏标记。
- **阶段三 (v2.34)**: 实现了与**撤销历史的集成**。删除一段包含标记的文本，撤销时不仅文本会恢复，标记也会随之恢复。这要求标记本身成为可被记录和回滚的“操作”的一部分，类似于 ProseMirror 中的“步骤 (Steps)”，如 guide.md 所述。
- **阶段四 (v3 分支，革命性扩展)**: 这是文章的重点，`markText` 被赋予了全新的、改变编辑器本质的能力：
  1.  **原子化 (`atomic`)**: 光标无法进入该范围，它被当作一个整体，一次性跳过或删除。
  2.  **只读 (`readOnly`)**: 范围内的文本无法被修改。
  3.  **折叠 (`collapsed`)**: 隐藏范围内的内容。
  4.  **小部件替换 (`replacedWith`)**: 将一个（通常是折叠的）范围替换为任意的 DOM 节点。
  5.  **自动清除 (`clearOnEnter`)**: 当光标进入时自动移除该标记。

### 3. 最大的技术挑战：打破“行”的边界

作者明确指出，实现**折叠 (`collapsed`)** 是最困难的部分。

- **问题所在**: 在此之前，CodeMirror 的内部数据结构（如 CodeMirror 的文档结构 lineTree.md 中描述的 B-Tree）和渲染逻辑都基于一个核心假设：**文档是由一行行独立的视觉单元组成的**。
- **打破假设**: 当一个可以跨越多行的标记范围被折叠时，例如，一个从第 1 行末尾到第 2 行开头的范围被折叠，那么第 1 行的剩余部分和第 2 行的剩余部分将在视觉上被“拼接”到同一行。
- **连锁反应**: 这个看似简单的功能，破坏了整个系统的基础假设，导致作者不得不重写了大量核心代码，包括**选区绘制**和**字符位置测量**。

### 4. 巨大的回报：统一与强大的新能力

这次痛苦的重构是值得的。

- **架构统一**: 旧的、独立的**代码折叠 (line-folding)** 系统被完全废弃。因为“隐藏整行”只是“隐藏任意文本范围”的一个特例。新的代码折叠插件可以直接使用 `markText` 的 `collapsed` 和 `replacedWith` API 来实现，架构变得更简单、更统一。
- **开启新世界**: 这些扩展的组合，催生了全新的应用场景。文章中的 LaTeX 示例完美地诠释了这一点：
  - 将文本 `\epsilon` 用一个 `markText` 标记。
  - 设置 `collapsed: true` 和 `replacedWith: 'ε'`，在视觉上将其替换为希腊字母 ε。
  - 设置 `clearOnEnter: true`，当用户光标移入时，标记自动消失，变回可编辑的 `\epsilon` 文本。
  - 这在**不破坏底层纯文本文档一致性**的前提下，极大地增强了文档的**表现力**。

### 5. 终极野心：“用文本作为用户界面”

作者在文中坦诚了他的“秘密野心”：**取代 Emacs**。

他所向往的，是一种“文本即界面 (text as a user interface)”的编程和交互模式。通过组合使用 `readOnly`、`atomic` 和 `replacedWith` 等标记，开发者可以在一个纯文本编辑器中构建出表单、交互式命令行、甚至游戏。

这与 ProseMirror 的设计哲学不谋而合：**通过一个结构化的文档模型和强大的装饰器（Decorations）系统，编辑器不再仅仅是文本的容器，而是一个可以承载任意复杂视图和交互的应用平台。**

### 6. 历史意义：从 CodeMirror 到 ProseMirror 的思想传承

这篇文章中体现的思想，是理解从 CodeMirror 到 ProseMirror 演进的关键一环。

- **数据与表现分离**: `markText` 的核心就是将文档的底层数据（纯文本）与上层的视觉表现和行为（样式、小部件）分离开。
- **结构化信息的附加**: 标记范围就是在扁平的文本上附加了结构化的信息。这正是 ProseMirror 将文档模型设计为树状结构，并通过 Decoration 系统附加信息的思想雏形。
- **对复杂性的掌控**: **通过一个统一、强大的 API (`markText`) 来管理所有附加行为**，而不是为每个功能（折叠、只读等）创建独立的、可能相互冲突的系统，这体现了对系统复杂性的深刻理解和掌控力。

总而言之，`markText` 的演进，标志着 CodeMirror 从一个“代码编辑器”向一个“可编程文本环境”的转变。它所探索的“重载纯文本”的思想，为后来更先进、更结构化的编辑器（如 ProseMirror）铺平了道路。
