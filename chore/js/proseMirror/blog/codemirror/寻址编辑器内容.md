https://marijnhaverbeke.nl/blog/addressing-editor-content.html

好的，我们来详细分析和讲解 Marijn Haverbeke 的这篇关于“寻址编辑器内容”的博客文章。

这篇文章探讨了在文本编辑器中如何表示和追踪文档中特定位置的核心问题。这个问题之所以重要，是因为从光标、选区到代码高亮、注释等各种功能，都依赖于一种能够精确、高效地引用文档位置的机制。当文档内容频繁发生变化（如用户输入或删除文本）时，维持这些位置引用的有效性就成了一个巨大的挑战。

文章主要分析了四种不同的技术方案，并阐述了各自的优缺点。

---

### 1. 偏移量位置 (Offset Positions)

这是最直接、最常见的方法。

- **工作原理**: 将整个文档视为一个扁平的字符序列，每个位置都用一个从文档开头算起的整数偏移量（offset）来表示。例如，文档 "hello" 中，字母 'e' 前面的位置是 `1`，整个文档的末尾是 `5`。
- **优点**:
  - **简单直观**: 概念清晰，易于理解和实现。
  - **计算高效**: 查找附近的位置只需要简单的加减法。
  - **优于行列对**: 作者特别指出，这种“扁平”系统远优于使用 `{行, 列}` 对的方式。因为后者在处理跨行操作时逻辑非常复杂，需要不断查询行的长度，代码笨拙且容易出错。CodeMirror 6 从行列对迁移到偏移量系统，带来了巨大的便利。
- **主要缺点**:
  - **不稳定性**: 这是该方法最大的问题。当文档被修改时，几乎所有的偏移量都会失效。例如，在文档开头插入一个字符，所有后续位置的偏移量都必须加一。
  - **维护成本高**: 任何持有文档位置引用的数据（如光标、书签、装饰等），都必须在每次文档更新时进行“映射”（mapping）——即根据变更来更新其存储的偏移量值。这需要严格的编程纪律，且当需要追踪的位置很多时，开销会很大。

**小结**: 偏移量方法简单、高效，但其固有的不稳定性要求编辑器系统必须有一个`健壮的位置映射机制`来应对文档的频繁变更。

---

### 2. 唯一 ID (Unique IDs)

为了解决偏移量的不稳定性，一个自然的想法是给文档中的元素分配不会改变的身份标识。

- **工作原理**: 为文档中的每个最小单元（例如每个字符）分配一个全局唯一的、稳定的 ID。位置不再由数字偏移量定义，而是通过相对 ID 来描述，例如“在 ID 为 X 的元素之前”。
- **优点**:
  - **稳定性**: 理论上，只要元素存在，其 ID 就不变。即使文档被大量修改，基于 ID 的位置引用也无需像偏移量那样进行映射。
- **缺点**:
  - **删除问题**: 如果一个带有被引用 ID 的元素被删除了，这个位置引用就失去了意义。
  - **“墓碑”方案**: 为了解决删除问题，可以引入“墓碑”（tombstones）。即在元素被删除后，不立即清除其 ID，而是保留一个记录，将其指向相邻的、仍然存在的元素。但这会导致“墓碑”数据结构不断膨胀，甚至可能比文档本身还大。清理墓碑又会重新引入位置引用失效的问题。
  - **查找效率**: 从一个 ID 快速定位到它在文档中的当前偏移量，本身就是一个难题。每次都全文档扫描显然太慢。
  - **数据结构限制**: 作者提到，虽然在可变的数据结构（如双向链表）中可以通过一些技巧（ID -> 节点 -> 遍历父节点）来快速定位，但这与他偏爱的“持久化数据结构”（Persistent Data Structures）不兼容。

**小结**: 唯一 ID 方案追求绝对的稳定性，但引入了删除处理、查找效率和数据结构复杂性等一系列新问题，实践起来非常棘手。

---

### 3. 有序 ID (Ordered IDs)

这是对唯一 ID 方案的一种改进，灵感来源于 CRDTs（无冲突复制数据类型）。

- **工作原理**: 分配的 ID 不仅是唯一的，而且其自身的排序关系就对应了它们在文档中的顺序。例如，ID "a" 在 ID "b" 之前。
- **优点**:
  - **解决查找问题**: 因为 ID 是有序的，所以可以通过二分查找或树搜索等高效算法，快速地从 ID 定位到其在文档中的位置。
  - **部分解决删除问题**: 即使一个 ID 被删除了，我们仍然可以比较它与其他现存 ID 的大小，从而确定它“原本”应该在哪个区间。
- **缺点**:
  - **ID 生成复杂**: 最大的挑战在于，如何能总是在任意两个已存在的 ID 之间生成一个新的、合法的 ID？这通常需要 `ID 本身具有可变长度或复杂结构`（例如，在 "a" 和 "b" 之间插入 "aa", "ab" ... "az"；或者使用分数索引）。
  - **删除后的歧义**: 如果一个元素被删除，其留下的 ID 空间可能会被后续插入的新内容填充。这时，一个仍然引用着旧 ID 的指针可能会错误地定位到这些新内容中的某个随机位置，从而失去意义。

**小结**: 有序 ID 解决了普通 ID 的查找效率问题，但在 ID 生成和处理删除歧义方面引入了新的复杂性。

---

### 4. 事务日志 (Transaction Log)

这是文章发表后，由 Jamie Brandon 提出的一个新思路。

- **工作原理**: 将位置定义为一个 `{版本, 偏移量}` 对。同时，文档维护一个从初始版本开始的所有变更记录（事务日志）。当需要解析一个旧版本的位置时，系统可以从那个旧版本开始，依次应用后续的所有变更，从而将旧的偏移量“映射”到当前文档的正确位置。
- **优点**:
  - **概念清晰**: 将问题重新定义为“版本间的坐标变换”，逻辑上很优雅。
- **缺点**:
  - **性能衰减**: 一个位置越“老”，解析它所需的时间就越长，因为它需要重放的变更记录就越多。
  - **空间成本**: 需要存储完整的编辑历史，这可能导致数据结构的大小与编辑历史成正比，而不是与当前文档大小成正比。

**小结**: 事务日志方法提供了一个有趣的新视角，但可能面临性能和存储的挑战。

---

### 结论

作者 Marijn Haverbeke（CodeMirror 和 ProseMirror 的创建者）在权衡了所有方案后，最终选择继续在他自己的项目中使用第一种方法——**偏移量位置**。

他的理由是：尽管在每次文档变更时映射所有位置引用是一件“苦差事”，但这种方法**最容易理解和推理**，并且不需要引入和维护那些极其复杂的数据结构。它的缺点（需要映射）是明确且可控的，而其他方案的缺点则更深奥、更难驾驭。这体现了一位资深工程师在复杂系统设计中对“简单性”和“可维护性”的重视。
