https://marijnhaverbeke.nl/blog/display-updates-in-codemirror.html

The way CodeMirror schedules updates to the DOM

好的，遵照您的要求，我将倾尽所学，对 Marijn Haverbeke 这篇关于 CodeMirror “显示更新”的博客文章进行一次深入、详细、透彻的讲解。

这篇文章是理解现代高性能 UI 框架（包括 CodeMirror 自身、React 等）核心思想的绝佳范例。它揭示了为了在浏览器这种“读写-分离”性能模型下实现流畅体验，所必须采用的**批量更新 (Batching)** 和 **调度 (Scheduling)** 策略。

我们将从以下几个角度，层层递进，来彻底剖析这个系统：

1.  **核心问题：DOM 的“读写”诅咒**
2.  **解决方案的核心：操作 (Operation)**
3.  **数据结构：如何追踪需要更新的内容？**
4.  **更新的执行：在鸡蛋上行走 (Walking on Eggs)**
5.  **与 React 的异同**
6.  **总结：一个精心设计的更新管道**

---

### 1. 核心问题：DOM 的“读写”诅咒

文章开篇就指出了根本矛盾：

- **写操作 (Write)**: 修改 DOM，例如改变一行文本的内容、添加 CSS 类。
- **读操作 (Read)**: 从 DOM 读取布局信息，例如获取一个字符的屏幕坐标来绘制光标。

浏览器的渲染引擎有一个特性：如果你在一次 JavaScript 执行中，**交错地进行 DOM 的“读”和“写”**，性能会急剧下降。

- **原因**: 当你“写”了 DOM 后，再去“读”布局信息，浏览器为了给你一个准确的值，必须**立即**重新计算布局（这个过程称为“强制同步布局”或“回流/重排 (reflow/relayout)”，代价极高）。
- **CodeMirror 的困境**: 几乎每一次对文档的修改，都伴随着需要重新定位光标的需求。如果每个修改函数都立即更新 DOM，然后立即读取光标位置，那么一次简单的按键输入就可能触发多次昂贵的重排，导致编辑器卡顿。

这个问题迫使 CodeMirror 必须设计一个机制，来避免这种“读写交错”的死亡螺旋。

---

### 2. 解决方案的核心：操作 (Operation)

CodeMirror 的解决方案是引入一个名为“**操作 (Operation)**”的核心概念。一个“操作”将一连串的修改**打包**在一起。

- **实现**: 通过一个高阶函数 `operation(action)` 来实现。

  ```javascript
  // 伪代码
  CodeMirror.prototype.operation = function (action) {
    // 如果已经在一个操作中，直接执行即可，实现嵌套
    if (this.alreadyInOperation()) return action()

    this.setUpOperation() // 开始一个新操作，准备记录变更
    try {
      return action()
    } finally {
      // 执行所有修改逻辑
      this.finishOperation()
    } // 结束操作，执行真正的 DOM 更新
  }
  ```

- **关键特性**:
  1.  **批量处理**: 在 `action()` 执行期间，所有对文档的修改都**不会立即触及 DOM**。它们只是被记录在某个地方。
  2.  **延迟执行**: 真正的 DOM 更新被推迟到 `finishOperation()` 中，在所有修改逻辑都执行完毕后，**一次性**地、以最优顺序执行。
  3.  **可嵌套**: `operation` 可以安全地嵌套调用，只有最外层的 `operation` 才会真正触发一次完整的“开始-结束”流程。
  4.  **隐式包装**: 所有 CodeMirror 的公开修改方法（如 `setValue`, `replaceRange`）都已被隐式地包装在 `operation` 中，用户只有在需要自己组合多个操作时才需要显式调用它。

这个机制将一系列零散的修改，聚合成了**一个**批量的显示更新任务。

---

### 3. 数据结构：如何追踪需要更新的内容？

在 `operation` 期间，CodeMirror 使用一个临时的数据结构来记录所有发生的变更。

- **行级失效 (Line Invalidation)**:
  - CodeMirror 维护一个 `view` 数据结构，描述了当前渲染在屏幕上的**视觉行 (visual lines)** 范围。
  - 当一个可见行被修改时（例如，通过 `regLineChange` 函数），它会被标记为“失效 (invalidated)”。
  - 区分不同类型的失效：仅仅是 CSS 类变化，还是内容变化，或是行小部件变化。这允许在更新时采取更优化的路径，避免不必要的整行重绘。
- **范围变更 (Range Change)**:
  - 当一个范围的行发生变化（增加、删除）时，`regChange` 函数会被调用。
  - 这个函数会“修补”当前的 `view` 数据结构，以反映新的文档结构。这是一个复杂的过程，因为它需要处理坐标系的变化（行号的增删）和代码折叠信息的变更。
- **全局标记**: 还会有一些全局的标志位，用于记录是否需要重新计算某些全局信息，例如“文档中最宽行的宽度”（用于更新水平滚动条）。

**例子**: 用户输入一个字符，触发了自动缩进，又触发了自动闭合括号。

- **过程**: 发生了 3 次逻辑上的修改。
- **结果**: 在 `operation` 结束时，CodeMirror 的记录里只有一个信息：“第 3 行失效了，需要重绘”。光标也只需要被重新定位一次。

---

### 4. 更新的执行：在鸡蛋上行走 (Walking on Eggs)

`finishOperation()` 中的显示更新过程，是整个系统中最复杂、最脆弱的部分，作者称之为“在鸡蛋上行走”。

- **目标**: 将所有 DOM 的“读”操作和“写”操作分离开，最大限度地减少重排次数。
- **更新管道 (Update Pipeline)**:
  1.  **同步滚动位置**: 首先，根据编辑器的当前滚动位置，更新 `view` 数据结构，裁剪掉视口外的部分，添加新进入视口的部分。
  2.  **执行所有“写”操作**:
      - 根据失效标记，重绘所有需要更新的行。
      - 更新伪造滚动条的尺寸。
      - ...所有其他不依赖布局信息的 DOM 修改。
  3.  **触发一次重排**: 此时，浏览器会计算所有刚刚发生的变更。
  4.  **执行所有“读”操作**:
      - 读取光标/选区相关字符的精确屏幕坐标。
      - 读取文档的实际尺寸信息。
      - ...所有其他需要读取布局信息的操作。
  5.  **执行依赖于“读”的“写”操作**:
      - 根据上一步读取到的坐标，更新光标的 DOM 位置。
      - 根据读取到的尺寸，决定是否显示/隐藏滚动条。

这个过程将更新逻辑按照其在“管道”中的位置（读/写阶段）来组织，而不是按照子系统（光标、滚动条等）来组织。这使得代码变得“相当复杂”，但却能将大多数操作的重排次数控制在一到两次。

---

### 5. 与 React 的异同

作者将 CodeMirror 的方法与 React 进行了比较。

- **相似之处**:
  - 都认识到了直接操作 DOM 的低效，并采用了批量更新的思想。
  - 都有一个中间层来缓冲和聚合变更（React 的虚拟 DOM，CodeMirror 的 `operation` 变更记录）。
- **不同之处**:
  - **抽象层次**: React 提供了一个更高层次的、声明式的抽象。开发者只需描述“UI 应该是什么样子”，React 负责计算差异并更新。
  - **实现方式**: CodeMirror 的方法更底层、更命令式。它不是通过比较两棵完整的树（虚拟 DOM vs 真实 DOM），而是通过精确地记录“哪些行失效了”来进行更新。这是一种更“手术刀式”的更新，而不是“地毯式轰炸”。
  - **依赖读取**: CodeMirror 强依赖于从 DOM 读取布局信息，这使得其更新管道必须精心设计“读写分离”。而许多 React 应用的更新逻辑对布局信息的依赖较少。

---

### 6. 总结：一个精心设计的更新管道

CodeMirror 的显示更新系统是一个为了应对浏览器性能限制而精心设计的工程杰作。

1.  **核心是批量处理**: 通过 `operation` 概念，将多次零散的修改聚合为一次统一的更新，从根本上避免了“读写交错”的性能陷阱。
2.  **精确的变更追踪**: 它不使用通用的虚拟 DOM diff，而是通过一套专门为文本编辑器设计的、更精确的失效标记系统来追踪变更，实现了高效的增量更新。
3.  **脆弱但高效的更新管道**: 它将所有 DOM 操作严格地排序为“写-读-写”的管道，以最小化昂贵的浏览器重排。这个过程虽然复杂且易碎，但却是实现极致性能的关键。
4.  **跨实例优化**: 这个系统甚至被扩展到了支持跨多个 CodeMirror 实例的批量更新，进一步提升了在复杂应用中的性能。

这篇文章深刻地揭示了，在构建高性能 Web 应用时，理解并顺应浏览器的底层工作模式是多么重要。CodeMirror 的方案，是命令式 UI 更新范式下的一个极致优化的典范。
