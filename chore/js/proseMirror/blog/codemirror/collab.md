# Collaborative Editing in CodeMirror

好的，我们来对 Marijn Haverbeke 这篇关于 CodeMirror 协同编辑的博文进行一次系统且深入的分析讲解。这篇文章堪称一篇“反高潮”的技术选型报告，它记录了一个顶尖工程师在面对一个复杂问题时，如何抵制“炫酷技术”的诱惑，最终回归到一个“无聊但实用”的解决方案上的心路历程。

我们将从以下几个角度来剖析这篇文章：

1.  **问题的重新定义**: 协同编辑的两种模式——分布式 vs. 中心化。
2.  **核心权衡：OT vs. CRDT**: 为什么最终选择了“无聊”的 OT？
3.  **ProseMirror 经验的扬弃**: 为什么 CodeMirror 没有完全照搬 ProseMirror 的协同方案？
4.  **CodeMirror 的最终方案**: `ChangeSet` 的设计与“真·OT”的应用。
5.  **OT 的“阿喀琉斯之踵”**: 为什么文档能收敛，但位置映射（Position Mapping）却不能？

---

### 1. 问题的重新定义：分布式 vs. 中心化

文章开篇就做了一个至关重要的区分，这也是很多协同编辑讨论的混淆点：

- **分布式协同 (Distributed Collaboration)**:

  - **场景**: 多个对等的客户端（Peers）直接互相通信，没有中央服务器。
  - **特点**: 这是学术界研究的重点，理论上更通用、更“去中心化”。
  - **挑战**: 极其复杂。除了要解决文档收敛问题，还要处理节点发现、连接维护、历史存储等一系列工程难题。

- **中心化协同 (Coordinated Collaboration)**:
  - **场景**: 多个客户端都只与一个中央服务器通信，由服务器来协调和广播变更。
  - **特点**: 这是绝大多数 Web 应用的实际场景。
  - **优势**: 问题被大大简化。服务器可以作为最终的“仲裁者”，确定变更的顺序。

**Marijn 的决策**: 对于一个 JS 库的核心来说，支持真正的分布式模型带来的复杂性远大于其收益。因此，他明确地将目标锁定在**中心化协同**上，这使得他可以忽略掉 95% 的学术论文，聚焦于解决一个更具体、更实际的问题。

---

### 2. 核心权衡：OT vs. CRDT

在中心化协同的背景下，主要有两种技术路线来实现数据收敛。

#### A. 操作变换 (Operational Transformation, OT)

- **核心思想**: 当两个并发的变更 A 和 B 发生时，通过一个 `transform(A, B)` 函数，将它们分别转换为 `A'` 和 `B'`，使得 `A + B'` 和 `B + A'` 能得到相同的结果。
- **优点**:
  - **数据结构简单**: 文档本身可以只存储纯文本，非常轻量。
  - **性能高**: 变更和变换操作通常很快。
- **缺点 (为什么被认为很难？)**:
  - **“黑魔法”**: OT 像一个“黑客技巧”，虽然实用，但缺乏坚实的理论基础，难以推理和证明其正确性。尤其是在复杂文档结构（如树）或去中心化场景下，定义一个能保证收敛的 `transform` 函数极其困难。
  - **历史包袱**: 学术界有大量关于 OT 的论文后来被证明是错误的。

#### B. 无冲突复制数据类型 (Conflict-free Replicated Data Types, CRDT)

- **核心思想**: 通过设计一种特殊的数据结构，使得任何顺序的变更应用最终都能收敛到相同的结果。它将复杂性从“变换算法”转移到了“数据结构”本身。
- **文本 CRDT 的常见实现**:
  1.  **ID-per-character + Tombstones**: 为每个字符分配唯一 ID，删除操作只是打上“已删除”标记（墓碑），永不真正移除。
  2.  **Fractional Indexing**: 为每个字符生成一个介于其相邻字符之间的分数 ID。插入新字符就是生成一个新的分数。
- **优点**:
  - **理论坚实**: 提供了清晰的数学模型，易于推理和证明收敛性。
  - **天然支持分布式**: 因为操作顺序无关紧要。
- **缺点**:
  - **数据结构臃肿**: 每个字符都需要附带额外的元数据（ID），甚至不能真正删除字符，导致内存开销巨大。这与 CodeMirror 支持超大文档的目标相冲突。
  - **编程接口不友好**: 开发者需要和这些复杂的内部数据结构打交道。

**Marijn 的决策**: 尽管 CRDT 在理论上很优美，并且能解决一些 OT 无法解决的问题（后文会提到），但其巨大的内存开销和复杂性对于 CodeMirror 的核心来说是不可接受的。因此，他选择了**“无聊但够用”的经典中心化 OT**。

---

### 3. ProseMirror 经验的扬弃

Marijn 之前在 ProseMirror 中已经实现了一套协同方案，为什么不直接照搬？

- **ProseMirror 的方案 (Faux OT)**:

  - 它有一个 `transform` 函数，但这个函数**不保证收敛**。
  - **收敛策略**: 当客户端收到与本地未确认变更冲突的远程变更时，它会：
    1.  **撤销 (undo)** 所有本地未确认的变更。
    2.  **应用 (apply)** 远程变更。
    3.  **重做 (redo)** 经过变换后的本地变更。
  - **本质**: 通过强制让所有客户端以**相同的顺序**（服务器确定的顺序）应用变更，来“绕过”了 OT 的收敛性难题。这是一种非常务实且聪明的工程做法。

- **为什么 CodeMirror 不完全采用？**
  - **文档模型不同**: ProseMirror 是复杂的树状结构，定义收敛的 OT 变换极其困难。而 CodeMirror 的文档模型（行序列）相对简单，实现“真·OT”是可行的。
  - **变更表示不便**: ProseMirror 的“一系列独立变更”的表示法，对于某些操作（如在选区两端加括号）很不直观，需要开发者手动计算坐标变换。

**结论**: ProseMirror 的方案对于其复杂的文档模型是必要的妥协，但对于 CodeMirror 来说，有更直接、更优化的选择。

---

### 4. CodeMirror 的最终方案：`ChangeSet` 与“真·OT”

基于以上思考，CodeMirror 的方案成型了：

- **核心数据结构：`ChangeSet`**:

  - 不再是一系列独立的 `Step`，而是一个**扁平的、描述多处变更的集合**。
  - 它被表示为一系列**“保留”和“替换”的片段**。例如，“在 10-20 两端加括号”可以表示为：`[保留 10, 插入 '(', 保留 10, 插入 ')']`。
  - 这种表示法更符合用户的直觉，也更容易从中提取变更的精确范围。
  - 它还包含了文档长度信息，可以在应用时进行动态检查，避免很多低级错误。

- **采用“真·OT”**:

  - 既然文档模型简单，`ChangeSet` 的表示也清晰，那么为它定义一个**保证收敛的 `transform` 函数**是完全可行的。
  - 这比 ProseMirror 的“撤销-重做”方案更高效。

- **应用扩展**:
  - 这套变换机制不仅用于协同编辑，还同样适用于**实现复杂的撤销历史**（例如，只撤销自己的变更，而不影响他人的变更）。

---

### 5. OT 的“阿喀琉斯之踵”：位置映射不收敛

这是文章最令人沮丧也最深刻的部分。Marijn 发现了一个惊人的事实：

> **即使文档内容可以通过 OT 完美收敛，文档中的位置（Position）在经过变换后却无法保证收敛！**

- **问题示例**:

  - 初始文档: `_ _ _ _ _` (下划线代表字符)
  - 用户 A: 删除 2-4 (`del(2, 4)`)
  - 用户 B: 在位置 4 插入 X (`ins(4, 'X')`)
  - **A 的视角**: 先 `del(2, 4)`，文档变为 `_ _`。再应用变换后的 B 的操作 `ins(2, 'X')`，文档变为 `_ _ X`。
  - **B 的视角**: 先 `ins(4, 'X')`，文档变为 `_ _ _ _ X _`。再应用变换后的 A 的操作 `del(2, 4)`，文档变为 `_ _ X _`。
  - **文档内容收敛了！**（假设初始内容相同，最终结果都是在第 2 个字符后插入 X）
  - **位置映射出问题了**: 假设我们追踪初始位置 `2`。
    - 在 A 的世界里，`2` 先经过 `del(2, 4)` 保持不变，再经过 `ins(2, 'X')`，如果偏向插入点之后，会变为 `3`。
    - 在 B 的世界里，`2` 先经过 `ins(4, 'X')` 不变，再经过 `del(2, 4)` 也不变，最终还是 `2`。
  - **结论**: 两个客户端对于同一个初始位置，最终计算出的新位置不同。

- **原因分析**:

  - **信息丢失**: 映射操作在经过**删除**范围时会丢失信息。我们无法知道原始位置是在被删除范围的内部，还是在它的边缘。
  - **OT 的局限**: OT 只关心最终的文本内容，而被删除的内容对它来说是“无关紧要”的。但对于需要精确跟踪位置的场景（如协同标注），这些被删除的内容恰恰是重要的上下文。

- **CRDT 的优势再现**:
  - 这正是 CRDT 能解决的问题。因为 CRDT 为每个字符（包括已删除的）分配了**永不改变的唯一 ID**。
  - 你可以用这个 ID 来锚定一个位置，它自然就实现了跨变更的收敛。

**最终的、痛苦的决策**: 尽管 CRDT 能解决位置收敛问题，但为了这个“相对小众”的需求而引入整个 CRDT 的复杂性和内存开销，是**不值得的**。Marijn 最终接受了这个不完美，并选择了更轻量的 OT 方案。

### 总结

这篇文章是一份杰出的技术决策备忘录，它告诉我们：

1.  **清晰地定义问题**是解决问题的第一步（中心化 vs. 分布式）。
2.  **没有银弹**。OT 和 CRDT 各有优劣，选择哪一个取决于你的核心需求和约束（性能、内存 vs. 理论完备性、分布式支持）。
3.  **务实胜于完美**。ProseMirror 的“伪 OT”和 CodeMirror 接受“位置不收敛”的现实，都是在工程约束下做出的明智妥协。
4.  **深入理解技术的边界**至关重要。只有像 Marijn 这样真正深入研究后，才能自信地说出“OT 无法实现位置收敛”，并基于这个深刻的理解做出最终决策。
