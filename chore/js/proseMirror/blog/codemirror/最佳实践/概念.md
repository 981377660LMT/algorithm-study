CodeMirror（特别是 v6 版本）确实是一个架构非常现代但也相对复杂的库。它采用了函数式编程思想和不可变数据结构，这与传统的 DOM 操作方式有很大不同。

以下是理解 CodeMirror 核心概念的指南、最佳实践和设计原则：

### 1. 核心概念模型：MVC 模式的变体

CodeMirror 6 将编辑器拆分为三个主要部分，理解这种分离是关键：

- **State (Model):** `EditorState`

  - 这是单一事实来源（Single Source of Truth）。
  - 它包含文档内容（Text）、当前选区（Selection）以及各种配置（Facets）。
  - **关键点：** State 是**不可变（Immutable）**的。你不能直接修改它，只能通过 Transaction 生成一个新的 State。

- **View (View):** `EditorView`

  - 这是 DOM 的直接映射。它负责将 State 渲染到屏幕上，并监听用户的输入事件。
  - **关键点：** View 依赖于 State。当 State 更新时，View 会高效地更新 DOM（类似 React 的 diff 算法）。

- **Transaction (Update):** `Transaction`
  - 这是改变 State 的唯一方式。
  - 它描述了“发生了什么变化”（例如：用户输入了字符 'a'，或者插件请求折叠代码）。

### 2. 关键 API 与定义解析

#### Facet (切面/配置项)

这是最难理解但也最强大的概念。

- **定义：** Facet 是扩展系统的基础。它允许不同的扩展向同一个配置点提供值。
- **类比：** 想象一个 React Context 或者 Redux 的 Reducer 组合。
- **用途：** 定义快捷键、事件监听器、样式类名等。
- **原则：** 多个插件可以向同一个 Facet 添加数据（例如，多个插件都可以添加快捷键绑定）。

#### Extension (扩展)

- **定义：** CodeMirror 的一切功能（包括行号、语法高亮、撤销重做）都是扩展。
- **最佳实践：** 构建编辑器时，实际上是在组装一个扩展数组。

#### Decoration (装饰)

- **定义：** 用于在不改变文档实际内容的情况下，改变文档的视觉表现。
- **类型：**
  - `MarkDecoration`: 改变文本样式（如语法高亮颜色）。
  - `WidgetDecoration`: 在文本中插入 DOM 元素（如折叠后的省略号、Lint 错误图标）。
  - `LineDecoration`: 改变整行样式（如当前行高亮）。

#### ViewPlugin (视图插件)

- **定义：** 当你需要直接操作 DOM 或者需要基于 View 的状态（如滚动位置、视口可见范围）进行计算时使用。
- **场景：** 比如实现一个“代码小地图”或者“当前作用域高亮”。

### 3. 最佳实践与原则

#### 原则 1：不可变性优先 (Immutability First)

永远不要尝试直接修改 `view.state.doc`。
**错误做法：**

```javascript
view.state.doc.toString() = "new content"; // 报错或无效
```

**正确做法 (Dispatch Transaction)：**

```javascript
view.dispatch({
  changes: { from: 0, to: view.state.doc.length, insert: 'new content' }
})
```

#### 原则 2：数据流单向流动

`State` -> `View` -> `DOM Event` -> `Transaction` -> `New State` -> `View Update`。
如果你在编写插件，确保你的逻辑遵循这个循环。不要在渲染周期（View Update）中触发新的 Transaction，这会导致死循环。

#### 原则 3：按需引入 (Tree Shaking)

CodeMirror 6 是模块化的。不要引入整个库，只引入你需要的功能。

```javascript
import { EditorState } from '@codemirror/state'
import { EditorView, keymap } from '@codemirror/view'
import { defaultKeymap } from '@codemirror/commands'
// 只引入需要的模块
```

#### 原则 4：理解坐标系

- CodeMirror 使用一维坐标（offset），从 0 开始。
- 行和列的概念是计算出来的，不是存储的。
- **注意：** 换行符在不同系统下长度不同（`\n` vs `\r\n`），CodeMirror 内部通常规范化为 `\n` (长度为 1)，但在处理外部输入时要小心。

### 4. 调试技巧

在开发时，利用 `EditorView.updateListener` 来观察发生了什么：

```javascript
const debugExtension = EditorView.updateListener.of(update => {
  if (update.docChanged) {
    console.log('文档内容变了')
  }
  if (update.selectionSet) {
    console.log('光标位置变了', update.state.selection.main.head)
  }
  // 查看具体的 Transaction
  update.transactions.forEach(tr => {
    console.log('Transaction:', tr)
  })
})
```

### 总结

CodeMirror 6 的学习曲线陡峭是因为它不仅仅是一个编辑器库，它是一个**用于构建编辑器的框架**。

- 如果你只是想用：关注 `EditorView` 的配置和现成的 `Extensions`。
- 如果你要开发插件：必须深入理解 `Facet` 和 `Transaction` 机制。

---

CodeMirror v6 的 API 确实设计得非常底层和抽象，因为它优先考虑的是灵活性和性能，而不是“开箱即用”的简单性。

针对“API 难懂”这个问题，以下是针对几个最常用、最易错的 API 场景的**最佳实践模式**。记住这些模式可以帮你避开 80% 的坑。

### 1. 修改文档内容 (Document Changes)

**痛点：** 很多人不知道如何正确替换文本，或者在循环中多次修改导致性能问题或坐标错乱。

**最佳实践：**

- **一次性提交所有变更**：不要在一个循环里多次调用 `dispatch`。
- **使用 `changes` 数组**：Transaction 支持一次性传入多个变更对象。
- **坐标自动映射**：当你传入多个变更时，CodeMirror 会自动处理坐标偏移（后面的变更不需要手动计算前面变更导致的位移）。

```javascript
// ❌ 错误做法：多次 dispatch，性能差，且容易导致视图抖动
for (const line of lines) {
    view.dispatch({ changes: { from: ..., insert: "..." } });
}

// ✅ 最佳实践：构建变更说明数组（ChangeSpec），一次性提交
const changes = [
    { from: 0, to: 5, insert: "Hello" }, // 替换前5个字符
    { from: 10, insert: " World" }       // 在第10个字符处插入（注意：这里的10是基于原始文档的坐标）
];

view.dispatch({
    changes: changes,
    // 可选：顺便移动光标到最后
    selection: { anchor: 11 },
    scrollIntoView: true
});
```

### 2. 读取文档内容 (Reading Content)

**痛点：** `state.doc` 是一个树状结构（Text Leaf），不是简单的字符串。直接操作它很慢。

**最佳实践：**

- **切片读取**：尽量只获取你需要的范围，而不是 `toString()` 整个文档。
- **按行迭代**：如果你需要处理每一行，使用迭代器而不是分割字符串。

```javascript
// ❌ 避免做法：大文件时内存爆炸
const allText = view.state.doc.toString()
const lines = allText.split('\n')

// ✅ 最佳实践：使用迭代器或切片
const doc = view.state.doc

// 获取特定行
const line = doc.line(5) // 获取第5行对象
console.log(line.text) // 行内容
console.log(line.from, line.to) // 行的起始和结束位置

// 遍历所有行（高效）
for (let i = 1; i <= doc.lines; i++) {
  const line = doc.line(i)
  // 处理 line.text
}
```

### 3. 状态管理与配置 (State Fields & Facets)

**痛点：** 如何在编辑器里存储自定义数据（比如：当前是否开启了“只读模式”，或者存储一个外部的 ID）？

**最佳实践：**

- **使用 `StateField`**：这是在 CodeMirror 内部存储自定义状态的标准方式。它类似于 Redux 的 reducer。
- **不要污染全局作用域**：不要把变量存在 `window` 或组件 `this` 上，尽量存在 `StateField` 里，这样状态会跟随编辑器实例。

```javascript
import { StateField, Effect } from '@codemirror/state'

// 1. 定义一个 Effect 来触发修改
const toggleReadOnly = StateField.defineEffect()

// 2. 定义 Field
const readOnlyField = StateField.define({
  create() {
    return false
  }, // 初始值
  update(value, transaction) {
    // 检查是否有特定的 Effect 发生
    for (let effect of transaction.effects) {
      if (effect.is(toggleReadOnly)) return effect.value
    }
    return value
  }
})

// 3. 在组件中使用
// 读取状态
const isReadOnly = view.state.field(readOnlyField)

// 修改状态
view.dispatch({
  effects: toggleReadOnly.of(true)
})
```

### 4. 视图更新与插件 (ViewPlugins)

**痛点：** 想在 DOM 上做点事（比如给编辑器加个边框，或者根据滚动位置显示元素），但不知道时机。

**最佳实践：**

- **使用 `ViewPlugin`**：这是连接 CodeMirror 状态和 DOM 的桥梁。
- **利用 `update` 方法**：这是 React `componentDidUpdate` 的 CodeMirror 版本。
- **检查 `docChanged` 或 `selectionSet`**：不要每次 update 都重绘，先检查 flag。

```javascript
import { ViewPlugin } from '@codemirror/view'

const myPlugin = ViewPlugin.fromClass(
  class {
    constructor(view) {
      this.dom = document.createElement('div')
      this.dom.textContent = 'Status: Ready'
      view.dom.appendChild(this.dom) // 挂载到编辑器 DOM 中
    }

    update(update) {
      // ✅ 最佳实践：性能优化，只有文档变了才更新 DOM
      if (update.docChanged) {
        this.dom.textContent = `Length: ${update.state.doc.length}`
      }
    }

    destroy() {
      this.dom.remove() // 清理
    }
  }
)
```

### 5. 坐标转换 (Positions)

**痛点：** 鼠标点击的位置（x, y）怎么转换成文档里的字符位置（offset）？

**最佳实践：**

- **使用 `view.posAtCoords` 和 `view.coordsAtPos`**。
- **注意 `side` 参数**：这决定了如果点击在字符的左半边还是右半边时，光标应该归属哪一边。

```javascript
// 获取光标当前在屏幕上的坐标（用于显示自动补全弹窗等）
const pos = view.state.selection.main.head
const coords = view.coordsAtPos(pos)
// coords = { left: 100, top: 200, bottom: 220, ... }

// 根据鼠标事件获取文档位置
document.addEventListener('click', e => {
  const pos = view.posAtCoords({ x: e.clientX, y: e.clientY })
  if (pos !== null) {
    console.log('点击了文档的第', pos, '个字符')
  }
})
```

### 总结：心法口诀

1.  **改内容**：用 `dispatch({ changes: [...] })`，别直接改。
2.  **读内容**：用 `doc.line(n)` 或迭代器，别 `toString()` 整个大文件。
3.  **存状态**：用 `StateField`，别用全局变量。
4.  **动 DOM**：用 `ViewPlugin`，并在 `update` 里检查 `docChanged`。
5.  **找位置**：用 `posAtCoords` / `coordsAtPos`。

---

CodeMirror 6 的设计哲学是“组合优于继承”，这导致它有很多细粒度的抽象概念。接下来的讲解将深入这些“深水区”，帮你建立完整的心理模型。

### 1. 深入抽象：RangeSet 与 Decorator 体系

这部分是实现语法高亮、折叠、Lint 提示的核心数据结构。

#### RangeSet (范围集合)

- **定义**：`RangeSet` 是一个高度优化的数据结构（通常是 B 树的变体），用于存储“带有位置范围的值”。
- **为什么难理解**：它不是数组。你不能用 `index` 访问。它必须处理重叠、嵌套和巨大的文档跨度。
- **最佳实践**：
  - **不要手动构建**：总是使用 `RangeSetBuilder`。它要求你按顺序（位置从小到大）添加元素，这样构建速度极快。
  - **用途**：主要用于存储 `Decoration`（装饰），但也可以存储任何自定义数据。
  - **迭代**：使用 `iter()` 方法获取游标（Cursor）来遍历，而不是转换成数组。

#### MatchDecorator (匹配装饰器)

- **定义**：这是一个辅助工具类，用于“基于正则表达式自动维护装饰”。
- **场景**：你想高亮所有的 `#hashtag` 或者 `TODO` 标记。
- **工作原理**：它会自动监听文档变化，只重新扫描受影响的行，并更新 `Decoration`。
- **最佳实践**：
  - 配合 `ViewPlugin` 使用。这是实现简单高亮的最快路径，不需要写完整的 Parser。

```javascript
import { MatchDecorator, ViewPlugin, Decoration } from '@codemirror/view'

// 1. 定义装饰样式
const hashtagMark = Decoration.mark({ class: 'cm-hashtag' })

// 2. 创建匹配器
const hashtagMatcher = new MatchDecorator({
  regexp: /#\w+/g,
  decoration: match => hashtagMark
})

// 3. 封装进 ViewPlugin
const hashtagPlugin = ViewPlugin.fromClass(
  class {
    constructor(view) {
      this.decorations = hashtagMatcher.createDeco(view)
    }
    update(update) {
      // 自动增量更新，性能极高
      this.decorations = hashtagMatcher.updateDeco(update, this.decorations)
    }
  },
  {
    decorations: v => v.decorations // 告诉编辑器这里有装饰要渲染
  }
)
```

### 2. EditorView 上的静态 API (Static APIs)

`EditorView` 不仅仅是实例，它的类上挂载了很多用于**配置**和**扩展定义**的方法。

#### `EditorView.theme(spec, options)`

- **用途**：定义编辑器的主题（CSS 样式）。
- **核心概念**：CodeMirror 的样式是 JS-in-CSS 的变体。它会生成唯一的类名，实现样式隔离。
- **特殊选择器**：`&` 代表编辑器根元素。
- **最佳实践**：
  - 区分 `Base Theme` (库作者用) 和 `Theme` (最终用户用)。
  - 使用 `&.cm-focused` 来定义聚焦时的样式。

#### `EditorView.domEventHandlers(handlers)`

- **用途**：这是监听 DOM 事件的**正确方式**。
- **为什么不用 addEventListener**：直接在 DOM 上监听可能会干扰 CodeMirror 内部的事件处理（如输入法合成、拖拽）。这个 API 允许你以“插件”的方式注册事件。
- **最佳实践**：
  - 返回 `true` 表示“我处理了这个事件，CodeMirror 你别管了”（阻止默认行为）。
  - 返回 `false` 表示“我只是看看，继续传递”。

```javascript
import { EditorView } from '@codemirror/view'

const clickHandler = EditorView.domEventHandlers({
  mousedown(event, view) {
    if (event.altKey) {
      console.log('Alt + Click detected!')
      return true // 阻止编辑器处理这个点击（例如阻止光标移动）
    }
  }
})
```

#### `EditorView.updateListener`

- **用途**：全局的“观察者”。
- **最佳实践**：用于向外部框架（React/Vue）同步数据。

### 3. 深入 Change：如何消费变更 (ChangeSet)

当 `update.docChanged` 为 true 时，`update.changes` 是一个 `ChangeSet` 对象。理解它对于协同编辑、撤销重做、或者位置映射至关重要。

#### 消费变更 (iterChanges)

`ChangeSet` 内部是压缩存储的。你不能直接看“改了什么”，必须迭代它。

```javascript
// 假设用户把 "Hello" 变成了 "He123llo"
// update.changes 包含了这个变化

update.changes.iterChanges((fromA, toA, fromB, toB, inserted) => {
  // fromA, toA: 变化发生前，在旧文档中的范围 (2, 2)
  // fromB, toB: 变化发生后，在新文档中的范围 (2, 5)
  // inserted: 插入的文本对象 ("123")

  console.log(`在旧位置 ${fromA} 删除了 ${toA - fromA} 个字符`)
  console.log(`在新位置 ${fromB} 插入了: ${inserted.toString()}`)
})
```

#### 位置映射 (MapPos) - **这是最重要的概念之一**

**场景**：你有一个插件记录了第 100 个字符处有一个“错误提示”。用户在第 0 个字符处插入了 5 个字。你的错误提示现在应该在第 105 个字符处。
**API**：`ChangeSet.mapPos(pos)`

```javascript
let myErrorPos = 100

// 当发生 transaction 时
const changes = update.changes
// 自动计算新位置
myErrorPos = changes.mapPos(myErrorPos)
// 如果该位置被删除了，mapPos 默认会吸附到删除点的左侧或右侧（可配置 assoc 参数）
```

### 4. 其他关键抽象概念

#### Prec (Precedence / 优先级)

- **问题**：你定义了 `Enter` 键的快捷键，但没生效，因为默认的换行行为抢先了。
- **解决**：CodeMirror 的扩展是按顺序执行的，但你可以用 `Prec` 强制插队。
- **级别**：
  - `Prec.highest`: 最高优先级（慎用）。
  - `Prec.high`: 高于默认。
  - `Prec.default`: 默认。
  - `Prec.low`: 低于默认。

```javascript
import { keymap } from '@codemirror/view'
import { Prec } from '@codemirror/state'

// 强制覆盖默认行为
const myKeymap = Prec.high(
  keymap.of([
    {
      key: 'Enter',
      run: () => {
        console.log('My Enter!')
        return true
      }
    }
  ])
)
```

#### Selection (EditorSelection)

- **定义**：CodeMirror 6 原生支持**多光标**。
- **结构**：
  - `ranges`: 所有的光标范围数组。
  - `main`: “主”光标（通常是最后一个添加的，或者用户主要关注的那个）。
- **最佳实践**：
  - 编写命令时，总是假设可能由多个光标。使用 `state.changeByRange` 辅助函数来处理多光标逻辑，它会自动帮你合并重叠的变更。

```javascript
// 将选中的文本转换为大写的命令（支持多光标）
const upperCaseCommand = view => {
  const transaction = view.state.changeByRange(range => {
    // 针对每一个光标范围 range 执行逻辑
    const text = view.state.sliceDoc(range.from, range.to)
    const upper = text.toUpperCase()
    return {
      changes: { from: range.from, to: range.to, insert: upper },
      range: EditorSelection.range(range.from, range.from + upper.length) // 新的光标位置
    }
  })
  view.dispatch(transaction)
  return true
}
```

### 总结图谱

1.  **数据结构层**：`RangeSet` (存储), `ChangeSet` (变更), `EditorSelection` (光标)。
2.  **逻辑层**：`StateField` (状态), `Facet` (配置聚合), `Prec` (优先级)。
3.  **表现层**：`Decoration` (装饰), `ViewPlugin` (DOM 交互), `MatchDecorator` (正则高亮)。

掌握 `mapPos` 和 `iterChanges` 是从“使用者”进阶到“开发者”的分水岭。

---

既然要“深挖”，我们就不能只停留在 API 的表面调用上，而要进入 CodeMirror 6 的**架构核心**和**高级定制**领域。

以下是 4 个更深层次的概念，通常只有在开发复杂 IDE 功能（如代码补全、协同编辑、自定义语言支持）时才会接触到。

---

### 1. 语法树与 Lezer 集成 (The Syntax Tree)

CodeMirror 6 抛弃了基于正则的简单高亮，引入了 **Lezer** 解析器。这意味着编辑器时刻维护着一份当前代码的 **CST (Concrete Syntax Tree，具体语法树)**。

#### 核心概念：`syntaxTree(state)`

你不再需要自己写正则去匹配“函数名”或“变量”，你可以直接问语法树。

**最佳实践：**

- **不要遍历整个树**：树可能很大。使用 `Cursor`（游标）来遍历。
- **处理不完整树**：解析是增量的、异步的。在视口（Viewport）内的树通常是准备好的，但文件末尾的可能还没解析完。

**代码示例：找到光标所在的所有父级节点类型**

```javascript
import { syntaxTree } from '@codemirror/language'

function getContext(state) {
  const pos = state.selection.main.head
  // 获取语法树
  const tree = syntaxTree(state)
  // resolveInner 用于深入到最具体的节点
  let node = tree.resolveInner(pos, -1)

  const path = []
  while (node) {
    path.push(node.name) // 例如: "Identifier", "FunctionDeclaration", "Script"
    node = node.parent
  }
  return path
}
```

**深挖点**：利用这个特性，你可以实现“智能”的快捷键。例如：只有在 `Comment` 节点内按回车，才自动插入注释符号。

---

### 2. WidgetType 与 DOM 协调 (Reconciliation)

当你需要在文档流中插入复杂的 DOM（比如：颜色选择器色块、折叠后的 `...` 按钮、或者嵌入的表格）时，你需要使用 `WidgetDecoration`。

**难点**：CodeMirror 如何知道你的 DOM 元素是否需要更新？如果每次都销毁重建，输入会非常卡顿。

**核心类：`WidgetType`**
你必须继承这个类，并实现两个关键方法：`toDOM` 和 `eq`。

**最佳实践：**

- **`eq(other)` 是性能的关键**：CodeMirror 会比较新旧 Widget。如果 `eq` 返回 `true`，它会直接复用旧的 DOM，完全跳过渲染。
- **`updateDOM` (可选)**：如果你想复用 DOM 但只修改其中一部分（比如改个背景色），实现这个方法。

```javascript
import { WidgetType, Decoration } from '@codemirror/view'

class ColorWidget extends WidgetType {
  constructor(color) {
    super()
    this.color = color
  }

  // 1. 比较：决定是否复用 DOM
  eq(other) {
    return other.color === this.color
  }

  // 2. 创建：初次渲染
  toDOM() {
    let span = document.createElement('span')
    span.style.backgroundColor = this.color
    span.className = 'color-box'
    return span
  }

  // 3. 忽略事件：通常设为 true，防止编辑器把光标放进你的 Widget 里
  ignoreEvent() {
    return true
  }
}

// 使用
const deco = Decoration.widget({
  widget: new ColorWidget('red'),
  side: 1
})
```

---

### 3. Transaction Annotations & Effects (元数据与副作用)

`Transaction` 不仅仅包含文档变化（Changes），它还是一个**消息总线**。

#### Annotations (注解)

**场景**：你需要区分这个变化是“用户输入的”还是“协同编辑插件从网络同步过来的”？或者是“撤销操作产生的”？
**定义**：`Annotation` 是附加在 Transaction 上的元数据，不会改变 State，但能被 ViewPlugin 读取。

```javascript
import { Annotation } from '@codemirror/state'

// 定义一个注解类型
const RemoteChange = Annotation.define()

// 发送 Transaction 时带上注解
view.dispatch({
  changes: { from: 0, insert: 'Hi' },
  annotations: RemoteChange.of('user-123') // 标记来源
})

// 在 ViewPlugin 或 UpdateListener 中消费
if (tr.annotation(RemoteChange)) {
  console.log('这是远程变化，不要触发自动补全！')
}
```

#### Effects (副作用)

**场景**：你想通过 Transaction 触发一些非文档的变更，比如“折叠第 10 行”或“展开所有区域”。
**定义**：`StateEffect` 用于更新 `StateField`。它是 State 变更的最小单元。

**深挖点**：CodeMirror 的折叠（Folding）功能就是完全基于 `StateEffect` 实现的，而不是直接操作 DOM。

---

### 4. Atomic Ranges (原子范围)

**场景**：你在编辑器里插入了一个 `@User` 标签。你希望用户按退格键时，整个标签被一次性删除，而不是删掉最后一个字母。你也不希望光标能停在 `@` 和 `U` 之间。

**解决方案：`EditorView.atomicRanges`**

这是一个 Facet，允许你定义文档中的某些范围是“原子的”（Atomic）。

**最佳实践：**

- 通常配合 `Decoration.replace` 使用。
- 当光标试图进入原子范围时，CodeMirror 会自动把它弹射到范围的边缘。

```javascript
import { EditorView } from '@codemirror/view'
import { RangeSetBuilder } from '@codemirror/state'

const atomicPlugin = EditorView.atomicRanges.of(view => {
  // 假设我们想让文档中所有的 "[LOCKED]" 字符串不可进入
  let ranges = new RangeSetBuilder()
  // ... 遍历文档找到位置 ...
  // ranges.add(from, to);
  return ranges.finish()
})
```

---

### 5. 终极深挖：自定义 Facet 的组合逻辑

这是架构师级别的视角。当你定义一个 `Facet` 时，你需要决定**多个插件提供的值如何合并**。

`Facet.define({ combine: ... })`

- **默认行为**：返回数组 `[value1, value2]`。
- **逻辑与/或**：比如 `EditorView.editable`，只要有一个插件说 `false`，编辑器就不可编辑。它的 combine 逻辑就是 `values => values.every(x => x)`。
- **优先级覆盖**：比如快捷键 `keymap`，它的 combine 逻辑是按优先级顺序展平数组。

**理解这一点，你就能明白为什么有时候你的配置不生效——可能是被其他高优先级的 Facet 覆盖了，或者合并逻辑不是你想象的那样。**

### 总结：CodeMirror 6 的心智模型

如果你想精通 CodeMirror 6，请把编辑器想象成一个 **React + Redux** 的应用：

1.  **State** 是 Redux Store（不可变数据）。
2.  **View** 是 React Component（负责渲染）。
3.  **Transaction** 是 Action（描述变化）。
4.  **StateField** 是 Reducer（处理逻辑）。
5.  **Facet** 是 Context（依赖注入）。
6.  **WidgetType** 是 React.memo（性能优化）。

---

在 React 中封装 CodeMirror 6 是一个经典的挑战，因为你需要协调 **React 的声明式生命周期** 与 **CodeMirror 的命令式生命周期**。

如果不遵循最佳实践，很容易遇到：光标跳动、死循环更新、性能低下、内存泄漏等问题。

以下是构建 `useCodeMirror` 和组件的**工业级最佳实践**。

### 核心架构图

1.  **初始化**：`useEffect` + `useRef` 挂载 DOM。
2.  **数据流出 (CM -> React)**：通过 `EditorView.updateListener` 捕获变化 -> 调用 `onChange`。
3.  **数据流入 (React -> CM)**：`useEffect` 监听 `props.value` -> **比对差异** -> `view.dispatch`。
4.  **配置更新**：使用 `Compartment` (隔间) 或 `StateEffect.reconfigure` 动态更新扩展，而不是销毁重建。

---

### 1. 实现 `useCodeMirror` Hook

这是核心逻辑。

```typescript
import { useEffect, useState, useRef } from 'react'
import { EditorState, Extension } from '@codemirror/state'
import { EditorView, ViewUpdate } from '@codemirror/view'
import { basicSetup } from 'codemirror' // 或 @codemirror/basic-setup

interface UseCodeMirrorProps {
  container: HTMLDivElement | null
  value: string
  onChange?: (value: string, viewUpdate: ViewUpdate) => void
  extensions?: Extension[]
  autoFocus?: boolean
  theme?: Extension // 单独传入主题以便动态切换
}

export function useCodeMirror(props: UseCodeMirrorProps) {
  const { container, value, onChange, extensions = [], autoFocus, theme } = props

  // 存储 view 实例，但不触发重渲染
  const viewRef = useRef<EditorView | null>(null)
  // 存储当前的扩展配置，用于后续对比或重配置
  const [view, setView] = useState<EditorView | null>(null)

  // 1. 初始化编辑器
  useEffect(() => {
    if (!container) return

    // 初始状态
    const startState = EditorState.create({
      doc: value,
      extensions: [
        basicSetup,
        // 关键：绑定 Update Listener
        EditorView.updateListener.of(update => {
          if (update.docChanged && onChange) {
            // 只有文档真正变了才通知 React
            const docString = update.state.doc.toString()
            onChange(docString, update)
          }
        }),
        ...extensions,
        theme ? theme : []
      ]
    })

    const view = new EditorView({
      state: startState,
      parent: container
    })

    viewRef.current = view
    setView(view)

    if (autoFocus) {
      view.focus()
    }

    // 销毁清理
    return () => {
      view.destroy()
      viewRef.current = null
    }
    // 注意：依赖项尽量少，避免重复销毁重建
    // 这里我们只在 container 变化时初始化一次
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [container])

  // 2. 处理外部 Value 变化 (React -> CM)
  useEffect(() => {
    const view = viewRef.current
    if (!view) return

    const currentValue = view.state.doc.toString()

    // 核心最佳实践：Loop Breaker (循环阻断)
    // 只有当传入的 value 和编辑器当前内容不一致时，才 dispatch
    // 这防止了：输入 'a' -> onChange -> setState('a') -> prop update 'a' -> dispatch -> 光标重置
    if (value !== currentValue) {
      view.dispatch({
        changes: { from: 0, to: currentValue.length, insert: value || '' }
      })
    }
  }, [value])

  // 3. 处理动态扩展更新 (高级最佳实践)
  // 如果 extensions 经常变，建议使用 Compartment，这里演示简单的 reconfigure
  useEffect(() => {
    const view = viewRef.current
    if (!view) return

    // 注意：这里是一个简化的重配置。
    // 生产环境中，你应该使用 Compartment 来隔离 Theme、Language 等
    // 避免每次 props 变了都全量重置扩展
    /* 
       view.dispatch({
         effects: StateEffect.reconfigure.of([...extensions, theme])
       })
    */
  }, [extensions, theme])

  return { view }
}
```

---

### 2. 实现 React 组件

组件层主要负责提供 DOM 容器。

```tsx
import React, { useRef, useEffect } from 'react'
import { useCodeMirror } from './useCodeMirror'
import { javascript } from '@codemirror/lang-javascript'

export const CodeEditor = ({ value, onChange }) => {
  const ref = useRef<HTMLDivElement>(null)

  const { view } = useCodeMirror({
    container: ref.current,
    value,
    onChange,
    extensions: [javascript()], // 传入语言包
    theme: undefined // 传入主题
  })

  return <div ref={ref} style={{ height: '100%', width: '100%', textAlign: 'left' }} />
}
```

---

### 3. 关键最佳实践解析 (必读)

#### A. 解决“光标跳动”与“死循环”

这是新手最容易踩的坑。

- **现象**：你在打字，每次打一个字，光标就跳回文档开头，或者 React 报错 "Too many re-renders"。
- **原因**：React 更新 `value` prop -> `useEffect` 触发 -> `view.dispatch` 替换全文 -> CodeMirror 认为这是全新的内容 -> 光标重置。
- **解法**：在 `useEffect` 中必须加判断 `if (value !== currentValue)`。只有当外部传入的值真的和编辑器内部不一样（比如重置表单、加载新文件）时，才写入。

#### B. 动态配置 (Compartment)

如果你需要动态切换主题（Light/Dark）或语言（JS/Python），不要销毁重建 View，也不要暴力 `reconfigure` 所有扩展。
**最佳实践是使用 `Compartment`**。

```typescript
import { Compartment } from '@codemirror/state'

// 1. 创建隔间
const languageConf = new Compartment()
const themeConf = new Compartment()

// 2. 初始化时放入隔间
const state = EditorState.create({
  extensions: [
    languageConf.of(javascript()), // 初始语言
    themeConf.of(oneDark) // 初始主题
  ]
})

// 3. 动态更新时 (在 useEffect 中)
view.dispatch({
  effects: [
    languageConf.reconfigure(python()), // 只替换语言部分
    themeConf.reconfigure(myLightTheme) // 只替换主题部分
  ]
})
```

这样做的好处是：**编辑器的撤销历史(Undo History)、滚动位置、折叠状态都会被保留**。

#### C. 扩展引用的稳定性

在 React 组件中：

```javascript
// ❌ 错误：每次渲染都生成新数组
<CodeEditor extensions={[javascript()]} />
```

这会导致 `useCodeMirror` 里的 `useEffect` 依赖项变化，可能导致不必要的重配置。
**建议**：使用 `useMemo` 缓存扩展数组，或者将静态扩展定义在组件外部。

#### D. CSS 布局

CodeMirror 默认高度是 `auto`（随内容增长）。如果你希望它撑满父容器并滚动：

1.  给父容器定高。
2.  设置 CodeMirror 样式：

```css
.cm-editor {
  height: 100%;
}
.cm-scroller {
  overflow: auto;
}
```

### 总结

做一个好的 `react-codemirror` 封装，核心在于：

1.  **Ref 管理**：确保 DOM 挂载后再初始化。
2.  **Diff 检查**：写入 Value 前先检查是否相等，保护光标。
3.  **Compartment**：用隔间技术做动态配置，保留编辑器状态。
4.  **销毁**：组件卸载时必须 `view.destroy()`，否则会有内存泄漏（全局事件监听器未移除）。

---

CodeMirror (特别是 v6) 虽然强大，但因为设计理念太超前（纯函数式、不可变数据），导致有很多“反直觉”的坑。

以下是开发者社区里最常遇到的“月经问题”（Recurring Issues）和经典坑：

### 1. 样式坑：编辑器高度为 0 或无限增长

**现象：**

- 编辑器渲染出来了，但高度只有一行，或者根本看不见。
- 或者编辑器随着内容增加无限变长，导致页面滚动条和编辑器滚动条双重出现。

**原因：**
CodeMirror 默认行为是 `height: auto`（随内容撑开）。它不像 `textarea` 那样有个默认行高。

**最佳实践：**
必须显式设置 CSS。

```css
/* 方案 A: 固定高度，内部滚动 */
.cm-editor {
  height: 500px; /* 或者 100% 继承父容器 */
}
.cm-scroller {
  overflow: auto;
}

/* 方案 B: 最小/最大高度 */
.cm-editor {
  min-height: 200px;
  max-height: 800px;
}
```

### 2. 交互坑：Tab 键无法缩进 (Focus Trap)

**现象：**
按下 `Tab` 键，光标没有缩进，而是直接跳出了编辑器，聚焦到了页面上下一个按钮上。

**原因：**
这是为了符合 **WAI-ARIA 无障碍标准**。网页上的标准行为是 `Tab` 切换焦点。CodeMirror 默认保留了这个行为。

**最佳实践：**
如果你写的是代码编辑器，必须手动绑定 Tab 键行为。

```javascript
import { keymap } from '@codemirror/view'
import { indentWithTab } from '@codemirror/commands'

const extensions = [
  keymap.of([indentWithTab]) // 加上这个
  // ...其他扩展
]
```

### 3. 环境坑：SSR (Next.js/Nuxt) 报错 `document is not defined`

**现象：**
在 Next.js 或 Nuxt 中引入 CodeMirror，页面刷新直接白屏报错。

**原因：**
CodeMirror 的核心包在 import 时会立即尝试访问 `document` 或 `navigator` 来检测环境（比如检测是不是 Mac 以决定用 Cmd 还是 Ctrl）。服务端没有这些对象。

**最佳实践：**

1.  **动态引入 (Dynamic Import)**：确保只在客户端加载。
2.  **检查环境**：

```javascript
// React/Next.js 示例
import dynamic from 'next/dynamic'

const CodeEditor = dynamic(
  () => import('./MyEditorComponent'),
  { ssr: false } // 禁用 SSR
)
```

### 4. 数据坑：换行符的“灵异事件” (`\r\n` vs `\n`)

**现象：**
后端传来的字符串长度是 100，放入 CodeMirror 后，获取出来的长度变成了 98。或者正则匹配位置总是差几个字符。

**原因：**
CodeMirror v6 会强制将所有的换行符规范化为 `\n` (LF)。
如果你的原始数据包含 Windows 风格的 `\r\n` (CRLF)，CodeMirror 会把它们变成 `\n`。

- `\r\n` 是 2 个字符。
- `\n` 是 1 个字符。
  每有一行，你的坐标就会偏移 1。

**最佳实践：**

- **入：** 接受 CodeMirror 的规范化，不要依赖原始字符串的长度索引。
- **出：** 如果后端严格要求 `\r\n`，在 `view.state.doc.toString()` 之后，手动 replace 回去。

### 5. React 坑：Strict Mode 下的双重初始化

**现象：**
开发环境下，页面上出现了两个编辑器，或者插件逻辑执行了两次。

**原因：**
React 18 的 Strict Mode 会强制执行 `mount -> unmount -> mount` 流程来检查副作用清理。如果你的 `useEffect` 清理函数没写好，第一个编辑器没销毁，第二个又创建了。

**最佳实践：**
确保 `destroy` 被调用。

```javascript
useEffect(() => {
    const view = new EditorView({ ... });

    return () => {
        view.destroy(); // 必须写！
    };
}, []);
```

### 6. 样式坑：Tooltip/Autocomplete 被遮挡 (z-index)

**现象：**
编辑器放在一个 Modal (弹窗) 里，自动补全的列表弹出来时，被 Modal 的边缘切断了，或者显示在 Modal 下面。

**原因：**
CodeMirror 默认将 Tooltip 渲染在编辑器 DOM 内部。如果编辑器容器有 `overflow: hidden` 或者 Modal 有复杂的 `z-index` 上下文，就会出问题。

**最佳实践：**
配置 Tooltip 挂载到 `body` 上，脱离当前 DOM 结构。

```javascript
import { tooltips } from '@codemirror/view'

const extensions = [
  tooltips({
    position: 'absolute',
    parent: document.body // 挂载到 body
  })
]
```

### 7. 性能坑：超长单行文件 (Minified Code)

**现象：**
打开一个只有一行但有 1MB 大小的 `min.js` 或 JSON 文件，编辑器直接卡死。

**原因：**
CodeMirror 有“视口虚拟化”（只渲染看得见的行），但这依赖于行数。如果只有一行，它必须渲染这一整行的所有 DOM。

**最佳实践：**
目前 CodeMirror 对超长单行支持有限。

- **方案：** 检测到超长行时，自动格式化（Prettify）后再显示。
- **配置：** 限制单行最大长度（虽然这只是截断显示）。

### 8. 概念坑：ReadOnly vs Editable

**现象：**
设置了 `readOnly`，但插件依然能修改内容，或者光标依然能闪烁。

**区别：**

- `EditorState.readOnly.of(true)`: **状态层面的只读**。用户无法通过键盘输入修改，但你的代码可以通过 `dispatch` 修改。
- `EditorView.editable.of(false)`: **DOM 层面的只读**。将 `contenteditable` 设为 false。键盘弹不起，光标可能消失（取决于浏览器）。

**最佳实践：**
通常你需要的是组合拳：

```javascript
extensions: [
  EditorState.readOnly.of(true), // 禁止修改内容
  EditorView.editable.of(false) // 禁用 DOM 编辑属性（可选，视需求而定）
]
```

你提到的“多次重复更新”确实是 CodeMirror 集成中最令人头秃的问题之一，通常被称为 **“乒乓效应” (Ping-Pong Effect)** 或 **“更新死循环”**。

除了这个问题，还有几个非常隐蔽但一旦遇到就很难排查的“深坑”。

### 1. 核心痛点：更新死循环 (The Update Loop / Ping-Pong)

这是你印象中最深刻的问题，通常发生在 React/Vue 双向绑定时。

**现象：**

- 控制台报错：`Error: Calls to EditorView.update are not allowed while an update is in progress`。
- 或者：输入一个字符，光标突然跳到最后或最前。
- 或者：CPU 飙升，React DevTools 显示组件疯狂 re-render。

**场景 A：React 的 `useEffect` 依赖没写好**

```javascript
// ❌ 错误示范
useEffect(() => {
  // 每次组件渲染，都创建一个新的 EditorState
  // 导致编辑器内容重置，光标丢失
  const state = EditorState.create({ doc: props.value })
  view.setState(state)
}, [props.value]) // 只要 value 变了就重置
```

**场景 B：同步更新的“乒乓球”**

1.  用户在 CM 输入 'A' -> 触发 CM `updateListener`。
2.  `updateListener` 调用 React `onChange('A')`。
3.  React 更新 State -> 触发组件重渲染。
4.  组件接收新 Props `value='A'`。
5.  `useEffect` 监听到 `value` 变了 -> 调用 `view.dispatch({ insert: 'A' })`。
6.  **死循环开始**：CM 收到 dispatch -> 再次触发 `updateListener`...

**✅ 最佳实践（必背口诀）：**
在将 Props 同步回 CodeMirror 之前，**必须** 检查内容是否已经一致。

```javascript
useEffect(() => {
  const currentDoc = view.state.doc.toString()
  // 🛑 守门员：只有当外部传入的值，真的和编辑器里的不一样时，才动手
  if (props.value !== currentDoc) {
    view.dispatch({
      changes: { from: 0, to: currentDoc.length, insert: props.value }
    })
  }
}, [props.value])
```

---

### 2. 中文输入法 (IME) 坑：Composition Events

对于中文开发者，这是仅次于死循环的第二大坑。

**现象：**

- 正在打拼音（比如输入 "zhong" 还没选字），结果触发了自动补全，或者触发了搜索过滤。
- 或者在 React 中，拼音还没选完，输入框就被重置了。

**原因：**
CodeMirror 的 `updateListener` 非常诚实。当你打 "zhong" 的时候，文档内容确实变了（变成了带有下划线的预览字符）。

**✅ 最佳实践：**
在处理 `onChange` 或关键逻辑时，检查 `view.composing` 状态。

```javascript
EditorView.updateListener.of(update => {
  // 🛑 如果用户正在用输入法打字（拼音选词中），不要触发业务逻辑
  if (update.view.composing) {
    return
  }

  if (update.docChanged) {
    // 安全的更新
    props.onChange(update.state.doc.toString())
  }
})
```

---

### 3. 字体加载坑：测量错误 (Layout Thrashing)

**现象：**
编辑器初始化时，光标位置错位（比如光标在字符中间），或者行号和代码对不齐。点击某一行，光标却出现在下一行。

**原因：**
CodeMirror 极其依赖**精确的字符测量**。
如果编辑器初始化时，你的自定义字体（比如 'Fira Code'）还没加载完成，浏览器会先用默认字体渲染。CodeMirror 测量了默认字体的宽度。
几毫秒后，字体加载完成，文字变宽或变窄了，但 CodeMirror 缓存的坐标系统没有更新。

**✅ 最佳实践：**

1.  确保字体加载完成后再初始化编辑器（使用 `document.fonts.ready`）。
2.  或者，强制触发一次测量：

```javascript
// 当你确信布局发生巨大变化但 CM 没反应时
view.requestMeasure()
```

---

### 4. 浏览器原生行为冲突：Ctrl+F 与 Cmd+S

**现象：**

- 用户按 `Ctrl+F` 想用浏览器的搜索，结果弹出了 CodeMirror 的搜索框（或者反之，想用编辑器的搜索却唤起了浏览器的）。
- 用户按 `Ctrl+S` 保存，结果弹出了浏览器的“保存网页”对话框。

**原因：**
CodeMirror 的 `keymap` 优先级。

**✅ 最佳实践：**

- **搜索**：如果你引入了 `searchKeymap`，它会默认覆盖 `Mod-f`。如果你想保留浏览器搜索，需要修改 keymap 配置。
- **保存**：必须显式阻止默认行为。

```javascript
import { keymap } from '@codemirror/view'

const saveKeymap = keymap.of([
  {
    key: 'Mod-s',
    run: () => {
      saveData()
      return true // 🛑 返回 true 表示“我消费了这个事件”，阻止浏览器默认行为
    }
  }
])
```

---

### 5. 隐藏字符坑：Zero-width space & BOM

**现象：**
代码看起来完全正常，但语法高亮乱了，或者解析器报错。复制出来放到记事本里也看不出问题。

**原因：**
用户可能从某些网站复制了代码，带入了 **零宽空格 (Zero-width space)** 或 **BOM 头**。CodeMirror 默认会如实渲染这些不可见字符。

**✅ 最佳实践：**
使用 `highlightSpecialChars()` 扩展。它会把这些不可见字符渲染成一个红色的点或特殊的占位符，让用户知道这里有脏东西。

```javascript
import { highlightSpecialChars } from '@codemirror/view'
// 默认的 basicSetup 里通常包含了这个，但如果你是手动组装扩展，千万别漏了
```

### 6. 销毁坑：内存泄漏 (Memory Leak)

**现象：**
SPA 应用（单页应用）切换路由几次后，页面越来越卡。

**原因：**
`EditorView` 会在 `window` 和 `document` 上绑定很多全局事件（resize, mouseup 等）。如果组件卸载时没有调用 `view.destroy()`，这些监听器永远不会移除，View 实例也永远不会被垃圾回收。

**✅ 最佳实践：**
永远在组件卸载钩子中销毁。

```javascript
// React
useEffect(() => {
  return () => {
    if (viewRef.current) {
      viewRef.current.destroy() // 🗑️ 必须手动销毁
    }
  }
}, [])
```

### 总结：CodeMirror 避坑指南

1.  **防抖动**：React 更新前必做 `value !== doc` 检查。
2.  **防拼音**：关键逻辑检查 `view.composing`。
3.  **防错位**：字体加载完再渲染，或手动 `requestMeasure`。
4.  **防泄漏**：组件卸载必调 `destroy()`。

---

这个错误 `Error: Calls to EditorView.update are not allowed while an update is in progress` 的本质含义是：**重入（Re-entrancy）**。

简单来说：**CodeMirror 正在忙着处理上一个变更（计算状态、更新 DOM、通知插件），还没喘过气来，你又塞给它一个新的变更（dispatch）。**

CodeMirror 的更新是**同步且原子**的，它不允许在“更新周期”内部再次触发“更新”。

以下是导致这个报错的 5 个最经典场景，按发生频率排序：

### 1. 在 `updateListener` 中直接 `dispatch` (最常见)

这是新手最容易犯的错。你想监听文档变化，如果发现内容不对，立马修正。

**错误场景：**

```javascript
EditorView.updateListener.of((update) => {
    if (update.docChanged) {
        const text = update.state.doc.toString();
        if (text.includes("bad")) {
            // ❌ 炸了！updateListener 执行时，当前的 update 还没结束
            view.dispatch({ changes: { ... } });
        }
    }
})
```

**✅ 修复方案：**
必须把新的 dispatch 放到下一个事件循环（Macro-task）中。

```javascript
EditorView.updateListener.of((update) => {
    if (update.docChanged && text.includes("bad")) {
        // ✅ 放到 setTimeout 里，等当前更新周期完全结束后再执行
        setTimeout(() => {
            view.dispatch({ changes: { ... } });
        }, 0);
    }
})
```

### 2. 在 `ViewPlugin` 的 `update` 方法中 `dispatch`

`ViewPlugin` 的 `update(update)` 方法是用来更新插件自己的 DOM 或内部状态的，不是用来更新编辑器状态的。

**错误场景：**

```javascript
ViewPlugin.fromClass(class {
    update(update) {
        if (update.viewportChanged) {
            // ❌ 炸了！视图正在更新渲染中，不能插入新的事务
            this.view.dispatch({ ... });
        }
    }
})
```

**✅ 修复方案：**
同上，使用 `setTimeout`，或者重新思考架构。通常你不需要在 View 更新时反向修改 State。如果你是想根据状态变化自动修改文档，应该使用 **`EditorState.transactionFilter`** 或 **`EditorState.transactionExtender`**（在事务发生**前**拦截并修改它，而不是发生**后**再补一刀）。

### 3. React/Vue 的同步更新回流 (Sync Loop)

如果你的框架更新逻辑太快（同步），会在同一个 Call Stack 里把数据推回来。

**错误场景：**

1.  用户输入 'A'。
2.  CM 触发 `updateListener`。
3.  你调用 `props.onChange('A')`。
4.  **关键点**：父组件是一个同步更新的组件（没有异步批处理），它立即计算出新 Props，并触发子组件重渲染。
5.  子组件的 `useEffect` (或 Vue 的 `watch`) 立即执行。
6.  `useEffect` 里调用 `view.dispatch`。
7.  此时，第 2 步的 `updateListener` 其实还没完全跑完（或者处于同一个微任务队列尾部）。

**✅ 修复方案：**
在 `useEffect` 里加锁，或者确保 `onChange` 是异步的。但最稳妥的还是我在上一个回答里提到的：**比对内容**。

```javascript
// 如果内容没变，根本不要 dispatch，直接切断循环
if (view.state.doc.toString() !== newValue) {
    view.dispatch(...)
}
```

### 4. 在 DOM 事件处理器中同步 Dispatch (极少数情况)

通常 DOM 事件（如 `click`, `keydown`）是安全的，因为它们本身就是新的宏任务。但在某些特殊情况下会出问题。

**错误场景：**
你使用 `EditorView.domEventHandlers` 拦截了某个事件，但在处理过程中，你触发了另一个会引起编辑器更新的副作用，而这个副作用又同步回调了编辑器。

**✅ 修复方案：**
在事件处理函数中，尽量一次性把所有 `changes` 打包进一个 `dispatch`，不要分多次调用。

### 5. 多个插件互相打架 (连锁反应)

**错误场景：**

- 插件 A 监听更新 -> `setTimeout` -> `dispatch`。
- 插件 B 监听更新 -> 发现插件 A 改了东西 -> `dispatch`。
- 插件 A 监听到插件 B 改了东西 -> `dispatch`。

虽然这通常会导致“死循环”而不是“Update in progress”错误（因为 `setTimeout` 隔开了），但如果其中有一个插件没有用 `setTimeout` 而是直接调用，就会报这个错。

### 总结：如何彻底根治？

当你看到这个错误，脑子里要有两个解决方案：

1.  **“我要改时机” (The Hacky Fix)**:
    只要把 `view.dispatch` 包在 `setTimeout(() => { ... }, 0)` 里，99% 的这个报错都会消失。这是因为 `setTimeout` 强行把操作推到了当前更新周期结束之后。

2.  **“我要改架构” (The Proper Fix)**:
    问自己：_“为什么我要在‘更新发生后’立刻触发‘另一个更新’？”_

    - 如果是为了**修正用户输入**（例如强制大写）：请使用 `EditorState.transactionFilter`。它允许你在变更**应用到 State 之前**就修改它，这样就只需要一次更新，效率更高，且绝不会报错。

    ```javascript
    // ✅ 正确做法：在事务发生前拦截
    const upperCaseFilter = EditorState.transactionFilter.of(tr => {
      if (tr.docChanged) {
        // 检查变更，如果有小写，直接修改这个 transaction 的 changes
        // 返回修改后的 transaction，或者 null (不拦截)
      }
      return tr
    })
    ```

---

这个错误 `Error: Calls to EditorView.update are not allowed while an update is in progress` 是 CodeMirror 6 开发中一道典型的“分水岭”。

初学者遇到它会觉得是“Bug”，而资深开发者遇到它会意识到是**“数据流设计出了问题”**。

为了让你彻底理解，我们跳出代码片段，进入真实的**复杂业务场景**。以下是 3 个最容易触发此错误的真实案例，以及对应的架构级解决方案。

---

### 场景一：协同编辑中的“光标冲突” (Collaboration & Remote Cursors)

**业务背景：**
你正在开发一个类似 Google Docs 的多人协作编辑器。

1.  用户 A 正在打字。
2.  同时，WebSocket 收到了用户 B 的光标移动消息。
3.  你需要更新用户 B 在用户 A 屏幕上的光标位置（一个 Widget Decoration）。

**错误实现（触发报错）：**

```javascript
// WebSocket 监听器
socket.on('remoteCursorMove', data => {
  // 拿到数据直接更新
  // 💥 风险点：如果此时用户 A 刚好按下一个键，触发了 View 的更新周期
  // 而 WebSocket 的回调刚好在这个微任务间隙插进来了（虽然 JS 是单线程，但 React/Vue 的调度机制可能导致这种情况看似“并发”）
  // 或者更常见的是：你在一个 ViewPlugin 的 update 方法里去处理了协同状态的同步
  updateRemoteCursor(data)
})

function updateRemoteCursor(data) {
  // 这里调用了 dispatch 来更新 StateField 里的光标位置
  view.dispatch({ effects: updateCursorEffect.of(data) })
}
```

**深度解析：**
虽然 JS 是单线程的，但如果你的 `updateRemoteCursor` 逻辑被绑定在某个 React 组件的生命周期里，而这个组件又是因为 CodeMirror 的 `onUpdate` 触发重渲染的，那就撞车了。

**✅ 最佳实践：解耦数据源**
不要让 WebSocket 直接驱动 View。应该让 WebSocket 驱动 `State`，或者使用 `ViewPlugin` 的独立更新机制。

- **方案：** 使用 `ViewPlugin` 维护远程光标 DOM，而不是通过 `dispatch` 修改 State。
  - 远程光标通常不需要进入 Undo History，也不影响文档内容。
  - 直接操作 DOM（或者通过 Decoration）比走 Transaction 更轻量，且不会触发 State Update 锁。

---

### 场景二：即时格式化/掩码 (Input Masking / Auto-Formatting)

**业务背景：**
你有一个输入框，要求用户输入手机号 `13812345678`，但你想在视图上实时显示为 `138-1234-5678`。或者用户输入 JSON 时，你想实时 `Prettier` 格式化。

**错误实现（触发报错）：**

```javascript
EditorView.updateListener.of(update => {
  if (update.docChanged) {
    const text = update.state.doc.toString()
    const formatted = formatPhoneNumber(text) // 变成 "138-..."

    if (text !== formatted) {
      // 💥 炸了！
      // 你试图在“文档刚变完”的通知里，立刻“再变一次文档”
      view.dispatch({
        changes: { from: 0, to: text.length, insert: formatted }
      })
    }
  }
})
```

**深度解析：**
这是典型的“事后诸葛亮”模式。CodeMirror 刚费劲把用户输入的 `1` 渲染上去，你马上说“不对，重来，渲染 `1-`”。这不仅报错，还会导致光标位置极其诡异（因为你替换了全文）。

**✅ 最佳实践：Transaction Filter (事前拦截)**
不要等改完了再修，要在修改发生前就拦截并篡改。

```javascript
import { EditorState } from "@codemirror/state";

const phoneMask = EditorState.transactionFilter.of(tr => {
    if (!tr.docChanged) return tr;

    // 1. 拿到原本要发生的变更
    // 2. 计算应用这些变更后的新文档
    // 3. 如果新文档不符合格式，计算出“修正后”的变更
    // 4. 返回一个新的 Transaction 描述，替换掉原本的 tr

    // (简化伪代码)
    let newText = applyChanges(tr);
    if (needsFormat(newText)) {
        return [tr, { changes: ...extraFormatting... }];
        // 或者直接返回一个完全重构的 changes
    }
    return tr;
});
```

**核心思想：** 将两次 Update 合并为一次。用户按键 -> 拦截 -> 修改变更 -> 应用。

---

### 场景三：复杂的联动 UI (Linked Editing / Side Panels)

**业务背景：**
你有一个“低代码编辑器”。左边是 CodeMirror 代码区，右边是属性配置面板（Form 表单）。

- 修改代码 -> 更新表单。
- 修改表单 -> 更新代码。

**错误实现（触发报错）：**

1.  用户在 CM 改代码。
2.  CM `onUpdate` -> 通知 React Context。
3.  React Context 更新 -> 导致右侧表单重渲染。
4.  **关键点：** 右侧表单的 `useEffect` 里写了“如果表单值变了，同步回代码”。
5.  虽然你加了 `if (val !== code)` 判断，但由于 React 18 的并发渲染或某些复杂的 State 计算逻辑，导致在这个瞬间，React 认为数据不一致，触发了 `view.dispatch`。
6.  此时 CM 的 `onUpdate` 还没彻底结束（Call Stack 还没清空）。

**深度解析：**
这是“双向绑定”最容易出现的时序问题。React 的渲染周期和 CM 的更新周期在时间轴上重叠了。

**✅ 最佳实践：单向数据流 + 标记来源 (Annotations)**

不要只靠 `if (value !== code)`，要靠 **Annotation** 区分“谁引发的变更”。

1.  **定义注解：**

    ```javascript
    const FromForm = Annotation.define()
    ```

2.  **表单改代码时：**

    ```javascript
    view.dispatch({
        changes: ...,
        annotations: FromForm.of(true) // 👈 贴个条：这是表单改的
    });
    ```

3.  **代码改表单时 (在 updateListener 中)：**
    ```javascript
    EditorView.updateListener.of(update => {
      // 🛑 如果这次变更是表单自己触发的，就别再通知表单了！
      if (update.transactions.some(tr => tr.annotation(FromForm))) {
        return
      }
      // 只有纯用户手写的代码，才通知表单更新
      updateForm(update.state.doc.toString())
    })
    ```

**核心思想：** 打断回环。通过元数据（Annotation）明确变更的所有权，防止 A -> B -> A 的死循环，从而避免在 Update 期间触发 Dispatch。

### 总结：心法

当你再次遇到 `Calls to EditorView.update are not allowed...`：

1.  **如果是格式化/掩码需求**：用 `transactionFilter`（事前拦截），别用 `updateListener`。
2.  **如果是外部 UI 联动**：用 `Annotation` 标记来源，打断回环。
3.  **如果是实在没招的 Hack**：用 `setTimeout`，但这是下策。
