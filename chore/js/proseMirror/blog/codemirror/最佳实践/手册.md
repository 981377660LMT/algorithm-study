基于你提供的 `styleGuide.md`（CodeMirror 6 系统指南），我将结合实际业务场景，为你深入解析 CodeMirror 6 的核心架构、最佳实践以及如何解决常见问题。

CodeMirror 6 (CM6) 与之前的版本（CM5）有着本质的区别。CM6 采用了**模块化**、**函数式核心（Functional Core）**与**命令式外壳（Imperative Shell）**的设计。理解这一点是掌握最佳实践的关键。

---

### 一、 核心架构与心智模型

在开始写代码之前，必须建立正确的心智模型，这类似于从 jQuery 转向 React/Redux 的思维转变。

1.  **State (数据)**: `EditorState` 是不可变的（Immutable）。它包含文档内容、选区、配置（Facets）和状态字段（State Fields）。
2.  **View (视图)**: `EditorView` 是命令式的。它负责将 State 渲染到 DOM，并监听用户事件。
3.  **Transaction (事务)**: 改变 State 的唯一途径。类似于 Redux 的 Action + Reducer。你创建一个 Transaction，Dispatch 给 View，View 更新 State 并重绘。

---

### 二、 业务场景与最佳实践

#### 场景 1：实现自定义的业务逻辑状态（如：字数统计、特定语法检查）

**业务需求**：你需要实时统计文档中的“敏感词”数量，或者计算文档的复杂度分值，并在界面展示。

**❌ 错误做法**：
在 `ViewPlugin` 的 `update` 方法中直接遍历 `view.state.doc` 进行计算。

- _后果_：每次按键都会触发全量计算，大文档会导致卡顿。

**✅ 最佳实践：使用 `StateField`**
`StateField` 就像 Redux 的 reducer。它允许你定义一个状态，并根据 Transaction 增量更新它。

```typescript
import { StateField, EditorState } from '@codemirror/state'

// 定义一个 StateField 来追踪特定逻辑
const wordCountField = StateField.define({
  create() {
    return 0
  }, // 初始值
  update(value, tr) {
    // 最佳实践：先检查文档是否发生变化
    if (!tr.docChanged) return value

    // 简单示例：全量计算（生产环境建议利用 tr.changes 做增量计算）
    return tr.state.doc.length
  }
})

// 在业务中使用
let state = EditorState.create({
  extensions: [wordCountField]
})

// 获取当前值
console.log(state.field(wordCountField))
```

#### 场景 2：富文本展示与自定义 UI（如：颜色预览块、占位符替换）

**业务需求**：在代码编辑器中，当用户输入 `#ff0000` 时，在旁边显示一个小红块；或者将 `{{variable}}` 渲染为一个特殊的胶囊样式。

**❌ 错误做法**：
尝试直接操作 DOM 节点（`document.querySelector`）去修改编辑器内部的内容。

- _后果_：CodeMirror 的虚拟滚动（Viewport）机制会移除你的 DOM，或者你的修改会被下一次重绘覆盖。

**✅ 最佳实践：使用 `Decoration` (装饰器)**
装饰器是修改文档视觉表现的标准方式，不改变文档实际内容。

- **Mark Decoration**: 修改文本样式（颜色、字体）。
- **Widget Decoration**: 在文本中插入 DOM 元素（如颜色块）。
- **Replace Decoration**: 隐藏文本或用 DOM 替换文本（如折叠代码）。

```typescript
import { EditorView, Decoration, DecorationSet, ViewPlugin, ViewUpdate } from '@codemirror/view'
import { RangeSetBuilder } from '@codemirror/state'

// 定义一个 ViewPlugin 来管理装饰器
const colorHighlighter = ViewPlugin.fromClass(
  class {
    decorations: DecorationSet

    constructor(view: EditorView) {
      this.decorations = this.computeDecorations(view)
    }

    update(update: ViewUpdate) {
      // 只有当文档或视口变化时才重新计算
      if (update.docChanged || update.viewportChanged)
        this.decorations = this.computeDecorations(update.view)
    }

    computeDecorations(view: EditorView) {
      let builder = new RangeSetBuilder<Decoration>()
      // 最佳实践：只遍历当前视口（Viewport）内的可见范围，提升性能
      for (let { from, to } of view.visibleRanges) {
        // ... 你的正则匹配逻辑，找到颜色代码 ...
        // builder.add(pos, pos, Decoration.widget({ widget: new ColorWidget(color) }))
      }
      return builder.finish()
    }
  },
  {
    decorations: v => v.decorations // 告诉编辑器使用这个插件提供的装饰器
  }
)
```

#### 场景 3：动态配置切换（如：切换只读模式、切换语言、切换主题）

**业务需求**：用户点击一个按钮，编辑器从“编辑模式”变为“只读模式”，或者字体大小发生变化。

**❌ 错误做法**：
销毁旧的 `EditorView`，用新的配置重新创建一个。

- _后果_：丢失滚动位置、撤销历史（Undo History）和焦点状态，用户体验极差。

**✅ 最佳实践：使用 `Compartment` (隔间) 进行重构 (Reconfiguration)**
`Compartment` 允许你动态替换配置树中的某一部分。

```typescript
import { EditorState, Compartment } from '@codemirror/state'
import { EditorView } from '@codemirror/view'

let readOnlyCompartment = new Compartment()

let state = EditorState.create({
  extensions: [
    // 初始配置放入隔间
    readOnlyCompartment.of(EditorState.readOnly.of(false))
    // ... 其他扩展
  ]
})

let view = new EditorView({ state })

// 切换为只读模式
function toggleReadOnly(isReadOnly: boolean) {
  view.dispatch({
    effects: readOnlyCompartment.reconfigure(EditorState.readOnly.of(isReadOnly))
  })
}
```

#### 场景 4：处理大型文档与性能优化

**业务需求**：加载几万行的日志文件或代码文件，要求滚动流畅。

**核心原理**：
CodeMirror 6 默认实现了 **Viewport（视口）** 机制。它只渲染 DOM 中可见的部分。

**✅ 最佳实践**：

1.  **不要假设所有行都在 DOM 中**：如果你使用 `document.querySelectorAll('.cm-line')`，你只能获取到当前屏幕上的行。
2.  **使用 `view.visibleRanges`**：在编写插件（如高亮、Lint）时，只处理视口范围内的文本。
3.  **原子化更新**：尽量将多个变更合并到一个 Transaction 中 Dispatch。

```typescript
// ❌ 糟糕的性能：多次重绘
view.dispatch({ changes: { from: 0, insert: 'A' } })
view.dispatch({ changes: { from: 1, insert: 'B' } })

// ✅ 最佳实践：合并为一个事务
view.dispatch({
  changes: [
    { from: 0, insert: 'A' },
    { from: 1, insert: 'B' } // 注意：这里的坐标是基于原始文档的，或者使用顺序变更
  ]
})
```

#### 场景 5：外部 UI 与编辑器交互（如：工具栏、侧边栏）

**业务需求**：点击外部的“加粗”按钮，修改编辑器选区内容；或者在编辑器外部显示当前光标位置。

**✅ 最佳实践**：

1.  **外部 -> 编辑器**：调用 `view.dispatch()` 发送 Transaction。
2.  **编辑器 -> 外部**：使用 `EditorView.updateListener` 扩展。

```typescript
const syncStatusExtension = EditorView.updateListener.of(update => {
  if (update.docChanged) {
    // 文档变了，通知外部保存
    saveToDatabase(update.state.doc.toString())
  }
  if (update.selectionSet) {
    // 选区变了，更新外部状态栏
    updateStatusBar(update.state.selection.main.head)
  }
})
```

---

### 三、 总结：CodeMirror 6 开发检查清单

1.  **不要直接修改 State**：永远不要写 `state.doc = ...`。必须使用 `state.update()` 创建 Transaction 并 `view.dispatch()`。
2.  **区分 State 和 View**：
    - 数据逻辑（存什么）放 `StateField`。
    - 交互逻辑（怎么画、怎么响应事件）放 `ViewPlugin`。
3.  **利用 TypeScript**：CM6 的类型定义非常完善，使用 TS 能避免 90% 试图修改只读属性的错误。
4.  **理解 Facet**：配置就是 Facet。多个扩展可以向同一个 Facet 提供值（例如多个插件都添加按键绑定），CM 会自动合并它们。
5.  **善用官方扩展包**：
    - `@codemirror/commands`: 常用编辑命令。
    - `@codemirror/autocomplete`: 自动补全。
    - `@codemirror/lint`: 错误提示。
    - `@codemirror/language`: 语言支持基础。

通过遵循这些架构原则，你可以构建出既能处理百万行代码，又能拥有丰富交互体验的编辑器应用。

---

基于 `styleGuide.md` 文档，除了之前提到的核心架构，以下是业务开发中经常遇到、且容易踩坑的几个关键领域：**位置映射**、**多光标处理**、**样式主题定制**以及**扩展配置模式**。

### 一、 位置映射 (Position Mapping)：解决“标记漂移”问题

**业务场景**：
你在编辑器中实现了一个“行内评论”功能，或者记录了一个“断点”位置。当用户在文档顶部插入一段文本时，你的评论或断点应该自动向下移动，保持在原来的代码行上，而不是留在原本的坐标位置（那样会错位）。

**核心概念**：
CodeMirror 的坐标是基于字符索引的数字。文档变化后，旧的索引需要通过 `ChangeSet` 映射到新文档的索引。

**✅ 最佳实践**：
不要只保存一个数字位置。在处理更新时，必须使用 `transaction.changes.mapPos()` 来更新你存储的位置。

```typescript
import { EditorState, Transaction } from '@codemirror/state'

// 假设我们记录了一个断点在位置 100
let breakpointPos = 100

// 用户在位置 0 插入了 10 个字符
let transaction = view.state.update({
  changes: { from: 0, insert: '0123456789' }
})

// ❌ 错误：直接使用旧位置，断点还在 100，但内容已经变了
// ✅ 正确：映射位置
// mapPos 第二个参数 1 表示“向后关联”（如果插入在当前位置，点会随内容向后移）
// -1 表示“向前关联”
let newBreakpointPos = transaction.changes.mapPos(breakpointPos, 1)

console.log(newBreakpointPos) // 输出 110
```

**进阶技巧**：
对于复杂的范围追踪，直接使用 `RangeSet` (用于 Decoration) 或 `StateField` 来管理，它们内部已经处理了映射逻辑（只要你在 `update` 方法中正确调用了 `map`）。

---

### 二、 多光标与选区处理 (Multiple Selections)

**业务场景**：
你需要实现一个“格式化选中文本”的功能（例如转大写）。用户可能按住 `Alt` 键选中了文档中的三个不同区域。你的功能必须同时处理这三个区域。

**核心概念**：
默认情况下 CM6 只支持单选区。要支持多选区，需要开启 `EditorState.allowMultipleSelections`。

**✅ 最佳实践：使用 `changeByRange`**
不要手动遍历 `state.selection.ranges` 然后拼凑 `changes` 数组，这非常容易出错（因为第一个变更会改变文档长度，导致第二个变更的坐标失效）。
`changeByRange` 帮你自动处理这些复杂的坐标偏移。

```typescript
import { EditorState } from '@codemirror/state'

// 业务功能：将所有选区的内容转为大写
function upperCaseSelection(state: EditorState) {
  return state.changeByRange(range => {
    // 1. 获取当前选区的文本
    let text = state.sliceDoc(range.from, range.to)
    // 2. 处理文本
    let upper = text.toUpperCase()
    // 3. 返回该选区的变更描述（changes）和新的选区位置（range）
    return {
      changes: { from: range.from, to: range.to, insert: upper },
      range: EditorView.selection.range(range.from, range.from + upper.length)
    }
  })
}

// 调用
view.dispatch(upperCaseSelection(view.state))
```

---

### 三、 深度样式定制 (Theming)

**业务场景**：
设计师要求编辑器必须符合产品的 Design System，包括暗色模式适配、自定义光标颜色、选区背景色等。

**❌ 错误做法**：
直接写全局 CSS (`.cm-content { ... }`)。

- _后果_：样式冲突，无法跟随编辑器的主题切换（Light/Dark），且容易被 CM 默认样式覆盖。

**✅ 最佳实践：使用 `EditorView.theme`**
CM6 的主题系统会自动生成带哈希的类名，保证样式隔离。

```typescript
import { EditorView } from '@codemirror/view'

const myTheme = EditorView.theme(
  {
    // 主编辑器容器
    '&': {
      color: 'white',
      backgroundColor: '#282c34'
    },
    // 内容区域
    '.cm-content': {
      caretColor: '#0e9' // 自定义光标颜色
    },
    // 选中区域（注意 & 的使用）
    '&.cm-focused .cm-selectionBackground, ::selection': {
      backgroundColor: '#3E4451'
    },
    // 匹配暗色模式的特殊样式
    '&dark .cm-gutters': {
      backgroundColor: '#21252b',
      color: '#abb2bf'
    }
  },
  { dark: true }
) // 标记为暗色主题

let view = new EditorView({
  extensions: [myTheme]
})
```

**注意**：如果你开发的是一个通用插件（如行号插件），应该使用 `EditorView.baseTheme`。它允许用户的主题覆盖你的默认样式。

---

### 四、 扩展配置模式 (Facet Configuration)

**业务场景**：
你编写了一个“敏感词检测”插件。在 A 页面需要检测“密码”，在 B 页面需要检测“Token”。你需要一种方式将配置传递给深层的插件逻辑。

**核心概念**：
`Facet` 是 CM6 中传递配置的标准方式。它类似于 React 的 Context。

**✅ 最佳实践**：

1.  定义一个 Facet 用于存储配置。
2.  导出一个函数来创建扩展，该函数接受配置并返回 Facet 的值。
3.  在插件内部读取 Facet。

```typescript
import { Facet, EditorState } from '@codemirror/state'
import { ViewPlugin } from '@codemirror/view'

// 1. 定义配置 Facet
const forbiddenWordsFacet = Facet.define<string[], string[]>({
  combine: values => values.flat() // 如果有多个配置，合并数组
})

// 2. 插件逻辑读取 Facet
const wordCheckerPlugin = ViewPlugin.fromClass(
  class {
    constructor(view) {
      // 获取当前配置
      let words = view.state.facet(forbiddenWordsFacet)
      console.log('Checking for:', words)
    }
  }
)

// 3. 导出配置函数
export function forbiddenWords(words: string[]) {
  return [forbiddenWordsFacet.of(words), wordCheckerPlugin]
}

// 4. 业务使用
let state = EditorState.create({
  extensions: [
    forbiddenWords(['password', 'secret']) // 传入配置
    // 如果其他地方也调用了 forbiddenWords，配置会自动合并（因为我们在 combine 里定义了 flat）
  ]
})
```

### 五、 避免布局抖动 (Layout Thrashing)

**业务场景**：
你想在光标位置显示一个自定义的 Tooltip。

**❌ 错误做法**：
在 `update` 循环中直接读取 DOM 坐标 (`view.coordsAtPos`) 然后立即修改 DOM 样式。

- _后果_：强制浏览器重排（Reflow），导致严重的性能问题。

**✅ 最佳实践：使用 `requestMeasure`**
CM6 提供了读写分离的机制。

```typescript
view.requestMeasure({
  // 读阶段：在这里读取坐标，此时 DOM 是稳定的
  read(view) {
    return view.coordsAtPos(view.state.selection.main.head)
  },
  // 写阶段：拿到读阶段的返回值，更新 DOM
  write(measureReturnValue, view) {
    if (measureReturnValue) {
      tooltip.style.top = measureReturnValue.top + 'px'
      tooltip.style.left = measureReturnValue.left + 'px'
    }
  }
})
```

这些实践能帮助你写出更健壮、性能更好且易于维护的 CodeMirror 集成代码。

---

这是一个非常棒的问题。CodeMirror 6 (CM6) 的学习曲线陡峭，主要原因就是它的概念拆分得非常细。

为了让你在实际业务中能够迅速做出架构决策，我将这些概念映射到具体的**业务意图**上。

我们可以把 CM6 的核心组件看作一个**MVC 模式**的变体：

- **Model (数据层)**: `StateField`
- **View (视图层)**: `ViewPlugin`, `Decoration`
- **Controller (配置与胶水层)**: `Facet`, `Transaction`

以下是详细的场景决策指南：

---

### 1. 什么时候使用 `StateField`？

**核心意图：** 我需要“记住”一些数据，这些数据是文档状态的一部分，且必须随着文档的修改（Transaction）而更新/映射。

**典型场景：**

- **业务逻辑状态**：
  - _场景_：你需要统计文档中“TODO”标签的数量，并在外部显示。
  - _原因_：这是一个纯数据计算，不依赖 DOM。
- **协同编辑 (Collab)**：
  - _场景_：记录版本号、未确认的变更步骤（Steps）。
  - _原因_：这些数据必须是“单一事实来源”，且必须严格跟随 Transaction 变动。
- **复杂的语法树/解析结果**：
  - _场景_：你需要维护一份当前代码的 AST（抽象语法树）或折叠状态。
  - _原因_：解析很昂贵，你希望增量更新它，而不是每次按键都重算。
- **跨视图持久化**：
  - _场景_：如果我销毁了 `EditorView` 但保留了 `EditorState`，下次重建视图时，这个数据还需要在吗？如果需要，就用 `StateField`。

**代码特征**：

```typescript
// 只有纯逻辑，没有 DOM 操作
StateField.define({
  create() { return initialValue },
  update(value, transaction) {
    // 必须处理 map (位置映射)
    return transaction.changes.mapPos(...)
  }
})
```

---

### 2. 什么时候使用 `ViewPlugin`？

**核心意图：** 我需要与 DOM 交互，或者我的逻辑只与“当前用户看到的东西”有关（Viewport），不需要保存到文档状态里。

**典型场景：**

- **视口优化 (Viewport Optimization)**：
  - _场景_：高亮当前视口内的特定关键词。
  - _原因_：文档可能有 10 万行，用 `StateField` 存 10 万行的高亮数据太浪费内存。`ViewPlugin` 允许你只计算 `view.visibleRanges`。
- **DOM 事件监听**：
  - _场景_：监听鼠标移动（Hover）、点击事件，或者集成第三方库（如 Tippy.js 做 Tooltip）。
  - _原因_：`StateField` 接触不到 DOM 节点，只有 `ViewPlugin` 可以。
- **装饰器 (Decorations) 的主要生产者**：
  - _场景_：给代码加颜色、加下划线。
  - _原因_：通常我们只需要渲染可见区域的装饰器。

**代码特征**：

```typescript
ViewPlugin.fromClass(
  class {
    constructor(view) {
      /* 初始化 DOM 监听 */
    }
    update(update) {
      if (update.docChanged || update.viewportChanged) {
        // 重新计算可见区域
      }
    }
    destroy() {
      /* 清理事件 */
    }
  }
)
```

---

### 3. 什么时候使用 `Decoration`？

**核心意图：** 我想改变编辑器内容的**视觉表现**，但不想修改文档的**实际文本内容**。

`Decoration` 通常不单独使用，它需要由 `ViewPlugin` 或 `StateField` 提供。

**细分场景：**

- **Mark Decoration (标记)**：
  - _场景_：语法高亮、搜索结果高亮、波浪线错误提示。
  - _作用_：给文本套一个 `<span>` 或加 class，不改变布局。
- **Widget Decoration (挂件)**：
  - _场景_：在代码行尾显示“Git Blame”信息、在颜色代码 `#fff` 旁显示颜色块、原子化 CSS 的类名预览。
  - _作用_：在文本流中插入一个 DOM 元素（这个元素不是文档内容的一部分，光标会跳过它）。
- **Replace Decoration (替换/隐藏)**：
  - _场景_：代码折叠（把多行变成一个 `...` 按钮）、将 URL 替换为一个短链接徽章。
  - _作用_：隐藏一段文本，并可选地用一个 Widget 替代它。
- **Line Decoration (行样式)**：
  - _场景_：高亮当前行背景色、给特定行添加行号旁边的图标（断点）。
  - _作用_：作用于整行容器 DOM。

---

### 4. 什么时候使用 `Facet`？

**核心意图：** 我需要定义配置项，或者让多个独立的扩展（Extension）能够“通信”或“合并数据”。

**典型场景：**

- **全局配置**：
  - _场景_：`tabSize`、`readOnly`、`lineWrapping`。
  - _原因_：这些是简单的值，不需要复杂的更新逻辑。
- **扩展插槽**：
  - _场景_：你写了一个“事件总线”插件，允许其他插件注册回调函数。
  - _原因_：`Facet` 可以收集所有扩展传入的值并合并（Combine）成一个数组。
  - _例子_：`keymap.of([...])` 就是一个 Facet，它收集所有按键绑定。

---

### 5. 什么时候使用 `EditorView.updateListener`？

**核心意图：** 我需要将编辑器的状态同步给**外部世界**（React/Vue 组件、后端 API）。

**典型场景：**

- **保存文档**：
  - _场景_：用户停止输入 500ms 后，将内容发送给后端。
- **更新 UI**：
  - _场景_：在编辑器外部的状态栏显示当前光标位置（行:列）。
  - _原因_：这是单向的数据流出。

---

### 总结：决策流程图

当你接到一个需求时，请按以下步骤思考：

1.  **这个功能需要修改文档内容吗？**

    - 是 -> 使用 `Transaction` (`view.dispatch`).
    - 否 -> 继续。

2.  **这个功能需要存储数据吗？**

    - 是，且数据必须随文档版本回滚/重做 -> 使用 `StateField`.
    - 是，但只是临时的 UI 状态（如鼠标悬停状态） -> 使用 `ViewPlugin` 的类属性.
    - 否 -> 继续。

3.  **这个功能需要改变长相（颜色、结构）吗？**

    - 是 -> 使用 `Decoration` (由 `ViewPlugin` 或 `StateField` 提供).

4.  **这个功能需要监听 DOM 事件或操作 DOM 节点吗？**

    - 是 -> 使用 `ViewPlugin`.

5.  **这个功能是给其他插件提供配置的吗？**
    - 是 -> 使用 `Facet`.

### 实战案例：实现一个“TODO 列表”插件

假设需求是：

1.  高亮所有的 `TODO:` 文本（黄色背景）。
2.  在编辑器右侧显示一个面板，列出所有 TODO 的行号。

**架构拆解：**

1.  **高亮 (Visuals)**:

    - 使用 **`ViewPlugin`** + **`Decoration.mark`**。
    - _理由_：只需要高亮当前视口内的 TODO，没必要高亮几万行不可见的代码。

2.  **列表数据 (Data)**:

    - 使用 **`StateField`**。
    - _理由_：右侧面板需要展示**整个文档**的 TODO，不仅仅是视口内的。而且当用户打字时，我们需要增量更新这个列表，而不是每次全量扫描文档。

3.  **面板 UI (External UI)**:
    - 使用 **`EditorView.updateListener`** 或 React 组件。
    - _理由_：监听 `StateField` 的变化，一旦变化，重新渲染 React 组件列表。

通过这种组合（StateField 负责全量数据，ViewPlugin 负责视口渲染），你就能得到性能最佳的实现。

---

这部分是 CodeMirror 6 开发中最容易卡壳的“深水区”。很多开发者能跑通 Demo，但一遇到复杂的交互（如协同、富文本嵌入、框架集成）就会踩坑。

以下是针对**更细粒度场景**的决策指南：

---

### 1. 什么时候使用 `StateEffect`？

**核心意图：** 我需要**主动**修改 `StateField` 的值，而不是依赖文档变化（typing）来**被动**计算。

**场景对比：**

- **被动更新 (不需要 Effect)**：
  - _场景_：字数统计。
  - _逻辑_：只要 `doc` 变了，字数就变了。`StateField.update` 里直接读 `tr.newDoc.length` 即可。
- **主动更新 (必须用 Effect)**：
  - _场景_：代码折叠（Folding）、高亮特定行（Debugger Breakpoint）。
  - _逻辑_：用户点击了行号旁边的红点。文档内容没变，但“断点列表”这个状态变了。
  - _操作_：你需要定义一个 `StateEffect`，然后 `view.dispatch({ effects: myEffect.of(payload) })`。

**代码模式：**

```typescript
import { StateField, StateEffect } from '@codemirror/state'

// 1. 定义 Effect 类型
const addBreakpoint = StateEffect.define<number>()

// 2. 在 Field 中监听 Effect
const breakpointField = StateField.define({
  create() {
    return []
  },
  update(breakpoints, tr) {
    // 先处理位置映射（如果文档变了，断点位置也要变）
    breakpoints = breakpoints.map(pos => tr.changes.mapPos(pos))

    // 再处理 Effect（如果有人发起了 addBreakpoint 动作）
    for (let effect of tr.effects) {
      if (effect.is(addBreakpoint)) {
        breakpoints = [...breakpoints, effect.value]
      }
    }
    return breakpoints
  }
})

// 3. 业务调用
function toggleBreakpoint(linePos) {
  view.dispatch({ effects: addBreakpoint.of(linePos) })
}
```

---

### 2. 什么时候使用 `TransactionFilter`？

**核心意图：** 我想**拦截**、**修改**或**取消**用户的操作（按键、粘贴、Drop）。

**典型场景：**

- **输入掩码 (Input Mask)**：
  - _场景_：只允许输入数字，或者将输入的 `a` 强制转为 `A`。
  - _做法_：在 Transaction 应用到 State 之前，修改它的 `changes`。
- **只读区域保护**：
  - _场景_：文档的某些段落是锁定的，不允许编辑。
  - _做法_：检查 `tr.changes` 是否触碰了禁区，如果是，则过滤掉这些变更。
- **最大长度限制**：
  - _场景_：文档不能超过 1000 字。

**代码模式：**

```typescript
import { EditorState } from '@codemirror/state'

const numberOnlyFilter = EditorState.transactionFilter.of(tr => {
  // 如果没有文档变更，直接放行（比如只是移动光标）
  if (!tr.docChanged) return tr

  // 检查所有变更插入的内容
  let newChanges = []
  tr.changes.iterChanges((fromA, toA, fromB, toB, inserted) => {
    // 如果插入了非数字，就拦截
    if (!/^\d*$/.test(inserted.toString())) {
      // 这里可以选择返回 [] 取消整个事务，或者返回修改后的事务
      // 简单起见，这里我们直接丢弃非数字的输入
    }
  })

  // 如果发现非法输入，返回空数组（取消事务）
  // 或者返回一个新的 TransactionSpec
  return tr
})
```

---

### 3. 什么时候使用 `Widget.destroy`？

**核心意图：** 我在编辑器里渲染了复杂的 DOM（比如 React 组件、ECharts 图表），需要防止内存泄漏。

**场景细节：**
CodeMirror 的视口（Viewport）机制会频繁地从 DOM 中移除不可见的行。

- 如果你用 `Decoration.widget` 插入了一个 React 组件。
- 当用户滚动，这个组件被移出屏幕，DOM 节点被移除。
- **坑点**：React 的状态可能还在内存中，或者 `setInterval` 还在跑。

**最佳实践：**
在自定义 Widget 类中实现 `destroy` 方法。

```typescript
class ReactWidget extends WidgetType {
  constructor(readonly props: any) {
    super()
  }

  toDOM() {
    let wrap = document.createElement('div')
    // 挂载 React/Vue
    ReactDOM.render(<MyComponent {...this.props} />, wrap)
    return wrap
  }

  // 关键：当 CM 移除这个节点时调用
  destroy(dom: HTMLElement) {
    ReactDOM.unmountComponentAtNode(dom)
  }
}
```

---

### 4. 什么时候使用 `StateField.provide`？

**核心意图：** 我的数据在 `StateField` 里，但我同时需要根据这些数据渲染 `Decoration`。

**场景：**

- 你做了一个“搜索”插件。
- `StateField` 存储了当前的搜索关键词和所有匹配到的位置（数据）。
- 你需要把这些位置高亮出来（视图）。

**❌ 笨办法：**
写一个 `StateField` 存数据，再写一个 `ViewPlugin` 读数据并渲染。

- _缺点_：逻辑分散，容易不同步。

**✅ 最佳实践：**
使用 `provide` 让 Field 直接驱动 View。

```typescript
const searchField = StateField.define<RangeSet<Decoration>>({
  create() {
    return Decoration.none
  },
  update(decorations, tr) {
    // ... 计算逻辑 ...
    return newDecorations
  },
  // 关键：告诉编辑器，这个 Field 的值就是装饰器
  provide: field => EditorView.decorations.from(field)
})
```

---

### 5. 什么时候使用 `EditorView.domEventHandlers`？

**核心意图：** 我需要监听特定的 DOM 事件，但不想写复杂的 `ViewPlugin`。

**场景：**

- **点击跳转**：按住 Ctrl 点击变量名跳转定义。
- **拖拽上传**：监听 `drop` 事件上传图片。

**代码模式：**

```typescript
import { EditorView } from '@codemirror/view'

const clickHandler = EditorView.domEventHandlers({
  mousedown(event, view) {
    if (event.ctrlKey) {
      const pos = view.posAtCoords({ x: event.clientX, y: event.clientY })
      console.log('Ctrl+Click at', pos)
      return true // 返回 true 阻止默认行为
    }
  },
  drop(event, view) {
    // 处理文件拖拽
  }
})
```

---

### 6. 什么时候关注 `MapMode` (位置映射模式)？

**核心意图：** 我在追踪一个位置（比如评论锚点），当用户在这个位置**正好**插入文本时，我的锚点应该在插入文本的**前面**还是**后面**？

**场景细节：**
假设位置 `pos = 5`。
用户在 `5` 处插入了 "hello"。

- **Mode 1 (TrackDel)**: 锚点应该变成 `5` 还是 `10`？
  - 如果是“书签”，通常希望它留在插入内容的后面（变成 10）。
  - 如果是“起始标记”，可能希望它留在前面（保持 5）。

**API 细节：**

- `MapMode.Simple` (默认): 插入点后的位置会向后移。
- `MapMode.TrackBefore`: 紧贴插入点前面的位置，会留在插入点前面。
- `MapMode.TrackAfter`: 紧贴插入点后面的位置，会随插入点移动。

在 `StateField` 或 `Decoration` 中，这通常由 `inclusive` (包含性) 属性控制：

- `inclusive: true` -> 选区包含插入的内容。
- `inclusive: false` -> 选区不包含插入的内容。

---

### 总结：一张表看懂

| 你的需求                 | 推荐工具            | 关键 API                                |
| :----------------------- | :------------------ | :-------------------------------------- |
| **存数据** (纯逻辑)      | `StateField`        | `define`, `update`                      |
| **改数据** (非打字)      | `StateEffect`       | `StateEffect.define`, `tr.effects`      |
| **画东西** (高亮/挂件)   | `Decoration`        | `mark`, `widget`, `replace`             |
| **画复杂组件** (React)   | `WidgetType`        | `toDOM`, `destroy`, `eq`                |
| **拦截输入** (校验)      | `TransactionFilter` | `EditorState.transactionFilter`         |
| **监听 DOM** (点击/拖拽) | `domEventHandlers`  | `EditorView.domEventHandlers`           |
| **监听生命周期** (Mount) | `ViewPlugin`        | `constructor`, `destroy`                |
| **配置传递** (依赖注入)  | `Facet`             | `Facet.define`, `view.state.facet(...)` |

---

这是一份 CodeMirror 6 (CM6) 的**全景开发手册**。我将开发中可能遇到的几乎所有场景进行了分类盘点，并给出了对应的最佳实践方案。

你可以把这份清单当作你的**架构决策字典**。

---

### 📂 第一章：基础编辑与数据流 (Basic Editing & Data Flow)

这是最基础的部分，涉及如何读写编辑器的数据。

| 场景              | ❌ 错误/低效做法                                         | ✅ 最佳实践                                                                            | 关键 API          |
| :---------------- | :------------------------------------------------------- | :------------------------------------------------------------------------------------- | :---------------- |
| **获取文档内容**  | `view.dom.innerText`                                     | `view.state.doc.toString()`                                                            | `Text` 对象       |
| **设置/重置内容** | 销毁 View 重建                                           | `view.dispatch({ changes: { from: 0, to: view.state.doc.length, insert: "新内容" } })` | `Transaction`     |
| **监听内容变化**  | `view.dom.addEventListener('input')`                     | `EditorView.updateListener.of(u => { if(u.docChanged) ... })`                          | `ViewUpdate`      |
| **外部数据同步**  | 在 `updateListener` 里直接 `setState` (React) 导致死循环 | 检查 `update.transactions` 是否来自外部 (`!tr.isUserEvent('input')`) 或对比内容指纹    | `Annotation`      |
| **只读模式切换**  | 重新创建 View                                            | 使用 `Compartment` 动态重配置 `EditorState.readOnly`                                   | `Compartment`     |
| **获取光标位置**  | `view.state.selection.ranges[0]`                         | `view.state.selection.main.head`                                                       | `Selection`       |
| **移动光标**      | 手动计算坐标                                             | `view.dispatch({ selection: { anchor: 100 } })`                                        | `EditorSelection` |

---

### 🎨 第二章：视觉表现与装饰 (Visuals & Decorations)

涉及如何改变代码的颜色、样式、隐藏或插入元素。

| 场景                        | ❌ 错误/低效做法           | ✅ 最佳实践                                                              | 关键 API               |
| :-------------------------- | :------------------------- | :----------------------------------------------------------------------- | :--------------------- |
| **语法高亮**                | 自己写正则匹配并操作 DOM   | 使用官方语言包 + `HighlightStyle`                                        | `@codemirror/language` |
| **搜索高亮/关键词**         | 遍历整个文档 DOM 加 class  | `ViewPlugin` + `Decoration.mark` (仅渲染视口内)                          | `Decoration.mark`      |
| **行内小部件 (如颜色块)**   | 插入 `<span>` 到文档文本中 | `Decoration.widget` (不影响文档内容长度)                                 | `WidgetType`           |
| **代码折叠/隐藏**           | `display: none`            | `Decoration.replace`                                                     | `foldCode`             |
| **整行背景色 (如调试行)**   | 查找 DOM 添加 class        | `Decoration.line({ attributes: {class: '...'} })`                        | `Decoration.line`      |
| **原子化块 (如提及 @User)** | 插入文本                   | `Decoration.widget` 或 `Decoration.replace` (作为原子节点，光标一次跳过) | `WidgetType`           |
| **自定义主题**              | 全局 CSS 覆盖              | `EditorView.theme({ ... }, { dark: true })`                              | `EditorView.theme`     |

---

### 🧠 第三章：代码智能与辅助 (Intelligence & Assistance)

涉及自动补全、错误提示、悬浮提示等 IDE 特性。

| 场景                    | ❌ 错误/低效做法                | ✅ 最佳实践                                       | 关键 API            |
| :---------------------- | :------------------------------ | :------------------------------------------------ | :------------------ |
| **自定义自动补全**      | 监听 `input` 事件弹出一个 `div` | `autocompletion({ override: [mySource] })`        | `CompletionSource`  |
| **异步补全 (API 请求)** | 同步等待                        | 返回 `Promise<CompletionResult>`                  | `CompletionContext` |
| **错误提示 (Lint)**     | 手动画波浪线                    | `linter(view => diagnostics)`                     | `@codemirror/lint`  |
| **悬浮提示 (Hover)**    | 监听 `mousemove`                | `hoverTooltip((view, pos) => { ... })`            | `Tooltip`           |
| **括号匹配**            | 自己计算栈                      | `bracketMatching()` 扩展                          | `matchBrackets`     |
| **代码片段 (Snippets)** | 纯文本插入                      | `snippetCompletion("template", { label: "..." })` | `snippet`           |

---

### 🖱️ 第四章：交互与事件 (Interaction & Events)

涉及鼠标、键盘、拖拽等用户输入处理。

| 场景                          | ❌ 错误/低效做法                     | ✅ 最佳实践                                        | 关键 API            |
| :---------------------------- | :----------------------------------- | :------------------------------------------------- | :------------------ |
| **自定义快捷键**              | `window.addEventListener('keydown')` | `keymap.of([{ key: "Mod-s", run: save }])`         | `KeyBinding`        |
| **拦截特定输入 (如只输数字)** | `input` 事件后回退                   | `EditorState.transactionFilter` (在变更发生前拦截) | `TransactionFilter` |
| **点击交互 (Ctrl+Click)**     | 给每个 token 加 onclick              | `EditorView.domEventHandlers({ mousedown: ... })`  | `domEventHandlers`  |
| **文件拖拽上传**              | 监听全局 drop                        | `EditorView.domEventHandlers({ drop: ... })`       | `domEventHandlers`  |
| **粘贴处理 (如粘贴图片)**     | 监听 paste                           | `EditorView.domEventHandlers({ paste: ... })`      | `Clipboard`         |
| **多光标编辑**                | 循环 dispatch                        | `state.changeByRange(range => ...)`                | `changeByRange`     |

---

### 📐 第五章：界面组件 (UI Components)

涉及编辑器周边的 UI，如行号栏、面板、工具提示。

| 场景                        | ❌ 错误/低效做法 | ✅ 最佳实践                                 | 关键 API       |
| :-------------------------- | :--------------- | :------------------------------------------ | :------------- |
| **行号栏 (Gutter)**         | 绝对定位 div     | `lineNumbers()` 或 `gutter({ class: ... })` | `Gutter`       |
| **行号旁图标 (断点)**       | 修改行号 DOM     | 自定义 `gutter` + `GutterMarker`            | `GutterMarker` |
| **顶部/底部面板 (搜索框)**  | 外部 HTML 覆盖   | `showPanel.of(view => dom)`                 | `Panel`        |
| **光标跟随提示 (参数提示)** | 计算坐标绝对定位 | `showTooltip.of(tooltip)`                   | `Tooltip`      |

---

### 🚀 第六章：高级架构与性能 (Advanced Architecture)

涉及复杂应用场景、大文件处理、协同编辑。

| 场景                       | ❌ 错误/低效做法  | ✅ 最佳实践                                                      | 关键 API                |
| :------------------------- | :---------------- | :--------------------------------------------------------------- | :---------------------- |
| **大文件性能**             | 关闭所有插件      | 依赖 CM6 默认的 `Viewport` 机制，插件只处理 `view.visibleRanges` | `Viewport`              |
| **协同编辑 (Google Docs)** | 手动合并字符串    | 使用 `y-codemirror.next` + `Yjs`                                 | `Collab`                |
| **撤销/重做**              | 自己存历史栈      | `history()` 扩展                                                 | `history`               |
| **持久化状态 (JSON)**      | 存整个 State 对象 | `state.toJSON(fields)` / `EditorState.fromJSON`                  | `toJSON`                |
| **跨扩展通信**             | 全局变量          | 定义 `Facet` 注入配置，或 `StateEffect` 触发动作                 | `Facet` / `StateEffect` |
| **动态语言切换**           | 销毁重建          | `Compartment.reconfigure(newLanguage)`                           | `Language`              |

---

### 💡 核心心法总结

1.  **一切皆状态 (State is Truth)**: 不要信赖 DOM，DOM 只是 State 的投影。
2.  **变更皆事务 (Changes are Transactions)**: 任何修改（内容、选区、配置）都必须通过 Dispatch Transaction 完成。
3.  **视口即性能 (Viewport is Performance)**: 永远假设文档有 100 万行，你的插件只应该处理用户看得到的那 50 行。
4.  **配置即隔间 (Config is Compartment)**: 凡是未来可能要动态改的配置（只读、语言、主题），初始化时都装进 `Compartment` 里。

---

在 CodeMirror 6 (CM6) 中，API 的设计极其严谨且模块化。为了让你在开发时能像查字典一样快速定位，我将基础 API 分为 **文档操作、选区管理、事务处理、视图交互、以及扩展机制** 五大核心板块进行深度盘点。

---

### 一、 文档与文本 API (`@codemirror/state`)

CM6 的文档不是简单的字符串，而是一个名为 `Text` 的树状结构（Rope Data Structure），这使得它处理超大文件时非常高效。

#### 1. `Text` 对象

- **`state.doc.toString()`**: 将整个文档转为字符串。
- **`state.doc.length`**: 获取文档总字符数。
- **`state.doc.lines`**: 获取总行数。
- **`state.doc.line(n)`**: 获取第 `n` 行的信息（**注意：行号从 1 开始**）。
  - 返回对象包含：`from`, `to`, `text`, `number`。
- **`state.doc.lineAt(pos)`**: 获取字符位置 `pos` 所在的行信息。
- **`state.doc.sliceString(from, to)`**: 高效截取指定范围的字符串。

#### 2. 坐标转换

- **`pos = line.from + col`**: 行列转绝对位置。
- **`line = state.doc.lineAt(pos)`**: 绝对位置转行信息。

---

### 二、 选区 API (`EditorSelection`)

CM6 原生支持多选区（Multiple Selections）。

- **`state.selection.main`**: 获取“主”选区（通常是最后一个创建的或唯一的那个）。
- **`state.selection.ranges`**: 获取所有选区数组。
- **`range.from` / `range.to`**: 选区的开始和结束位置（`from` 总是小于等于 `to`）。
- **`range.anchor` / `range.head`**:
  - `anchor`: 鼠标按下的起点。
  - `head`: 光标所在的位置（移动端或拖选时的终点）。
- **`range.empty`**: 布尔值，判断是否只是一个闪烁的光标（无选中内容）。

**最佳实践：**
创建新选区时使用 `EditorSelection.cursor(pos)` 或 `EditorSelection.range(anchor, head)`。

---

### 三、 事务 API (`Transaction`)

这是修改编辑器的唯一入口。

- **`state.update(...)`**: 创建一个 Transaction 对象，但不应用它。
- **`view.dispatch(...)`**: 创建并立即应用 Transaction。
- **常用参数：**
  - **`changes`**: `{from, to, insert}`。如果 `to` 省略，则为插入；如果 `insert` 为空，则为删除。
  - **`selection`**: 设置新的选区位置。
  - **`scrollIntoView: true`**: 确保操作后的光标在可视区域内。
  - **`effects`**: 携带 `StateEffect`（如折叠代码、切换主题）。
  - **`annotations`**: 给事务打标签，例如 `Transaction.userEvent.of("input")`。

---

### 四、 视图 API (`EditorView`)

负责 DOM 渲染和用户交互。

- **`view.state`**: 获取当前的不可变状态。
- **`view.dispatch(tr)`**: 派发事务。
- **`view.dom`**: 编辑器的根 DOM 节点。
- **`view.scrollDOM`**: 负责滚动的 DOM 节点（设置高度通常找它）。
- **`view.posAtCoords({x, y})`**: 根据屏幕坐标获取文档位置（实现悬浮提示的关键）。
- **`view.coordsAtPos(pos)`**: 根据文档位置获取屏幕坐标。
- **`view.requestMeasure()`**: 安全地读取 DOM 布局信息，避免布局抖动。

---

### 五、 扩展机制 API (Extensions)

这是 CM6 最强大的地方，通过不同的类实现功能增强。

#### 1. `StateField` (状态字段)

用于存储自定义数据。

- **`create`**: 初始化数据。
- **`update`**: 核心逻辑，根据 `tr` 计算新状态。
- **`provide`**: 将数据暴露给其他扩展（如 `EditorView.decorations`）。

#### 2. `ViewPlugin` (视图插件)

用于处理 DOM 和视口逻辑。

- **`update(update: ViewUpdate)`**: 每次视图更新（滚动、打字、焦点变化）时触发。
- **`destroy()`**: 销毁时清理定时器或 DOM 监听。

#### 3. `Facet` (配置槽)

用于插件间的通信和配置合并。

- **`Facet.define()`**: 定义一个新的配置项。
- **`combine`**: 定义多个插件提供相同配置时如何合并（例如：取最大值、合并数组）。

#### 4. `Compartment` (隔间)

用于动态替换扩展。

- **`of(extension)`**: 初始包装。
- **`reconfigure(newExtension)`**: 生成一个 Effect 来替换该隔间内的内容。

---

### 六、 常用辅助工具 API

- **`RangeSet` / `RangeSetBuilder`**: 高效管理大量带位置的数据（如 1000 个高亮项）。
- **`CharCategory`**: 判断字符类型（单词、空格、标点），用于自定义双击选中逻辑。
- **`indentString(state, distance)`**: 根据当前配置（Tab 还是空格）生成缩进字符串。

---

### 💡 避坑指南：API 使用细节

1.  **不可变性**：永远记住 `state` 是不可变的。`state.doc = "..."` 是无效的，必须通过 `view.dispatch`。
2.  **异步陷阱**：在 `setTimeout` 或 `Promise` 中使用 `view.state` 时要小心，因为此时 `view.state` 可能已经不是最新的了。**最佳实践**：始终通过 `view.state` 实时获取。
3.  **位置有效性**：在派发变更时，确保 `from` 和 `to` 不超过 `state.doc.length`，否则会抛出 Range Error。
4.  **性能消耗**：在 `ViewPlugin` 的 `update` 中避免执行 `O(n)` 的全量文档扫描。利用 `update.changes.iterChanges` 只处理变化的部分。

掌握了这些基础 API，你就能像拼乐高一样，组合出任何复杂的编辑器功能。

---

在前面的讨论中，我们已经覆盖了 CodeMirror 6 (CM6) 的核心架构和常用组件。为了达到“全覆盖”和“深度进阶”，我们需要补充一些**文档中非常重要但容易被忽视的细节**，以及在复杂业务（如低代码平台、大型 IDE）中必然会遇到的高级课题。

---

### 一、 事务的“元数据”：Annotation (注解)

**业务场景**：
你写了一个插件，在用户输入时自动补全括号。但你发现这触发了你的“内容变更保存”逻辑。你希望区分：这次变更**是用户手打的**，还是**插件自动改的**？

**✅ 最佳实践**：
使用 `Annotation` 给 Transaction 打标签。

```typescript
import { Annotation, Transaction } from '@codemirror/state'

// 1. 定义一个自定义注解
const myPluginSource = Annotation.define<boolean>()

// 2. 在派发变更时携带注解
view.dispatch({
  changes: { from: 0, insert: '(' },
  annotations: myPluginSource.of(true)
})

// 3. 在监听器中识别
const listener = EditorView.updateListener.of(update => {
  update.transactions.forEach(tr => {
    if (tr.annotation(myPluginSource)) {
      console.log('这是由我的插件产生的变更，忽略保存逻辑')
    }
    // 官方内置注解：判断是否是用户输入（键盘、粘贴、拖拽）
    if (tr.isUserEvent('input')) {
      console.log('这是用户真实输入')
    }
  })
})
```

---

### 二、 语法树的深度利用：Syntax Tree & Lezer

**业务场景**：
你希望实现一个功能：**只有当用户在“字符串”内部点击时**，才弹出特定的 UI。

**核心概念**：
CM6 拥有增量解析的语法树。不要用正则去判断上下文，要用 `syntaxTree`。

**✅ 最佳实践**：
利用 `TreeCursor` 遍历语法节点。

```typescript
import { syntaxTree } from '@codemirror/language'

view.dom.addEventListener('click', () => {
  let pos = view.state.selection.main.head
  let tree = syntaxTree(view.state)
  let cursor = tree.cursorAt(pos)

  // 向上查找节点类型
  do {
    if (cursor.name === 'String') {
      console.log('用户点击了字符串内部！')
      break
    }
  } while (cursor.parent())
})
```

---

### 三、 优先级控制：Precedence (Prec)

**业务场景**：
你添加了一个 `keymap` 处理 `Enter` 键，但发现它被官方的 `defaultKeymap` 拦截了，或者你的快捷键失效了。

**核心概念**：
CM6 的扩展是平铺的，但执行顺序受 `Prec` 影响。

**✅ 最佳实践**：
显式声明优先级。

```typescript
import { Prec } from '@codemirror/state'
import { keymap } from '@codemirror/view'

const myKeymap = keymap.of([
  {
    key: 'Enter',
    run: () => {
      console.log('我的回车逻辑优先')
      return true
    }
  }
])

// 使用 Prec.highest 确保在最前面
const extensions = [Prec.highest(myKeymap), defaultExtensions]
```

- `Prec.highest`: 最高优先级。
- `Prec.high`: 高。
- `Prec.default`: 默认。
- `Prec.low`: 低。

---

### 四、 性能怪兽：RangeSet 与增量更新

**业务场景**：
你需要渲染 10,000 个高亮标记（例如：超大型日志文件的关键词）。

**核心概念**：
如果你每次 `update` 都重新 `new RangeSetBuilder`，大文档会卡死。

**✅ 最佳实践：使用 `RangeSet.map()`**
`RangeSet` 支持增量映射，它能根据文档的变更自动调整内部所有标记的位置。

```typescript
// 在 StateField 的 update 中
update(value, tr) {
  // 这一步非常高效：它不会重新计算所有位置，而是根据 tr.changes 批量偏移
  return value.map(tr.changes)
}
```

---

### 五、 撤销历史的精细控制：`addToHistory`

**业务场景**：
你实现了一个“自动格式化”功能，用户输入 `;` 后自动调整缩进。用户按 `Ctrl+Z` 时，他希望**只撤销格式化**，还是**连同分号一起撤销**？

**✅ 最佳实践**：
通过 `addToHistory: false` 隐藏某些中间步骤。

```typescript
// 1. 用户输入分号（正常记录历史）
view.dispatch({ changes: { from: 10, insert: ';' } })

// 2. 插件自动调整缩进（不希望作为独立的撤销步骤）
view.dispatch({
  changes: { from: 0, to: 5, insert: '  ' },
  annotations: Transaction.addToHistory.of(false) // 不进入撤销栈
})
```

---

### 六、 外部 UI 协同：Tooltip 的自定义渲染

**业务场景**：
你需要一个悬浮提示框，里面不仅有文字，还有按钮、图片甚至是一个 React 组件。

**✅ 最佳实践**：
利用 `Tooltip` 的 `create` 钩子进行生命周期管理。

```typescript
import { showTooltip } from '@codemirror/view'

const myTooltip = showTooltip.of({
  pos: 10,
  create(view) {
    let dom = document.createElement('div')
    dom.className = 'my-custom-tooltip'
    dom.textContent = '提示内容'

    // 你可以在这里挂载 React/Vue
    // ReactDOM.render(<MyComp />, dom)

    return {
      dom,
      offset: { x: 0, y: 10 }, // 偏移量
      update(update) {
        /* 视图更新时的逻辑 */
      },
      destroy() {
        /* 销毁逻辑，记得卸载 React */
      }
    }
  }
})
```

---

### 七、 单元测试：如何测试你的插件？

**业务场景**：
你写了一个复杂的 `StateField` 逻辑，不想每次都打开浏览器手动测试。

**✅ 最佳实践**：
CM6 的设计非常利于测试，因为 `State` 是纯逻辑的。

```typescript
import { EditorState } from '@codemirror/state'

test('my field logic', () => {
  let state = EditorState.create({
    extensions: [myField]
  })

  // 模拟一个事务
  let tr = state.update({ changes: { from: 0, insert: 'hello' } })
  let newState = tr.state

  // 断言 Field 的值
  expect(newState.field(myField)).toBe(expectedValue)
})
```

---

### 八、 总结：CM6 的“三不”原则

1.  **不要直接操作 DOM**：除非你在写 `WidgetType.toDOM` 或 `ViewPlugin` 的构造函数。
2.  **不要在 `update` 里做重计算**：`update` 触发频率极高，昂贵逻辑必须配合 `tr.docChanged` 或 `tr.viewportChanged` 检查。
3.  **不要忘记 `map` 位置**：任何你存储的数字位置（pos），在 `StateField` 更新时如果不经过 `tr.changes.mapPos(pos)`，它在下一次操作时一定会指向错误的地方。

掌握了这些细节，你才算真正从“会用 CodeMirror”进阶到了“能驾驭 CodeMirror”。

---

在前面的基础上，我们进一步挖掘 CodeMirror 6 中那些**文档角落里非常关键、但在复杂业务中必不可少**的 API 细节。

---

### 一、 事务 (Transaction) 的深度属性

除了 `changes` 和 `selection`，`Transaction` 对象中还有几个属性在处理复杂逻辑时至关重要：

#### 1. `tr.isUserEvent(type: string)`

**场景**：你只想在用户“打字”时触发某个逻辑，而不想在“代码格式化”或“协同同步”时触发。

- **细节**：CM6 会给事务打上内置标签。
  - `tr.isUserEvent("input")`: 键盘输入。
  - `tr.isUserEvent("delete")`: 删除操作。
  - `tr.isUserEvent("undo")` / `tr.isUserEvent("redo")`: 撤销重做。
- **最佳实践**：在 `updateListener` 中过滤非用户行为，防止无限循环。

#### 2. `tr.newDoc` 与 `tr.newSelection`

**场景**：在 `StateField` 的 `update` 函数中，你需要知道变更**之后**的文档长什么样。

- **细节**：`tr.doc` 是旧文档，`tr.newDoc` 是应用变更后的新文档。同理，`tr.selection` 是旧选区，`tr.newSelection` 是新选区。

---

### 二、 状态字段 (StateField) 的高级参数

`StateField.define` 除了 `create` 和 `update`，还有两个容易被忽略的参数：

#### 1. `compare: (a, b) => boolean`

**场景**：你的 `StateField` 存储了一个复杂的对象。

- **细节**：CM6 默认使用 `===` 比较状态是否改变。如果你的 `update` 每次都返回一个新对象（即使内容没变），会导致依赖这个 Field 的插件（如 `ViewPlugin`）频繁重绘。
- **最佳实践**：提供一个深比较函数，优化性能。

#### 2. `toJSON` / `fromJSON`

**场景**：用户刷新页面后，你希望恢复之前的“断点”、“书签”或“折叠状态”。

- **细节**：这两个函数允许你将 Field 的状态序列化。
- **最佳实践**：配合 `EditorState.toJSON()` 使用，实现编辑器状态的持久化。

---

### 三、 文本迭代器 (Text Iterator)：大文件处理的利器

**场景**：你需要扫描一个 50MB 的文件来查找某个字符串。

**❌ 错误做法**：`state.doc.toString().indexOf(...)`

- 这会瞬间产生一个巨大的字符串对象，导致内存溢出或 GC 抖动。

**✅ 最佳实践**：使用 `doc.iter()`。

```typescript
let iter = state.doc.iter()
while (!iter.next().done) {
  console.log(iter.value) // 每次只获取一小块文本（Chunk）
}
```

---

### 四、 语言数据 (Language Data)：插件间的“协议”

**场景**：你写了一个“注释/取消注释”的通用插件，它怎么知道当前语言的注释符号是 还是 `#`？

**核心 API**：`state.languageDataAt<T>(name: string, pos: number)`

- **细节**：语言包（如 `@codemirror/lang-javascript`）会将元数据注册到 `languageData` 中。
- **常用 Key**：
  - `commentTokens`: `{line: "//", block: {open: "/*", close: "*/"}}`
  - `closeBrackets`: 自动闭合的括号。
  - `wordChars`: 哪些字符被视为单词的一部分。

---

### 五、 装饰器集合 (RangeSet) 的高效遍历

**场景**：你有一万个高亮标记，现在你想找出光标位置处有哪些标记。

**❌ 错误做法**：遍历数组。

**✅ 最佳实践**：使用 `RangeCursor`。

```typescript
let cursor = myRangeSet.iter()
// 跳到指定位置附近
cursor.next()
// RangeSet 内部是平衡树结构，查找效率是 O(log N)
```

---

### 六、 视图更新 (ViewUpdate) 的精细判断

在 `ViewPlugin` 的 `update(update: ViewUpdate)` 中，不要只看 `docChanged`。

- **`update.viewportChanged`**: 当用户滚动页面，导致新的行进入视野时为 `true`。这是实现“懒加载高亮”的关键。
- **`update.focusChanged`**: 编辑器获得或失去焦点。
- **`update.geometryChanged`**: 编辑器的大小改变（比如容器被拉伸）。
- **`update.transactions`**: 你可以拿到触发这次更新的所有事务，从而读取里面的 `annotations` 或 `effects`。

---

### 七、 缩进服务 (Indent Service)

**场景**：用户按下回车，你希望光标自动缩进到正确的位置。

**核心 API**：`getIndentation(state, pos)`

- **细节**：它会咨询当前的语言模式（Parser），根据语法树计算该位置应有的缩进深度。
- **最佳实践**：在实现自定义“回车”命令时，使用此 API 保持缩进一致性。

---

### 八、 搜索与替换 (SearchQuery)

**场景**：你想在代码中实现“查找并高亮”功能，但不想自己写正则。

**核心 API**：`SearchQuery` 类。

- **细节**：它是官方 `@codemirror/search` 插件的核心。它处理了大小写敏感、正则转义、以及跨行匹配的复杂逻辑。
- **用法**：
  ```typescript
  let query = new SearchQuery({ search: 'myVar', caseSensitive: true })
  let cursor = query.getCursor(state.doc)
  while (!cursor.next().done) {
    console.log('找到匹配位置:', cursor.value.from, cursor.value.to)
  }
  ```

---

### 九、 总结：API 选用“潜规则”

1.  **位置计算**：优先使用 `state.doc.lineAt(pos)` 而不是自己去算 `\n` 的数量。
2.  **DOM 测量**：永远在 `requestMeasure` 的 `read` 阶段调用 `view.coordsAtPos`。
3.  **配置合并**：如果你发现多个插件都在争夺同一个控制权，定义一个 `Facet` 来做仲裁。
4.  **命令返回**：自定义 `Command` 时，如果你的逻辑不适用当前状态，请务必返回 `false`，这样 CM 才会继续执行后续的快捷键绑定。

这些 API 构成了 CodeMirror 6 的底层基石，理解它们的细节能让你在处理极端边缘 case 时游刃有余。

---

在前面的基础上，我们进入 CodeMirror 6 的**底层引擎级 API**。这些 API 通常在编写高性能插件、实现复杂的撤销/重做逻辑或深度定制编辑器行为时才会用到。

---

### 一、 变更集 (ChangeSet)：文档演变的底层引擎

`Transaction.changes` 返回的就是一个 `ChangeSet`。它是 CM6 处理文档更新的核心。

#### 1. `ChangeSet.compose(other: ChangeSet)`

- **场景**：你需要将两个连续的变更合并成一个。例如，在协同编辑中，将用户快速输入的多个字符合并为一个历史记录点。
- **细节**：它能计算出两个变更叠加后的最终效果。

#### 2. `ChangeSet.invert(doc: Text)`

- **场景**：实现自定义的撤销逻辑。
- **细节**：给定原始文档，它能生成一个“反向变更”，将文档恢复到变更前的状态。

#### 3. `ChangeSet.iterChanges(f: (fromA, toA, fromB, toB, inserted) => void)`

- **场景**：你需要精确知道文档的哪些部分被替换成了什么。
- **细节**：这是最高效的遍历变更的方法，比直接看 `tr.changes` 的内部结构要安全得多。

---

### 二、 选区进阶：Goal Column 与 Association

`SelectionRange` 不仅仅是 `from` 和 `to`。

#### 1. `goalColumn: number`

- **场景**：实现“向上/向下移动光标”的自定义命令。
- **细节**：当你从一行长文本移动到一行短文本，再移动回长文本时，光标应该回到原来的列。这个“原始列”就存储在 `goalColumn` 中。
- **最佳实践**：在手动修改选区时，如果希望保持垂直对齐，记得保留或设置这个值。

#### 2. `assoc: number`

- **场景**：处理换行（Line Wrapping）时的光标位置。
- **细节**：当光标位于自动换行的行尾时，它是在上一行的末尾还是下一行的开头？`assoc` 为负表示关联前一个字符，为正表示关联后一个字符。

---

### 三、 挂件性能优化：WidgetType 的高级方法

在 `WidgetType` 中，除了 `toDOM`，还有两个方法决定了编辑器的流畅度：

#### 1. `eq(other: WidgetType): boolean`

- **场景**：编辑器重绘时。
- **细节**：CM6 会调用 `eq` 比较新旧 Widget。如果返回 `true`，它会**复用**现有的 DOM 节点，而不是销毁重建。
- **最佳实践**：永远实现 `eq`，比较你的 Widget 属性。

#### 2. `updateDOM(dom: HTMLElement): boolean`

- **场景**：Widget 的数据变了，但你不想重新创建整个 DOM。
- **细节**：如果 `eq` 返回 `false`，CM6 会尝试调用 `updateDOM`。你可以在这里手动修改 DOM 属性并返回 `true`。

---

### 四、 状态效果映射：StateEffect.map

**场景**：你在 `StateField` 中存储了一些带位置的 `StateEffect`（比如一个临时的闪烁高亮）。

- **细节**：很多人记得映射 `pos`，但忘了 `StateEffect` 本身也需要映射。
- **API**：`effect.map(mapping: ChangeDesc)`。
- **最佳实践**：
  ```typescript
  update(effects, tr) {
    // 必须映射旧的 effects，否则它们的位置会漂移
    effects = effects.map(e => e.map(tr.changes)).filter(e => e != undefined)
    // ... 处理新 effects ...
  }
  ```

---

### 五、 侧边栏与标记：Gutter & GutterMarker

**场景**：实现类似 VS Code 的断点、修改痕迹（Git Gutter）。

- **`GutterMarker`**：类似于 `WidgetType`，但用于侧边栏。
- **`toDOM`**：返回侧边栏显示的图标。
- **`elementAttributes`**：可以给侧边栏的这一行容器添加 CSS 类（例如高亮整行行号）。
- **交互**：在 `gutter` 配置中使用 `domEventHandlers` 监听侧边栏的点击。

---

### 六、 命令接口 (Command) 的本质

在 CM6 中，`Command` 的定义非常简单：`(view: EditorView) => boolean`。

- **细节**：
  - 返回 `true`：表示命令已执行，停止后续处理。
  - 返回 `false`：表示命令不适用，继续尝试其他快捷键绑定。
- **最佳实践**：编写自定义命令时，第一步通常是检查 `view.state.readOnly`。

---

### 七、 错误处理：exceptionSink

**场景**：插件代码报错了，导致整个编辑器崩溃或白屏。

- **API**：`EditorView.exceptionSink` (这是一个 Facet)。
- **细节**：你可以提供一个函数来捕获编辑器内部抛出的异步错误（如在 `update` 循环中发生的错误）。
- **最佳实践**：在生产环境中，将这些错误上报到 Sentry。

---

### 八、 视图可见性：visibleRanges

**场景**：实现超高性能的实时预览。

- **API**：`view.visibleRanges`。
- **细节**：返回一个数组 `[{from, to}, ...]`，表示当前用户在屏幕上**真正看到**的代码范围。
- **注意**：由于虚拟滚动，这个范围通常比你想象的要小。利用它来跳过不可见区域的昂贵计算。

---

### 九、 总结：API 深度图谱

| 领域         | 进阶 API            | 解决的问题                   |
| :----------- | :------------------ | :--------------------------- |
| **变更逻辑** | `ChangeSet.compose` | 多个变更的原子化合并         |
| **选区行为** | `goalColumn`        | 跨行移动时的列对齐           |
| **DOM 性能** | `Widget.updateDOM`  | 避免 Widget 频繁销毁重建     |
| **状态同步** | `Effect.map`        | 确保非文档数据随文档同步偏移 |
| **侧边栏**   | `GutterMarker`      | 实现断点、Git 状态等交互     |
| **健壮性**   | `exceptionSink`     | 插件报错不影响主线程         |

这些 API 是构建专业级编辑器插件的最后拼图。理解了它们，你就能处理诸如“如何在用户打字时保持 10 万个标记的位置正确”或“如何实现丝滑的侧边栏交互”等高级课题。

---

这是 CodeMirror 6 API 盘点的**最后一块拼图**。我们将深入探讨那些涉及**底层交互拦截、无障碍、国际化以及视觉布局**的高级 API。

---

### 一、 拦截底层输入：`EditorView.inputHandler`

**场景**：你希望在用户输入特定字符（如 `@` 或 `/`）时，不让它直接进入编辑器，而是弹出你自己的菜单，或者根据输入内容动态改变逻辑。

- **API**: `EditorView.inputHandler.of((view, from, to, text) => boolean)`
- **细节**：它在 Transaction 产生之前触发。如果返回 `true`，CodeMirror 会认为你已经处理了这次输入，从而**阻止**默认的字符插入。
- **最佳实践**：用于实现类似 Notion 的命令菜单触发器。

---

### 二、 原子范围：`EditorView.atomicRanges`

**场景**：你用 `Decoration.replace` 隐藏了一段代码并显示为一个图标。你希望用户按左右方向键时，光标能**一次性跳过**整个图标，而不是进入被隐藏的文本内部。

- **API**: `EditorView.atomicRanges.of(view => RangeSet<any>)`
- **细节**：被包含在 Atomic Range 中的区域，在光标移动和选区操作时会被视为一个不可分割的单元。
- **最佳实践**：配合 `Widget` 使用，提供类似“胶囊标签”的交互体验。

---

### 三、 逻辑行 vs 视觉行：`lineBlockAt`

**场景**：开启了 `lineWrapping`（自动换行）后，一行很长的代码在屏幕上显示为 3 行。你想知道光标所在的**那一个视觉行**的顶部坐标。

- **API**: `view.lineBlockAt(pos)`
- **细节**：
  - `state.doc.lineAt(pos)` 返回的是**逻辑行**（以 `\n` 分隔）。
  - `view.lineBlockAt(pos)` 返回的是**视觉块**（考虑了自动换行和 Widget 占位）。
- **最佳实践**：在计算浮动菜单位置时，使用 `lineBlockAt` 能避免在换行处出现位置偏移。

---

### 四、 国际化与本地化：`EditorState.phrases`

**场景**：你想把编辑器内置的右键菜单、搜索框提示词（如 "Find", "Replace"）翻译成中文。

- **API**: `EditorState.phrases.of({ "Find": "查找", "Replace": "替换" })`
- **细节**：这是一个 Facet。CM6 内部所有的 UI 字符串都通过 `state.phrase(key)` 获取。
- **最佳实践**：在创建 `EditorState` 时注入语言包。

---

### 五、 访问插件实例：`view.plugin()`

**场景**：你在 `ViewPlugin` 里维护了一些复杂的内部状态（比如一个 WebSocket 连接），你想在编辑器外部通过按钮调用这个插件的方法。

- **API**: `view.plugin(pluginValue)`
- **细节**：
  ```typescript
  const myPlugin = ViewPlugin.fromClass(class { ... });
  // 外部获取实例
  const pluginInstance = view.plugin(myPlugin);
  pluginInstance?.doSomething();
  ```
- **注意**：如果插件因为配置原因没被加载，返回 `null`。

---

### 六、 精确滚动控制：`scrollIntoView`

**场景**：搜索跳转时，你不仅希望光标过去，还希望该行滚动到屏幕的**正中间**，而不是仅仅贴在边缘。

- **API**: `EditorView.scrollIntoView(pos, options)`
- **细节**：
  - `y: "center"`: 垂直居中。
  - `y: "nearest"`: 只要可见就不滚动。
  - `x: "center"`: 水平居中。
- **用法**：
  ```typescript
  view.dispatch({
    effects: EditorView.scrollIntoView(pos, { y: 'center' })
  })
  ```

---

### 七、 DOM 与位置的互转：`posAtDOM` & `nodeDOM`

**场景**：你监听了一个全局的 `click` 事件，拿到了一个 `event.target`（DOM 节点），你想知道这个节点对应编辑器里的哪个字符位置。

- **API**:
  - `view.posAtDOM(node, offset)`: DOM 转位置。
  - `view.nodeDOM(pos)`: 位置转最近的父级 DOM 节点。
- **细节**：这是处理复杂拖拽、右键菜单定位的底层工具。

---

### 八、 无障碍与属性注入：`contentAttributes`

**场景**：你需要为编辑器添加 `aria-label`，或者在特定情况下禁用拼写检查 (`spellcheck="false"`)。

- **API**:
  - `EditorView.contentAttributes.of({ ... })`: 作用于可编辑区域。
  - `EditorView.editorAttributes.of({ ... })`: 作用于编辑器外层容器。
- **最佳实践**：用于提升编辑器的无障碍（Accessibility）评分。

---

### 九、 字符与组移动逻辑：`moveByChar` & `moveByGroup`

**场景**：你想实现一个自定义命令，按下某个键时，光标向后跳过一个“单词”或一个“字符”。

- **API**: `view.moveByChar(range, forward, filter)`
- **细节**：它会考虑双向文本（Bidi）和复杂的字符组合，比简单的 `pos + 1` 要健壮得多。

---

### 🏁 终极总结：如何进阶为 CodeMirror 专家？

如果你已经掌握了以上所有 API，你已经超越了 95% 的 CodeMirror 用户。进阶的最后一步是：

1.  **阅读源码中的 `Facet` 定义**：CM6 的大部分功能都是通过 Facet 组合的，看源码能理解它们是如何互相影响的。
2.  **掌握 Lezer 语法解析**：如果你能自己写 `.grammar` 文件，你就能为任何私有协议编写高性能的语言包。
3.  **关注 `Transaction.changes.iterChanges`**：这是理解“增量更新”灵魂的关键，也是写出高性能插件的基石。

CodeMirror 6 不仅仅是一个编辑器，它是一个**用于构建编辑器的框架**。希望这份深度盘点能助你一臂之力！

---

确实还有一些非常关键、但在常规教程中往往被一笔带过的“进阶 API”。这些 API 通常是解决**复杂交互、性能瓶颈或底层集成**的最后钥匙。

以下是 CodeMirror 6 API 盘点的**终极补充**：

---

### 一、 变更过滤器 vs 事务过滤器 (ChangeFilter vs TransactionFilter)

很多人只知道 `transactionFilter`，但其实还有一个更细粒度的 `changeFilter`。

- **`EditorState.changeFilter`**:
  - **场景**：你只想拦截**文本内容的修改**，而不关心选区移动或 Effect。
  - **细节**：它只针对 `tr.changes`。如果返回 `false`，该事务中的所有文本变更都会被丢弃，但事务的其他部分（如选区改变）可能仍然有效。
- **`EditorState.transactionFilter`**:
  - **场景**：拦截**整个事务**。
  - **细节**：如果返回空数组 `[]`，整个事务被彻底取消。

---

### 二、 事务扩展器 (TransactionExtender)

**场景**：当用户执行某个操作时，你希望**自动附加**一个额外的效果。例如：当用户输入 TODO 时，自动给这个事务加上一个“提醒”的 `StateEffect`。

- **API**: `EditorState.transactionExtender.of(tr => ExtensionSpec)`
- **细节**：它允许你在事务被应用之前，动态地向其中注入新的 `effects`、`annotations` 甚至 `selection`。
- **区别**：`Filter` 是用来“减”东西的，`Extender` 是用来“加”东西的。

---

### 三、 语法解析的同步控制：`ensureSyntaxTree`

**场景**：你需要立即获取完整的语法树（AST）来执行复杂的逻辑（如重构、全量校验），但 CM6 的解析是异步且分片的。

- **API**: `ensureSyntaxTree(state, limit, timeout)`
- **细节**：
  - 如果语法树还没解析完，这个函数会尝试在给定的 `timeout` 时间内强制同步解析。
  - 如果解析太耗时，它可能只返回部分树。
- **最佳实践**：在执行“保存前校验”或“重命名变量”等需要完整 AST 的操作时使用。

---

### 四、 正则装饰器助手：`MatchDecorator`

**场景**：你需要根据正则表达式高亮某些内容（如 URL、自定义标签 `[[tag]]`）。

- **API**: `new MatchDecorator({ regexp, decoration, boundary, ... })`
- **细节**：手动写 `ViewPlugin` 去遍历视口、匹配正则、管理装饰器非常繁琐。`MatchDecorator` 封装了所有这些逻辑。
- **用法**：
  ```typescript
  const decorator = new MatchDecorator({
    regexp: /\[\[(.+?)\]\]/g,
    decoration: m => Decoration.mark({ class: 'custom-tag' })
  })
  // 在 ViewPlugin 的 update 中直接调用 decorator.update
  ```

---

### 五、 兼容旧版：`StreamLanguage`

**场景**：你需要支持一种非常冷门的语言，CM6 还没有对应的 Lezer 解析器，但 CM5 有。

- **API**: `StreamLanguage.define(legacyMode)`
- **细节**：它允许你将 CodeMirror 5 的模式（Mode）包装成 CodeMirror 6 的扩展。
- **代价**：它不产生真正的语法树（AST），因此无法支持高级的语法感知功能，且性能略低于 Lezer。

---

### 六、 滚动快照：`scrollSnapshot`

**场景**：在单页应用（SPA）中，用户切换页面后再切回来，你希望编辑器恢复到**完全一致**的滚动位置。

- **API**: `view.scrollSnapshot()`
- **细节**：它捕捉当前的滚动偏移。当你重新创建 `EditorView` 或恢复状态时，可以将其作为配置传入。
- **注意**：这比简单的 `scrollTop` 更健壮，因为它能处理行高变化和异步渲染。

---

### 七、 字符分类器：`charCategorizer`

**场景**：你想定义什么是“单词”。例如，在某些业务中，`user-id` 应该被视为一个单词，而不是两个单词。

- **API**: `state.charCategorizer(pos)`
- **细节**：它返回一个函数，用于判断字符属于哪一类（单词、空格、标点）。
- **应用**：这直接影响双击选中的范围、`Ctrl + Left/Right` 跳跃的步长。

---

### 八、 强制视图更新：`requestUpdate`

**场景**：你通过外部手段（非 `dispatch`）修改了某些影响编辑器显示的东西（比如修改了某个全局 CSS 变量，或者外部数据源变了）。

- **API**: `view.requestUpdate()`
- **细节**：它会告诉编辑器在下一个动画帧执行一次完整的 `update` 循环，触发所有插件的 `update` 钩子。

---

### 九、 测量文本宽度：`measureText`

**场景**：你需要计算一段字符串在当前编辑器字体下占用的像素宽度（用于精确定位浮动 UI）。

- **API**: `view.measureText(text, prec)`
- **细节**：它利用编辑器内部的测量机制，比你自己创建一个隐藏的 `div` 去测量要准确得多，因为它考虑了编辑器的字体、字号、缩放等所有样式。

---

### 十、 总结：最后的技术边界

| API                       | 核心价值                          |
| :------------------------ | :-------------------------------- |
| **`changeFilter`**        | 精确控制“谁能改动我的代码”        |
| **`transactionExtender`** | 实现自动化的联动效果              |
| **`ensureSyntaxTree`**    | 解决异步解析带来的数据不一致      |
| **`MatchDecorator`**      | 极速开发正则高亮功能              |
| **`StreamLanguage`**      | 桥接 CM5 生态，解决语言支持覆盖率 |
| **`charCategorizer`**     | 定制编辑器的“分词”逻辑            |

至此，我们已经从**宏观架构**到**微观 API**，从**业务场景**到**底层原理**，对 CodeMirror 6 进行了全方位的深度拆解。

**最后的建议**：CodeMirror 6 的设计哲学是“组合优于继承”。当你觉得某个功能很难实现时，通常是因为你试图在一个组件里做太多事。尝试将其拆分为 `StateField`（存数据）、`ViewPlugin`（画 UI）和 `Facet`（传配置），一切都会豁然开朗。

---

确实还有一些非常硬核且在特定业务场景（如：复杂 IDE、多语言编辑器、高性能可视化工具）中起决定性作用的 API。

以下是 CodeMirror 6 API 盘点的**最后一次深度补充**：

---

### 一、 坐标计算的“最后一公里”：`side` 参数

在调用 `posAtCoords` 或 `coordsAtPos` 时，很多人忽略了 `side` 参数，这在处理**光标位置判定**时至关重要。

- **`view.posAtCoords({x, y}, side)`**:
  - **场景**：用户点击了一个字符的左半部分还是右半部分？
  - **细节**：`side` 为 `-1` 倾向于返回前一个位置，`1` 倾向于后一个。
- **`view.coordsAtPos(pos, side)`**:
  - **场景**：在换行处，光标是在第一行的末尾还是第二行的开头？
  - **细节**：对于同一个 `pos`（换行符位置），`side: -1` 返回上一行末尾的坐标，`side: 1` 返回下一行开头的坐标。
  - **最佳实践**：在实现自定义光标或浮动菜单时，必须根据业务逻辑选择 `side`，否则菜单会跳动。

---

### 二、 动态语言加载：`LanguageDescription`

**场景**：你正在做一个类似 GitHub 的编辑器，需要支持 100 种语言。你不可能一次性把所有语言包都 import 进来。

- **API**: `LanguageDescription` 类。
- **细节**：它允许你定义语言的元数据（名称、别名、扩展名）以及一个**异步加载函数**。
- **最佳实践**：

  ```typescript
  import { languages } from '@codemirror/language-data'
  import { LanguageDescription } from '@codemirror/language'

  // 根据文件名查找语言描述
  let desc = LanguageDescription.matchFilename(languages, 'script.js')
  if (desc) {
    let lang = await desc.load() // 只有在这里才会真正下载/加载语言包
    view.dispatch({
      effects: languageCompartment.reconfigure(lang)
    })
  }
  ```

---

### 三、 语法树的“元数据”：NodeProp

**场景**：你正在写一个语法高亮插件，你想知道某个节点是否是“函数定义”，但不想硬编码节点名称（因为不同语言节点名不同）。

- **API**: `NodeProp`
- **细节**：Lezer 语法树的节点可以携带属性。例如 `openedBy` / `closedBy` 用于括号匹配。
- **自定义属性**：你可以给节点绑定自定义数据。
  ```typescript
  const myProp = new NodeProp<boolean>()
  // 在解析器中给特定节点打标签
  // 在插件中读取：tree.type.prop(myProp)
  ```

---

### 四、 样式与语法的桥梁：HighlightStyle & tags

**场景**：你想定义一种新的高亮类型（比如“敏感词”），并希望它能被主题系统识别。

- **API**: `Tag` 与 `HighlightStyle`
- **细节**：
  1.  定义一个 `Tag`: `let myTag = Tag.define()`。
  2.  在语法解析或装饰器中分配这个 `Tag`。
  3.  在主题中使用 `HighlightStyle.define([{tag: myTag, color: "red"}])`。
- **核心价值**：它解耦了**语法分析**（这是什么东西）和**视觉表现**（它长什么样）。

---

### 五、 滚动边距：`EditorView.scrollMargins`

**场景**：你的编辑器顶部有一个固定的浮动工具栏（Sticky Header），或者底部有一个状态栏。当光标移动到顶部时，它会被工具栏遮住。

- **API**: `EditorView.scrollMargins.of(view => ({top: 50, bottom: 20}))`
- **细节**：它告诉编辑器在执行 `scrollIntoView` 时，预留出多少像素的“安全区域”。
- **最佳实践**：如果你的 UI 遮挡了编辑器区域，必须配置这个 Facet。

---

### 六、 解决缩放偏移：`EditorView.scale`

**场景**：你的编辑器放在一个经过 CSS `transform: scale(0.8)` 缩放的容器里。你会发现点击位置全乱了。

- **API**: `EditorView.scale` (Facet)
- **细节**：CM6 默认假设缩放比例是 1。如果容器有缩放，你需要通过这个 Facet 告诉编辑器当前的缩放比例。
- **最佳实践**：在响应式布局或大屏展示中，如果涉及缩放，这是必填项。

---

### 七、 跨平台换行符：`EditorState.lineSeparator`

**场景**：你的后端只接受 `\r\n` (Windows)，但浏览器默认处理的是 `\n`。

- **API**: `EditorState.lineSeparator.of("\r\n")`
- **细节**：设置后，`state.doc.line(n)` 会根据这个分隔符来拆分行，且 `toString()` 也会使用它。
- **注意**：默认情况下 CM6 会自动检测，但显式指定可以避免跨平台协作时的格式混乱。

---

### 八、 快捷键的精细控制：`preventDefault` 与 `stopPropagation`

在 `KeyBinding` 对象中，除了 `run`，还有两个容易被忽视的属性：

- **`preventDefault: boolean`**: 默认为 `true`。如果设为 `false`，即使你的命令执行了，浏览器默认行为（如浏览器的搜索框）仍会触发。
- **`stopPropagation: boolean`**: 是否阻止事件冒泡到父容器。
- **`any: (view, event) => boolean`**: 这是一个万能匹配器，可以捕获任何按键。

---

### 九、 视图更新的“指纹”：`ViewUpdate.startState`

**场景**：在 `update` 钩子中，你想对比“这次更新之前”和“这次更新之后”的某个复杂状态。

- **API**: `update.startState`
- **细节**：`update.state` 是更新后的状态，`update.startState` 是更新前的状态。
- **最佳实践**：用于检测某些非文档内容的 Facet 或 StateField 是否发生了变化。

---

### 十、 总结：CodeMirror 6 的设计哲学

到这里，我们几乎翻遍了 CodeMirror 6 的所有核心 API。你会发现 CM6 的设计极其强调**显式性（Explicitness）**：

1.  **没有魔法**：位置不会自动更新，必须手动 `map`。
2.  **没有全局变量**：所有配置都通过 `Facet` 注入。
3.  **读写分离**：通过 `requestMeasure` 保护性能。
4.  **数据驱动**：视图只是状态的函数。

**最后的一点建议**：
如果你在开发中遇到瓶颈，最好的办法是去 GitHub 搜索 `@codemirror/` 相关的官方仓库（如 `view`, `state`, `language`）。CM6 的源码注释非常详尽，很多高级用法其实就藏在源码的类型定义里。

祝你在 CodeMirror 6 的开发中游刃有余！

---

这是 CodeMirror 6 API 盘点的**终极进阶篇**。我们将触及那些支撑起 CM6 灵活性底座、但在日常开发中极少被提及的“幕后英雄” API。

---

### 一、 高效查询：`RangeSet.between`

**场景**：你有一万个高亮标记（Decorations），现在你想知道用户点击的 `pos` 附近 100 个字符内有哪些标记。

- **API**: `rangeSet.between(from, to, (from, to, value) => { ... })`
- **细节**：
  - 不要使用 `iter()` 然后手动判断位置，那依然是 `O(N)`。
  - `between` 利用了内部的平衡树结构，查询效率是 **`O(log N + M)`**（M 是范围内标记的数量）。
- **最佳实践**：在实现“点击标记弹出菜单”或“局部语法检查”时，这是性能最优解。

---

### 二、 混合文本方向：Bidi (Bidirectional Text)

**场景**：你的编辑器需要支持阿拉伯语（RTL）和英语（LTR）混合输入。

- **API**: `view.bidiSpans(line)` 与 `EditorView.perLineTextDirection`
- **细节**：
  - CM6 内部有一套复杂的算法来处理双向文本的渲染顺序。
  - `bidiSpans` 可以让你获取一行中哪些部分是向左读的，哪些是向右读的。
- **最佳实践**：如果你在做国际化编辑器，且需要自定义光标移动逻辑，必须理解 Bidi Span。

---

### 三、 深入 DOM 结构：`scrollDOM` vs `contentDOM`

**场景**：你想给编辑器加一个背景水印，或者实现一个跟随滚动的侧边栏。

- **API**:
  - `view.scrollDOM`: 负责滚动的容器（通常设置 `overflow: auto`）。
  - `view.contentDOM`: 真正承载文本内容的容器（`contenteditable="true"`）。
  - `view.dom`: 编辑器的最外层包装容器。
- **细节**：
  - 如果你想监听滚动事件，应该在 `scrollDOM` 上挂载。
  - 如果你想修改字体样式，应该作用于 `contentDOM`。

---

### 四、 虚拟选区渲染：`drawSelection`

**场景**：你觉得原生浏览器的光标太丑，或者在多光标模式下，原生选区渲染有 Bug。

- **API**: `@codemirror/view` 中的 `drawSelection()` 扩展。
- **细节**：
  - CM6 默认会隐藏原生光标，并用一个绝对定位的 `div` 来模拟光标。
  - 这允许你通过 CSS 自由定制光标的颜色、宽度、甚至闪烁动画。
- **最佳实践**：几乎所有专业的 CM6 集成都会开启这个扩展。

---

### 五、 Facet 的高级合并逻辑：`combine`

**场景**：你定义了一个 Facet 来收集所有插件提供的“关键词列表”，但你希望最后的结果是**去重后排序**的数组。

- **API**: `Facet.define({ combine: (values) => ... })`
- **细节**：
  - `values` 是一个数组，包含了所有扩展通过 `.of()` 传入的值。
  - 你可以返回任何类型：数组、对象、甚至是单个布尔值（如：只要有一个插件要求只读，最终结果就是只读）。
- **示例**：
  ```typescript
  const myFacet = Facet.define<string[], string[]>({
    combine: values => Array.from(new Set(values.flat())).sort()
  })
  ```

---

### 六、 语法树的内存优化：Tree vs Buffer

**场景**：你正在处理一个超大型文件，发现语法树占用了几百 MB 内存。

- **API**: `Lezer` 的 `Buffer` 机制。
- **细节**：
  - `Tree`: 完整的树结构，每个节点都是对象，方便遍历但耗内存。
  - `Buffer`: 将语法节点存储在 `Uint16Array` 中，极度节省内存。
- **最佳实践**：在编写 Lezer Parser 时，对于重复性极高的简单节点（如：单个字符、空白符），应配置为存储在 Buffer 中。

---

### 七、 库作者必备：`EditorView.baseTheme`

**场景**：你正在编写一个开源的 CodeMirror 插件，你想提供默认样式，但又不想让用户难以覆盖。

- **API**: `EditorView.baseTheme({ ... })`
- **细节**：
  - `theme()` 定义的样式优先级很高，带哈希类名。
  - `baseTheme()` 定义的是基础样式，优先级最低，用户通过普通的 CSS 或 `theme()` 可以轻松覆盖。
- **最佳实践**：插件开发者应始终使用 `baseTheme`。

---

### 八、 自定义事务类型：`Transaction.userEvent`

**场景**：你实现了一个“自动格式化”功能，你希望这个操作在撤销栈（Undo History）中被视为一个独立的类型，或者在协同编辑中被特殊处理。

- **API**: `Transaction.userEvent.of("format.myPlugin")`
- **细节**：
  - 你可以自定义任何字符串作为事件类型。
  - `history` 插件会根据这些标签来决定是否合并撤销步骤。
- **最佳实践**：为你的插件操作定义唯一的 `userEvent` 标签。

---

### 九、 文本行的物理高度：`view.lineBlockAt` 的返回值

**场景**：你需要精确计算编辑器中第 100 行到第 200 行一共占了多少像素高度。

- **细节**：`lineBlockAt` 返回的 `BlockInfo` 包含：
  - `top`, `bottom`: 物理像素坐标。
  - `height`: 该块的高度（包含换行）。
- **注意**：由于虚拟滚动，不在视口内的行高度是**估算值**。只有当行进入视口后，高度才会变为精确值。

---

### 十、 终极调试利器：`EditorView.perLineTextDirection`

**场景**：在处理混合语言时，某些行需要从左往右，某些行需要从右往左。

- **细节**：这是一个 Facet，允许你根据行内容动态决定该行的渲染方向。

---

### 💡 最后的架构建议

CodeMirror 6 的 API 体系非常庞大，但其核心逻辑始终围绕着 **“状态（State）的演变”**。

如果你发现自己在频繁地操作 DOM，或者在 `ViewPlugin` 里写了大量的逻辑，请停下来思考一下：**“我能不能把这些逻辑移到 `StateField` 里？”**

- **StateField** 是大脑（逻辑、数据、持久化）。
- **ViewPlugin** 是手脚（渲染、事件、DOM）。
- **Facet** 是神经系统（配置、通信）。

当你能清晰地划分这三者时，你就已经真正掌握了 CodeMirror 6。

这是 CodeMirror 6 API 盘点的**最后一块拼图**。我们将目光聚焦在**无障碍访问 (A11y)**、**代码智能的高级控制**、**格式化细节**以及**生命周期管理**上。这些 API 往往决定了一个编辑器是否“专业”和“好用”。

---

### 一、 无障碍访问：`EditorView.announce`

**场景**：当自动补全弹窗出现、或者代码中有错误时，屏幕阅读器（Screen Reader）通常无法感知。你需要主动通知视障用户。

- **API**: `view.announce(messages: string[])`
- **细节**：
  - 它会将消息写入一个隐藏的 `aria-live` 区域，触发屏幕阅读器朗读。
  - **用法**：
    ```typescript
    // 当用户执行了一个复杂操作（如重构）完成时
    view.announce(['重构完成，修改了 5 处代码'])
    ```
- **最佳实践**：在编写自定义 UI（如搜索面板、提示框）时，务必使用此 API 增强可访问性。

---

### 二、 缩进与制表符的权威控制：`indentUnit` vs `tabSize`

很多开发者分不清这两个 Facet 的区别。

#### 1. `EditorState.tabSize`

- **定义**：一个 `\t` (Tab 字符) 在屏幕上**看起来**等于几个空格的宽度。
- **默认值**：4。
- **影响**：只影响视觉渲染，不改变文档内容。

#### 2. `indentUnit`

- **定义**：当用户按下回车换行并自动缩进时，或者按下 Tab 键（如果配置为插入空格）时，应该插入**什么字符串**。
- **默认值**：2 个空格。
- **用法**：

  ```typescript
  import { indentUnit } from '@codemirror/language'
  import { EditorState } from '@codemirror/state'

  let state = EditorState.create({
    extensions: [
      // 设定：按 Tab 插入 4 个空格
      indentUnit.of('    '),
      // 设定：Tab 字符显示为 8 个空格宽（如果文档里真有 \t 的话）
      EditorState.tabSize.of(8)
    ]
  })
  ```

- **最佳实践**：始终显式配置 `indentUnit`，不要依赖默认值。

---

### 三、 自动补全的高级控制：`Completion` 对象

在 `autocomplete` 扩展中，返回的候选项 (`Completion`) 除了 `label` 和 `type`，还有几个强大的属性：

#### 1. `boost: number`

- **场景**：你希望“最近使用过的变量”排在补全列表的最前面。
- **细节**：CodeMirror 默认根据匹配度排序。`boost` 可以给特定选项加权。正数提升排名，负数降低排名。

#### 2. `apply: string | ((view, completion, from, to) => void)`

- **场景**：用户选中 "log" 时，你希望插入 `console.log(|)` 并将光标放在括号里。
- **细节**：
  - 如果是字符串，直接替换。
  - 如果是函数，你可以执行任意 Transaction（插入文本、移动光标、甚至触发另一个补全）。
  - **示例**：
    ```typescript
    apply: (view, completion, from, to) => {
      view.dispatch({
        changes: { from, to, insert: 'console.log()' },
        selection: { anchor: from + 12 } // 光标放括号里
      })
    }
    ```

#### 3. `info: string | ((completion) => DOM)`

- **场景**：显示函数的文档注释或 Markdown 说明。
- **细节**：支持返回一个 Promise（异步加载文档）或直接返回 DOM 节点。

---

### 四、 错误诊断的“快速修复”：`Diagnostic.actions`

**场景**：Linter 发现了一个错误（如“变量未定义”），你希望提供一个“自动导入”或“声明变量”的按钮。

- **API**: `Diagnostic` 对象的 `actions` 属性。
- **结构**：
  ```typescript
  interface Action {
    name: string
    apply: (view: EditorView, from: number, to: number) => void
  }
  ```
- **效果**：当用户在错误处按下快捷键（通常是 `Mod-.`）或点击错误提示时，会执行 `apply` 函数。

---

### 五、 矩形选区 (Column Selection)：`rectangularSelection`

**场景**：用户想同时编辑多行代码的第 10 列（例如批量删除行首注释）。

- **API**: `rectangularSelection()` 扩展。
- **用法**：
  - 加载此扩展后，用户按住 `Alt` (macOS 是 `Option`) 并拖动鼠标，即可创建矩形选区。
  - 这会生成多个 `SelectionRange`。
- **交互**：配合 `crosshairCursor()` 使用，可以在按住修饰键时将鼠标指针变为十字准星，提升体验。

---

### 六、 语法树的非阻塞检查：`syntaxTreeAvailable`

**场景**：你的插件依赖语法树，但不想在树还没解析好时强制解析（这会阻塞主线程，导致卡顿）。

- **API**: `syntaxTreeAvailable(state, pos)`
- **细节**：
  - 返回 `boolean`。
  - 如果返回 `false`，说明解析器还在后台忙活。此时你可以选择跳过逻辑，或者显示一个“Loading...”状态，而不是调用 `ensureSyntaxTree` 阻塞界面。

---

### 七、 编辑器销毁：`view.destroy()`

**场景**：在 React/Vue/Angular 单页应用中，组件卸载时。

- **API**: `view.destroy()`
- **细节**：
  - 这非常重要！它会清理全局事件监听器（如 `resize`, `focus`）、停止后台解析器、销毁所有插件。
  - **后果**：如果不调用，会导致严重的内存泄漏，且旧的编辑器实例可能继续响应快捷键。

---

### 八、 特殊字符高亮：`highlightSpecialChars`

**场景**：用户复制了一段代码，里面包含不可见的“零宽空格”或控制字符，导致代码跑不通。

- **API**: `highlightSpecialChars()`
- **细节**：
  - 它会自动将不可见字符渲染为一个红色的占位符（通常是一个小点或 unicode 码）。
  - 你可以自定义 `render` 函数来改变这些字符的显示方式。

---

### 九、 读写权限的细粒度控制：`EditorView.editable`

我们之前提到了 `EditorState.readOnly`，但还有一个 `EditorView.editable`。

- **`EditorState.readOnly`**:
  - 数据层面的只读。
  - 禁止任何修改文档的 Transaction。
  - **副作用**：通常也会禁用一些编辑相关的插件行为。
- **`EditorView.editable`**:
  - DOM 层面的只读。
  - 控制编辑器根元素的 `contenteditable` 属性。
  - **场景**：你想让编辑器看起来像一个普通的 `div`（不可聚焦、不可编辑），但仍然想通过代码 (`view.dispatch`) 修改它。

---

### 十、 总结：CodeMirror 6 API 完整版图

至此，我们已经构建了一个完整的 CodeMirror 6 知识体系：

1.  **骨架**：`EditorState`, `EditorView`, `Transaction`
2.  **肌肉**：`StateField` (记忆), `ViewPlugin` (交互)
3.  **皮肤**：`Decoration`, `Theme`, `Gutter`
4.  **神经**：`Facet` (配置), `Event Handlers`
5.  **大脑**：`Lezer` (语法树), `Language Data`
6.  **工具**：`RangeSet`, `ChangeSet`, `A11y`

**最后的建议**：
CodeMirror 6 是一个**“组装式”**的编辑器框架。它没有“默认行为”，只有“默认扩展”。当你觉得它“缺了什么功能”时，99% 的情况是有一个官方扩展包 (`@codemirror/xxx`) 专门解决这个问题，或者你需要通过 `Facet` 注入一行配置。

不要试图 hack DOM，**Trust the State, Trust the Transaction.**

---

CodeMirror 6 本身的核心设计是**同步**的（Transaction -> State Update -> View Update），这是为了保证状态的一致性和可预测性。

但是，在实际业务中（特别是结合 React/Vue 或处理外部异步数据流时），确实存在“异步批量更新”的需求。CodeMirror 并没有一个名为 `asyncDispatch` 的原生 API，但它提供了几种机制来实现**异步场景下的批量更新与防抖**。

以下是实现“异步批量更新”的三种标准流程：

### 1. 外部防抖 (Debouncing) + 批量 Dispatch

这是最常见、最简单的模式。适用于“短时间内收到大量外部事件（如 WebSocket 消息、协同编辑操作），需要合并后一次性渲染”的场景。

**流程：**

1.  创建一个缓冲队列（Buffer）。
2.  收到事件时，不立即 `dispatch`，而是推入队列。
3.  使用 `requestAnimationFrame` 或 `setTimeout` 触发真正的更新。

**代码示例：**

```typescript
let updateQueue: any[] = []
let pendingFrame: number | null = null

function scheduleUpdate(change: any) {
  updateQueue.push(change)

  if (pendingFrame === null) {
    pendingFrame = requestAnimationFrame(() => {
      // 1. 合并队列中的所有变更
      // 注意：如果是纯文本变更，需要小心处理坐标偏移
      // 建议使用 ChangeSet.compose 或者简单的全量替换（如果性能允许）
      // 或者如果是协同编辑，通常使用 Yjs/CRDT 库自带的 batch 机制

      const transactionSpec = {
        changes: updateQueue // 假设 updateQueue 里存的是 {from, insert} 对象
        // 可以在这里添加 annotations: Transaction.addToHistory.of(false)
      }

      // 2. 一次性 Dispatch
      view.dispatch(transactionSpec)

      // 3. 清理
      updateQueue = []
      pendingFrame = null
    })
  }
}

// 业务调用
scheduleUpdate({ from: 0, insert: 'A' })
scheduleUpdate({ from: 1, insert: 'B' }) // 这里的坐标需要注意，通常建议使用相对坐标或协同库
```

### 2. 协同编辑场景下的 `y-codemirror` 批量机制

如果你是在做协同编辑（这是最需要异步批量更新的场景），不要自己手写防抖。`y-codemirror` 结合 `Yjs` 已经内置了事务批处理。

**流程：**

1.  Yjs 接收到网络传来的多个 update。
2.  Yjs 内部会进行 `transact`。
3.  `y-codemirror` 监听 Yjs 的变化，将这一批变化转换为**一个** CodeMirror Transaction。

**最佳实践：**
如果你需要手动修改 Yjs 数据并希望 CM6 只更新一次：

```typescript
// doc 是 Yjs 的 Document
doc.transact(() => {
  // 在这里做任意多的 Yjs 修改
  yText.insert(0, 'A')
  yText.insert(1, 'B')
  // ...
})
// 事务结束时，y-codemirror 会收到一次通知，并只触发一次 view.dispatch
```

### 3. 视图层面的“异步”渲染：`requestMeasure` (读写分离)

虽然 `dispatch` 是同步的，但涉及 DOM 测量和布局调整时，为了避免浏览器强制重排（Layout Thrashing），CM6 提供了异步的读写分离机制。这不算“批量更新数据”，但算“批量更新视图”。

**流程：**

1.  调用 `view.requestMeasure`。
2.  CM6 等待下一个动画帧。
3.  执行 `read` 回调（安全读取 DOM）。
4.  执行 `write` 回调（安全修改 DOM）。

**代码示例：**

```typescript
// 假设你有 100 个地方需要根据光标位置更新 UI
for (let i = 0; i < 100; i++) {
  // 不会立即触发重排，而是收集起来
  view.requestMeasure({
    read: view => view.coordsAtPos(i),
    write: (coords, view) => {
      // 统一在下一帧修改 DOM
      updateOverlay(i, coords)
    }
  })
}
```

### 4. 极端的“非阻塞”解析：`WorkScheduler` (内部机制)

CodeMirror 内部处理语法高亮和语法树解析时，确实是**异步且分片**的。

- **机制**：它利用 `requestIdleCallback` (或模拟实现) 在浏览器空闲时解析代码。
- **控制**：你可以通过 `ensureSyntaxTree(state, limit, timeout)` 来控制是“强制同步解析完”还是“有多少用多少”。

### 总结：流程对比

| 场景                           | 推荐方案             | 流程                                                               |
| :----------------------------- | :------------------- | :----------------------------------------------------------------- |
| **高频外部数据流** (WebSocket) | **外部缓冲 + rAF**   | 收到数据 -> 存入数组 -> `requestAnimationFrame` -> `view.dispatch` |
| **协同编辑** (Collab)          | **Yjs `transact`**   | `doc.transact(() => { ...多步操作... })` -> 自动触发单次 Dispatch  |
| **DOM 布局操作** (Tooltip)     | **`requestMeasure`** | `requestMeasure` -> 等待下一帧 -> 批量读 -> 批量写                 |
| **用户输入** (Typing)          | **原生同步**         | 必须同步，否则输入会有延迟感，不要尝试异步化用户输入。             |

**核心原则**：CodeMirror 的 `state` 更新必须是同步且原子化的（为了保证历史记录和变更映射的正确性），所谓的“异步批量”，本质上都是**在 `dispatch` 之前**把参数攒够，然后一次性同步提交。

---

这是一个非常经典且深刻的问题。

**CodeMirror** (特别是 v6) 和 **ProseMirror** 确实非常有“兄弟相”。这并不奇怪，因为它们的核心作者都是同一个人——**Marijn Haverbeke**。

CodeMirror 6 的架构设计在很大程度上吸取了 ProseMirror 的经验（例如不可变状态、事务驱动、视图与状态分离）。因此，你在 API 层面（State, View, Transaction, Plugin/Extension）会感到非常相似。

但是，它们的**底层数据模型**和**设计初衷**有着本质的区别，这决定了它们各自的适用场景。

以下是深度的对比分析：

### 一、 核心区别：一句话总结

- **CodeMirror** 是为了编辑 **“扁平的文本序列”** (Flat Text)。它的核心是**行 (Lines)** 和 **字符 (Characters)**。
- **ProseMirror** 是为了编辑 **“树状的文档结构”** (Tree Structure)。它的核心是 **节点 (Nodes)** 和 **Schema (模式)**。

---

### 二、 深度对比：数据模型与渲染

| 特性                 | CodeMirror 6                                                                                                                             | ProseMirror                                                                                                                                        |
| :------------------- | :--------------------------------------------------------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------- |
| **数据模型**         | **Rope (绳索结构)**。本质上是一个高效的字符串处理机制。它关注的是 `doc.length`，偏移量 `pos`，以及行号。                                 | **Document Tree (文档树)**。类似 DOM 的结构。它关注的是 `Node`（段落、标题、列表），以及父子关系。                                                 |
| **Schema (模式)**    | **无 (弱模式)**。文本就是文本。虽然有语法解析（Lezer），但它只是为了高亮，不强制文本结构。                                               | **强 Schema**。你必须定义文档允许包含什么（例如：`<ul>` 里必须是 `<li>`）。不符合 Schema 的内容会被自动修正或拒绝。                                |
| **DOM 渲染**         | **虚拟滚动 (Virtual Viewport)**。它只渲染视口内的行。为了性能，它会复用 DOM，甚至不使用 `contenteditable` 的原生行为，而是自己接管输入。 | **语义化渲染**。它尽量渲染出语义化的 HTML（如 `p`, `strong`, `table`）。它依赖 `contenteditable`，但通过复杂的拦截机制来保证 Model 和 DOM 的同步。 |
| **选区 (Selection)** | 主要是**文本范围**（Range）。关注字符的开始和结束位置。                                                                                  | **结构化选区**。除了文本选区，还有 `NodeSelection`（选中整个图片、选中整个表格单元格）。                                                           |
| **性能瓶颈**         | 处理**超长文本**（如 10 万行代码）非常强悍。                                                                                             | 处理**深层嵌套**和**富文本交互**很强，但如果把 10 万行代码塞进去，性能会崩，因为它是树状遍历。                                                     |

---

### 三、 场景分析：什么时候用哪个？

#### 1. 必须使用 CodeMirror 的场景

只要你的目标是**“编辑代码”**或**“编辑纯文本数据”**，首选 CodeMirror。

- **IDE / 代码编辑器**：需要语法高亮、自动补全、代码折叠、Lint 错误提示。
- **配置文件编辑**：JSON, YAML, TOML, XML 编辑器。
- **SQL 查询运行器**：输入 SQL 语句。
- **Markdown 源码编辑**：注意，是编辑**源码**（看到的是 `**bold**` 而不是加粗的效果）。虽然可以通过装饰器让它看起来像富文本，但本质还是在操作字符。
- **日志查看器**：需要高性能渲染大量文本行。
- **公式/脚本编辑器**：如 LaTeX 源码编辑。

**为什么不用 ProseMirror？**
如果你用 ProseMirror 做代码编辑器，你需要把每一行代码定义为一个“段落”。当代码有 1 万行时，ProseMirror 需要维护一个巨大的节点树，且很难处理“代码折叠”这种纯视觉但影响行号的逻辑。

#### 2. 必须使用 ProseMirror 的场景

只要你的目标是**“所见即所得 (WYSIWYG)”**或**“结构化文档”**，首选 ProseMirror。

- **富文本编辑器**：类似 Word、Google Docs。需要加粗、斜体、链接、图片。
- **CMS 内容录入**：发布文章，需要严格的 HTML 结构（标题、段落、引用）。
- **协同文档 (Notion-like)**：需要块级元素（Block-based），可以拖拽段落，转换类型（把段落变成标题）。
- **复杂的嵌套结构**：表格（Table）、嵌套列表、脚注。
- **混合媒体排版**：文本中嵌入视频、推文卡片、动态组件。

**为什么不用 CodeMirror？**
如果你用 CodeMirror 做富文本，你需要用 `Widget Decoration` 把 `**bold**` 隐藏起来，并渲染成加粗。这非常痛苦，而且很难处理光标在加粗边界的行为。更别提表格编辑了，在 CodeMirror 里实现一个可交互的表格简直是噩梦。

---

### 四、 灰色地带：Markdown 编辑器

这是最容易纠结的场景。现在流行的 Markdown 编辑器有两种流派：

**流派 A：源码模式 + 实时预览 (Split View)**

- **代表**：GitHub 在线编辑器、早期的 VS Code Markdown。
- **选择**：**CodeMirror**。
- **逻辑**：左边写源码（CodeMirror），右边渲染 HTML。

**流派 B：所见即所得 / 混合模式 (Hybrid / WYSIWYG)**

- **代表**：Typora, Obsidian (Live Preview), Notion。
- **选择**：**ProseMirror** (或类似架构)。
- **逻辑**：你输入 `## Title`，按下回车，它立刻变成了一个大标题。
  - 虽然 Obsidian 的 Live Preview 实际上是基于 CodeMirror 6 魔改的（通过极其复杂的 Decoration 隐藏源码），但这是因为 Obsidian 本质上还是想保留“纯文本文件”的控制权。
  - 如果你从零开发一个 Typora 竞品，**ProseMirror 是更自然的选择**。你可以定义一套 Schema，将 Markdown 解析为 Node Tree，编辑时直接操作 Tree，保存时序列化回 Markdown。

---

### 五、 架构层面的决策指南

如果你还在犹豫，请问自己三个问题：

1.  **文档的“真相”是什么？**

    - 如果真相是**字符串**（例如保存到数据库的是一串字符），选 **CodeMirror**。
    - 如果真相是**JSON 树**（例如保存到数据库的是 `{ type: "doc", content: [...] }`），选 **ProseMirror**。

2.  **换行意味着什么？**

    - 如果换行只是一个 `\n` 字符，选 **CodeMirror**。
    - 如果换行意味着“结束当前段落节点，开始一个新的段落节点”，选 **ProseMirror**。

3.  **你需要“表格”编辑功能吗？**
    - 如果需要（合并单元格、拖拽列宽），请直接选 **ProseMirror**。在 CodeMirror 里做表格编辑是不切实际的。

### 六、 总结

- **CodeMirror 6**: 现代 Web 的 **VS Code** 引擎。处理代码、数据、纯文本。
- **ProseMirror**: 现代 Web 的 **Word** 引擎。处理文章、文档、语义化内容。

两者都是各自领域的顶级库（State-of-the-art），选择的关键在于你的数据是**扁平的**还是**树状的**。

---

CodeMirror 6 (CM6) 和 ProseMirror (PM) 都是高度模块化的编辑器框架。在实际的生产级项目中，良好的代码组织结构至关重要，否则很容易陷入“配置地狱”或“状态管理混乱”。

以下是针对这两个库的**最佳实践项目结构**和**代码组织原则**。

---

### 一、 CodeMirror 6 项目结构最佳实践

CM6 的核心哲学是 **Extension（扩展）**。你的整个编辑器配置本质上就是一个巨大的扩展数组。

#### 1. 推荐文件夹结构

```text
src/
  editor/
    ├── index.tsx             # 编辑器组件入口 (React/Vue 组件)
    ├── setup.ts              # 基础配置 (Basic Setup)
    ├── theme.ts              # 主题定义 (Theme)
    ├── extensions/           # 自定义扩展目录
    │   ├── index.ts          # 导出所有扩展
    │   ├── keymap.ts         # 自定义快捷键
    │   ├── events.ts         # DOM 事件处理器 (Click, Drop)
    │   ├── autocompletion.ts # 自动补全逻辑
    │   └── widgets/          # 复杂的 UI 挂件 (WidgetType)
    │       ├── ColorWidget.ts
    │       └── ImageWidget.ts
    ├── state/                # 状态管理
    │   ├── index.ts
    │   ├── facets.ts         # 配置 Facet 定义
    │   └── fields.ts         # StateField 定义 (核心业务逻辑)
    └── language/             # 语言相关
        ├── my-lang.ts        # 自定义语言支持
        └── linter.ts         # 语法检查
```

#### 2. 核心代码组织原则

- **Setup 分离**：不要把所有东西都写在 `EditorState.create` 里。创建一个 `useExtensions` 或 `getExtensions` 函数。
- **Feature-based Grouping**：将一个功能的所有相关部分（StateField, ViewPlugin, Keymap）封装在一个函数中导出。

**示例：`src/editor/extensions/word-count.ts`**

```typescript
import { StateField, Extension } from '@codemirror/state'
import { EditorView, showPanel, Panel } from '@codemirror/view'

// 1. State (数据层)
const wordCountState = StateField.define<number>({
  create: () => 0,
  update: (count, tr) => (tr.docChanged ? tr.newDoc.length : count)
})

// 2. View (UI层)
function wordCountPanel(view: EditorView): Panel {
  const dom = document.createElement('div')
  return {
    dom,
    update(update) {
      dom.textContent = `${update.state.field(wordCountState)} chars`
    }
  }
}

// 3. Export (组合层)
export function wordCount(): Extension {
  return [wordCountState, showPanel.of(wordCountPanel)]
}
```

---

### 二、 ProseMirror 项目结构最佳实践

PM 的核心哲学是 **Schema（模式）** 和 **Plugin（插件）**。由于 PM 通常涉及复杂的富文本逻辑，结构需要更偏向于“文档模型”。

#### 1. 推荐文件夹结构

```text
src/
  editor/
    ├── index.tsx             # 编辑器组件入口
    ├── Editor.tsx            # 核心 View 包装器
    ├── schema/               # 模式定义 (最重要！)
    │   ├── index.ts          # 导出 Schema 实例
    │   ├── nodes.ts          # 节点定义 (Paragraph, Heading, Image)
    │   └── marks.ts          # 标记定义 (Bold, Link, Color)
    ├── plugins/              # 插件目录
    │   ├── index.ts
    │   ├── keymap.ts         # 快捷键绑定
    │   ├── input-rules.ts    # 输入规则 (Markdown 快捷输入)
    │   ├── menu/             # 菜单栏逻辑 (Floating Menu, Bubble Menu)
    │   └── collab.ts         # 协同编辑逻辑 (Yjs 等)
    ├── commands/             # 自定义命令
    │   ├── index.ts
    │   └── table-commands.ts
    └── node-views/           # 自定义节点渲染 (React/Vue 组件)
        ├── ImageView.tsx
        └── CodeBlockView.tsx
```

#### 2. 核心代码组织原则

- **Schema First**：Schema 是 PM 的灵魂。将 Node 和 Mark 的定义拆分到独立文件，保持 `schema/index.ts` 干净。
- **NodeView 隔离**：复杂的节点（如图片上传、代码块、数学公式）必须使用 `NodeView`。如果使用 React/Vue，请使用对应的 Adapter（如 `prosemirror-adapter`）。
- **Command 纯函数化**：编写 Command 时，遵循 `(state, dispatch) => boolean` 的签名，便于测试和复用。

**示例：`src/editor/schema/nodes.ts`**

```typescript
import { NodeSpec } from 'prosemirror-model'

export const image: NodeSpec = {
  inline: true,
  attrs: {
    src: {},
    alt: { default: null }
  },
  group: 'inline',
  draggable: true,
  parseDOM: [
    {
      tag: 'img[src]',
      getAttrs: (dom: HTMLElement) => ({
        src: dom.getAttribute('src'),
        alt: dom.getAttribute('alt')
      })
    }
  ],
  toDOM: node => ['img', node.attrs]
}
```

---

### 三、 通用最佳实践 (适用于两者)

1.  **不要直接操作 DOM**

    - **CM6**: 使用 `ViewPlugin` 或 `WidgetType`。
    - **PM**: 使用 `NodeView`。
    - _原因_：编辑器有自己的虚拟 DOM 或更新机制，直接操作会导致状态不同步。

2.  **状态单一数据源 (Single Source of Truth)**

    - 不要在 React State 和编辑器 State 之间同步同样的数据。
    - **正确做法**：编辑器 State 是主数据源，React 组件通过 `updateListener` (CM6) 或 `dispatchTransaction` (PM) 仅仅作为“渲染者”或“触发者”。

3.  **类型安全 (TypeScript)**

    - 这两个库的类型定义都非常完善。务必定义好你的 `Schema` 类型或 `StateField` 类型，这能避免 90% 的运行时错误。

4.  **样式隔离**
    - 使用 CSS Modules 或 Styled Components 给编辑器容器加 Scope，防止全局样式污染编辑器内部（特别是 PM，因为它依赖 `contenteditable`，容易受全局 `p` 或 `ul` 样式影响）。

### 四、 总结对比图

| 关注点       | CodeMirror 6 结构重点     | ProseMirror 结构重点             |
| :----------- | :------------------------ | :------------------------------- |
| **核心配置** | `extensions/` (功能扩展)  | `schema/` (文档结构定义)         |
| **UI 定制**  | `WidgetType` (轻量级 DOM) | `NodeView` (重量级组件)          |
| **逻辑复用** | `Facet` & `StateField`    | `Plugin` & `PluginKey`           |
| **输入处理** | `TransactionFilter`       | `InputRules` & `handleDOMEvents` |

如果你正在从零开始，建议参考社区优秀的开源实现：

- **CodeMirror**: 参考 Replit 的开源组件或 `codemirror-lang-*` 系列源码。
- **ProseMirror**: 参考 **TipTap** (它封装了一套非常优秀的基于 Extension 的架构，你可以模仿它的目录结构)。

---

这个问题触及了 CodeMirror 6 处理文档变化时最核心、也最微妙的逻辑：**坐标映射（Position Mapping）**。

简单来说，文档是动态的。如果你在位置 `5` 记了一个笔记，当用户在位置 `0` 插入了 10 个字符，你的笔记位置必须变成 `15`。但最难的情况是：**如果用户恰好在位置 `5` 插入了内容，你的“点”该往哪边倒？**

为了让你彻底理解，我们把这个“位置”想象成一个**磁铁**。

---

### 1. 核心冲突：零宽度的“缝隙”

假设文档是 `ABCDE`，位置 `2` 就在 `B` 和 `C` 之间。
现在用户在位置 `2` 插入了 `XYZ`。
新文档变成了 `AB XYZ CDE`。

**你的位置 `2` 现在有两个选择：**

1.  留在 `B` 的后面（位置 `2`）。
2.  跟着 `C` 走，挪到 `Z` 的后面（位置 `5`）。

这就是 `MapMode` 要解决的问题。

---

### 2. MapMode 的三种模式详解

#### ① MapMode.Simple (默认模式)

- **逻辑**：它是“务实派”。
- **表现**：如果插入点**恰好**在你的位置上，它通常倾向于**留在原地**（不随新插入的内容向后移）。
- **场景**：大多数普通标记。

#### ② MapMode.TrackBefore (向左靠)

- **逻辑**：它把位置看作是**紧贴着前一个字符**的。
- **表现**：无论你在缝隙里插入多少内容，它都死死抱住左边的字符，**留在原地**。
- **场景：起始标记（Start Tag）**。
  - 比如你标记了一个加粗区域的开头 `<b>`。用户在 `<b>` 的位置开始打字，新打的字应该在 `<b>` 里面，所以开头标记应该留在最左边。

#### ③ MapMode.TrackAfter (向右靠)

- **逻辑**：它把位置看作是**紧贴着后一个字符**的。
- **表现**：只要有新内容插入，它就**被推到后面去**。
- **场景：书签（Bookmark）或结束标记（End Tag）**。
  - 比如你在行尾放了一个“评论图标”。用户在行尾继续打字，图标应该永远保持在所有文字的最右边，所以它必须随新内容向后移。

#### ④ MapMode.TrackDel (删除感知)

- **逻辑**：如果我标记的位置所在的字符被删除了，这个位置还有意义吗？
- **表现**：如果该位置落在了被删除的范围内，`mapPos` 会返回 `null`。
- **场景：断点（Breakpoint）**。
  - 如果你在第 5 行设置了断点，用户把第 4 到第 6 行全删了，这个断点就该消失，而不是随便漂移到其他行。

---

### 3. 为什么 Decoration 有 inclusive 属性？

在 `Decoration`（装饰器）中，我们处理的是一个**范围（Range）**，即 `from` 到 `to`。

`inclusive` 实际上是 `MapMode` 在“范围”上的应用。它决定了**当用户在边缘打字时，新内容是否属于这个装饰器**。

- **`inclusive: false` (默认)**：

  - 在 `from` 处插入 -> 新内容在范围**外**（`from` 向后移）。
  - 在 `to` 处插入 -> 新内容在范围**外**（`to` 留在原地）。
  - **类比**：就像数学里的开区间 `(5, 10)`。

- **`inclusive: true`**：

  - 在 `from` 处插入 -> 新内容在范围**内**（`from` 留在原地）。
  - 在 `to` 处插入 -> 新内容在范围**内**（`to` 向后移）。
  - **类比**：就像数学里的闭区间 `[5, 10]`。

- **混合模式 (`inclusiveStart`, `inclusiveEnd`)**：
  - 你可以让开头不包含，结尾包含。这在处理类似“链接”或“行内代码块”时非常有用。

---

### 4. 业务场景决策表

| 业务需求            | 推荐模式           | 理由                                                   |
| :------------------ | :----------------- | :----------------------------------------------------- |
| **光标位置**        | `TrackAfter`       | 用户打字时，光标必须永远在最新输入的字符后面。         |
| **行内评论锚点**    | `TrackBefore`      | 通常希望锚点固定在某个单词的开头，即使前面插入了空格。 |
| **代码折叠区域**    | `inclusive: false` | 用户在折叠块外面打字，不应该被吸进去。                 |
| **搜索结果高亮**    | `TrackDel`         | 如果用户修改了文本导致匹配失效，高亮应该直接消失。     |
| **Lint 错误波浪线** | `inclusive: true`  | 用户在错误单词中间或边缘修改，通常波浪线应该继续覆盖。 |

### 总结

- **想留在左边（不随插入移动）**：用 `TrackBefore` 或 `inclusive: true` (对于 start)。
- **想跟到右边（随插入移动）**：用 `TrackAfter` 或 `inclusive: true` (对于 end)。
- **如果内容没了，我也不要了**：用 `TrackDel`。

理解了 `MapMode`，你就能解决 CodeMirror 插件开发中最头疼的“标记漂移”和“选区粘连”问题。

---

在 CodeMirror 6 中，**Panel (面板)** 和 **Tooltip (提示框)** 是处理编辑器 UI 扩展的两个核心机制。它们的设计目标是：**将 UI 逻辑与编辑器核心状态解耦，同时保证 UI 能随编辑器状态自动同步。**

以下是针对这两个功能的深度解析与实战指南。

---

### 一、 Panel (顶部/底部面板)

**核心意图**：在编辑器的顶部或底部插入一个固定的 UI 区域，该区域会随编辑器缩放，但不随文档内容滚动。

#### 1. 核心 API：`showPanel`

`showPanel` 是一个 **Facet (配置槽)**。你通过提供一个构造函数来创建一个面板。

```typescript
import { showPanel, Panel } from '@codemirror/view'

function createMyPanel(view: EditorView): Panel {
  let dom = document.createElement('div')
  dom.textContent = '这是面板内容'

  return {
    dom,
    top: true, // true 放在顶部，false 放在底部
    update(update) {
      // 当编辑器状态变化时触发
      if (update.docChanged) {
        dom.textContent = `当前字数: ${update.state.doc.length}`
      }
    },
    mount() {
      /* 挂载后的逻辑 */
    },
    destroy() {
      /* 销毁逻辑 */
    }
  }
}

// 使用
const extensions = [showPanel.of(createMyPanel)]
```

#### 2. 业务场景与最佳实践

- **搜索框 (Search Box)**：官方的 `@codemirror/search` 插件就是用 Panel 实现的。
- **状态栏 (Status Bar)**：显示行号、列号、编码格式、字数统计。
- **工具栏 (Toolbar)**：放置加粗、斜体、插入代码块等按钮。

**💡 最佳实践：**

- **性能优化**：在 `update(update)` 方法中，务必先检查 `update.docChanged` 或 `update.selectionSet`，避免不必要的 DOM 操作。
- **样式控制**：CodeMirror 会给面板容器加上 `.cm-panel` 类。建议使用 `EditorView.baseTheme` 来定义面板样式，以保证主题兼容性。

---

### 二、 Tooltip (光标跟随提示)

**核心意图**：在文档的特定位置（通常是光标处或鼠标悬停处）显示一个浮动的 UI 窗口。它会自动处理**边界溢出**（如靠近屏幕右侧时自动左移）。

#### 1. 核心 API：`showTooltip`

`showTooltip` 也是一个 Facet。它需要一个包含位置信息的对象。

```typescript
import { showTooltip, Tooltip } from '@codemirror/view'

const cursorTooltip = showTooltip.of({
  pos: 10, // 锚点位置（字符索引）
  above: true, // 是否显示在文字上方
  arrow: true, // 是否显示小箭头
  create(view) {
    let dom = document.createElement('div')
    dom.className = 'cm-my-tooltip'
    dom.textContent = '提示信息'
    return { dom }
  }
})
```

#### 2. 进阶：Hover Tooltip (鼠标悬停提示)

业务中经常需要“鼠标指到某个变量显示文档”。官方提供了 `hoverTooltip` 辅助函数。

```typescript
import { hoverTooltip } from '@codemirror/view'

const wordHover = hoverTooltip((view, pos, side) => {
  // 1. 逻辑判断：pos 处是否有需要显示的内容
  let { from, to, text } = view.state.doc.lineAt(pos)

  // 2. 返回 Tooltip 配置
  return {
    pos: from,
    end: to,
    above: true,
    create(view) {
      let dom = document.createElement('div')
      dom.textContent = `你正在查看: ${text}`
      return { dom }
    }
  }
})
```

#### 3. 业务场景与最佳实践

- **参数提示 (Parameter Hints)**：输入函数名和 `(` 后，显示参数列表。
- **语法错误 (Linting)**：鼠标悬停在红色波浪线上显示错误详情。
- **文档预览**：悬浮显示函数定义或 Markdown 链接预览。

**💡 最佳实践：**

- **生命周期管理**：如果 Tooltip 内部使用了 React/Vue，务必在 `create` 返回对象的 `destroy()` 方法中调用 `unmount`，否则会造成内存泄漏。
- **坐标计算**：Tooltip 的位置是基于字符索引 `pos` 的。如果你需要根据鼠标坐标显示，请使用 `view.posAtCoords`。
- **避免遮挡**：CM6 内部有 `computeTooltipPos` 逻辑，会自动计算 Tooltip 是否超出编辑器边界。如果你的编辑器在滚动容器内，确保容器没有 `overflow: hidden` 截断 Tooltip。

---

### 三、 Panel vs Tooltip 深度对比

| 特性         | Panel (面板)              | Tooltip (提示框)                  |
| :----------- | :------------------------ | :-------------------------------- |
| **位置**     | 固定在编辑器顶部或底部    | 随文档内容位置浮动                |
| **滚动影响** | 不随文档滚动              | 随文档内容一起滚动                |
| **遮挡处理** | 挤压编辑器内容区域        | 悬浮在内容上方，自动计算边界      |
| **主要用途** | 全局辅助 UI（搜索、状态） | 局部上下文 UI（补全、报错、提示） |
| **数据驱动** | 通常监听全局 `StateField` | 通常由当前光标或鼠标位置驱动      |

### 四、 总结：如何选择？

1.  **如果 UI 是为了服务于整个文档**（如：查找替换、字数统计），请使用 **Panel**。
2.  **如果 UI 是为了解释某个具体的代码片段**（如：变量定义、函数参数、语法错误），请使用 **Tooltip**。
3.  **如果 UI 需要频繁出现又消失**，且位置不固定，**Tooltip** 是唯一选择。

**开发技巧**：
在实现复杂的 Tooltip（如自动补全列表）时，建议参考官方包 `@codemirror/autocomplete` 的源码。它展示了如何处理复杂的键盘导航（上下键选择）与 Tooltip 渲染的结合。

---

这两个 API 是 CodeMirror 6 处理**文本边界**和**光标导航**的核心工具。它们决定了编辑器如何理解“什么是单词”以及“如何正确地移动光标”。

---

### 七、 字符分类器：`charCategorizer`

在编辑器中，当你双击一个单词或按 `Ctrl + →` 时，编辑器需要知道在哪里停下来。`charCategorizer` 就是负责这个“分词逻辑”的裁判。

#### 1. 核心概念：三种分类

CodeMirror 将所有字符归为三类（定义在 `CharCategory` 枚举中）：

1.  **`Word` (单词)**：字母、数字、下划线等。
2.  **`Space` (空格)**：空格、制表符等不可见字符。
3.  **`Other` (其他)**：标点符号、特殊符号（如 `-`, `+`, `(`, `)`）。

#### 2. 为什么需要它？

默认情况下，`user-id` 会被识别为：`Word(user)` + `Other(-)` + `Word(id)`。

- **双击 `user`**：只会选中 `user`。
- **按 `Ctrl + →`**：光标会跳到 `-` 前面，再按一次跳到 `id` 后面。

**业务场景**：在 CSS 或 Lisp 开发中，`-` 通常是变量名的一部分。你希望双击 `user-id` 时选中整个词。

#### 3. 如何自定义？

你不需要手动实现分类函数，通常通过 **Language Data** 来配置。

```typescript
import { EditorState } from '@codemirror/state'
import { javascript } from '@codemirror/lang-javascript'

const state = EditorState.create({
  doc: 'const user-id = 123',
  extensions: [
    javascript(),
    // 自定义语言数据：将 '-' 视为单词字符
    EditorState.languageData.of(() => [
      {
        wordChars: '-'
      }
    ])
  ]
})

// 获取分类器
const categorizer = state.charCategorizer(0)
console.log(categorizer('-')) // 输出 CharCategory.Word (原本是 Other)
```

---

### 九、 字符与组移动逻辑：`moveByChar` & `moveByGroup`

这两个方法是 `EditorView` 提供的底层工具，用于计算光标移动后的新位置。

#### 1. 为什么不能直接用 `pos + 1`？

直接加减索引在现代文本编辑中会引发灾难，原因有三：

1.  **字符簇 (Grapheme Clusters)**：像 👨‍👩‍👧‍👦 这种表情由多个 Unicode 码点组成，但视觉上是一个字符。`pos + 1` 会让光标进到表情内部。
2.  **双向文本 (Bidi)**：在阿拉伯语（从右往左）和英语混合时，“向右移动”可能意味着索引减小。
3.  **原子范围 (Atomic Ranges)**：如果你插入了一个不可编辑的 Widget（如一个标签卡片），光标应该直接跳过它。

#### 2. `moveByChar` (按字符移动)

计算光标向左或向右移动一个**视觉字符**后的位置。

```typescript
// range: 当前选区, forward: 方向, filter: 过滤函数
const newRange = view.moveByChar(view.state.selection.main, true)
view.dispatch({ selection: newRange })
```

#### 3. `moveByGroup` (按组/单词移动)

计算光标跳过一个“组”后的位置。它内部会调用 `charCategorizer` 来判断哪里是组的边界。

**业务场景：实现自定义的“跳词”命令**
假设你想实现一个功能：按下 `Alt + 方向键` 时，跳过单词，但要跳过你自定义的逻辑。

```typescript
const moveWordForward = (view: EditorView) => {
  const selection = view.state.selection.main
  // 使用 moveByGroup 自动处理 Bidi 和 字符分类
  const newRange = view.moveByGroup(selection, true)

  view.dispatch({
    selection: newRange,
    scrollIntoView: true
  })
  return true
}
```

#### 4. 高级技巧：使用 `filter` 参数

`moveByChar` 和 `moveByGroup` 都接受一个可选的 `filter` 函数。这允许你**拦截**光标位置。

**场景**：你的文档中有很多只读的“占位符”，你不希望光标落在这些占位符中间。

```typescript
const newRange = view.moveByChar(currentRange, true, pos => {
  // 如果 pos 落在禁区，返回 false，moveByChar 会继续寻找下一个有效位置
  return !isInForbiddenZone(pos)
})
```

---

### 总结：两者之间的联动

1.  **`charCategorizer` 定义了“边界”在哪里**。它告诉编辑器：遇到 `-` 时，是该停下来（视为标点），还是继续冲过去（视为单词）。
2.  **`moveByGroup` 使用了这些边界**。当你调用 `moveByGroup` 时，它会不断咨询 `charCategorizer`：“当前字符是什么类？下一个呢？类变了吗？变了我就停下。”
3.  **`moveByChar` 则是最底层的视觉保障**。它确保你的光标永远不会落在 Emoji 的半中间，或者掉进 Bidi 文本的逻辑陷阱里。

**最佳实践建议**：

- 如果你要改变**双击选中**的行为，去配置 `languageData` 中的 `wordChars`。
- 如果你要编写**光标移动**的快捷键插件，永远使用 `moveByChar` / `moveByGroup`，绝对不要手动加减 `pos`。

---

这两个 API 分别关乎编辑器的**生命周期安全**与**内容健壮性**。在构建生产级应用时，它们是必不可少的“防线”。

---

### 七、 编辑器销毁：`view.destroy()`

在现代前端框架（React, Vue, Angular）中，组件的销毁并不意味着内存的自动释放。CodeMirror 6 是一个高度依赖 DOM 事件和后台计算的库，如果不手动销毁，会引发严重的后果。

#### 1. 为什么必须调用 `destroy()`？

CodeMirror 在运行时会建立许多“外部连接”：

- **全局监听器**：为了处理选区变化、窗口缩放（Resize）和焦点丢失，它会在 `window` 或 `document` 上挂载事件。
- **后台解析器 (Lezer)**：解析器在后台线程或空闲时间运行。如果不停止，它会继续解析已经不存在的文档。
- **插件生命周期**：许多插件（如协同编辑、自动保存）在内部开启了 `setInterval` 或 WebSocket 连接。

#### 2. 内存泄漏与“幽灵”行为

- **内存泄漏**：旧的 `EditorView` 引用了整个 `EditorState`（包含巨大的文档和完整的撤销历史）。如果不销毁，这些数据将永远留在内存中。
- **幽灵快捷键**：如果你在插件里注册了全局快捷键（如 `Ctrl+S`），不销毁视图会导致你按下快捷键时，**所有曾经打开过但没销毁的编辑器实例**都会尝试执行保存逻辑。

#### 3. 最佳实践：在框架中使用

以 React 为例，必须在 `useEffect` 的清理函数中执行：

```typescript
useEffect(() => {
  const view = new EditorView({
    state: EditorState.create({ ... }),
    parent: editorRef.current
  });

  return () => {
    // 核心：组件卸载时务必销毁
    view.destroy();
    console.log("编辑器已安全释放");
  };
}, []);
```

---

### 八、 特殊字符高亮：`highlightSpecialChars`

这是一个“救命”的功能。在编程场景中，最难排查的错误往往是**肉眼看不见**的错误。

#### 1. 业务场景：隐形杀手

用户从网页、PDF 或聊天软件中复制一段代码，可能会带入：

- **零宽空格 (`\u200b`)**：常用于排版，但在 JS 中会导致 `SyntaxError: Invalid or unexpected token`。
- **软连字符 (`\u00ad`)**。
- **控制字符**：如退格符、换页符等。

这些字符在普通编辑器里完全透明，用户会看着“完美”的代码报错而崩溃。

#### 2. API 使用与效果

加载该扩展后，CodeMirror 会自动识别这些字符，并将其渲染为一个**红色的占位符**。

```typescript
import { highlightSpecialChars } from '@codemirror/view'

const state = EditorState.create({
  extensions: [
    highlightSpecialChars({
      // 可选：自定义哪些字符需要高亮（使用正则）
      // specialChars: /[\u0000-\u0008...]/,

      // 可选：自定义渲染方式
      render: (code, description, placeholder) => {
        let span = document.createElement('span')
        span.textContent = '●' // 将不可见字符显示为一个点
        span.title = description // 鼠标悬停显示字符名称（如 "zero width space"）
        span.style.color = 'red'
        return span
      }
    })
  ]
})
```

#### 3. 细节补充

- **默认行为**：如果不传参数，它会默认高亮大多数非打印字符，并显示其十六进制代码（如 `\u0001`）。
- **性能**：该功能是基于装饰器（Decoration）实现的，只会在视口可见范围内进行扫描，因此对大文档非常友好。
- **安全性**：它不仅能防止代码跑不通，还能防止 **"Homograph Attack"**（同形异义词攻击，即用看起来一样的 Unicode 字符替换代码中的变量名）。

### 总结

- **`view.destroy()`** 是编辑器的**终点**：确保资源归还系统，防止页面越用越卡。
- **`highlightSpecialChars()`** 是内容的**质检员**：让隐藏的隐患无处遁形，极大提升开发者体验。
