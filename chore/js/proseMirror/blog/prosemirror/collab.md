好的，我们来对 Marijn Haverbeke 这篇关于 ProseMirror 协同编辑算法的博文进行一次系统且深入的分析讲解。这篇文章写于 2015 年，是理解现代富文本编辑器协同方案的奠基之作，它提出的“中心化、非收敛的 OT”思想，深刻影响了后来的许多系统，包括 CodeMirror 6。

我们将从以下几个角度来剖析这篇文章：

1.  **对经典 OT 的批判**: 为什么说真正的分布式 OT 是“一场噩梦”？
2.  **核心思想：中心化**: 引入“中央权威”如何极大地简化了问题？
3.  **ProseMirror 的算法**: 它是如何借鉴 Git 的 `rebase` 思想来实现协同的？
4.  **关键技术：位置映射 (Position Mapping)**: 它是如何取代传统 OT 的 `transform` 函数的？
5.  **算法的细节与挑战**: 如何处理多步 rebase、映射偏差和变更类型？
6.  **意图保留与局限性**: 算法如何尝试保留用户意图，以及它不适用于哪些场景？
7.  **协同下的撤销历史**: 如何实现“只撤销自己的修改”？

---

### 1. 对经典 OT 的批判

文章首先指出了学术界研究的“经典 OT”与工业界实际需求的脱节。

- **经典 OT (Operational Transformation)**:
  - **目标**: 实现一个**真正的分布式**系统，没有中央服务器。
  - **核心属性**:
    1.  **可变换 (Transformable)**: 变更可以相对于其他并发变更进行变换。
    2.  **收敛性 (Convergent)**: **无论并发变更以何种顺序应用，最终都会得到相同的文档**。这是最关键也最难实现的属性。
- **为什么是“一场噩梦” (`a nightmare to implement`)**:
  - **复杂性**: 保证“收敛性”在只有简单的插入/删除操作时还算可行，一旦引入更复杂的变更类型（如样式、拆分、合并），其复杂性会呈指数级增长。
  - **Google Wave 的教训**: 连 Google Wave 的工程师都吐槽实现 OT “烂透了”。

**Marijn 的观点**: 经典 OT 的大部分复杂性都源于对“真正分布式”的执着。对于一个本身就是中心化架构的系统（如 Google Docs），使用如此复杂的分布式算法是令人费解的。

---

### 2. 核心思想：中心化

ProseMirror 的算法做出了一个根本性的简化：**放弃分布式，拥抱中心化**。

- **引入中央服务器**:

  - 有一个单一的节点（服务器）来**决定所有变更被应用的最终顺序**。
  - **效果**: 问题被极大地简化了。不再需要保证“任意顺序应用都能收敛”，因为现在只有**一种**确定的顺序。

- **算法的核心**:
  - 它仍然使用基于“变更”的词汇表，并且也需要“变换”变更。
  - 但它**不试图保证**不同顺序的应用会产生相同的结果。
  - 这使得算法更容易实现和推理。

---

### 3. ProseMirror 的算法：借鉴 Git Rebase

这个中心化的算法流程，与我们熟悉的版本控制系统 Git 非常相似。

1.  **线性历史**: 服务器维护一个线性的文档历史，每个版本可以用一个简单的整数（版本号）来表示。
2.  **Push & Pull**:
    - 客户端做出修改后，尝试将这些修改“推送 (push)”到服务器。
    - **成功**: 如果客户端的修改是基于服务器当前的最新版本，推送成功。
    - **失败 (冲突)**: 如果在客户端修改期间，有其他人已经推送了新的版本，服务器会拒绝此次推送。
3.  **Rebase & Retry**:
    - 推送失败的客户端必须先“拉取 (pull)”服务器上的新变更。
    - 然后，将自己的本地修改**“变基 (rebase)”**到这些新变更之上。
    - 最后，再次尝试推送。

**与 Git 的区别**: 这是一个实时的过程，所有客户端都在持续地拉取最新变更，尽可能快地与服务器保持同步。

---

### 4. 关键技术：位置映射 (Position Mapping)

算法中最难的部分是“rebase”。ProseMirror 没有使用传统 OT 的 `transform(changeA, changeB)` 函数，而是引入了一个更通用的概念：**位置映射 (Position Map)**。

- **什么是位置映射？**:

  - 当你对一个文档应用一个变更后，你会得到一个新文档和一个**位置映射**。
  - 这个映射知道如何将**旧文档中的任何位置**，转换为**新文档中的对应位置**。
  - 最直观的用途是调整光标位置。

- **用位置映射来变换变更**:
  - ProseMirror 中所有的变更变换，都是通过**映射变更所关联的位置**来实现的。
  - 一个变更通常有关联的位置（如 `from`, `to`, `at`）。要 rebase 一个变更，只需将它的这些关联位置通过其他变更产生的位置映射进行“穿透”即可。
  - **优点**: 这种方法是**通用的**，与具体的变更类型无关。你不需要为每一种变更组合编写特定的变换逻辑。

---

### 5. 算法的细节与挑战

#### A. 多步 Rebase 与信息丢失

- **问题**: 当需要将本地的多步修改 `L1, L2` rebase 到远程的多步修改 `R1, R2` 之上时，情况变得复杂。`L2` 是基于 `L1` 之后的文档，它的坐标系与 `R1, R2` 的初始坐标系不同。
- **信息丢失**: 直接通过位置映射进行“向后映射再向前映射”会丢失信息。例如，在一个插入操作的内部插入字符，这个“内部”的位置在原始文档中是不存在的，映射回去再映射回来，位置信息就丢失了。
- **解决方案：镜像映射 (Mirror Images)**:
  - 系统在映射时，会识别出互为“镜像”的映射对（例如，一个删除操作和它的逆向插入操作）。
  - 当一个位置在穿过一个删除映射时，系统会向前查找它的镜像（插入）映射，并利用相对偏移量，将位置精确地恢复到新插入的内容中。

#### B. 映射偏差 (Mapping Bias)

- **问题**: 当内容被插入时，恰好在插入点上的位置，可以被映射到插入内容的前面，也可以是后面。
- **解决方案**: 允许映射时指定一个**偏差 (bias)**（向前或向后）。
- **应用**: 变更的 `from` 位置使用“向前偏差”，`to` 位置使用“向后偏差”，以确保不会错误地将插入到边界上的内容包含进来。

---

### 6. 意图保留与局限性

- **保留意图 (Preserving Intention)**:

  - 算法的设计目标是让 rebase 后的结果尽可能符合用户的直觉。
  - **丢弃变更**: 当变更的上下文消失时（例如，在一个已被他人删除的段落中打字），变更会被自动丢弃。
  - **修改变更**: 当上下文变化但变更仍有意义时（例如，给他人的插入内容添加样式），变更会被修改。
  - **无交互**: 当变更重叠但互不影响时（例如，一个加粗，一个加链接），两者都可以保留。

- **算法的局限性**:
  - 这个模型**只适用于实时协同**，因为用户可以立即看到变更被丢弃或修改的反馈。
  - 它**不适用于离线工作或分支合并**。在这种场景下，静默地丢弃大量工作是不可接受的。对于这种情况，应该使用类似 Git 的、基于三方合并（3-way merge）并需要用户手动解决冲突的 `diff` 方法。

---

### 7. 协同下的撤销历史

- **问题**: 协同编辑中，撤销操作应该只撤销**自己的**上一次修改，而不是文档的全局上一次修改。
- **解决方案**:
  1.  **可逆的变更 (Invertible Steps)**: 将每个变更（Step）都设计成可逆的。
  2.  **独立的撤销栈**: 每个用户都有自己的撤销历史栈，里面存储的是自己操作的**逆向变更 (inverted steps)**。
  3.  **映射撤销**: 当执行撤销时，从栈顶取出逆向变更，通过一系列的位置映射，将其 rebase 到当前的最新文档版本上，然后应用。
  4.  **历史压缩**: 为了避免位置映射链无限增长，撤销历史会定期将旧的逆向变更向前映射，使其基准版本更新到当前文档，从而可以丢弃中间的映射信息。

### 总结

ProseMirror 的协同算法是一次伟大的工程实践。它通过一个关键的决策——**用中心化服务器代替分布式共识**——极大地简化了问题，并创造性地提出了**基于“位置映射”的 Rebase 机制**，从而绕开了传统 OT 在保证“收敛性”上的巨大复杂性。

这篇文章清晰地阐述了：

- 一个**务实、可实现**的中心化协同模型。
- 一个**通用、与变更类型解耦**的变换机制。
- 一个**健壮的、支持协同**的撤销历史实现。

这个“非收敛的、中心化的 OT”思想，不仅在 ProseMirror 中取得了巨大成功，也成为了后来 CodeMirror 6 协同方案的基石，证明了其在实际工程中的强大生命力。
