以下是 Marijn Haverbeke 博客文章《ProseMirror》的全文翻译：

---

### ProseMirror

**2015 年 7 月 7 日，星期二 | JavaScript, ProseMirror, 架构**

有时我深夜辗转反侧，焦灼地寻找新方法，好让自己承担更多几乎没有报酬的责任。接着灵光一现：我应该再启动一个开源项目！

好吧，事实并非完全如此。但结果是一样的：我不断构建复杂且高要求的代码，然后将其无偿捐献。实际的机制通常是：我想到某个技术概念，发现还没人做过，出于好奇心和自尊心的混合驱动，我必须看看自己能否实现它。

这是最新的“杰作”：**ProseMirror**，一个基于浏览器的富文本编辑器。虽然我并不是直接将其捐献，而是通过众筹来使其开源，并思考了如何让发布后的维护可持续化。

#### 这是一个编辑器？

我刚才不是说要实现“尚未被完成”的东西吗？而市面上不是已经有至少一百个基于浏览器的富文本编辑器了吗？

是的，确实如此。但现有的项目都没有采用我认为理想的方法。其中许多项目根植于旧范式：依赖 `contentEditable` 元素，然后试图清理随之而来的混乱。这让我们对用户和浏览器对文档的操作几乎没有控制权。

为什么我们需要控制权？首先，它让保持文档处于健康状态变得容易得多。如果文档仅由你的代码修改，你可以定义这些修改以确保它们保留你想要的约束，并确保不同浏览器上发生相同的事情。

但更重要的是，它允许你以一种比“这里发生了变化，这是新的文档状态”更抽象的方式来表示这些修改。这在实现**协作编辑**时极其有用——为了有效地合并来自多个用户的冲突更改，准确表示更改的“意图”非常有帮助。

#### 通用方法

ProseMirror 确实创建了一个 `contentEditable` 元素来显示文档。这让我们免费获得了与焦点和光标移动相关的逻辑，并使支持屏幕阅读器和双向文本变得容易得多。

任何对文档的实际修改都会通过处理相应的浏览器事件来捕获，并转换为我们自己的修改表示。对于现代浏览器，大多数类型的更改都很容易处理。我们可以处理键盘事件来捕获输入的文本以及退格和回车。我们可以处理剪贴板事件来支持复制、剪切和粘贴。拖放也通过事件暴露。甚至 IME（输入法）输入也会触发相对可用的合成事件。

不幸的是，在某些情况下，浏览器不会触发描述用户意图的事件，你只能得到一个事后的输入事件。例如，从拼写检查菜单中选择更正，或者使用组合键输入特殊字符（例如 Linux 上的“Multi-e =”输入“€”）。幸运的是，到目前为止我遇到的所有此类情况都涉及简单的字符级输入。`我们可以检查 DOM，将其与我们的文档表示进行比较，并从中推导出预期的修改。`

当修改发生时，编辑器的文档表示会随之改变，然后显示层（屏幕上的 DOM 元素）会更新以反映新文档。通过对文档使用**持久化数据结构**（进行更改会创建一个新的文档对象，而不改变旧对象），我们可以使用非常快速的文档差异（diffing）算法，仅进行必要的 DOM 更新。这与 React 及其衍生框架的做法有些相似，`不同之处在于 ProseMirror 处理的是它自己的文档表示，而不是通用的类 DOM 数据结构。`

#### 文档模型

这种文档表示明确**不是 HTML**。它是一种文档的“语义化”表示，是一个树状数据结构，用段落、标题、列表、强调、链接等术语描述文本结构。它可以渲染为 DOM 树，也可以渲染为 Markdown 文本，以及任何能够表达其编码概念的其他格式。

这种表示的外部部分（处理段落、标题、列表等）在结构上非常像 DOM——它由带有子节点的节点组成。段落节点（以及其他块级元素如标题）的内容被表示为**行内元素的扁平序列**，每个元素都关联有一组样式。这比像 DOM 那样全程使用树状结构效果更好。它更容易强制执行约束（例如不允许文本被重复强调），并允许我们将段落中的位置表示为简单的字符偏移量，这比树中的位置更容易推理。

在段落之外，我们被迫使用树。因此，文档中的位置由路径表示，路径是一个整数序列，表示树每一层的子节点索引，以及路径末尾节点的偏移量。这就是光标位置的表示方式，也是存储修改发生位置的方式。

ProseMirror 当前的文档模型镜像了 Markdown 的模型，精确支持该格式可以表达的内容。未来，你将能够扩展和自定义要在给定编辑器实例中使用的文档模型。

#### 界面

该编辑器目前提供两种风格的用户界面。一种是顶部的经典工具栏。另一种是在选区上方显示工具提示以进行行内样式设置，并在当前选中段落右侧显示菜单按钮以进行块级操作。我相当喜欢后者，因为它在不使用时不会碍事，但我预计许多人会更喜欢熟悉的工具栏。

但这些界面是作为编辑器核心之外的模块实现的，其他界面风格也可以在相同的 API 之上实现。

按键绑定也是可配置的，紧跟 CodeMirror 的模式。按键绑定的功能作为命名命令提供，也可以使用 `execCommand` 方法从脚本运行。

最后，还有一个名为 `inputrules` 的模块，可用于指定在输入匹配给定模式的文本时应发生的操作。它可以用于“智能引号”，也可以用于实现输入“1.”并按空格时自动出现列表。

#### 协作

我之前提到了协作。这个项目的大量工作都投入到了支持**实时协作编辑**上。我写了另一篇关于技术细节的博客文章，但核心概念大致如下：

当修改应用于文档时，它会创建一个新文档以及一个**位置映射（position map）**，该映射将旧文档中的位置映射到新文档中的位置。例如，为了响应修改而移动光标，就需要这样做。

能够映射位置使得通过映射应用位置来“变基（rebase）”修改成为可能。这其中还有很多细节，在做对之前我重写了好几次这个系统，但我现在很有信心我最终得到了一个可行的方案。

在协作场景中，当客户端进行修改时，修改会在本地缓冲并发送到服务器。如果另一个客户端在我们的修改到达之前提交了它的修改，服务器会响应“不行，先应用这些修改”，客户端接收这些修改，将自己的修改在其基础上进行变基，然后重试。当修改通过后，它们会被广播给所有其他客户端，确保每个人都保持同步。

#### 目标受众

我期望谁会使用它？

一方面，使用 Markdown 或类似格式进行输入的网站可能希望为技术水平较低的用户提供一个更容易学习的界面，然后将结果转换为 Markdown。

另一方面，那些一直提供传统富文本输入但希望控制输出内容的网站可能希望转向 ProseMirror，因为让编辑体验直接反映并强制执行你的约束，比清理混乱的 HTML 并祈祷最好的结果要好得多。

最后，我期望对协作富文本编辑的坚实支持将开辟一个目前尚不存在的利基市场，允许人们将目前在 Google Docs 上做的一些事情转移到他们自己的产品中。

听起来很有趣？看看众筹活动进展如何。

---

富文本编辑器的本质，是**“人类视觉意图”与“机器结构化数据”之间的翻译官**。

要一针见血地理解它，可以拆解为以下三个逻辑层次：

### 一、 核心矛盾：自由度 vs 确定性

- **用户的需求**：像在 Word 或纸上一样，随心所欲地加粗、换行、插图（视觉自由）。
- **开发者的需求**：拿到一段干净、规范、能存入数据库并在各种终端完美渲染的数据（结构确定）。
- **冲突点**：早期的编辑器依赖浏览器的 `contentEditable` 属性，把控制权交给浏览器。结果是：你在 Chrome 里敲个回车生成的是 `<p>`，在 IE 里可能是 `<br>` 或 `<div>`。**这种“不可控”是富文本开发痛苦的根源。**

### 二、 进化逻辑：从“操作 DOM”到“驱动模型”

富文本编辑器的技术演进经历了三个阶段，逻辑非常清晰：

1.  **L1 阶段：原生命令派 (如 `document.execCommand`)**
    - **逻辑**：直接修改浏览器的 DOM。
    - **结果**：代码最简单，但生成的 HTML 极其混乱，无法保证跨端一致性。目前已被废弃。
2.  **L2 阶段：半受控派 (如 Quill, Draft.js)**
    - **逻辑**：引入一个中间层模型（如 Delta JSON）。你操作编辑器，它先更新 JSON 模型，再根据模型渲染 DOM。
    - **结果**：初步解决了数据一致性问题，但对复杂的嵌套逻辑（如表格里套列表）处理较弱。
3.  **L3 阶段：完全受控派 (如 ProseMirror, Slate, Lexical)**
    - **逻辑**：**彻底抛弃浏览器默认行为。** 拦截几乎所有的键盘和鼠标事件，自己实现一套类似虚拟 DOM 的文档树。
    - **结果**：极其强大。你可以精确定义“标题下不能直接跟图片”这种业务规则。这也是目前顶级编辑器（如 Notion、Google Docs）的基石。

### 三、 架构三要素：模型、变换、渲染

一个现代富文本编辑器的逻辑闭环如下：

1.  **Model (模型)**：用一种纯粹的数据结构（通常是树状 JSON）来描述内容。
    - _例如：`{type: 'paragraph', children: [{text: 'Hello', bold: true}]}`_
2.  **Transform/Command (变换)**：定义修改数据的唯一方式。
    - _逻辑：用户点击加粗 -> 触发 `toggleBold` 指令 -> 修改 Model 中的属性 -> 产生一个新的 Model 状态。_
3.  **View (渲染)**：将 Model 映射到屏幕上的 DOM。
    - _逻辑：利用 Diff 算法，只更新发生变化的那一小块 DOM，保证性能。_

### 四、 终极挑战：协同与性能

- **协同 (Collaboration)**：当多个人同时编辑时，如何解决冲突？这涉及到了 **OT (Operational Transformation)** 或 **CRDT** 算法。这是编辑器开发的“天花板”。
- **性能**：当文档达到几万行时，如何保证打字不卡顿？这需要对 DOM 渲染和长列表优化有极深的理解。

### 总结

**富文本编辑器不是一个简单的 UI 组件，而是一个微型的、运行在浏览器里的“排版引擎”。**

评价一个编辑器好坏的标准只有一条：**它在多大程度上夺回了浏览器对内容的控制权。** 夺回得越多，编辑器就越稳定、越强大。
