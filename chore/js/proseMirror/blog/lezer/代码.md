好的，我们来详细讲解 Lezer 的代码、核心概念和工作流程。

Lezer 是一个为 CodeMirror 6 设计的增量解析器生成器。它的核心目标是**高效**地解析代码，尤其是在用户频繁编辑大文件时，能够只重新解析发生变化的部分及其相关上下文，而不是整个文件。

### 核心概念

1.  **语法文件 (`.grammar`)**: 这是 Lezer 的核心。你使用一种特定的 EBNF (扩展巴科斯范式) 风格的语法来定义你的语言。这个文件描述了语言的词法（Tokens）和句法（Rules）。

    - **Tokens**: 语言的最小单元，通常用正则表达式定义，例如关键字、标识符、字符串、数字等。
    - **Rules**: 规则定义了如何将 Tokens 组合成更大的语法结构，例如表达式、语句、函数声明等。

2.  **解析器生成器 (`lezer-generator`)**: 这是一个命令行工具，它读取你的 `.grammar` 文件，并将其编译成一个高效的、用 JavaScript/TypeScript 编写的解析器模块。

3.  **具体语法树 (Concrete Syntax Tree - CST)**: Lezer 解析文本后生成的输出。与抽象语法树（AST）不同，CST 会保留源代码中的所有信息，包括空格、注释和标点符号。这对于需要精确反映原始文本的工具（如代码格式化、语法高亮）至关重要。

4.  **增量解析 (Incremental Parsing)**: 这是 Lezer 的王牌特性。当文本发生变化时，Lezer 会复用之前解析结果中未受影响的部分，只重新解析已更改的区域。这使得在编辑器中输入时，语法分析的响应速度极快。

5.  **树指针 (`TreeCursor`)**: 用于遍历 CST 的高效迭代器。直接访问树节点对象可能会创建大量对象，消耗内存。`TreeCursor` 是一个轻量级的指针，你可以移动它来访问节点的类型、起始位置和结束位置，而无需为每个节点都创建新对象。

---

### 工作流程

下面是一个完整的、从零开始使用 Lezer 的工作流程，包含代码示例。

假设我们要为一种简单的语言创建一个解析器，该语言只包含赋值语句，如 `let a = 10;`。

#### 第 1 步：编写语法文件 (`.grammar`)

创建一个名为 `simple.grammar` 的文件。

```lezer
@top Program { Statement* }

Statement {
  (Let | Identifier) "=" Expression ";"
}

Expression {
  Number | Identifier
}

@tokens {
  let { "let" }
  Identifier { $[a-zA-Z_][a-zA-Z_0-9]* }
  Number { $[0-9]+ }
  LineComment { "//" ![\n]* }
}

@skip { LineComment | $[ \t\n\r]+ }
```

**代码讲解**:

- `@top Program { Statement* }`: 定义了顶层规则 `Program`，它由零个或多个 `Statement` 组成。`@top` 指明这是解析的入口点。
- `Statement { ... }`: 定义了语句的结构：`let` 关键字或一个标识符，后跟 `=`，一个 `Expression`，最后是分号 `;`。
- `Expression { Number | Identifier }`: 表达式可以是一个数字或一个标识符。
- `@tokens { ... }`: 定义词法单元（Tokens）。
  - `let { "let" }`: `let` 是一个关键字。
  - `Identifier { $[a-zA-Z_]... }`: 定义标识符的正则表达式。
  - `Number { $[0-9]+ }`: 定义数字的正则表达式。
- `@skip { ... }`: 定义在解析时应该被忽略的内容，这里是行注释和空白字符。

#### 第 2 步：安装 `lezer-generator` 并生成解析器

在你的项目终端中运行以下命令：

```sh
# 安装生成器
npm install @lezer/generator

# 运行生成器，将 simple.grammar 编译成 simple.js
npx lezer-generator simple.grammar -o simple.js
```

执行后，你会得到一个 `simple.js` 文件和一个 `simple.js.map` 文件。`simple.js` 包含了驱动解析的解析表和一些辅助代码。

#### 第 3 步：在代码中使用生成的解析器

现在，你可以在你的 JavaScript/TypeScript 项目中使用这个解析器了。

首先，需要安装 Lezer 的核心包：

```sh
npm install @lezer/common @lezer/lr
```

然后，创建一个文件来使用它，例如 `test-parser.js`。

```javascript
import { parser } from './simple.js' // 导入生成的解析器
import { TreeCursor } from '@lezer/common'

// 要解析的代码
const code = `
  let a = 10;
  b = a; // 这是一个赋值语句
`

// 1. 解析代码，生成语法树
const tree = parser.parse(code)

// 2. 使用 TreeCursor 遍历语法树
let cursor = tree.cursor()

function printTree(cursor, code, indent = '') {
  do {
    // 打印当前节点的信息
    console.log(
      `${indent}${cursor.node.type.name} [${cursor.from}-${cursor.to}]: "${code.substring(
        cursor.from,
        cursor.to
      )}"`
    )

    // 如果有子节点，则递归进入
    if (cursor.firstChild()) {
      printTree(cursor, code, indent + '  ')
      cursor.parent() // 完成子节点遍历后，返回父节点
    }
  } while (cursor.nextSibling()) // 移动到下一个兄弟节点
}

console.log('--- Syntax Tree ---')
printTree(cursor, code)
```

#### 第 4 步：运行并查看结果

使用 Node.js 运行你的测试脚本（需要配置 Node.js 以支持 ES 模块，例如在 package.json 中添加 `"type": "module"`）。

```sh
node test-parser.js
```

你将看到如下输出，清晰地展示了代码的语法结构：

```
--- Syntax Tree ---
Program [0-48]: "
  let a = 10;
  b = a; // 这是一个赋值语句
"
  Statement [3-16]: "let a = 10;"
    let [3-6]: "let"
    Identifier [7-8]: "a"
    Expression [11-13]: "10"
      Number [11-13]: "10"
  Statement [19-25]: "b = a;"
    Identifier [19-20]: "b"
    Expression [23-24]: "a"
      Identifier [23-24]: "a"
```

### 总结

- **流程**: `定义语法 (.grammar)` -> `生成代码 (lezer-generator)` -> `在应用中使用 (parser.parse)` -> `处理语法树 (TreeCursor)`。
- **代码**: `.grammar` 文件是你与 Lezer 交互的主要“代码”，它是一种声明式的领域特定语言。生成的 `.js` 文件是机器代码，你通常不需要直接修改它。应用代码通过导入生成的 `parser` 对象来使用它。
- **优势**: 这种分层和自动化的方法使得创建健壮、高性能的语言工具（如编辑器、静态分析器）变得更加简单和高效。Lezer 的增量特性是其在现代 Web 编辑器领域取得成功的关键。

---

当然可以。处理解析错误是 Lezer 设计中的一个重要部分。Lezer 的核心理念是**容错性**：即使代码包含语法错误，它也不会停止解析，而是会尽力恢复并继续解析文件的其余部分。

Lezer 通过在语法树中插入一个特殊的**`Error`节点**来标记错误。这个节点的名称通常是 `Error` 或 `⚠`。

### 如何找到并处理错误

处理错误的基本流程是：

1.  正常解析代码，获取语法树。
2.  遍历语法树（通常使用 `TreeCursor`）。
3.  检查节点的类型。如果节点类型是 `Error`，说明此处存在一个语法错误。
4.  获取 `Error` 节点的位置（`from` 和 `to`），然后你可以在 UI 中高亮显示该区域，或报告错误信息。

#### 代码示例

让我们在之前的例子中引入一个错误，并编写代码来检测它。

假设我们的输入代码是 `let a 10;` (缺少了 `=`)。

我们可以修改 `test-parser.js` 来查找错误节点。

```javascript
import { parser } from './simple.js'
import { TreeCursor } from '@lezer/common'

// 包含语法错误的代码
const codeWithErrors = `
  let a 10;
  b = a;
`

// 1. 解析代码，生成语法树
const tree = parser.parse(codeWithErrors)

// 2. 遍历树以查找错误
const errors = []
tree.iterate({
  enter: node => {
    // 在 CodeMirror 6.x 中，Error 节点的类型有一个 isError 属性
    // 在旧版本或直接检查时，可以比较类型的名字
    if (node.type.name === 'Error') {
      errors.push({
        from: node.from,
        to: node.to,
        message: `Syntax error: unexpected token "${codeWithErrors.slice(node.from, node.to)}"`
      })
    }
  }
})

// 3. 打印找到的错误
if (errors.length > 0) {
  console.log('Found syntax errors:')
  for (const err of errors) {
    console.log(`- At [${err.from}-${err.to}]: ${err.message}`)
  }
} else {
  console.log('No syntax errors found.')
}

// (可选) 打印整个树来观察 Error 节点的位置
console.log('\n--- Syntax Tree with Error ---')
function printTree(cursor, code, indent = '') {
  do {
    const nodeName = cursor.node.type.name
    const isError = nodeName === 'Error' ? ' <<< ERROR' : ''
    console.log(`${indent}${nodeName} [${cursor.from}-${cursor.to}]${isError}`)
    if (cursor.firstChild()) {
      printTree(cursor, code, indent + '  ')
      cursor.parent()
    }
  } while (cursor.nextSibling())
}
printTree(tree.cursor(), codeWithErrors)
```

#### 运行与结果

运行 `node test-parser-errors.js`，你将得到以下输出：

```
Found syntax errors:
- At [9-11]: Syntax error: unexpected token "10"

--- Syntax Tree with Error ---
Program [0-26]
  Statement [3-13]
    let [3-6]
    Identifier [7-8]
    Error [9-11] <<< ERROR
  Statement [16-22]
    Identifier [16-17]
    Expression [20-21]
      Identifier [20-21]
```

**结果分析**:

- 我们的代码成功地在位置 `9-11` 找到了一个 `Error` 节点，对应于非预期的 `10`。
- 从完整的语法树输出中可以看到，解析器在 `Identifier` "a" 之后期望的是 `=`，但它遇到了 `10`。它将 `10` 标记为 `Error` 节点。
- **重要的是**，解析器并没有停止。它成功恢复并正确解析了下一行 `b = a;`。这就是 Lezer 容错性的体现，对于实时编辑器至关重要。

### 高级错误恢复

对于更复杂的语言，你可以在 `.grammar` 文件中使用 `@recover` 策略来更精细地控制解析器在遇到错误后的行为。例如，你可以告诉它在遇到错误的表达式后，尝试跳到下一个分号 `;` 或右花括号 `}` 来恢复同步，从而提高后续代码解析的准确性。

总而言之，Lezer 通过将错误作为树的一部分来处理，而不是抛出异常，这使得构建能够优雅处理不完整或错误代码的工具成为可能。

---

好的，我们继续深入 Lezer 的相关高级主题。接下来将重点讲解两个方面：

1.  **更高级的 `.grammar` 语法特性**：如何处理更复杂的语言结构，如运算符优先级。
2.  **与 CodeMirror 6 的集成**：Lezer 的解析树如何在实际的编辑器中发挥作用，例如实现语法高亮。

---

### 1. 高级语法 (`.grammar`) 特性

简单的规则不足以描述真实世界的语言。Lezer 提供了一些高级功能来处理歧义和复杂性。

#### 运算符优先级和结合性 (`@prec`)

在之前的例子中，`Expression` 非常简单。但如果我们要解析 `1 + 2 * 3`，解析器如何知道应该先计算乘法？这就需要定义运算符的优先级。

你可以使用 `@prec` 块来声明。

**示例 `.grammar` 文件片段：**

```lezer
// ... (之前的 tokens 定义)

@top Program { Expression }

// 定义优先级和结合性
// 每一行代表一个优先级，从低到高
@prec {
  left "+" "-" // 加减法，左结合
  left "*" "/" // 乘除法，左结合 (优先级更高)
}

Expression {
  BinaryExpression | // 二元表达式
  Number |           // 数字
  "(" Expression ")" // 带括号的表达式
}

// 使用 `prec` 关键字引用优先级名称
BinaryExpression { Expression !prec[name] Expression }

// ... (tokens 定义)
@tokens {
  Number { $[0-9]+ }
  "+" "-" "*" "/" "(" ")" // 添加运算符
}

@skip { $[ \t\n\r]+ }
```

**代码讲解**:

- `@prec { ... }`: 这个块定义了名为 `+`, `-`, `*`, `/` 的优先级。
- `left "+" "-"`: 定义了 `+` 和 `-` 为左结合（`a - b - c` 被解析为 `(a - b) - c`），并且它们的优先级相同。
- `left "*" "/"`: 定义了 `*` 和 `/`，因为它们在 `@prec` 块中的位置更靠后，所以它们的**优先级更高**。
- `BinaryExpression { Expression !prec[name] Expression }`: 这是一个动态规则。`!prec[name]` 会在解析时根据实际匹配到的运算符（例如 `+` 或 `*`）去查找其在 `@prec` 块中定义的优先级，从而解决歧义。

现在，当解析 `1 + 2 * 3` 时，Lezer 会生成如下结构的树，正确地将 `2 * 3` 组合在一起：

```
BinaryExpression (+)
  - Number (1)
  - BinaryExpression (*)
    - Number (2)
    - Number (3)
```

---

### 2. 与 CodeMirror 6 集成：实现语法高亮

Lezer 的主要目标是服务于 CodeMirror 6。解析出的语法树是实现语法高亮、代码折叠、自动补全和实时错误检查（Linting）的基础。

语法高亮的工作流程如下：

1.  **解析代码**：Lezer 解析器运行，生成 CST。
2.  **定义高亮样式**：创建一个 `HighlightStyle`，它将一组标准的“高亮标签”（Highlighting Tags）映射到具体的 CSS 类名。
3.  **关联节点与标签**：在你的语言包中，创建一个 `highlighter`，它负责将语法树中的节点类型（如 `Identifier`, `Number`, `let`）映射到这些标准的高亮标签。
4.  **应用到编辑器**：CodeMirror 的视图（View）系统会遍历语法树，根据节点类型和你的映射规则，为对应的文本范围添加 CSS 类，从而实现高亮。

#### 代码示例

假设我们想为我们之前创建的 `simple` 语言添加语法高亮。

**第 1 步：安装 CodeMirror 相关包**

```sh
npm install @codemirror/language @codemirror/state @codemirror/view
```

**第 2 步：定义高亮标签映射**

创建一个 `simple-language.js` 文件来组织语言支持。

```javascript
import { parser } from './simple.js'
import {
  LRLanguage,
  LanguageSupport,
  indentNodeProp,
  foldNodeProp,
  foldInside,
  delimitedIndent
} from '@codemirror/language'
import { styleTags, tags as t } from '@lezer/highlight'

// 1. 创建一个 LRLanguage 实例，它将 Lezer 解析器与 CodeMirror 连接起来
export const simpleLanguage = LRLanguage.define({
  parser: parser.configure({
    // 2. 将语法树中的节点类型映射到标准高亮标签
    props: [
      styleTags({
        let: t.keyword, // "let" 字符串是关键字
        Identifier: t.variableName, // Identifier 是变量名
        Number: t.number, // Number 是数字
        LineComment: t.lineComment, // 注释
        '( )': t.paren, // 括号
        ';': t.separator, // 分号
        '=': t.operator // 等号是操作符
      })
    ]
  }),
  languageData: {
    commentTokens: { line: '//' }
  }
})

// 3. 创建一个 LanguageSupport 实例，这是 CodeMirror 扩展的标准格式
export function simple() {
  return new LanguageSupport(simpleLanguage)
}
```

**代码讲解**:

- `@lezer/highlight` 提供了 `styleTags` 函数和一组标准标签 `t`（例如 `t.keyword`, `t.variableName`）。使用标准标签而不是直接使用 CSS 类名，可以让你的语言包与任何主题（Theme）兼容。
- `LRLanguage.define`: 这是定义一个 CodeMirror 语言包的核心。
- `parser.configure({ props: [...] })`: 我们在这里为解析器附加元数据（props）。
- `styleTags({ ... })`: 这个函数接收一个对象，其键是你在 `.grammar` 文件中定义的节点名称（字符串形式），值是对应的高亮标签。

**第 3 步：在编辑器中使用**

现在，你可以在一个基本的 CodeMirror 实例中使用这个语言包。

```javascript
import { EditorState } from '@codemirror/state'
import { EditorView, keymap } from '@codemirror/view'
import { defaultKeymap } from '@codemirror/commands'
import { simple } from './simple-language.js' // 导入我们的语言支持
import { highlightActiveLine } from '@codemirror/view'
import { defaultHighlightStyle } from '@codemirror/language' // 导入默认高亮样式

const code = `let a = 10;
// This is a comment
b = a;
`

new EditorView({
  state: EditorState.create({
    doc: code,
    extensions: [
      keymap.of(defaultKeymap),
      simple(), // <-- 使用我们的语言包
      defaultHighlightStyle.fallback, // <-- 提供默认的颜色方案
      highlightActiveLine()
    ]
  }),
  parent: document.body
})
```

当你用 Webpack 或类似工具打包并运行此 HTML/JS 后，你将看到一个 CodeMirror 编辑器，其中 `let` 是关键字颜色，`a` 和 `b` 是变量颜色，`10` 是数字颜色，注释也被正确高亮。

### 总结

- Lezer 的 `.grammar` 语法足够强大，可以通过 `@prec` 等指令处理真实语言中的复杂情况。
- Lezer 的最终产物（CST）是为工具服务的。通过 `@codemirror/language` 和 `@lezer/highlight`，可以轻松地将 CST 节点映射为语法高亮标签，实现与编辑器主题无关的、高性能的语法高亮。
- 这个模式也同样适用于代码折叠 (`foldNodeProp`)、缩进 (`indentNodeProp`) 等其他编辑器智能特性。
