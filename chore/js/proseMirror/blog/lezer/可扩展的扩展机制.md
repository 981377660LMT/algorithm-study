# 可扩展的扩展机制

https://marijnhaverbeke.nl/blog/extensibility.html

- 将大型系统构造成若干独立包的做法已成时尚。其驱动理念是，与其将人们锁定在你对某一功能的实现中，不如将该功能作为一个独立包提供，用户可以将其与核心系统一起加载。
  这种方法的代价主要是复杂性。你可以提供一个内置完备的包装包来帮助用户入门，但在某个阶段，他们可能不得不拆掉盖子，开始安装和配置特定的辅助包，这通常比在单体库中开启一个功能要难。

- make it possible to add (and remove) styling, instead of setting it
  你必须确保扩展可以组合使用，即使它们完全不知道彼此的存在，也不会导致有问题的相互作用。
  为此，每个扩展点必须支持被任意数量的参与者作用。如何处理多个效果因用例而异。一些可能有意义的策略包括：

  - 它们全部生效。
  - 它们形成一个流水线。
  - 先到先得的方法可以应用于例如事件处理器。每个处理器都有机会处理该事件，直到其中一个声明已经处理了它，此时排在后面的处理器就不再被询问。
  - 用某种运算符（比如逻辑或、逻辑与、最小值或最大值）将多个输入约简为单一值

  在许多情况下，顺序是重要的。这意味着应该能够控制并预测具有影响的优先级如何被应用。这是命令式、基于副作用的扩展系统往往表现不佳的地方之一。`如果单一系统控制所有调用，或者调用顺序恰好无关紧要，这没有问题，但当多个独立的软件各自添加处理器时，就很难预测哪些处理器会先被调用。`

---

好的，遵照您的要求，我将倾尽所学，对 Marijn Haverbeke 这篇关于“可扩展的扩展机制”的博文进行一次深入、详细、透彻的讲解。

这篇文章是理解 CodeMirror 6 核心设计哲学——尤其是其革命性的扩展系统 Facet——的**思想源头**。虽然文末的具体实现细节后来发生了演变（正如作者在文首的标注中所说），但这篇文章所探讨的**问题的本质、设计的权衡、以及最终解决方案的雏形**，是理解最终 Facet 系统“为何如此设计”的无价之宝。它是一份关于如何设计一个能“大规模扩展”的系统的深刻思考录。

我们将从以下几个角度，层层递进，来彻底剖析这篇文章：

1.  **问题的提出：从“模块化”到“可组合性”**: 为什么简单的模块化还不够？一个“好的”扩展系统到底要解决什么？
2.  **ProseMirror 的反思：一个“简单方法”的局限性**: ProseMirror 的插件系统已经很先进了，但它在“大规模扩展”时遇到了哪些瓶颈？
3.  **核心挑战的拆解：排序、分组与去重**: 作者将设计一个更强大系统的难题，拆解为三个相互关联的核心挑战。
4.  **设计草图：一个更强大系统的诞生 (Behavior 系统)**: 详细解读 CodeMirror 6 早期设计的“三驾马车”——Behavior、复合扩展、唯一扩展，以及它们如何协同工作。
5.  **思想的升华：从命令式到声明式**: 为什么说这种设计虽然更难上手，但其价值足以抵消成本？

---

### 1. 问题的提出：从“模块化”到“可组合性”

文章开篇就指出了现代软件架构的趋势——**模块化**，并列举了其四大好处（按需加载、可替换、接口的现实检验、隔离性）。但紧接着，作者通过一个自己犯过的“愚蠢错误”的例子，引出了一个更深层次的问题：**可组合性 (Composability)**。

- **愚蠢的错误**: 早期的编辑器 API 允许 `setLineStyle()`。这在只有一个扩展时工作良好。但当两个独立的扩展都想设置样式时，它们会互相覆盖，造成混乱。
- **解决方案**: 将 `set` (设置) 改为 `add/remove` (添加/移除)。这样多个扩展就可以在不互相破坏的情况下，共同作用于同一行。
- **核心洞见**: 一个好的扩展系统，必须确保**多个互不知晓的扩展能够被组合在一起，而不会产生问题**。

作者进一步将“组合策略”归纳为四种常见模式：

1.  **全部生效 (All take effect)**: 如添加 CSS 类、显示小部件。需要考虑顺序。
2.  **形成管道 (Pipeline)**: 如过滤文档变更。每个处理器处理上一个的输出。
3.  **先到先得 (First come, first served)**: 如事件处理、快捷键绑定。第一个声明处理了事件的扩展，将中断后续处理。
4.  **归约为一 (Reduce to a single value)**: 如配置参数。通过 `min`, `max`, `||`, `&&` 等操作符将多个输入合并为一个输出。

**关键问题**: 在很多策略中，**顺序 (Ordering)** 都至关重要。而传统的、基于副作用的命令式系统（如 `addEventListener`）在处理顺序时有天然缺陷，因为顺序依赖于不可预测的注册时机。

---

### 2. ProseMirror 的反思：一个“简单方法”的局限性

ProseMirror 的插件系统是作者第一次大规模实践模块化思想的产物。它已经非常先进了：

- **机制**: 创建编辑器时，传入一个扁平的 `plugins` 数组。
- **优点**: 插件的顺序决定了其优先级，简单直接。例如，快捷键插件在数组中越靠前，优先级越高。
- **局限性 (当扩展规模变大时)**:
  1.  **优先级捆绑**: 一个插件如果需要多种效果（如快捷键和事件处理），而这些效果又需要不同的优先级，你就必须把这个插件拆分成更小的单元，非常笨拙。
  2.  **排序脆弱**: 用户很难知道哪些插件之间存在优先级冲突。排序错误往往只在运行时特定场景下才暴露，难以发现。
  3.  **手动依赖管理**: 插件 A 如果依赖插件 B，只能在文档里说明，并寄希望于用户记得把 B 也加到配置里，并且放在正确的位置。

**结论**: ProseMirror 的“简单方法”虽然够用，但它无法优雅地处理“大规模扩展”带来的复杂依赖和排序问题。CodeMirror 6 需要一个**更具表现力 (more expressive)** 的系统。

---

### 3. 核心挑战的拆解：排序、分组与去重

作者将设计这个“更具表现力”的系统的过程，归结为解决三大核心挑战：

#### A. 排序 (Ordering)

- **`z-index` 的教训**: 简单地使用数值作为优先级（像 CSS 的 `z-index`）是灾难性的。模块在隔离开发时，无法知道其他模块会用什么值，最终导致大家都在用 `999999` 这样的魔法数字。
- **改进思路**: 定义一组**有限的、有良好命名的优先级类别**（如 `highest`, `default`, `lowest`）。这比无限的数字范围要好得多，但仍然需要一种方法来解决同类别内的顺序问题。

#### B. 分组 (Grouping)

一旦你开始大量依赖扩展，可能会出现某些扩展依赖于其他扩展的情况。手动管理依赖关系难以扩展，因此如果能够一次性引入一组扩展会更好。

- **需求**: 能够将一个功能所需的所有扩展（及其依赖）打包成一个单元，而不是让用户手动管理。
- **引入的问题**: 分组让排序问题变得更复杂，并且带来了新的问题——去重。

#### C. 去重 (Deduplication)

- **问题**: 如果扩展 A 和 B 都依赖于共享扩展 C，那么在配置中很容易出现多个 C 的实例。对于某些扩展（如 Undo 历史），这是致命的。
- **挑战**: 扩展通常是可以配置的，这意味着不同的 C 实例可能并不完全相同。你不能简单地随便挑一个用，而需要以一种有意义的方式**合并 (merge)** 它们的配置，或者在无法合并时报错。

**结论**: 允许扩展组合，不可避免地将**依赖管理的复杂性**引入到了扩展系统中。

---

### 4. 设计草图：一个更强大系统的诞生 (Behavior 系统)

这里描述的是 Facet 系统的早期原型，它通过引入三个核心概念来应对上述挑战。

#### 核心概念 1: 行为 (Behavior)

- **定义**: 一个“行为”就是一个**可被扩展的东西**，一个扩展点。例如，“状态字段行为”、“事件处理器行为”。
- **角色**:
  - **消费者**: 从一个“行为”中可以获取一个有序的值序列。
  - **提供者**: “扩展”可以为“行为”提供值。
- **创新点**: “行为”本身也是一个**值**。这使得任何第三方代码都可以定义自己的新扩展点，与核心内置的扩展点地位完全平等。例如，行号插件可以定义一个“行号槽标记行为”，允许其他插件往行号槽里添加标记。

#### 核心概念 2: 扩展 (Extension)

- **定义**: 一个用于配置编辑器的**值**。
- **类型**:
  1.  **行为实例 (Simplest type)**: 最简单的扩展就是一个行为的值。
  2.  **复合扩展 (Grouped extension)**: 一个扩展可以由一组其他扩展构成。例如，一个“语言包”扩展可以打包“语法高亮”、“缩进规则”、“自动补全源”等多个子扩展。

#### 核心概念 3: 唯一扩展 (Unique Extension)

- **目的**: 解决**去重**问题。
- **机制**:
  1.  **定义**: 想要去重的扩展（如 Undo 历史）需要将自己定义为“唯一扩展”。它需要提供一个 `spec` 类型（配置参数的类型）和一个**实例化函数**。
  2.  **解析过程**:
      - 系统在解析所有扩展时，会收集所有同类型的“唯一扩展”实例。
      - 然后，它将所有这些实例的 `spec` (配置) 收集起来，作为一个数组，传递给该唯一扩展的**实例化函数**。
      - 这个实例化函数负责**合并**所有的配置，并最终只返回**一个**扩展实例。
- **精妙之处**: 它将“如何合并多个配置”这一复杂问题，交给了**唯一扩展的作者自己去定义**，而不是让框架做不合理的猜测。

#### 解决排序问题

- **基本规则**: 默认顺序由扩展在配置数组中的位置决定。复合扩展会被“扁平化”插入到其出现的位置。唯一扩展的解析结果会被插入到其第一次出现的位置。
- **优先级类别**: 扩展可以将其子扩展分配到不同的优先级类别中（`fallback`, `default`, `extend`, `override`）。最终排序首先按类别，然后按原始位置。

---

### 5. 思想的升华：从命令式到声明式

文章最后，作者总结了这个设计的核心价值：

> "Having extensions properly compose seems to provide enough value to offset that cost." (让扩展能够正确地组合，其价值足以抵消因此带来的成本。)

- **成本是什么？**: 这个系统引入了新的概念（Behavior, Unique Extension 等），它比传统的命令式 API (`editor.addPlugin()`) **更难理解和使用**。
- **价值是什么？**:
  1.  **真正的组合性**: 扩展可以被组合，而无需关心其内部实现细节。
  2.  **声明式**: 你描述的是“你想要什么配置”，而不是“如何一步步修改编辑器的状态”。
  3.  **健壮性**: 系统负责解决排序、依赖、去重等复杂问题，将开发者从脆弱的手动管理中解放出来。

### 总结

这篇文章是一份无与伦比的、关于复杂系统设计的深度思考。它记录了从一个“好的”系统（ProseMirror）到一个“伟大的”系统（CodeMirror 6）的思想飞跃。

它告诉我们，当系统的复杂性达到一定规模时，简单的修修补补是无用的。你必须回归问题的本源——**可组合性**，并愿意为此设计一套全新的、虽然更抽象但更强大的机制。

“Behavior”系统的设计草图，虽然在细节上与最终的 Facet 系统有所不同，但其核心思想——**将扩展点本身作为值、通过声明式提供配置、由系统负责解析和组合**——被完整地继承了下来。这篇文章，就是打开 CodeMirror 6 架构黑箱，理解其设计动机和思想演进的“罗塞塔石碑”。
