谈谈编辑器的架构设计
https://zhuanlan.zhihu.com/p/681850367

1. 总览

编辑器的架构类似 MVC。

- State
  每当我们编辑一个东西时，某一时刻的这个东西在内存中的那个对象就是所谓的 state。
  State 往往和我们所见一一映射，无论何时何地，回滚到某个特定的 state，我们的所见一定是一致的。
  `可以理解为，database 中的数据。核心数据结构。`
  `低代码中的schema.`
- Model
  Model 介于 state 和 view `之间`。
  提`供了操作 state 的接口、向 view 暴露 state 的接口。`
  `并在 state 发生变化时，保证 view 能够及时同步。`
- View
  `它将 state 映射为某个色彩斑斓的页面，且所有用户的交互操作都会通过这一层的代码变成 model API 的调用。`

由于 `view 与业务强耦合`，所以后文我们探讨的大部分问题都和 state/model 的设计相关。
在 view 层的设计中，我们主要关注模块化、复用性和可扩展性，因此会探讨一下插件化的架构设计。

2. State 的数据结构设计
   State 的设计放在第一位，因为对编辑器来说它往往是个复合的数据结构，而`数据结构则与业务强相关`，后续的两个层级也紧紧围绕着这个数据结构而制定。
   一个代码编辑器，其数据结构可能就是一个字符串。
   一个富文本编辑器，数据结构往往是树形的。
   一个表格，数据结构可能是一些列数组。

   围绕着 state 的数据结构，model 提供的读写 state 的 api 也就定型了：

   - 字符串的 api 就是通过下标访问。
   - 树形结构的 api 中，对某个节点的操作既有可能从当前节点发起，又有可能从父节点或者子节点发起。因此，操作特定子节点的 api 和操作父节点的 api 都是必要的。
   - 表格的 api

3. 版本管理
   diff/snaphot => op/crdt
   两种形式都是必要的

   - Snapshot 是最简单的版本管理载体。不论编辑器的中间过程是否有 bug，不论 app 本身是从内存、本地文件系统还是云上获取版本，使用 snapshot 只需要一次读操作，简单且稳定。
   - Diff 也有其必要性，因为对于很大很复杂的 state 来说，diff 的存储空间小，易于传输；diff 可以避免一次性更新整个 view。

   如果要做版本的存储和切换，则使用 snapshot。如果在使用编辑器期间对用户的交互做同步，则使用 diff 以降低延时，减少计算量。
   diff 有时叫 step，是一种操作的记录，可以用来回滚，也可以用来同步。
   涉及到两个问题：diff 的算法和 diff 的序列化

   - diff 算法

     1. 做的简单一点，直接将用户的输入记录为 diff。
     2. 做的复杂一点，就是给定两个 snapshot，计算它们的 diff.
        为了配合这样的算法，甚至 state 的数据结构也可以做修改。例如在 codemirror 中，它的数据结构并非一个完整的字符串，而是一个一个子字符串拼接起来的 array (分块)。

        vscode 案例：
        正常的编辑、undo、redo 时，其产生的 diff 都基于交互输入直接计算得到；
        在 File History 一栏中选择特定版本回滚时，其会直接回滚，然后通过算法来得到 diff（例如 git 所使用的 myers diff 算法）；

   - diff 序列化
     Diff 需要序列化，以保证它能够跨进程/跨端被同步，例如 Language Server Protocol 和协同编辑。
     这个又是与数据结构本身深度耦合的事情.

4. 读写接口设计
   这里主要想谈谈树形结构。为了保证灵活性，几种访问的模式都需要考虑。

   - getNodeById
   - getParent
   - getChilden
   - 导出、导入 state (dump、load)

   好的方式是将所有节点的 state 当做一个整体存储在某个变量中，然后将树形的 model 与其做一一映射。

5. 事务
   JavaScript 是单线程的，所以没有隔离性的问题，但原子性、一致性和持久性需要考虑。
   `双缓冲：`框架中有一个变量代表完整的 state。框架提供一个 update(callback)函数，当调用时，框架为 state 创建一个 deep copy，然后再在 callback 中执行更新操作。当 callback 结束后，框架用新的 state 替换旧的（也可以在这个阶段计算 diff）。
   `协同编辑`：
   CRDT/yjs 的核心思想：要求操作满足交换律、结合律。根据`时间戳`+相对的 diff 恢复出绝对坐标的算法
6. 事件驱动设计
   编辑器中的主要事件，暴露为接口以供插件使用。
   两类事件：

   - 修改前，可以拿到修改，transduce 成新的修改。
     `由于输入的信息和输出的信息不一致，因此注册的callback需要有顺序（优先级）。`
   - 修改完成后，广播 diff

   除了编辑器提供的事件之外，view 中的不同模块/插件之间也可能有联动的需求。
   考虑 ServiceLocator 或者依赖注入。
