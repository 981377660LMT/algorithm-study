这篇文章的核心思想是介绍“云凤蝶”这个低代码平台中“自由画布”功能的架构设计。为了管理复杂画布上的各种用户交互和视觉元素，云凤蝶采用了一种**分层模型**，这既保证了代码的清晰可维护，也优化了性能。

我们可以将整个讲解分为四个关键部分：

### 1. 核心理念：渲染与交互分离

文章开篇就点明了核心：**画布的一切都是分层的**。这就像在 Photoshop 或画图软件里使用图层一样。

- **渲染层 (Rendering Layer)**：这是最底层的图层。它只做一件事——把 Antd 等 UI 组件按照用户的配置原样展示出来。它好比是画布的“底稿”，只负责呈现最终的样子，不关心用户如何点击、拖拽。
- **交互层 (Interaction Layer)**：这是叠加在渲染层之上的一系列透明图层。用户的每一个动作，比如选中组件、拖拽、右键点击，以及画布上显示的辅助信息，如对齐线、错误提示、组件间距等，都在这些独立的交互层上实现。

**为什么要分离？**
这种分离带来了巨大的好处：**关注点分离**。渲染层专心渲染，交互层专心处理交互逻辑。这使得系统结构清晰，当需要新增一种交互（比如一个新的辅助线）时，只需增加一个新的交互层，而无需改动复杂的渲染逻辑，大大提高了代码的可维护性和扩展性。

---

### 2. 核心机制：层与层之间的通信

既然渲染和交互分开了，那么交互层如何知道用户在渲染层上做了什么？比如，用户点击了哪个组件？组件的位置在哪里？文章介绍了两个关键机制：`EventBus` 和 `PositionMonitor`。

- **EventBus (事件总线)**：可以理解为一个“中央广播站”。

  - 当用户在画布上进行操作时（如点击、拖拽），事件首先发生在最底层的**渲染层**。
  - 渲染层捕获到这些原始事件后，并不自己处理，而是通过 `EventBus` 将事件“广播”出去（例如，“A 组件在坐标(x,y)被点击了”）。
  - 所有**交互层**都在“收听”这个广播站。对这个事件感兴趣的层（比如“选中框层”）接收到消息后，执行自己的逻辑（比如在 A 组件周围画上选中框）。
  - 这样就实现了层与层之间的解耦通信。

- **PositionMonitor (位置监视器)**：这是一个专门收集和提供组件位置信息的工具。
  - 交互层需要精确地知道每个组件在画布上的位置和大小，才能在正确的地方绘制辅助线、边框等。
  - `PositionMonitor` 利用浏览器的 `MutationObserver` API 来“监视”所有画布组件。一旦有组件的位置或尺寸发生变化（比如被拖拽或调整大小），它就会立即计算并更新该组件的最新坐标信息 (`getBoundingClientRect`)。
  - 其他层可以通过查询 `PositionMonitor` 来获取任何组件的实时位置，从而保证交互效果的精确性。

---

### 3. 性能优化：可观察模型驱动视图(类似 Signal)

对于画布这种需要高频交互（如拖拽时实时显示对齐线）的场景，性能至关重要。如果每次鼠标移动都触发整个画布的重新渲染，会造成严重的卡顿。

为了解决这个问题，云凤蝶采用了**“可观察模型驱动视图”**的机制，并引入了一个名为 `$model` 的核心对象。

- **$model**：这是一个全局共享的数据模型，挂载在画布的顶层，所有的层（包括渲染层和交互层）都可以访问它。它像一个“中央状态管理器”。
- **可观察 (Observable)**：`$model` 里的所有数据都是“被观察”的。当某个交互层去读取 `$model` 里的一个字段时（例如，`$model.selectedComponentId`），系统会自动记录下来：“哦，这个交互层依赖了这个字段”。
- **精确更新**：当这个字段的值发生变化时（例如，用户点击选中了另一个组件，`selectedComponentId` 改变了），系统不会盲目地更新所有图层，而是**只精确地通知那些依赖了这个字段的图层**去更新视图。没有依赖该字段的图层则完全不动。

这种方式避免了不必要的渲染，实现了“数据变化 -> 视图精确更新”的高性能模式，保证了拖拽等操作的流畅体验。

---

### 4. 视觉呈现：UI 视图堆叠模式

文章最后提到，简单的“交互层在渲染层之上”的堆叠模式有时无法满足复杂的视觉需求。例如，希望一个未选中的组件可以遮挡住另一个已选中组件的蓝色边框。

为此，云凤蝶设计了更精细的 4 种视图堆叠模式，让交互效果的实现更加灵活：

1.  **Layer**：标准的交互层，覆盖在整个画布之上。用于绘制对齐线、框选区域等。
2.  **InstanceLayer**：与单个组件实例绑定的层，覆盖在**特定组件**之上。
3.  **WrapperLayer**：包裹在**特定组件**的外部，但层级低于其他组件。这可以实现“选中框被其他组件遮挡”的效果。
4.  **ToolBar**：独立的工具条层，通常悬浮在画布或组件的特定位置。

一个交互功能可以根据需要，组合使用这几种模式，从而实现任意复杂的视觉交互效果。

### 总结

云凤蝶自由画布的成功在于其优雅的**分层架构**。通过将渲染和交互彻底分离，并借助 `EventBus`、`PositionMonitor` 进行通信，利用 `$model` 和可观察机制实现高性能的精确更新，再配合灵活的视图堆叠模式，最终构建了一个高内聚、低耦合、高性能且易于扩展的复杂画布系统。
