https://juejin.cn/post/7145010646248063006#heading-9

好的，我们来详细讲解这三份核心协议以及它们之间的关系。

为了方便理解，我们可以使用一个非常贴切的比喻：**用乐高积木拼装一个模型**。

- **《低代码引擎物料协议规范》 (Material Protocol)**：定义了**每一块乐高积木**是什么样的。它描述了积木的形状、颜色、有多少个凸起（属性），但它本身只是一块块独立的积木。
- **《低代码引擎搭建协议规范》 (Schema Protocol)**：这是**拼装图纸/说明书**。它告诉你应该用哪些积木（`componentName`），以什么样的顺序和结构（`children` 树状结构）组合起来，最终形成一个完整的模型（页面）。
- **《低代码引擎资产包协议规范》 (Assets Protocol)**：这是**整个乐高玩具的包装盒**。盒子上印着所有积木的清单（`packages`），每块积木的详细介绍（`components`），以及拼装说明书（`schema` 是由搭建协议定义的）。你拿到这个“盒子”，就拥有了拼装模型所需的一切信息和资源。

下面我们来逐一深入讲解。

---

### 1. 《低代码引擎物料协议规范》 (Material Protocol)

这份协议规范了“物料”的定义。在低代码领域，“物料”是一个广义的概念，通常指构成页面的基本单元，最核心的就是**组件**。

- **它回答的问题是**：“一个独立的组件，需要提供哪些信息才能被引擎识别和使用？”
- **核心内容**：这份协议详细定义了 `ComponentDescription` 接口（在 `2_资产包协议.md` 中可以看到）。它规定了一个标准的组件必须包含：
  - **身份信息**：`componentName` (唯一标识), `title` (名称), `icon` (图标) 等。
  - **属性定义 (`props`)**：声明该组件有哪些可配置的属性，以及每个属性的类型、默认值等。这就像定义一个 React 组件的 `propTypes`。
  - **配置描述 (`configure`)**：**这是关键**。它描述了 `props` 应该如何在设计器的“属性配置”面板中展示出来。比如，一个 `string` 类型的 `prop` 应该用一个文本输入框（`StringSetter`）来编辑，一个 `boolean` 类型的 `prop` 应该用一个开关（`BoolSetter`）来编辑。
  - **代码片段 (`snippets`)**：定义了当组件被拖拽到画布上时，初始生成的页面 `Schema` 结构。
  - **来源信息 (`npm`)**：指明这个组件的代码来自哪个 npm 包。

**简单来说，物料协议就是为所有“组件”制定的一份标准“身份证”模板，确保引擎能看懂并使用它们。**

---

### 2. 《低代码引擎搭建协议规范》 (Schema Protocol)

这份协议定义了如何描述一个完整的页面（或页面局部）的结构。

- **它回答的问题是**：“一个由无数组件构成的、复杂的页面，应该如何用数据来表达和存储？”
- **核心内容**：它定义了一个树状的 JSON 数据结构，我们称之为 `Schema`。
  - **树状结构**：`Schema` 的核心是 `componentsTree`，它是一个递归的树状结构。每个节点都代表一个组件实例。
    - `componentName`: 引用物料协议中定义的组件标识，告诉引擎这里要用哪个组件。
    - `props`: 配置该组件实例的属性。比如，一个 `Button` 组件，在这里可以设置它的 `text` 为“提交”，`type` 为 `primary`。
    - `children`: 一个数组，包含了当前组件的子节点，子节点的结构和父节点一样，从而形成一棵完整的组件树。
  - **页面级信息**：除了组件树，`Schema` 还包含整个页面的全局信息，如 `dataSource` (数据源配置)、`utils` (全局工具函数)、`css` (页面级样式) 等。

**简单来说，搭建协议就是页面的“数字骨架”或“蓝图”。低代码设计器上所有的拖拽、配置操作，最终都是在修改这份 `Schema` JSON 数据。当页面需要渲染时，引擎会解析这份 `Schema`，像搭积木一样，递归地实例化每一个组件，最终呈现出完整的页面。**

---

### 3. 《低代码引擎资产包协议规范》 (Assets Protocol)

这份协议将上述所有零散的概念整合在一起，形成一个可被引擎直接消费的完整“资源包”。

- **它回答的问题是**：“如何把一个项目所需的所有组件、插件、依赖库及其描述信息，打包成一个文件，方便引擎动态加载？”
- **核心内容**：它定义了 `Assets` 结构，这是一个顶层的 JSON 对象，包含了：
  - **`packages` (资源包清单)**：一个数组，列出了所有需要加载的 JS/CSS 文件的 CDN 地址。它告诉引擎去哪里下载 `React`、`Ant Design` 以及业务组件库的代码。它通过 `library` 字段指明每个库加载后在 `window` 上的全局变量名，是资源加载的基石。
  - **`components` (组件描述集合)**：一个数组，包含了项目中所有组件的**物料描述**（即遵循《物料协议》的 `ComponentDescription` 对象）。引擎通过读取这个数组，才知道组件面板里有哪些组件可选，以及每个组件的属性该如何配置。
  - **`plugins` / `setters` (插件/设置器)**：定义了设计器需要加载的插件和设置器，并指明它们的实现代码可以从 `packages` 中的哪个资源包里找到。
  - **`sort` (排序信息)**：定义组件在面板中的分组和排序。

**简单来说，资产包协议就是低代码引擎的“入口清单”。引擎启动时，首先加载并解析这份协议文件。然后根据 `packages` 去下载资源，根据 `components` 来初始化组件面板和属性配置逻辑。它是连接引擎、物料、资源的枢纽。**

### 三者关系总结

1.  **物料协议** 定义了**单个零件**（组件）的标准。
2.  **搭建协议** 定义了如何用这些零件**组装成最终产品**（页面）的**图纸**。
3.  **资产包协议** 则是一个**完整的工具箱**，它既包含了所有**零件的清单和说明书**（遵循物料协议的 `components` 数组），也包含了获取这些零件的**渠道**（`packages`），使得引擎可以根据**图纸**（搭建协议 `Schema`）进行施工。

**工作流如下：**

> 开发者提供一份**资产包 (Assets)** -> 低代码引擎加载这份资产包 -> 引擎根据 `packages` 下载 JS/CSS -> 引擎根据 `components` (物料协议) 初始化左侧组件面板 -> 用户在画布上拖拽组件 -> 设计器生成/修改页面的 **Schema (搭建协议)** -> 引擎根据 `Schema` 实时渲染出页面。
