- 是什么： 资产包: 低代码引擎加载资源的动态数据集合，主要包含组件及其依赖的资源、组件低代码描述、动态插件/设置器资源等。

- 为什么：一个组件要在引擎上渲染和配置，需要提供组件的 umd 资源以及组件的低代码描述，并且组件通常都是以集合的形式被引擎消费的；除了组件之外，还有组件的依赖资源、引擎的动态插件/设置器等资源也需要注册到引擎中；因此我们定义了`“低代码资产包”这个数据结构，来描述引擎所需加载的动态资源的集合。`

- 怎么办：
  协议最顶层结构如下，包含 7 方面的描述内容：

  version { String } 当前协议版本号
  packages { Array } 低代码编辑器中加载的资源列表
  components { Array } 所有组件的描述协议列表
  sort { Object } 用于描述组件面板中的 tab 和 category
  plugins { Array } 设计器插件描述协议列表
  setters { Array } 设计器中设置器描述协议列表
  extConfig { Object } 平台自定义扩展字段

```ts
/**
 * 资产包协议
 */
export interface Assets {
  /**
   * 资产包协议版本号
   */
  version: string
  /**
   * 资源列表
   */
  packages?: Array<Package>
  /**
   * 所有组件的描述协议集合
   */
  components: Array<ComponentDescription | RemoteComponentDescription>
  /**
   * 低代码编辑器插件集合
   */
  plugins?: Array<PluginDescription>
  /**
   * 低代码设置器集合
   */
  setters?: Array<SetterDescription>
  /**
   * 平台扩展配置
   */
  extConfig?: AssetsExtConfig
  /**
   * 用于描述组件面板中的 tab 和 category
   */
  sort: ComponentSort
}

export interface AssetsExtConfig {
  [index: string]: any
}

/**
 * 描述组件面板中的 tab 和 category 排布
 */
export interface ComponentSort {
  /**
   * 用于描述组件面板的 tab 项及其排序，例如：["精选组件", "原子组件"]
   */
  groupList?: String[]
  /**
   * 组件面板中同一个 tab 下的不同区间用 category 区分，category 的排序依照 categoryList 顺序排列；
   */
  categoryList?: String[]
}

/**
 * 定义资产包依赖信息
 */
export interface Package {
  /**
   * 唯一标识
   */
  id: string
  /**
   * 包名
   */
  package: string
  /**
   * 包版本号
   */
  version: string
  /**
   * 资源类型
   */
  type: string
  /**
   * 组件渲染态视图打包后的 CDN url 列表，包含 js 和 css
   */
  urls?: string[] | any
  /**
   * 组件多个渲染态视图打包后的 CDN url 列表，包含 js 和 css，优先级高于 urls
   */
  advancedUrls?: ComplexUrls
  /**
   * 组件编辑态视图打包后的 CDN url 列表，包含 js 和 css
   */
  editUrls?: string[] | any
  /**
   * 组件多个编辑态视图打包后的 CDN url 列表，包含 js 和 css，优先级高于 editUrls
   */
  advancedEditUrls?: ComplexUrls
  /**
   * 低代码组件的 schema 内容
   */
  schema?: ComponentSchema
  /**
   * 当前资源所依赖的其他资源包的 id 列表
   */
  deps?: string[]
  /**
   * 指定当前资源加载的环境
   */
  loadEnv?: LoadEnv[]
  /**
   * 当前资源是否是 external 资源
   */
  external?: boolean
  /**
   * 作为全局变量引用时的名称，和 webpack output.library 字段含义一样，用来定义全局变量名
   */
  library: string
  /**
   * 组件描述导出名字，可以通过 window[exportName] 获取到组件描述的 Object 内容；
   */
  exportName?: string
  /**
   * 标识当前 package 资源加载在 window.library 上的是否是一个异步对象
   */
  async?: boolean
  /**
   * 标识当前 package 从其他 package 的导出方式
   */
  exportMode?: string
  /**
   * 标识当前 package 内容是从哪个 package 导出来的
   */
  exportSourceId?: string
  /**
   * 标识当前 package 是从 window 上的哪个属性导出来的
   */
  exportSourceLibrary?: string
}

/**
 * 复杂 urls 结构，同时兼容简单结构和多模态结构
 */
export type ComplexUrls = string[] | MultiModeUrls

/**
 * 多模态资源
 */
export interface MultiModeUrls {
  /**
   * 默认的资源 url
   */
  default: string[]
  /**
   * 其他模态资源的 url
   */
  [index: string]: string[]
}

/**
 * 资源加载环境种类
 */
export enum LoadEnv {
  /**
   * 设计态
   */
  design = 'design',
  /**
   * 运行态
   */
  runtime = 'runtime'
}

/**
 * 低代码设置器描述
 */
export type SetterDescription = PluginDescription

/**
 * 低代码插件器描述
 */
export interface PluginDescription {
  /**
   * 插件名称
   */
  name: string
  /**
   * 插件标题
   */
  title: string
  /**
   * 插件类型
   */
  type?: string
  /**
   * 插件描述
   */
  description?: string
  /**
   * 插件文档地址
   */
  docUrl: string
  /**
   * 插件截图
   */
  screenshot: string
  /**
   * 插件相关的标签
   */
  tags?: string[]
  /**
   * 插件关键字
   */
  keywords?: string[]
  /**
   * 插件引用的资源信息
   */
  reference: Reference
}

/**
 * 资源引用信息，Npm 的升级版本，
 */
export interface Reference {
  /**
   * 引用资源的 id 标识
   */
  id?: string
  /**
   * 引用资源的包名
   */
  package?: string
  /**
   * 引用资源的导出对象中的属性值名称
   */
  exportName: string
  /**
   * 引用 exportName 上的子对象
   */
  subName: string
  /**
   * 引用的资源主入口
   */
  main?: string
  /**
   * 是否从引用资源的导出对象中获取属性值
   */
  destructuring: boolean
  /**
   * 资源版本号
   */
  version: string
}

/**
 * 低代码片段
 *
 * 内容为组件不同状态下的低代码 schema (可以有多个)，用户从组件面板拖入组件到设计器时会向页面 schema 中插入 snippets 中定义的组件低代码 schema
 */
export interface Snippet {
  title: string
  screenshot?: string
  schema: ElementJSON
}

/**
 * 组件低代码描述
 */
export interface ComponentDescription {
  componentName: string
  title: string
  description?: string
  docUrl: string
  screenshot: string
  icon?: string
  tags?: string[]
  keywords?: string[]
  devMode?: 'proCode' | 'lowCode'
  npm: Npm
  props: Prop[]
  configure: Configure
  /**
   * 多模态下的组件描述, 优先级高于 configure
   */
  advancedConfigures: MultiModeConfigures
  snippets: Snippet[]
  group: string
  category: string
  priority: number
  /**
   * 组件引用的资源信息
   */
  reference: Reference
}

export interface MultiModeConfigures {
  default: Configure
  [index: string]: Configure
}

/**
 * 远程物料描述
 */
export interface RemoteComponentDescription {
  /**
   * 组件描述导出名字，可以通过 window[exportName] 获取到组件描述的 Object 内容；
   */
  exportName?: string
  /**
   * 组件描述的资源链接；
   */
  url?: string
  /**
   * 组件多模态描述的资源信息，优先级高于 url
   */
  advancedUrls?: ComplexUrl
  /**
   * 组件(库)的 npm 信息；
   */
  package?: {
    npm?: string
  }
}

export type ComplexUrl = string | MultiModeUrl

export interface MultiModeUrl {
  default: string
  [index: string]: string
}

// https://lowcode-engine.cn/site/docs/specs/material-spec#221-%E7%BB%84%E4%BB%B6%E8%A7%84%E8%8C%83
export interface ComponentSchema {
  version: string
  componentsMap: ComponentsMap
  componentsTree: [ComponentTree]
  i18n: I18nMap
  utils: UtilItem[]
}
```

---

好的，我们来深入讲解这份《资产包协议》。

这份文档定义了一个核心概念——**资产包（Assets Bundle）**。你可以把它理解为一份详细的“**资源清单和说明书**”，专门为低代码引擎量身定制。

### 核心思想：打包与描述

低代码引擎要能使用一个组件，光有组件的源代码是远远不够的。引擎还需要知道：

1.  **这是什么组件？**（名称、图标、截图）
2.  **它从哪里来？**（组件代码的 CDN 地址、npm 包名）
3.  **它能做什么？**（有哪些属性可以配置，即 `props`）
4.  **该如何配置它？**（在右侧设置面板里，应该用输入框、开关还是颜色选择器来配置这些 `props`？）
5.  **它在组件库里应该放在哪里？**（属于“基础组件”还是“业务组件”？）

**资产包协议（Assets Protocol）**就是为了用一种标准化的数据格式（JSON），把以上所有信息清晰、完整地组织起来，让低代码引擎可以“阅读”并正确地加载、渲染和使用所有外部资源（包括组件、插件、设置器等）。

---

### 深入解析协议结构 (`Assets` 接口)

我们逐一拆解协议的最顶层结构，来理解每个部分的作用。

#### 1. `packages`: 资源包定义 (The "Where")

- **作用**：这是整个资产包的**依赖清单和资源定位系统**。它告诉引擎：“你需要用到的所有 JS 和 CSS 文件都在这些 URL 上，请去下载”。
- **核心字段解析**：

  - `package`, `version`: 类似于 package.json，用于标识一个独立的资源包（例如 `moment.js` 或者 `antd`）。
  - `library`: 极其重要。当浏览器通过 `<script>` 标签加载了 `urls` 里的 JS 文件后，这个库会挂载到 `window` 对象上。`library` 字段就定义了这个全局变量的名称。例如，`antd` 的 `library` 是 `'antd'`，加载后我们就可以通过 `window.antd` 访问它。
  - `urls` / `editUrls`: 分别定义了组件**渲染态**（最终线上运行的样子）和**编辑态**（在设计器里带辅助操作的样子）所需的 JS/CSS 文件地址。这是实现低代码“所见即所得”编辑体验的关键。
  - `exportName`: 如果一个 JS 包里导出了多个东西，`exportName` 用来指定我们具体需要哪一个。

- **通俗比喻**：`packages` 就像一份采购清单，上面写着：“去 A 仓库（URL）拿 antd v4.0（package & version），它在货架上的名字叫 'antd'（library）”。

#### 2. `components`: 组件描述 (The "What" and "How")

- **作用**：这是协议的**核心**，详细描述了每一个组件的“使用说明书”。
- **核心字段解析**：

  - `componentName`: 组件的唯一标识符，比如 `Button`。引擎通过它来识别组件。
  - `title`, `screenshot`, `icon`: 用于在组件面板中进行可视化展示，提升开发体验。
  - `npm`: 组件的来源信息，通常指向一个 npm 包。
  - `props`: 定义了组件可配置的属性列表。每个属性都有自己的类型、默认值等。
  - `configure`: **关键中的关键**。它将 `props` 和**设置器（Setters）**关联起来。它定义了在设计器的右侧属性面板中，每个 `prop` 应该用哪种控件（如 `InputSetter`, `BoolSetter`, `ColorSetter`）来编辑。这决定了低代码的配置体验。
  - `snippets`: **代码片段**。当用户从组件面板拖拽一个组件到画布上时，实际插入页面 `schema` 的是 `snippets` 中定义的 JSON 结构。这允许一个组件有多种预设模板（比如一个“主按钮”片段和一个“次按钮”片段）。

- **通俗比喻**：`components` 就像一本家电说明书。`componentName` 是“XX 型号冰箱”，`props` 是“可调节温度、可切换制冰模式”，`configure` 是“温度用旋钮调节、制冰模式用开关切换”，`snippets` 是“出厂默认设置为‘冷藏 5°C，制冰关闭’”。

#### 3. `plugins` & `setters`: 插件与设置器 (The "Tools")

- **作用**：定义了扩展低代码引擎能力的**插件**和用于配置属性的**设置器**。
- **插件 (`plugins`)**: 比如“页面数据源管理插件”、“大纲树插件”、“撤销重做插件”等，它们为设计器提供了核心功能之外的附加能力。
- **设置器 (`setters`)**: 它们是构成属性配置面板的原子控件，比如文本输入框、下拉选择框、JSON 编辑器等。`ComponentDescription` 中的 `configure` 字段就是通过引用这些 `setters` 来构建配置界面的。
- **`reference` 字段**: 这个字段告诉引擎，这个插件或设置器的具体实现代码，可以从 `packages` 列表里定义的哪个资源包 (`id` 或 `package`) 的哪个导出项 (`exportName`) 中找到。

#### 4. `sort`: 面板排序 (The "Layout")

- **作用**：定义组件在设计器左侧组件面板中的**分组和排序**。
- **`groupList`**: 定义顶部的 Tab，如 `["基础组件", "业务组件", "图表组件"]`。
- **`categoryList`**: 定义每个 Tab 内的分类，如 `["通用", "布局", "导航"]`。
- **通俗比喻**：`sort` 决定了超市货架的布局，告诉你“饮料区”在第 1 排，“零食区”在第 2 排。

### 总结与重要性

这份资产包协议是整个低代码引擎的**基石**。它的重要性体现在：

1.  **标准化**：它提供了一套统一的、与具体组件库无关的“对话语言”。任何前端组件库（React, Vue, Angular）只要能被编译成符合该协议的资产包，就能接入到低代码引擎中。
2.  **解耦**：它将**组件实现**（JS/CSS 代码）与**组件描述**（元数据）分离，并将它们动态地组合在一起。引擎核心逻辑不关心组件的具体实现，只关心这份“说明书”。
3.  **动态性**：引擎启动时，只需加载这份资产包 JSON，就可以动态地按需加载所有资源。这使得更新组件库、新增插件等操作无需重新部署整个低代码平台，只需更新这份 JSON 文件即可。
4.  **生态化**：基于这套标准协议，可以构建一个开放的物料生态。任何人都可以开发自己的组件或插件，并打包成符合协议的资产包，供他人使用。
