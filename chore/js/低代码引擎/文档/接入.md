## 接入编辑器

好的，我们来把这份关于“接入编辑器”的文档用清晰易懂的方式讲解一遍。

想象一下，你想开一家“**乐高主题咖啡馆**”。这家咖啡馆的核心，就是那个能让顾客自由拼搭积木的“**乐高工作台**”（低代码编辑器）。现在，你有两种方式来搭建这个工作台：

---

### 方法一：购买“官方整体解决方案”套餐

这是最简单、最省心的方式，适合绝大多数人，尤其是那些不想操心技术细节的咖啡馆老板。

**步骤拆解：**

1.  **联系官方授权服务商**:

    - 在你的电脑（终端）里，运行一个官方指定的命令，相当于拨打服务商的电话。
    - `npm install -g @alilc/create-element@latest`：这是在你的通讯录里存下服务商的电话号码。
    - `npm init @alilc/element editor-project-name`：拨通电话，告诉服务商你的项目名叫 `editor-project-name`。

2.  **选择套餐并回答问题**:

    - 服务商会问你：“您好，请问您需要什么服务？” 屏幕上会显示一个选项列表。
    - 你选择“**我想要一个编辑器**”。
    - 服务商会接着问一些细节问题，比如“您的咖啡馆叫什么名字？”、“需要什么主题风格？”等等。

3.  **服务商上门安装**:

    - 回答完问题后，服务商就会把一整套预制好的“乐高工作台”材料送到你的项目目录 (`editor-project-name`) 里。

4.  **自己动手，简单组装**:

    - `cd editor-project-name`：走进你的项目场地。
    - `npm install`：按照说明书，把所有送来的零件（依赖包）组装起来。
    - `npm start`：插上电源，启动工作台。

5.  **开业大吉**:
    - 如果屏幕上出现了完整的编辑器界面，恭喜你，你的“乐高工作台”已经成功搭建并运行起来了！

**一句话总结：这种方式就像购买宜家的家具，你只需要按照简单的说明书拧几个螺丝，就能得到一个完整、可用的产品，无需关心每一块木板是如何设计和生产的。**

---

### 方法二：自己动手，从零打造 (DIY)

这种方式适合那些经验丰富的“**木工大师**”（高级前端工程师），他们可能已经有了一个正在营业的咖啡馆（现有项目），现在想在里面加装一个“乐高工作台”，并且希望对工作台的每一个细节都有完全的控制。

**步骤拆解：**

1.  **采购原材料 (引入 UMD 包)**

    - 你没有购买整体套餐，而是选择去建材市场，一块一块地采购所有需要的原材料。
    - 你在你的 HTML 文件里，通过 `<link>` 和 `<script>` 标签，从指定的“供应商地址”（CDN）采购了所有必需的材料：
      - **各种样式的“装饰板” (`<link>` CSS 文件)**:
        - `engine-core.css`: 工作台的核心框架样式。
        - `next.min.css`: 工作台操作按钮、面板等所使用的 Fusion Next 组件库的样式。
        - `theme-lowcode-light.css`: 工作台的“浅色主题”皮肤。
        - `engine-ext.css`: 官方扩展包（如设置器）的样式。
      - **各种功能的“核心模块” (`<script>` JS 文件)**:
        - `react.js`, `react-dom.js`: **工作台的“地基”**，因为整个工作台是基于 React 技术构建的。
        - `lodash.js`, `moment.js`: 一些常用的“**五金工具**”（工具库）。
        - `next.min.js`: **操作按钮、面板**等 UI 组件的“功能模块”。
        - `engine-core.js`: **工作台的“主引擎”**，最核心的模块。
        - `engine-ext.js`: **官方扩展包**（如设置器）的“功能模块”。

2.  **告知自己的工具箱：“这些材料是外面买的” (配置 Webpack Externals)**

    - 你的个人工具箱（Webpack）非常智能，它会把你项目里用到的所有东西都打包到一起。
    - 但现在，很多原材料（React, Lodash, antd 等）你已经从外面市场买好了（通过 UMD script 标签引入），你就不希望工具箱再把它们重新生产并打包一遍，这会造成浪费和冲突。
    - 所以，你在工具箱的“配置文件” (`webpack.config.js`) 里告诉它：
      ```json
      "externals": {
        "react": "var window.React",
        // ... 其他库
      }
      ```
      这相当于贴了个条子：“注意！如果代码里需要 `react`，不要自己打包，直接去 `window.React` 这个全局变量上拿就行，那是我们从外面买好的。”

3.  **现场组装和启动 (初始化引擎)**

    - 所有原材料都已就位，现在开始在你的咖啡馆里现场组装。
    - 你在你的启动脚本里，找到已经放在全局 `window` 对象上的“主引擎” (`window.AliLowCodeEngine`)。
    - 调用它的 `init` 方法，开始初始化：

      ```javascript
      // 找到一块空地，给它一个ID，比如 'lce-container'
      // <div id="lce-container"></div>

      // 告诉主引擎，就在这块空地上开始搭建工作台
      window.AliLowCodeEngine.init(document.getElementById('lce-container'), {
        // 还可以附带一些个性化要求
        enableCondition: true // 比如：我需要“条件渲染”这个高级功能
      })
      ```

    - 如果你使用 TypeScript，为了获得更好的编码体验（代码提示），你可以安装 `@alilc/lowcode-engine` 的类型定义包，然后就可以用 `import { init } from '@alilc/lowcode-engine'` 的方式来写代码，而不是直接操作 `window` 对象。

**一句话总结：这种方式就像一个专业的木工，他精确地知道需要哪些木材、钉子和工具，然后自己采购、切割、组装，最终打造出一个完全符合自己需求的、高度定制化的工作台。**

## 接入运行时

好的，我们来把这份关于“接入运行时”的文档用最清晰、最易懂的方式讲解一遍。

想象一下，你在一个非常先进的“**电影工作室**”（低代码编辑器）里，通过拖拽演员、设置场景，制作完成了一部电影。当你点击“完成”时，工作室会导出两份核心文件：

1.  **`assets` (演职员及道具清单)**: 这是一个 JSON 文件，记录了这部电影用到了哪些“**外部资源**”。

    - **演员**: 比如“汤姆·汉克斯”（组件名 `Button`），他属于“派拉蒙影业”（npm 包名 `@alifd/next`）。
    - **道具/特效**: 比如某个“爆炸特效包”（一个 JS/CSS 库）。
    - **获取方式**: 清单上还写明了去哪里可以找到他们，比如“派拉蒙影业的官网地址”（资源的 URL）。

2.  **`schema` (分镜头脚本)**: 这是另一个 JSON 文件，是电影的**核心剧本**。
    - 它详细描述了每一个场景的结构（页面布局）。
    - 规定了哪个演员在什么时候出场（组件渲染）。
    - 写明了演员的台词和动作（组件的属性和事件）。

现在，你有了“清单”和“脚本”，下一步就是**如何把这部电影放映给观众**。你有两种放映方式：

- **方式一：运行时渲染 (在线直播)**

  - **比喻**: 你雇佣一个“**智能放映机器人**”（`@alilc/lowcode-react-renderer`）。你把“清单”和“脚本”交给它，它会**实时地**读取脚本，动态地从清单上的地址把演员请到舞台上，然后指挥他们进行**现场表演**。
  - **优点**: 方便快捷，如果你修改了脚本，机器人能立刻响应，表演新的内容。
  - **缺点**: 机器人本身比较“笨重”（运行时依赖包体积大），而且现场解析脚本和指挥演员需要消耗一些性能。观众也无法对表演进行二次创作。

- **方式二：出码 (制作成电影胶片)**
  - **比喻**: 你使用一个“**制片工具**”（出码模块），将“清单”和“脚本”直接制作成一份标准的**电影胶片**（可运行的前端源代码）。
  - **优点**: 这份胶片可以在任何一家电影院（任何项目环境）独立放映，不再需要那个“智能放映机器人”，因此播放起来更轻快、性能更好。影评人（开发者）还可以对胶片进行剪辑，添加新的特效（二次开发）。
  - **缺点**: 制作胶片需要额外的时间。一旦制作完成，就不能再用“电影工作室”去方便地修改它了。

这篇文档主要讲解第一种方式：**如何进行“在线直播”（运行时渲染）**。

---

### 深入讲解：如何实现“在线直播” (渲染模块)

“智能放映机器人” (`ReactRenderer`) 非常专业，它只需要两样东西就能开始工作：

1.  `schema`: **要表演的剧本**。
2.  `components`: **所有到场的、活生生的演员**，而不是一份演员名单。

但你手上只有“**项目总纲**” (`projectSchema`) 和“**演职员清单**” (`packages`)。所以，在放映前，你需要做一个**关键的准备工作**：把这两份原始材料转换成机器人需要的格式。

这个准备工作就是 `getSchemaAndComponents` 函数所做的事情，我们来一步步拆解它：

#### `getSchemaAndComponents` 函数详解：放映前的准备

```javascript
async function getSchemaAndComponents() {
  // 1. 从仓库拿到“项目总纲”和“演职员清单”
  const packages = JSON.parse(window.localStorage.getItem('packages'))
  const projectSchema = JSON.parse(window.localStorage.getItem('projectSchema'))

  // 2. 从“项目总纲”中，提取出今天真正要放映的“主线剧本”
  const schema = projectSchema.componentsTree[0]

  // 3. 准备“聘请”演员
  const libraryMap = {} // 记录演员属于哪个“经纪公司”
  const libraryAsset = [] // 记录所有“经纪公司”的地址（URL）

  // 遍历“演职员清单”(packages)
  packages.forEach(({ package: _package, library, urls }) => {
    // 记录：'antd' 这个包暴露出的全局变量名叫 'Antd'
    libraryMap[_package] = library
    // 记录：'antd' 的 JS/CSS 文件地址
    libraryAsset.push(urls)
  })

  // 4. 派出“星探”(AssetLoader)，去把所有演员都请到现场
  const assetLoader = new AssetLoader()
  // “星探”根据地址列表，动态加载所有演员的 JS/CSS 文件
  await assetLoader.load(libraryAsset)

  // 5. 组建“最终演员阵容”(components)
  // 此时，所有演员（比如 antd 的 Button）已经通过 JS 加载到全局环境中了。
  // buildComponents 函数会根据项目实际用到的演员，和他们的“经纪公司”信息，
  // 生成一个机器人能看懂的键值对。
  // 比如：{ Button: antd.Button, Card: antd.Card, ... }
  const components = await injectComponents(
    buildComponents(libraryMap, projectSchema.componentsMap)
  )

  // 6. 将准备好的“剧本”和“演员阵容”返回
  return {
    schema,
    components
  }
}
```

**这个过程的核心是：动态加载。我们不是在代码里写死 `import { Button } from 'antd'`，而是通过解析 `assets` 清单，动态地将页面需要的组件库加载进来，并组装成 `components` 对象。**

#### 进行渲染

一旦准备工作完成，放映就非常简单了：

```javascript
import ReactRenderer from '@alilc/lowcode-react-renderer'

// 假设已经通过 getSchemaAndComponents() 拿到了 schema 和 components
const SamplePreview = () => {
  return (
    <ReactRenderer
      schema={schema} // 把剧本交给机器人
      components={components} // 把演员阵容交给机器人
    />
  )
}
```

“智能放映机器人”拿到这两样东西，就会立刻开始在屏幕上进行“在线直播”了。

### 总结：生产与消费流程

这张图清晰地总结了整个流程：

1.  **生产环节 (左侧)**:

    - 你在**低代码编辑器**（电影工作室）里进行创作。
    - 你的创作成果——`assets` (清单) 和 `schema` (脚本)——被保存到**数据库**（电影资料库）中。

2.  **消费环节 (右侧)**:
    - **运行时渲染 (在线直播)**: 预览页面从数据库获取 `assets` 和 `schema`，通过**渲染模块**（智能放映机器人）进行实时放映。
    - **出码 (制作胶片)**: **出码模块**（制片工具）从数据库获取 `assets` 和 `schema`，生成**源代码**（电影胶片），这份代码可以独立部署和运行。

通过“接入编辑器”和“接入运行时”这两个步骤，你就打通了从“可视化生产”到“线上消费”的完整链路。
