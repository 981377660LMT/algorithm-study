## 渲染

好的，我们来把这份关于“使用渲染模块”的文档用最清晰、最易懂的方式讲解一遍。

想象一下，你是一个**剧院的导演**，你的任务是根据一份**剧本 (Schema)**，指挥一群**演员 (Components)**，在舞台上排演出一出精彩的话剧。

`@alilc/lowcode-react-renderer` 这个渲染模块，就是你手中的那个**智能导演系统**。

### 一、核心要素：剧本和演员

要排演一出话剧，你最核心的两个东西就是：

1.  **剧本 (Schema)**: 一个 JSON 对象，详细描述了这出戏的结构。

    - `componentName: 'Page'`: 剧本的名字叫“一页”。
    - `children`: 剧本里有哪些场景和角色。
    - `componentName: 'Button'`: 有一个角色是“按钮”。
    - `props`: 这个角色的“扮相”和“台词”。比如 `type: 'primary'`（穿蓝色的衣服），`children: '确定'`（台词是“确定”）。

2.  **演员表 (Components)**: 一个对象，里面是所有需要登台的**真实演员**。
    - `Button`: 剧本里写了需要一个叫“Button”的角色，你必须在这里提供一个真正的、能表演的 `Button` 演员（比如从 `@alifd/next` 库里请来的那位）。

**关键原则：剧本里提到的每一个角色 (`componentName`)，都必须在演员表 (`components`) 里找到对应的真人演员。否则导演系统就会报错：“找不到演员！”**

### 二、两种使用场景

#### 场景一：简单示例（自己写剧本和找演员）

这是最简单直接的方式，就像你临时起意，写个小品剧本，然后找两个朋友来演。

```javascript
// 1. 剧本 (Schema) - 你自己写的
const schema = {
  componentName: 'Page',
  children: [
    {
      componentName: 'Button', // 需要一个叫 'Button' 的角色
      props: { type: 'primary' },
      children: '确定'
    }
  ]
}

// 2. 演员表 (Components) - 你自己找的
import { Button } from '@alifd/next' // 从 antd 库请来了 Button 演员
const components = {
  Button // 把 Button 演员登记在册，角色名就叫 'Button'
}

// 3. 开演！
// 把剧本和演员表交给导演系统 ReactRenderer
ReactDOM.render(
  <ReactRenderer schema={schema} components={components} />,
  document.getElementById('root')
)
```

导演系统拿到剧本，看到需要一个 `Button`，就在演员表里找到了对应的 `Button` 演员，然后让它上台表演。

#### 场景二：项目使用示例（从设计器获取剧本和演员信息）

这个场景更真实，也更复杂。它模拟的是一个**“在线可视化编排” -> “独立预览页面”** 的完整流程。

想象一下，你在一个“可视化导演工作室”（低代码设计器）里，通过拖拽的方式排演了一出大戏。现在，你想把这出戏发布出去，让观众能在一个独立的网页上看到它。

**流程拆解：**

1.  **在“导演工作室” (设计器) 里，导出成果**

    - `project.exportSchema()`: 导出你排好的**完整剧本** (`projectSchema`)。这个剧本不仅包含页面结构，还包含了用到了哪些演员的信息。
    - `material.getAssets().packages`: 导出**演员信息包** (`packages`)。这里面记录了所有演员来自哪个“经纪公司”（npm 包名）、他们的“出场费清单”（JS/CSS 文件的 URL 地址）等信息。

2.  **存储成果**

    - 你把导出的 `projectSchema` 和 `packages` 存起来。示例中用了 `localStorage`，真实项目中通常会存到数据库里。

3.  **在“独立剧院” (预览页面) 里，准备开演**

    - **获取存储的成果**: 从 `localStorage` 或数据库里把 `projectSchema` 和 `packages` 读出来。
    - **动态加载演员 (核心步骤)**:
      - 你不能在代码里写死 `import { Button } from '@alifd/next'`，因为你不知道用户在设计器里到底用了哪些演员。
      - 所以，你需要一个**“星探” (`AssetLoader`)**。
      - 你把演员信息包 (`packages`) 里的 URL 列表交给“星探”。
      - `assetLoader.load(...)`: “星探”会根据 URL 列表，动态地去网络上把这些演员的 JS 和 CSS 文件加载到页面中。
      - `buildComponents(...)`: 加载完成后，这些演员（比如 `Button` 组件）就已经在全局环境中了。这个函数会根据演员信息，把它们组装成导演系统需要的 `components` 对象。
    - **准备就绪**: 现在，你手上有了 `schema` (剧本) 和 `components` (动态加载来的演员表)。

4.  **正式开演**
    - 和简单示例一样，把 `schema` 和 `components` 交给 `ReactRenderer`，话剧就上演了。

**这个复杂流程的核心是：实现剧本和演员的动态加载，从而让一个固定的预览页面，能够渲染出任意在设计器中搭建的内容。**

### 三、导演系统的高级功能 (API 详解)

`ReactRenderer` 这个导演系统非常强大，它还提供了很多高级的“导演指令” (Props)。

- **`locale` & `messages` (国际化)**

  - **作用**: 让你的话剧能说不同国家的语言。
  - **用法**: 你提供一个 `messages` 对象，里面是各种语言的翻译文本。然后通过 `locale` 告诉导演当前要用哪种语言。导演在排演时，如果剧本里有国际化标记，就会自动去 `messages` 里找对应的翻译。

- **`appHelper` (全局道具和场务)**

  - **作用**: 给整个剧组提供一些**公共的道具 (`constants`) 和场务人员 (`utils`)**。
  - **例子**: 你可以在 `appHelper` 里提供一个 `utils: { formatDate: ... }`。这样，在剧本的任何地方，演员都可以通过 `this.utils.formatDate(...)` 来调用这个公共函数。这对于处理公共逻辑非常有用。

- **`designMode` (排练模式)**

  - **作用**: 主要在“导演工作室”（设计器）里使用，方便导演进行排练。
  - **例子**: 设置为 `design` 模式后，一些平时看不见的“隐形”角色（比如弹窗 Dialog），也会在舞台上显示一个轮廓，方便你选中和操作它。

- **`onCompGetRef` (获取演员真人)**

  - **作用**: 在排练时，让你能直接拿到每个角色的“真人演员”实例 (`ref`)。
  - **用途**: 设计器需要通过这个来操作演员，比如获取它的尺寸、位置等信息。

- **`customCreateElement` (自定义选角)**

  - **作用**: 给你一个“最终拍板”的权力。在导演系统即将让一个演员上台前，你可以最后介入一下。
  - **用途**: 你可以临时给这个演员加点戏（增加 props），或者删掉一些戏份（删除 props），甚至可以临时换角（替换成另一个组件）。

- **`thisRequiredInJSE` (台词语法规范)**
  - **作用**: 规定剧本里 JS 表达式的写法。
  - **推荐 (`true`)**: 要求所有动态台词都必须以 `this.` 开头，比如 `this.state.name`。这样语法更规范，不易出错。

**总结一下，使用渲染模块就像导演排戏：**

1.  **准备好剧本 (`schema`) 和演员表 (`components`)。**
2.  **把它们交给导演系统 (`ReactRenderer`)。**
3.  **（可选）通过各种高级指令 (Props) 来控制排演的细节，比如国际化、公共道具、排练模式等。**

无论是简单的本地排演，还是复杂的远程动态加载，其核心原理都是一样的。

## 出码

好的，我们来把这份关于“使用出码功能”的文档用清晰易懂的方式讲解一遍。

想象一下，你是一位大厨，你刚刚用一套非常先进的“可视化配菜系统”（低代码平台）设计好了一份精美的“宴会菜单”（Schema）。现在，你有两种方式把这份菜单变成真正的菜肴：

1.  **运行时渲染 (Runtime Rendering)**: 你把“菜单”交给一个“全自动炒菜机器人”。机器人会实时地读取菜单，然后一道一道地现场制作并端上桌。
2.  **出码 (Code Generation)**: 你把“菜单”打印成一份详细的、给人类厨师看的“标准菜谱”（Source Code）。然后，任何一个专业厨房（项目环境）的厨师（开发者）都可以按照这份菜谱，做出完全一样的菜肴。

“出码功能”就是第二种方式：**将抽象的“菜单 (Schema)”转换成具体的“菜谱 (Code)”。**

### 一、为什么要出码？（什么时候需要“菜谱”？）

“全自动炒菜机器人”（运行时渲染）很方便，保存即预览，但它也有缺点：机器人本身很重（包体积大），而且现场解析菜单需要时间（性能开销），最重要的是，你没法让机器人做菜单上没有的创意菜（无法二次开发）。

所以，在以下三种情况下，你更需要一份“菜谱”（出码）：

1.  **追求极致性能（开高档餐厅）**:

    - **场景**: 你的餐厅开在市中心，顾客都是美食家，对上菜速度要求极高（C 端应用，如手淘、钉钉页面）。
    - **痛点**: 如果菜单很复杂，机器人现场解析会很慢，顾客会不耐烦。
    - **出码优势**: 你可以提前把菜单变成标准菜谱，在后厨把所有准备工作都做好。这样顾客一点单，几乎可以秒上。**（将运行时的解析开销转移到了编译时）**

2.  **在老厨房里加新菜（老项目集成）**:

    - **场景**: 你的餐厅已经开了很多年，有自己一套成熟的流程和厨师团队（老项目）。现在你想引入一些用“可视化配菜系统”设计的新菜品。
    - **痛点**: 你总不能为了几道新菜，把整个厨房都换成“全自动炒菜机器人”吧？这不现实。
    - **出码优势**: 你只需要把新菜的“菜谱”打印出来，交给你的厨师团队，他们就能无缝地把它集成到现有的菜单里。**（将搭建产物作为模块，集成到现有项目中）**

3.  **需要顶级大厨的即兴发挥（定制化开发）**:
    - **场景**: 顾客提出了一个非常天马行空的需求，比如“在牛排上雕一朵花”，这个需求在你的“可视化配菜系统”里根本没法描述。
    - **痛点**: 机器人只会严格按菜单做菜，无法处理这种超纲需求。
    - **出码优势**: 你可以先把牛排的基础做法用“菜谱”打印出来，然后交给你的顶级大厨（资深开发者）。大厨可以在菜谱的基础上，添加“雕花”这一个性化步骤，完成最终的创作。**（将低代码与源码开发相结合）**

### 二、如何使用出码功能？（获取“菜谱”的五种方式）

#### 1. 命令行快速体验（最快的方式）

这就像一个“菜谱自动打印机”。你把菜单文件喂给它，它直接吐出菜谱文件夹。

```bash
# npx @alilc/lowcode-code-generator -i <菜单文件> -o <输出目录> -s <菜系风格>
npx @alilc/lowcode-code-generator -i example-schema.json -o generated -s icejs3
```

- `-i`: 输入的菜单 (Schema) 文件。
- `-o`: 输出的菜谱 (代码) 目录。
- `-s`: 指定菜系风格，比如是 `icejs3` 风格的菜谱还是 `rax` 风格的。

#### 2. 设计器插件体验（最直观的方式）

在你的“可视化配菜系统”（低代码编辑器）里安装一个“一键打印”插件。

- **安装**: `npm install @alilc/lowcode-plugin-code-generator`
- **注册**: 在编辑器初始化时注册这个插件。
- **使用**: 编辑器右上角会出现一个“出码”按钮。点击它，就能在浏览器里直接看到生成的“菜谱”代码，并进行预览。

#### 3. 服务端出码（最工业化的方式）

这适用于专业的“中央厨房”（CI/CD 流程）。当你在设计器里保存菜单后，自动触发服务器进行出码、打包、部署。

```javascript
// 1. 引入出码工具
import CodeGenerator from '@alilc/lowcode-code-generator'

// 2. 选择一个“菜系”构建器，比如 icejs
const projectBuilder = CodeGenerator.solutions.icejs()

// 3. 传入“菜单”，生成“菜谱”项目
const project = await projectBuilder.generateProject(schema)

// 4. 选择一种“出版”方式，比如直接写入磁盘或打包成 zip
await CodeGenerator.publishers.disk().publish({
  project,
  outputPath: '/path/to/output'
})
```

#### 4. 浏览器中出码（最灵活的方式）

得益于现代浏览器的强大性能，你甚至可以在用户的浏览器里直接完成“菜单”到“菜谱”的转换，而无需服务器。

```javascript
// 引入浏览器专用的出码加载器
import * as CodeGenerator from '@alilc/lowcode-code-generator/standalone-loader'

// 传入“菜单”和“菜系”，直接生成代码
const result = await CodeGenerator.generateCode({
  solution: 'icejs',
  schema
})

console.log(result) // 在控制台就能看到生成的代码结构
```

这非常适合做“即时预览”功能。

#### 5. 自定义出码（最高级的方式）

如果官方提供的“菜系”（如 icejs, rax）都不符合你的要求，你想创造一个属于自己的“私房菜系”（比如 Vue 或 Svelte 风格的菜谱），你可以：

1.  **使用脚手架创建模板**:
    ```bash
    npx @alilc/lowcode-code-generator init-solution <你的菜系名>
    ```
2.  **编写插件**: 出码模块的核心功能都是由插件构成的。你可以通过修改或添加插件，来定义你的“私房菜系”的每一个细节。比如，一个插件负责生成 package.json，另一个插件负责生成路由文件。
3.  **发布和使用**: 将你定义好的“私房菜系”发布成一个 npm 包，之后就可以像使用官方菜系一样，在各种场景下使用它了。

**总结一下，出码功能为你提供了一座桥梁，连接了“可视化搭建”的高效和“源码开发”的灵活。你可以根据不同的场景，选择最适合的方式，将低代码的产出无缝地融入到任何现代前端开发流程中。**
