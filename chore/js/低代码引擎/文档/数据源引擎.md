Code 模块

好的，我们来深入讲解这份关于“数据源引擎设计”的文档。

想象一下，你的低代码应用是一个需要展示各种动态数据的“**智能仪表盘**”。这些数据可能来自不同的地方：

- 一部分来自公司内部的 API (比如 Mtop)。
- 一部分来自公开的 HTTP 接口。
- 还有一部分可能是通过 JSONP 跨域获取的。
- 甚至有些是直接写在代码里的静态 JSON 数据。

“数据源引擎”就是这个仪表盘背后那个**强大、统一的数据管理和获取中心**。它的核心任务是：**用一种标准化的方式来定义、请求和管理来自不同来源的数据，并把这些数据提供给页面上的组件使用。**

### 一、核心原理：引擎与处理器的分离 (Engine-Handler 模式)

这是整个设计的基石，也是最精妙的地方。

- **痛点**: 如果把所有类型的数据请求逻辑（比如 fetch, mtop, jsonp 的具体实现）都写在一个包里，会怎么样？

  1.  **包体积臃肿**: 你的应用可能只需要 fetch，但却被迫打包了 mtop 和 jsonp 的代码，造成资源浪费。
  2.  **扩展性差**: 如果未来出现一种新的数据协议（比如 WebSocket），你就必须去修改引擎的核心代码，这很危险且不灵活。

- **解决方案**: **引擎 (Engine) 和处理器 (Handler) 分离**。

  - **`datasource-engine` (引擎)**: 这是**指挥中心**。它只负责通用的、与具体请求方式无关的逻辑：
    - 管理数据源列表。
    - 解析数据源配置。
    - 根据数据源的 `type`，将请求任务**分发**给对应的处理器。
    - 管理数据状态（加载中、成功、失败）。
    - 提供统一的 API（如 `reloadDataSource`）给外部调用。
  - **`datasource-engine-x-handler` (处理器)**: 这是**执行单元**。每种 `type` 的数据源都有一个对应的处理器，比如：
    - `datasource-engine-fetch-handler`: 内部使用 `window.fetch` 来发送 HTTP 请求。
    - `datasource-engine-mtop-handler`: 内部使用阿里系的 Mtop SDK 来发送请求。
    - `datasource-engine-jsonp-handler`: 内部动态创建 `<script>` 标签来实现 JSONP 请求。
  - **工作流程**:
    1.  应用在初始化时，像**注册插件**一样，告诉引擎：“我需要用到 `fetch` 和 `mtop` 这两种能力。” (`requestHandlersMap`)
    2.  当引擎需要加载一个 `type: 'fetch'` 的数据源时，它就会在注册的处理器中找到 `fetch` 对应的 handler，然后把请求参数和上下文交给它去执行。
    3.  引擎不关心 handler 内部是如何实现的，它只等待 handler 返回一个符合标准格式的 `Promise` 结果。

- **好处**:
  1.  **按需加载**: 应用只注册和打包自己需要的 handler，保持了最终产物的轻量。
  2.  **高扩展性**: 支持一种新的数据源类型，只需要开发一个新的 handler 包并注册它即可，完全不需要动引擎的核心代码。

### 二、`DataSourceEngine` 详解

#### 1. 两种模式：`interpret` vs `runtime`

引擎提供了两种创建模式，以适应不同的使用场景：

- **`createInterpret` (解释模式)**:

  - **场景**: 用于**在线渲染**，比如在低代码编辑器的画布中。
  - **输入 (`DataSource`)**: 接收的是最原始的、从搭建 Schema 中解析出来的 JSON 对象。这个对象里充满了 `JSExpression` 和 `JSFunction` 这样的**字符串**。
    ```json
    {
      "isInit": "{{this.state.shouldLoad}}", // JSExpression
      "options": {
        "uri": "/api/user/{{this.props.userId}}" // JSExpression
      }
    }
    ```
  - **职责**: 引擎内部需要一个“**表达式求值器**”，在运行时动态地解析这些字符串，把 `{{this.state.shouldLoad}}` 这样的表达式，结合当前的上下文 `context`（比如 `this.state`），计算出真正的布尔值。

- **`createRuntime` (运行时模式)**:
  - **场景**: 用于**出码后的最终项目**。
  - **输入 (`RuntimeDataSource`)**: 接收的是已经由“出码模块”处理过的、可以直接运行的 JavaScript 对象。
    ```javascript
    {
      isInit: this.state.shouldLoad, // 已经是 JS 变量
      options: () => ({ // 已经是一个函数
        uri: `/api/user/${this.props.userId}`
      })
    }
    ```
  - **职责**: 引擎不需要再做复杂的字符串解析，可以直接执行这些函数和变量，性能更高。

**这个设计的核心是：将“解释执行”的复杂性留在了 `interpret` 模式中，让出码后的 `runtime` 模式尽可能地轻量和高效。**

#### 2. `create` 方法的三个参数

`engine.create(dataSource, context, extraConfig)`

1.  **`dataSource`**: 数据源的配置列表，就是我们上面讲的两种模式的输入。

2.  **`context` (上下文)**: **至关重要**。这是数据源与页面组件沟通的桥梁。

    - **提供数据**: 当数据源配置中的表达式（如 `this.state.userId`）需要求值时，引擎会从 `context` 中去寻找 `state` 和 `userId`。
    - **更新视图**: 当数据请求成功后，handler 可能会调用 `context.setState({ list: data })` 来把获取到的数据更新到页面的 state 中，从而触发 UI 刷新。
    - **共享能力**: `context` 中还可以挂载其他自定义方法，供数据源逻辑使用。

3.  **`extraConfig` (额外配置)**:
    - **`requestHandlersMap`**: **必需**。这就是我们前面提到的“注册处理器”的地方。它是一个 map，key 是数据源的 `type` (如 `'fetch'`)，value 是对应的 handler 函数。
      ```javascript
      const requestHandlersMap = {
        fetch: fetchHandler,
        mtop: mtopHandler
      }
      ```
      引擎通过这个 map 来实现请求的分发。

#### 3. `DataSourceEngine` 实例

`create` 方法返回一个引擎实例，它暴露了两个核心能力给外部：

- **`dataSourceMap`**: 一个包含了所有数据源当前状态（数据、加载状态、错误信息等）的 map。页面的组件可以直接从这里读取数据进行渲染。
- **`reloadDataSource()`**: 一个函数，调用它会触发所有 `isInit: true` 的数据源重新加载。这对于实现“刷新”功能非常有用。

### 总结

数据源引擎的设计体现了优秀软件工程的多个原则：

1.  **单一职责原则**: 引擎负责流程控制和状态管理，Handler 负责具体的请求实现。
2.  **开放/封闭原则**: 对扩展开放（可以无限添加新的 Handler），对修改封闭（无需修改引擎核心代码）。
3.  **依赖倒置原则**: 引擎不直接依赖于具体的请求库（如 fetch），而是依赖于一个抽象的 Handler 接口。
4.  **分层设计**: 清晰地区分了需要“解释执行”的在线场景 (`interpret`) 和原生执行的出码场景 (`runtime`)，兼顾了灵活性和性能。

通过这套设计，低代码平台获得了一个统一、强大、可扩展的数据管理层，能够优雅地应对各种复杂的数据获取需求。
