这一章虽然名为“导论”，但绝非
废话。它建立了全书的**世界观**和**词汇表**。如果你不理解这一章定义的“分层架构”和“数据驱动”思想，后面的技术细节就会变成一盘散沙。

以下是第 1 章的核心干货拆解：

### 1.1 典型游戏团队的结构 (The Structure of a Typical Game Team)

- **核心观点**：引擎程序员不是在真空中工作，我们是在为“客户”服务。
- **谁是客户？**
  - **美术师 (Artists)**：需要高效的导出工具和所见即所得的渲染器。
  - **策划 (Designers)**：需要强大的脚本系统和关卡编辑器。
- **工程师细分**：
  - **Runtime 程序员**：负责引擎核心、渲染、物理、网络（关注 CPU/GPU 周期和内存）。
  - **Tools 程序员**：负责编辑器、资产管道（关注用户体验和工作流效率）。
- **老兵经验**：很多新手只盯着 Runtime 里的图形学看，但实际上**工具链（Tools Pipeline）**的优劣直接决定了项目的成败。

### 1.2 游戏是什么 (What is a Game?)

- **定义**：Jason Gregory 给出了一个非常经典的工程定义 —— **软实时、交互式、基于代理的计算机模拟 (Soft real-time interactive agent-based computer simulation)**。
- **关键词解析**：
  - **软实时 (Soft Real-time)**：游戏必须在 16.6ms (60FPS) 或 33.3ms (30FPS) 内完成一帧的计算。如果超时，游戏会卡顿（掉帧），但不会像核电站控制系统（硬实时）那样导致灾难。
  - **基于代理 (Agent-based)**：游戏世界由多个独立的实体（玩家、NPC、物理对象）组成，它们相互交互。

### 1.3 游戏引擎是什么 (What is a Game Engine?)

- **核心理念：数据驱动 (Data-Driven Architecture)**。
- **解释**：引擎是“播放器”，游戏内容是“数据”。
  - **硬编码 (Hard-coded)**：`if (enemy.type == ORC) health = 100;` (错误的做法)
  - **数据驱动**：`health = load_from_xml("orc_stats.xml");` (正确的做法)
- **目的**：将技术与内容分离，使得引擎可以在不同项目中复用。

### 1.4 不同游戏类型中的引擎差异 (Engine Differences Across Genres)

- **FPS (第一人称射击)**：极度关注渲染质量、高精度物理、瞬时响应。
- **RTS (即时战略)**：关注大量单位的寻路 (Pathfinding)、群体 AI、确定性网络同步 (Lockstep)。
- **MMOG (大型多人在线)**：关注服务器负载均衡、数据库一致性、状态复制。
- **老兵经验**：不要试图写一个“万能引擎”。虚幻引擎 (Unreal) 擅长 FPS，Unity 比较通用，但如果你要做一个万人同屏的 RTS，你可能需要深度定制甚至重写核心架构。

### 1.5 & 1.6 游戏引擎概观与运行时架构 (Game Engine Survey & Runtime Architecture)

这是本章的**重中之重**，作者展示了著名的**“分层架构图” (The Layered Architecture)**。

想象一个千层饼，从下往上：

1.  **硬件层 (Hardware)**：PC, PS5, Xbox, Switch。
2.  **驱动层 (Drivers)**：DirectX, Vulkan, OpenGL, OS API。
3.  **核心系统 (Core Systems)**：内存管理、数学库、文件系统。（这是地基，地基不稳，大厦将倾）。
4.  **资源管理 (Resources)**：负责把硬盘上的数据搬进内存。
5.  **渲染/物理/音频 (Low-level Engine)**：具体的子系统。
6.  **游戏性基础 (Gameplay Foundation)**：世界图景、对象模型、脚本系统。
7.  **游戏逻辑 (Game Specific)**：具体的游戏代码（如：马里奥的跳跃逻辑）。

- **黄金法则**：**依赖性只能向下，不能向上**。
  - 渲染层可以调用内存层。
  - 内存层**绝对不能**知道渲染层的存在。如果底层代码引用了上层头文件，这就是架构腐烂的开始。

### 1.7 工具及资产管道 (Tools and the Asset Pipeline)

- **DCC 工具**：Digital Content Creation 工具（Maya, 3ds Max, Photoshop, Blender）。
- **管道 (Pipeline)**：
  1.  美术在 Maya 中制作模型。
  2.  **导出器 (Exporter)** 将其导出为中间格式。
  3.  **资产调节器 (Asset Conditioner/Compiler)** 处理数据（压缩纹理、计算切线空间、优化网格）。
  4.  引擎加载优化后的二进制数据。
- **老兵经验**：引擎运行时读取的数据格式（内存映射友好）通常与美术制作的格式（易于编辑）完全不同。资产管道就是负责这个转换过程的“翻译官”。

---

**总结第一章：**
这一章告诉你，写引擎不仅仅是写代码，而是设计一个**生态系统**。你需要处理硬件限制（软实时）、解耦数据与逻辑（数据驱动）、并构建严格的分层架构以防止代码库崩塌。
