https://zhuanlan.zhihu.com/p/23821422

## 序

### 书店里已经有很多游戏编程书籍了。为什么要再写一本呢？

很多编程书籍可以归为这两类：

- 特定领域的书籍
- 完整引擎的书籍

前者未设计组合代码，后者通常过于整体，过于专注某类游戏了

### 工程挑战：

- 时间和顺序通常是游戏架构的核心部分。事物必须在正确的时间按正确的顺序发生。
- 高度压缩的开发周期，大量程序员需要能快速构建和迭代一系列不同的行为，同时保证不烦扰他人，也不污染代码库。
- 在定义所有的行为后，游戏开始互动。怪物攻击英雄，药物相互混合，炸弹炸飞敌人或者友军。 实现这些互动不能把代码库搞成一团乱麻。
- 最后，游戏中性能很重要。 游戏开发者处于一场榨干平台性能的竞赛中。 节约 CPU 循环的技巧区分了 A 级百万销量游戏和掉帧差评游戏。

### 架构，性能和游戏

与其说这本书是关于如何写代码，不如说是关于如何架构代码的。
每个程序都有一定架构，哪怕这架构是“将所有东西都塞到 main()中看看如何”， 所以我认为讲讲什么造成了好架构是很有意思的。
我们如何区分好架构和坏架构呢？

**好的架构易于修改代码，轻松应对变化。**

保持平衡：
这些都是速度：长期开发的速度，游戏运行的速度，和短期开发的速度。

看看新手程序员，他们经常这么干：为每种情况编写条件逻辑。
当我们想象优雅的代码时，想的是通用的那一个： 只需要很少的逻辑就可以覆盖整个用况。
**“臻于完美之时，不是加无可加，而是减无可减。”**

但最重要的是，如果你想要做出让人享受的东西，那就享受做它的过程。

## 一、常用 GOF 设计模式（重访设计模式，Design Patterns Revisited）

我认为有些模式被过度使用了（单例模式）， 而另一些被冷落了（命令模式）。
有些模式在这里是因为我想探索其在游戏上的特殊应用（享元模式和观察者模式）。
最后，我认为看看有些模式在更广的编程领域是如何运用的是很有趣的（原型模式和状态模式）。

1. 命令模式
   **命令是具现化(thingify)的方法调用**
   具现化的意思是“实例化，对象化”
   命令模式是一种回调的面向对象实现：方法调用被存储在对象中

   AI -> 命令流 -> actor ，解耦了消费者和生产者

   - 你最终可能会得到很多不同的命令类。
     为了更容易实现这些类，定义一个具体的基类，包含一些能定义行为的高层方法，往往会有帮助。
     这将命令的主体 execute()转到子类沙箱中。（DataStep、ModelStep、MatrixStep）
   - 有些命令是无状态的纯粹行为，比如第一个例子中的 JumpCommand。
     在这种情况下，有多个实例是在浪费内存，因为所有的实例是等价的。 可以用享元模式解决。

2. 享元模式
   `森林`
   哪怕森林里有千千万万的树，它们大多数长得一模一样。 它们使用了相同的网格和纹理。 这意味着这些树的实例的大部分字段是一样的。
   我们可以通过显式地将对象切为两部分来更加明确地模拟。 第一，将树共有的数据拿出来分离到另一个类中：

   ```cpp
   // 共享状态
   class TreeModel
   {
   private:
     Mesh mesh_;
     Texture bark_;
     Texture leaves_;
   };
   ```

   游戏只需要一个这种类， 因为没有必要在内存中把相同的网格和纹理重复一千遍。 游戏世界中每个树的实例只需有一个对这个共享 TreeModel 的引用。 留在 Tree 中的是那些实例相关的数据：

   ```cpp
   class Tree
   {
   private:
     TreeModel* model_;

     Vector position_;
     double height_;
     double thickness_;
     Color barkTint_;
     Color leafTint_;
   };
   ```

   ![示意图](image-1.png)

   这有点像类型对象模式。 两者都涉及将一个类中的状态委托给另外的类，来达到在不同实例间分享状态的目的。 但是，这两种模式背后的`意图不同`。
   使用类型对象，目标是通过将类型引入对象模型，减少需要定义的类。 伴随而来的内容分享是额外的好处。享元模式则是纯粹的为了效率。

   实例渲染(Geometry instancing)：
   https://en.wikipedia.org/wiki/Geometry_instancing
   Direct3D 和 OpenGL 的 API 中，你需要提供两部分数据流。 第一部分是一块需要渲染多次的共同数据——在例子中是树的网格和纹理。 第二部分是实例的列表以及绘制第一部分时需要使用的参数。 然后调用一次渲染，绘制整个森林。

   `扎根之所`
   实际的地形类，没有状态

   ```cpp
   class Terrain
   {
   public:
     Terrain(int movementCost,
             bool isWater,
             Texture texture)
     : movementCost_(movementCost),
       isWater_(isWater),
       texture_(texture)
     {}

     int getMovementCost() const { return movementCost_; }
     bool isWater() const { return isWater_; }
     const Texture& getTexture() const { return texture_; }

   private:
     int movementCost_;
     bool isWater_;
     Texture texture_;
   };

   // 每个相同地形的区块会指向相同的地形实例
   class World
   {
   public:
     World()
     : grassTerrain_(1, false, GRASS_TEXTURE),
       hillTerrain_(3, false, HILL_TEXTURE),
       riverTerrain_(2, true, RIVER_TEXTURE)
     {}

   private:
     Terrain grassTerrain_;
     Terrain hillTerrain_;
     Terrain riverTerrain_;

     // 其他代码……
   };
   ```

   看上去是单例，实际上是享元模式，目的是节省内存，提高效率
   一般保存在对象池中

3. 观察者模式
   观察者模式应用广泛，Java 甚至将其放到了核心库之中（java.util.Observer），而 C#直接将其嵌入了语法（event 关键字）
   `“委托”是方法的引用在 C#中的术语`

   - `成就解锁`的案例
   - **观察者模式是同步的。**
     被观察者直接调用了观察者，这意味着直到所有观察者的通知方法返回后， 被观察者才会继续自己的工作。观察者会阻塞被观察者的运行。
     如果要对事件同步响应，你需要完成响应，尽可能快地返回，这样 UI 就不会锁死。
     `当你有耗时的操作要执行时，将这些操作推到另一个线程或工作队列中去。`
     在多线程引擎中，你最好使用`事件队列来做异步通信`。
   - 在好的观察者设计中，观察同一被观察者的两个观察者互相之间不该有任何顺序相关。
     `如果顺序确实有影响，这意味着这两个观察者有一些微妙的耦合，最终会害了你`

   - 链表有两种风格。学校教授的那种，`节点对象包含数据`。
     在我们之前的观察者链表的例子中，是另一种： `数据（这个例子中是观察者）包含了节点（next\_指针）。`
     后者的风格被称为“侵入式”链表，因为在对象内部使用链表侵入了对象本身的定义。
     侵入式链表灵活性更小，但如我们所见，也更有效率。 在 Linux 核心这样的地方这种风格很流行。

   - 销毁被观察者和观察者
     难点不在如何做，而在记得做。
     - 在每个被观察者销毁时，让观察者自动取消注册
     - 失效监听者问题: 由于被观察者保留了对观察者的引用，最终有 UI 界面对象僵死在内存中。 `这里的教训是要及时删除观察者。`

4. 原型模式
   `简化 json`
   无能的 JSON 没法这么做。所以让我们把它做得更加巧妙些
   我们可以为对象添加"prototype"字段记录委托对象的名字。 如果在此对象内没找到一个字段，那就去委托对象中查找。

   ```json
    {
     "name": "goblin grunt",
     "minHealth": 20,
     "maxHealth": 30,
     "resists": ["cold", "poison"],
     "weaknesses": ["fire", "light"]
    }

   {
     "name": "goblin wizard",
     "prototype": "goblin grunt",
     "spells": ["fire ball", "lightning bolt"]
   }

   {
     "name": "goblin archer",
     "prototype": "goblin grunt",
     "attacks": ["short bow"]
   }
   ```

   只需在游戏引擎上多花点时间，`你就能让设计者更加方便地添加不同的武器和怪物`，而增加的这些丰富度能够取悦玩家。

5. 单例模式
   当业界从 C 语言迁移到面向对象的语言，他们遇到的首个问题是“如何访问实例？”
   `他们知道有要调用的方法，但是找不到实例提供这个方法。 单例（换言之，全局化）是一条简单的解决方案。`
   这个章节展示如何避免使用单例模式
6. 状态模式

## 二、序列型模式

本章的三种模式都是游戏开发中的常客：

游戏循环是游戏运行的主心骨。
游戏对象通过更新方法来进行每帧的更新。
我们可以用双缓冲模式存储快照，来隐藏计算机的顺序执行，从而使得游戏世界能够同步更新。

7. 双缓冲模式(Double Buffer)

双缓冲类需保存两个缓冲的实例：下一缓存和当前缓存。
当信息从缓冲区中读取，我们总是去读取当前的缓冲区。
当信息需要写到缓存，我们总是在下一缓冲区上操作。
当改变完成后，一个交换操作会立刻将当前缓冲区和下一缓冲区交换，这样新缓冲区就是公共可见的了。旧的缓冲区则成为了下一个重用的缓冲区。

案例：动态规划的 dp 数组转移，可以双缓冲来减少空间复杂度。

8. 游戏循环(Game Loop)

游戏循环将游戏的处理过程和玩家输入解耦，和处理器速度解耦，实现用户输入和处理器速度在游戏行进时间上的分离

9.  更新方法(Update Method)

通过每次处理一帧的行为来模拟一系列独立对象
`更新方法模式，以及游戏循环模式和组件模式，是构建游戏引擎核心的铁三角`

- 要点
  更新方法模式：在游戏中保持游戏对象的集合。`每个对象实现一个更新方法`，以处理对象在一帧内的行为。每一帧中，游戏循环对集合中的每一个对象进行更新。
  当离开每帧时，我们也许需要存储下状态，以备不时之需。

  类似 react 类组件？

## 三、行为型模式

10. 字节码(Bytecode)
    将行为编码为虚拟机器上的指令，赋予其数据的灵活性。
    `指令集` 定义了可执行的底层操作。 一系列的指令被编码为`字节序列`。
    `虚拟机` 使用 `中间值栈` 依次执行这些指令。 通过组合指令，可以定义复杂的高层行为。
    （并不通用，TODO）
    Lua 是游戏中最广泛应用的脚本语言。 它的内部被实现为一个非常紧凑的，基于寄存器的字节码虚拟机。
11. 子类沙箱(Subclass Sandbox)
    模版模式？
    基类定义抽象的沙箱方法和几个提供的操作。 将操作标为 protected，表明它们只为子类所使用。 每个推导出的沙箱子类用提供的操作实现了沙箱函数。

    > 最近，你会发现很多人批评面向对象语言中的继承。 继承是有问题——在代码库中没有比父类子类之间的耦合更深的了——但我发现`扁平的继承树比起深的继承树更好处理`。

    - 要点：基类应该提供什么操作？
      一个极端，基类几乎不提供任何操作。只有一个沙箱方法。 为了实现功能，总是需要调用基类外部的系统。如果你这样做，很难说你在使用这个模式。
      另一个极端，基类提供了所有子类也许需要的操作。 子类只与基类耦合，不调用任何外部系统的东西。
      `你提供的操作越多，外部系统与子类耦合越少，但是与基类耦合越多。 从子类中移除了耦合是通过将耦合推给基类完成的。`
    - 基类如何获得它需要的状态(依赖注入)》？
      - 构造函数
      - 两阶初始化,init/inject 中注入
      - 让状态静态化，单例，直接获取
      - 使用服务定位器：自己从服务定位器中拿了一个依赖

12. 类型对象(Type Object)
    这个模式处理的高层问题是在多个对象间分享数据和行为。
    创造一个类 A 来允许灵活地创造新“类型”，类 A 的每个实例都代表了不同的对象类型。

    我们可以通过用不同值实例化 Monster 来创建成百上千的新品种。 如果从配置文件读取不同的数据初始化品种，我们就有能力完全靠数据定义新怪物品种。

    每个“对象”现在都是一对对象：主对象和它的类型对象。

    思想：
    **1. 使用参数取代子类**
    **2. 不简单地调用 new 创建对象（例子：插件内存分配->初始化),统一内存管理规范**
    **3. 通过继承分享数据(js 的 prototype)**

    - 要点
      类型对象的基本思想就是`给基类一个品种参数（breed 参数），而不是用一些子类继承自这个基类。`所以我们在做种类区分的时候就可以只有两个类，怪物类 monster 和品种类 breed，而不是 monster，dragon，troll 等一堆类。所以在此种情况下，游戏中的每个怪物都是怪物类的一个实例，而实例中的 breed 类包含了所有同种类型怪物共享的信息。
    - 使用场合
      不知道后续还需什么新类型。（举个例子，如果你的游戏需要支持增量更新，让用户下载后续新包含进来的怪物品种）
      想要不改变代码或不重新编译就能修改或添加新类型。
    - 这个模式引出的进阶问题是如何在不同对象之间共享数据
      这个模式和 GOF 设计模式中状态模式有很多相似之处，两者都是`委托了对象的部分定义给另外一个对象`

    一种保持多态的灵活性而不使用子类的方法是借助于类型对象模式。

## 四、解耦型模式

能让我们更好地适应变化的工具是解耦。
当我们说两块代码“解耦”时，是指`修改一块代码一般不会需要修改另一块代码。`
当我们修改游戏中的特性时，需要修改的代码越少，就越容易。

这一部分的三种模式，专注于解耦：

- 组件模式将一个实体拆成多个，解耦不同的领域。
- 事件队列解耦了两个互相通信的事物，稳定而且实时。
- 服务定位器让代码使用服务而无需绑定到提供服务的代码上(supplier)。

13. 组件模式
14. 事件队列
15. 服务定位器(Service Locator)
    提供服务的全局接入点，而不必让用户和实现它的具体类耦合。

## 五、优化型模式

16. 数据局部性(Data Locality)

    - 意图：
      合理组织数据，充分使用 CPU 的缓存来加速内存读取。
    - 动机：
      我们可以更快地处理数据，但不能更快地获得数据(RAM 没有紧跟 CPU 的速度增长)。
    - 原理：
      无论何时芯片需要从 RAM 取一字节的数据，它自动将一整块内存读入然后将其放入缓存——通常是 64 到 128 字节。 这些一次性传输的字节被称为 cache line。
      如果你需要的下一字节数据就在这块上， CPU 从缓存中直接读取，比从 RAM 中读取快得多。 成功从缓存中找到数据被称为“缓存命中”。 如果不能从中获得而得去主存里取，这就是一次缓存不命中。
      当缓存不命中时，CPU 空转——它不能执行下一条指令，因为它没有数据。 它坐在那里，无聊地等待几百个周期直到取到数据。 我们的任务是避免这一点。
      `因为缓存的存在，组织数据的方式直接影响了性能。`
      `所以目标是组织数据结构，让要处理的数据紧紧相邻。`
    - 模式:
      `现代的CPU有缓存来加速内存读取。 它可以更快地读取最近访问过的内存的毗邻内存。 通过提高内存局部性来提高性能——保证数据以处理顺序排列在连续内存上。`
    - 记住：
      抽象 vs 局部性，需要权衡
    - 举例：

      - **如果你想要提高数据局部性，找找那些你可以摆脱的间接跳转。**
        **多用连续数组。**
        `我们将每种组件存入巨大的数组：一个数组给 AI 组件，一个给物理，另一个给渲染。`
        而不是使用指针，在游戏地址空间中四处乱转，完成“256MB 内存四晚廉价游”。
        做得更好的一个技巧是新代码中有更少的`.`操作符。
      - **优化分支预测**
        使用 `swap and pop` **打包数据**，更新对象池中活跃的对象。

        ```cpp
        for (int i = 0; i < numParticles_; i++)
        {
          if (particles_[i].isActive())
          {
            particles_[i].update();
          }
        }
        ```

        将所有活跃的粒子放在列表的前头。 如果知道了这些粒子都是活跃的，就不必再检查这些标识位了。还可以很容易地追踪有多少活跃的粒子。

        ```cpp
        for (int i = 0; i < numActive_; i++)
        {
          particles[i].update();
        }
        ```

        现在没有跳过任何数据。 加载入缓存的每一字节都是需要处理的粒子的一部分。
        当一个粒子激活时，我们让它占据第一个不活跃粒子的位置， 将不活跃粒子移动到激活序列的尾端，完成一次交换：
        `这个技巧叫做“交换和递增”(swap and pop)。`

        ```cpp
        void ParticleSystem::activateParticle(int index)
        {
          particles_[index].activate();
          std::swap(particles_[index], particles_[numActive_]);
          numActive_++;
        }
        void ParticleSystem::deactivateParticle(int index)
        {
          particles_[index].deactivate();
          numActive_--;
          std::swap(particles_[index], particles_[numActive_]);
        }
        ```

      - **冷热分割**
        将数据结构划分为两个分离的部分。
        第一部分保存“热”数据，那些每帧都要调用的数据。
        剩下的片段被称为“冷”数据，在那里存储使用的次数较少的数据。
        热部分是 AI 组件的主体。 它是使用最多的部分，所以我们不希望解析指针去找到它。 冷组件可以被归到一边去，但是我们还是需要访问它，因此我们在热组件中包含一个指向它的指针

        ```cpp
        class AIComponent
        {
        public:
          // 方法……
        private:
          Animation* animation_;
          double energy_;
          Vector goalPos_;

          LootDrop* loot_;
        };

        class LootDrop
        {
          friend class AIComponent;
          LootType drop_;
          int minDrops_;
          int maxDrops_;
          double chanceOfDrop_;
        };
        ```

17. 脏标识模式(Dirty Flag)->Complex side effects should be deferred
    将工作延期至需要其结果时才去执行，以避免不必要的工作。
18. 对象池模式

    - 使用场合
      - 这个模式广泛使用在可见事物上，比如游戏物体和特效。但是它也可在不那么视觉化的数据结构上使用，比如正在播放的声音。
      - 满足以下情况可以使用对象池：
        - 需要频繁创建和销毁对象。
        - 对象大小相仿。
        - 在堆上分配对象缓慢或者会导致内存碎片。
        - 每个对象都封装了像数据库或者网络连接这样很`昂贵又可以重用的资源。`

19. 空间分区(Spatial Partition)
    将对象存储在基于位置组织的数据结构中，来有效的定位对象。
    最简单的空间分区：固定网格。
    这个模式的基本适用场景是你有一系列有位置的对象，当做了大量通过位置寻找对象的查询而导致性能下降的时候。
