https://zhuanlan.zhihu.com/p/23821422

## 一、常用 GOF 设计模式

1. 命令模式
2. 享元模式
3. 观察者模式
4. 原型模式
5. 单例模式
6. 状态模式

## 二、序列型模式

本章的三种模式都是游戏开发中的常客：

游戏循环是游戏运行的主心骨。
游戏对象通过更新方法来进行每帧的更新。
我们可以用双缓冲模式存储快照，来隐藏计算机的顺序执行，从而使得游戏世界能够同步更新。

7. 双缓冲模式(Double Buffer)

双缓冲类需保存两个缓冲的实例：下一缓存和当前缓存。
当信息从缓冲区中读取，我们总是去读取当前的缓冲区。
当信息需要写到缓存，我们总是在下一缓冲区上操作。
当改变完成后，一个交换操作会立刻将当前缓冲区和下一缓冲区交换，这样新缓冲区就是公共可见的了。旧的缓冲区则成为了下一个重用的缓冲区。

案例：动态规划的 dp 数组转移，可以双缓冲来减少空间复杂度。

8. 游戏循环(Game Loop)

游戏循环将游戏的处理过程和玩家输入解耦，和处理器速度解耦，实现用户输入和处理器速度在游戏行进时间上的分离

9.  更新方法(Update Method)

通过每次处理一帧的行为来模拟一系列独立对象
`更新方法模式，以及游戏循环模式和组件模式，是构建游戏引擎核心的铁三角`

- 要点
  更新方法模式：在游戏中保持游戏对象的集合。`每个对象实现一个更新方法`，以处理对象在一帧内的行为。每一帧中，游戏循环对集合中的每一个对象进行更新。
  当离开每帧时，我们也许需要存储下状态，以备不时之需。

## 三、行为型模式

10. 字节码(Bytecode)
11. 子类沙箱(Subclass Sandbox)
12. 类型对象(Type Object)

    - 要点
      类型对象的基本思想就是`给基类一个品种类（breed 类），而不是用一些子类继承自这个基类。`所以我们在做种类区分的时候就可以只有两个类，怪物类 monster 和品种类 breed，而不是 monster，dragon，troll 等一堆类。所以在此种情况下，游戏中的每个怪物都是怪物类的一个实例，而实例中的 breed 类包含了所有同种类型怪物共享的信息。
    - 使用场合
      不知道后续还需什么新类型。（举个例子，如果你的游戏需要支持增量更新，让用户下载后续新包含进来的怪物品种）
      想要不改变代码或不重新编译就能修改或添加新类型。
    - 这个模式引出的进阶问题是如何在不同对象之间共享数据
      这个模式和 GOF 设计模式中状态模式有很多相似之处，两者都是`委托了对象的部分定义给另外一个对象`

## 四、解耦型模式

这一部分的三种模式，专注于解耦：

组件模式将一个实体拆成多个，解耦不同的领域。
事件队列解耦了两个互相通信的事物，稳定而且实时。
服务定位器让代码使用服务而无需绑定到提供服务的代码上。

13. 组件模式
14. 事件队列
15. 服务定位器(Service Locator)
    提供服务的全局接入点，而不必让用户和实现它的具体类耦合。

## 五、优化型模式

16. 数据局部性(Data Locality)
    合理组织数据，充分使用 CPU 的缓存来加速内存读取。

17. 脏标识模式(Dirty Flag)->Complex side effects should be deferred
    将工作延期至需要其结果时才去执行，以避免不必要的工作。
18. 对象池模式

    - 使用场合
      - 这个模式广泛使用在可见事物上，比如游戏物体和特效。但是它也可在不那么视觉化的数据结构上使用，比如正在播放的声音。
      - 满足以下情况可以使用对象池：
        - 需要频繁创建和销毁对象。
        - 对象大小相仿。
        - 在堆上分配对象缓慢或者会导致内存碎片。
        - 每个对象都封装了像数据库或者网络连接这样很`昂贵又可以重用的资源。`

19. 空间分区(Spatial Partition)
    将对象存储在基于位置组织的数据结构中，来有效的定位对象。
    最简单的空间分区：固定网格。
    这个模式的基本适用场景是你有一系列有位置的对象，当做了大量通过位置寻找对象的查询而导致性能下降的时候。
