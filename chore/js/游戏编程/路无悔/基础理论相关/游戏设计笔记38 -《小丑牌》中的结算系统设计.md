https://www.bilibili.com/video/BV1dm41127Gk

《小丑牌》（Balatro）之所以让人上瘾，核心在于其**极其清晰但指数级膨胀**的数值系统。它的结算算法并非黑盒，而是一套严格遵循**优先级（Order of Operations）**的流水线。

下面我将深入讲解其核心结算算法，并提供一套 TypeScript 代码抽象来模拟这个过程。

---

### 第一部分：核心结算逻辑解析

Balatro 的得分公式只有一个：
$$ \text{Score} = \text{Chips} \times \text{Mult} $$

但在计算最终的 Chips（筹码）和 Mult（倍率）之前，游戏会经历四个严格的阶段。每一个阶段，都会更新当前的 `runningChips` 和 `runningMult`。

#### 1. 基础阶段 (Base Hand)

- 系统根据牌型（如同花、顺子）确立基础数值。
- **来源**：星球牌等级。
- **例子**：Lv.1 同花 = 35 Chips $\times$ 4 Mult。此时 `runningChips = 35`, `runningMult = 4`。

#### 2. 计分牌阶段 (Scored Cards)

这是最复杂的阶段，每张打出的计分牌会依次结算。

- **顺序**：从左到右结算每一张牌。
- **触发逻辑**：
  1.  **卡牌基础筹码**：牌面点数（如 A 加 11 筹码）。
  2.  **卡牌增强 (Enhancement)**：如石头牌 (+50 Chips)、玻璃牌 ($\times 2$ Mult) 等。
  3.  **卡牌版本 (Edition)**：如箔制 (+50 Chips)、镭射 (+10 Mult)、多彩 ($\times 1.5$ Mult)。
  4.  **Joker 触发**：特定 Joker 会在“每张牌计分时”触发（如：贪婪小丑——只要是方片，Mult +4）。
  5.  **重复触发 (Retrigger)**：红蜡封（Red Seal）或特定 Joker（如吊放/Sock and Buskin）会让上述 1-4 步对当前这张牌重新跑一遍。

#### 3. 手牌阶段 (Held in Hand Cards)

结算完打出的牌后，检查手里的牌。

- **触发逻辑**：钢铁牌 ($\times 1.5$ Mult)、国王/女王配合“公爵”Joker 等。
- 同样适用**重复触发**逻辑（如哑剧演员 Joker）。

#### 4. Joker 队列阶段 (Jokers)

这是数值膨胀的关键。Joker 从左到右依次结算。

- **+Mult (加法)**：通常先结算。
- **$\times$Mult (乘法)**：极为重要，因为它是基于当前的 `runningMult` 进行乘算的。
- **Joker 版本**：如果 Joker 自身是多彩（Polychrome），它会在结算完该 Joker 的技能后，立刻结算 $\times 1.5$ Mult。

---

### 第二部分：TypeScript 代码抽象

为了模拟这个过程，我们需要构建一个**上下文（Context）**驱动的计算器。

#### 1. 基础类型定义

```typescript
// 基础类型定义
type TriggerType = 'on_score' | 'on_held' | 'independent' | 'passive'

interface StatModifier {
  chips?: number // +Chips
  mult?: number // +Mult
  x_mult?: number // X Mult
}

// 卡牌定义
interface Card {
  id: string
  rank: number // 2-10, J=11, Q=12, K=13, A=14
  suit: 'Spade' | 'Heart' | 'Club' | 'Diamond'
  baseChips: number // 基础筹码 (2=2, A=11)
  edition?: 'Foil' | 'Holo' | 'Polychrome' | null // 版本
  enhancement?: 'Glass' | 'Stone' | 'Bonus' | 'Mult' | 'Steel' | null
  seal?: 'Red' | 'Blue' | 'Gold' | 'Purple' | null
}

// 牌型定义
interface HandType {
  name: string
  level: number
  baseChips: number
  baseMult: number
}

// Joker 定义
interface Joker {
  name: string
  edition?: 'Foil' | 'Holo' | 'Polychrome'
  // Joker 的核心逻辑：根据上下文返回修正值
  calculate: (context: CalculationContext) => StatModifier | null
}
```

#### 2. 计算上下文与状态管理

我们需要一个类来保存当前的计算状态（筹码、倍率）。

```typescript
class CalculationState {
  chips: number = 0
  mult: number = 0

  constructor(baseChips: number, baseMult: number) {
    this.chips = baseChips
    this.mult = baseMult
  }

  // 应用修正：核心数学逻辑
  applyModifier(mod: StatModifier, sourceName: string) {
    if (mod.chips) {
      this.chips += mod.chips
      console.log(`[${sourceName}] +${mod.chips} Chips => Total: ${this.chips}`)
    }

    // 注意：Balatro 中先加后乘，但顺序由触发时机决定
    if (mod.mult) {
      this.mult += mod.mult
      console.log(`[${sourceName}] +${mod.mult} Mult => Total: ${this.mult}`)
    }

    if (mod.x_mult) {
      this.mult *= mod.x_mult
      console.log(`[${sourceName}] x${mod.x_mult} Mult => Total: ${this.mult}`)
    }
  }
}

// 上下文：传递给 Joker 用来判断触发条件
interface CalculationContext {
  state: CalculationState
  scoringCard?: Card // 当前正在计分的牌
  heldCard?: Card // 当前正在检测的手牌
  playedHand: Card[] // 打出的所有牌
  jokers: Joker[] // 场上的 Joker
  triggerType: TriggerType // 当前触发阶段
}
```

#### 3. 核心计算引擎

这是整个算法的灵魂，模拟了 Balatro 的四个阶段。

```typescript
class BalatroCalculator {
  public calculateScore(
    handType: HandType,
    scoredCards: Card[],
    heldCards: Card[],
    jokers: Joker[]
  ): number {
    console.log(`=== 开始计算: ${handType.name} (Lv.${handType.level}) ===`)

    // Phase 1: 基础分
    const state = new CalculationState(handType.baseChips, handType.baseMult)

    // Phase 2: 计分牌循环 (Scored Cards)
    for (const card of scoredCards) {
      // 计算重复触发次数 (默认1次，红蜡封+1)
      // 注意：这里简化了逻辑，实际上还有 Joker (Seltzer, Hack) 能增加次数
      let triggers = 1
      if (card.seal === 'Red') triggers += 1

      for (let t = 0; t < triggers; t++) {
        console.log(`--- 计分卡牌: ${card.rank} (触发第 ${t + 1} 次) ---`)

        // 2.1 卡牌本身的基础筹码
        state.applyModifier({ chips: card.baseChips }, `Card Base`)

        // 2.2 卡牌增强 (Enhancements)
        this.applyCardEnhancement(state, card)

        // 2.3 卡牌版本 (Editions) - 比如箔制卡
        this.applyCardEdition(state, card)

        // 2.4 Joker 对卡牌的触发 (On Score Jokers)
        // 比如：贪婪小丑 (方片+4 Mult)
        for (const joker of jokers) {
          const mod = joker.calculate({
            state,
            scoringCard: card,
            playedHand: scoredCards,
            jokers,
            triggerType: 'on_score'
          })
          if (mod) state.applyModifier(mod, `Joker: ${joker.name}`)
        }
      }
    }

    // Phase 3: 手牌循环 (Held Cards)
    for (const card of heldCards) {
      // 检查钢铁牌等
      let triggers = 1
      if (card.seal === 'Red') triggers += 1

      for (let t = 0; t < triggers; t++) {
        this.applyHeldCardEffect(state, card)

        // Joker 对手牌的触发 (On Held Jokers)
        // 比如：男爵 (King x1.5 Mult)
        for (const joker of jokers) {
          const mod = joker.calculate({
            state,
            heldCard: card,
            playedHand: scoredCards,
            jokers,
            triggerType: 'on_held'
          })
          if (mod) state.applyModifier(mod, `Joker: ${joker.name}`)
        }
      }
    }

    // Phase 4: Joker 独立结算 (Independent Jokers)
    // 严格从左到右
    console.log(`--- Joker 结算阶段 ---`)
    for (const joker of jokers) {
      const mod = joker.calculate({
        state,
        playedHand: scoredCards,
        jokers,
        triggerType: 'independent'
      })

      if (mod) state.applyModifier(mod, `Joker: ${joker.name}`)

      // 4.1 Joker 自身的版本 (Polychrome Joker)
      // 在 Joker 自身效果结算完后，立刻结算 x1.5
      if (joker.edition === 'Polychrome') {
        state.applyModifier({ x_mult: 1.5 }, `Joker Edition: Polychrome`)
      } else if (joker.edition === 'Holo') {
        state.applyModifier({ mult: 10 }, `Joker Edition: Holo`)
      } else if (joker.edition === 'Foil') {
        state.applyModifier({ chips: 50 }, `Joker Edition: Foil`)
      }
    }

    const finalScore = state.chips * state.mult
    console.log(`=== 最终得分: ${state.chips} x ${state.mult} = ${finalScore} ===`)
    return finalScore
  }

  // 辅助函数：卡牌增强效果
  private applyCardEnhancement(state: CalculationState, card: Card) {
    if (card.enhancement === 'Bonus') state.applyModifier({ chips: 30 }, 'Enhancement: Bonus')
    if (card.enhancement === 'Mult') state.applyModifier({ mult: 4 }, 'Enhancement: Mult')
    if (card.enhancement === 'Glass') state.applyModifier({ x_mult: 2 }, 'Enhancement: Glass')
    if (card.enhancement === 'Stone') state.applyModifier({ chips: 50 }, 'Enhancement: Stone')
  }

  // 辅助函数：卡牌版本效果
  private applyCardEdition(state: CalculationState, card: Card) {
    if (card.edition === 'Foil') state.applyModifier({ chips: 50 }, 'Edition: Foil')
    if (card.edition === 'Holo') state.applyModifier({ mult: 10 }, 'Edition: Holo')
    // 注意：多彩卡是在卡牌计分阶段就乘算的
    if (card.edition === 'Polychrome') state.applyModifier({ x_mult: 1.5 }, 'Edition: Polychrome')
  }

  // 辅助函数：手牌效果
  private applyHeldCardEffect(state: CalculationState, card: Card) {
    if (card.enhancement === 'Steel') state.applyModifier({ x_mult: 1.5 }, 'Held: Steel')
  }
}
```

#### 4. 模拟运行实战

让我们创建一个具体的场景来测试代码。
**场景**：

- 牌型：一对 (Lv.1, 10 Chips, 2 Mult)
- 打出牌：一张 `玻璃方片 K`，一张 `普通方片 K`。
- Joker 1：`Jokier` (每打出一张人头牌 +4 Mult)。
- Joker 2：`Cavendish` (香蕉，x3 Mult)。
- Joker 2 是 `Polychrome` (多彩 x1.5 Mult)。

```typescript
// === 实例化 ===
const calculator = new BalatroCalculator()

// 定义 Joker 实现
const joker_jolly: Joker = {
  name: 'Jolly', // 假设是+Mult的普通Joker
  calculate: ctx => {
    // 逻辑：如果当前计分卡是人头牌，on_score 时触发
    if (ctx.triggerType === 'on_score' && ctx.scoringCard && ctx.scoringCard.rank >= 11) {
      return { mult: 8 } // 假设 Jolly 效果是 +8
    }
    return null
  }
}

const joker_banana: Joker = {
  name: 'Cavendish',
  edition: 'Polychrome', // 多彩香蕉！
  calculate: ctx => {
    // 逻辑：全局结算阶段触发
    if (ctx.triggerType === 'independent') {
      return { x_mult: 3 }
    }
    return null
  }
}

// 定义手牌
const glassKing: Card = {
  id: '1',
  rank: 13,
  suit: 'Diamond',
  baseChips: 10,
  enhancement: 'Glass'
}
const normalKing: Card = {
  id: '2',
  rank: 13,
  suit: 'Diamond',
  baseChips: 10
}

// 运行
calculator.calculateScore(
  { name: 'Pair', level: 1, baseChips: 10, baseMult: 2 },
  [glassKing, normalKing], // 打出的牌
  [], // 手里的牌
  [joker_jolly, joker_banana]
)
```

### 运行结果模拟 (Console Log 顺序)

```text
=== 开始计算: Pair (Lv.1) ===
--- 计分卡牌: 13 (触发第 1 次) ---
[Card Base] +10 Chips => Total: 20  (基数10+10)
[Enhancement: Glass] x2 Mult => Total: 4 (基数2x2)
[Joker: Jolly] +8 Mult => Total: 12
--- 计分卡牌: 13 (触发第 1 次) ---
[Card Base] +10 Chips => Total: 30
[Joker: Jolly] +8 Mult => Total: 20
--- Joker 结算阶段 ---
[Joker: Cavendish] x3 Mult => Total: 60
[Joker Edition: Polychrome] x1.5 Mult => Total: 90
=== 最终得分: 30 x 90 = 2700 ===
```

### 总结关键设计模式

1.  **事件钩子 (Hooks)**：代码区分了 `on_score` (随卡牌触发) 和 `independent` (独立触发)。这是区分“+4 Mult”小丑和“x3 Mult”小丑生效时机的关键。如果 `Jolly` 设为 `independent`，它将无法吃到 `Glass` 卡牌的 x2 加成（因为 Glass 是在卡牌阶段结算的）。
2.  **累加器模式 (Accumulator)**：`CalculationState` 对象贯穿全程，所有的修正都是对这个对象的状态进行修改。
3.  **触发器嵌套 (Trigger Loop)**：为了处理红蜡封（Red Seal），必须在卡牌循环外层包裹一个 Loop，而不是简单的数值 x2，因为第二次触发可能会引发新的 Joker 效果。
