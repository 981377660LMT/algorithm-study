在浏览器环境尤其是使用 CodeMirror 这种编辑器时，执行用户代码并定位报错位置，通常的核心步骤是：**捕获错误对象 -> 解析堆栈信息 (`error.stack`) -> 修正行列号偏移 -> 在编辑器中高亮**。

以下是具体的实现方案：

### 1. 核心原理

浏览器抛出的 `Error` 对象包含 `stack` 属性。不同浏览器（V8 chrome, SpiderMonkey Firefox, JSC Safari）的 stack 格式略有不同，但通常都包含 `:Line:Column` 的模式。

### 2. 报错解析函数

我们需要一个能够兼容主流浏览器的解析函数。以下是一个通用的解析实现：

```javascript
/**
 * 解析错误堆栈中的行列号
 * @param {Error} error 捕获到的错误对象
 * @returns {{line: number, column: number} | null} 返回基于 1 的行列号
 */
function parseErrorLocation(error) {
  if (!error || !error.stack) return null

  // 正则匹配 :行号:列号
  // Chrome/Edge: at <anonymous>:1:5 OR at func (url:1:5)
  // Firefox: func@url:1:5
  const stack = error.stack.split('\n')

  // 通常第一行是错误消息，第二行开始是堆栈。
  // 我们只关心堆栈的最顶层（即用户代码报错的那一行）
  // 注意：如果是 eval 或 new Function，堆栈中通常会包含 <anonymous> 或者 eval 标识

  const lineRegex = /:(\d+):(\d+)/

  for (const line of stack) {
    // 过滤掉无关的堆栈（比如来自 React/Vue 内部或者执行器本身的堆栈）
    // 这取决于你的执行环境文件名，如果是在 eval 中，通常找第一个匹配项即可
    const match = line.match(lineRegex)
    if (match) {
      return {
        line: parseInt(match[1], 10),
        column: parseInt(match[2], 10)
      }
    }
  }
  return null
}
```

### 3. 处理行列号偏移 (Offset)

**这是最关键的一步。**
当你使用 `new Function` 或 `eval` 执行代码时，浏览器解析的代码往往不仅仅是用户输入的代码，可能还包含你包裹的函数头。

例如，如果你这样执行：

```javascript
// 假设用户输入代码是: a.b = 1; (在第1行)

const userCode = 'a.b = 1;'
const wrapper = `
try {
  ${userCode}
} catch(e) {
  throw e;
}
`
// 这里实际上加了两行代码在前面
eval(wrapper)
```

此时报错行号可能是 3，但用户代码其实在第 1 行。你需要定义一个 `offset`。

**推荐的执行方式 (`new Function`) 及偏移计算：**

```javascript
function executeUserCode(codeStr) {
  // 定义偏移量：如果 new Function 内部不加额外换行，通常偏移量是 2
  // (new Function 创建了一个匿名函数 wrapper: `function anonymous() { ... }`)
  // Chrome 下 new Function 的第一行是函数头，第二行才是你的代码
  const LINE_OFFSET = 2

  try {
    // 使用 new Function 相对 eval 更干净，作用域更隔离
    const fn = new Function(codeStr)
    fn()
  } catch (err) {
    const loc = parseErrorLocation(err)

    if (loc) {
      // 修正行号
      const realLine = loc.line - LINE_OFFSET
      const realCol = loc.column

      console.log(`用户代码报错位置: 第 ${realLine} 行, 第 ${realCol} 列`)

      // 返回给外层 UI 进行高亮
      return { line: realLine, col: realCol, message: err.message }
    }
  }
}
```

### 4. 集成到 CodeMirror

获取到修正后的 `line` 和 `col` 后，需要调用 CodeMirror API 进行标记。

#### 如果是 CodeMirror 5:

```javascript
// cm 是 CodeMirror 实例
function highlightError(line, msg) {
  // CodeMirror 行号是 0-based，解析出来的是 1-based，需要 -1
  const doc = cm.getDoc()

  // 1. 添加行背景色
  cm.addLineClass(line - 1, 'background', 'line-error-bg')

  // 2. 添加行下方的错误提示 widget
  const msgEl = document.createElement('div')
  msgEl.className = 'line-error-msg'
  msgEl.innerText = msg
  cm.addLineWidget(line - 1, msgEl)
}
```

#### 如果是 CodeMirror 6:

```javascript
import { EditorView, Decoration } from '@codemirror/view'
import { StateEffect, StateField } from '@codemirror/state'

// 定义一个 Effect 来添加错误装饰
const addErrorEffect = StateEffect.define()

const errorField = StateField.define({
  create() {
    return Decoration.none
  },
  update(value, tr) {
    value = value.map(tr.changes)
    for (let effect of tr.effects) {
      if (effect.is(addErrorEffect)) {
        // 创建行内高亮或下划线
        value = value.update({
          add: [effect.value]
        })
      }
    }
    return value
  },
  provide: f => EditorView.decorations.from(f)
})

// 在捕获错误后调用
function highlightErrorV6(view, line, col) {
  const lineInfo = view.state.doc.line(line)
  // 简单的整行背景装饰
  const decoration = Decoration.line({ attributes: { class: 'cm-error-line' } })

  view.dispatch({
    effects: addErrorEffect.of(decoration.range(lineInfo.from))
  })
}
```

### 总结

1.  **捕获**：使用 `try-catch` 包裹执行逻辑。
2.  **解析**：正则提取 `error.stack` 中的 `:row:col`。
3.  **校准**：**非常重要**，根据你的 `execJavaScript` 具体实现（是否拼接了字符串，是否用了 `new Function`），手动测试并减去固定的 `Line Offset`。
4.  **显示**：CodeMirror API 转换为 0-based 索引进行展示。

---

`SyntaxError`（语法错误）尤其是正则表达式相关错误（如 `missing /`），与普通的运行时错误（Runtime Error）不同。

**原因**：语法错误发生在代码**编译/解析阶段**，此时代码还没开始运行。因此，浏览器往往无法生成详细的调用堆栈（Stack Trace），或者堆栈只会指向 `new Function` 调用的那一行，而不会深入到你的代码字符串内部。

解决这种“无行列号”的语法错误，有以下三种方案，按推荐程度排序：

### 方案一：引入轻量级 Parser 进行预检（最推荐）

这是 Web IDE（如 CodeSandbox、JSFiddle）的标准做法。在执行代码前，先用纯 JS 编写的解析器（如 **Acorn**）尝试解析代码。如果解析失败，它能提供**非常精准**的行列号。

**步骤**：

1. 安装 Acorn: `npm install acorn` (或者通过 CDN 引入)。
2. 在 `execJavaScript` 之前先跑一遍解析。

```javascript
import * as acorn from 'acorn'

function checkSyntax(code) {
  try {
    // 只需要 parse，不需要执行
    // ecmaVersion 设高一点以支持最新语法
    acorn.parse(code, { ecmaVersion: 2022 })
    return null // 语法没问题
  } catch (err) {
    // Acorn 的错误对象直接包含 loc 属性
    // err.loc = { line: 1, column: 5 }
    // err.pos = 15 (字符索引)
    // err.message = "Invalid regular expression: missing / (1:5)"

    return {
      line: err.loc.line, // Acorn 的行号通常是 1-based
      column: err.loc.column,
      message: err.message.replace(/\s\(\d+:\d+\)$/, '') // 去掉尾部自带的坐标
    }
  }
}

// 在你的执行逻辑中：
function execute() {
  const syntaxError = checkSyntax(userCode)
  if (syntaxError) {
    // 直接高亮报错，阻止执行
    highlightError(syntaxError.line, syntaxError.message)
    return
  }

  // ...继续执行 new Function ...
}
```

### 方案二：利用 CodeMirror 自带的 Linter

既然你已经使用了 CodeMirror，最好的体验其实是**在用户输入时就提示错误**，而不是等到点“运行”才报错。

- **如果用的是 CodeMirror 6**: 使用 `@codemirror/lang-javascript` 自带的 lint 功能。
- **如果用的是 CodeMirror 5**: 开启 `lint: true` 并引入 `javascript-lint` 和 `jshint/eslint`。

这样编辑器会在代码行首直接出现红色叉号，提示 `Expected '/' to match this '/'`，完全避免了去解析执行报错的麻烦。

### 方案三：针对特定浏览器的降级处理（不推荐）

如果你不想引入 Acorn，也不想用 Linter，只能尝试从某些浏览器特有的属性中“捡漏”，但在 Safari 或 Chrome 的某些版本上不一定有效。

```javascript
try {
  new Function(code)
} catch (e) {
  let line, col

  // 1. 尝试 Firefox 的 lineNumber / columnNumber 属性 (非标准)
  if (e.lineNumber !== undefined) {
    // 注意：这里的 lineNumber 常常是包含 new Function 前缀的总行数，需要减去 offset
    line = e.lineNumber - LINE_OFFSET
    col = e.columnNumber
  }
  // 2. 尝试从 message 中正则提取 (某些 Chrome 版本会把行号写在 message 里)
  // 例如: "SyntaxError: Unexpected token ... (1:5)"
  else if (/: (\d+):(\d+)\)$/.test(e.message)) {
    const match = e.message.match(/: (\d+):(\d+)\)$/)
    line = parseInt(match[1])
    col = parseInt(match[2])
  }

  if (!line) {
    // 实在找不到行号，只能告诉用户是语法错误，但不定位
    console.error('无法定位语法错误，请检查代码拼写')
  }
}
```

### 总结

对于 `Invalid regular expression: missing /` 这种错误：

1.  **原生堆栈不可靠**。
2.  如果你需要做成类 IDE 的体验，**请使用 Acorn 进行 AST 解析预检**，这是定位 SyntaxError 的唯一“银弹”。

---

在业界成熟的在线代码编辑器产品（如 CodeSandbox, StackBlitz, JSFiddle, LeetCode, 以及 VS Code Web 版）中，处理代码执行报错和行列号解析的**最佳实践**是一套组合拳。

主要分为三个层次：**编辑时静态分析 (Linting)**、**预编译/预解析 (Parsing)**、**运行时错误捕获 (Runtime Catch)**。

针对你提到的“无行列号 SyntaxError”问题，业界的标准解法不在“执行”阶段，而在“解析”阶段。

---

### 1. 第一道防线：编辑时检测 (Linter) —— 最佳用户体验

业界几乎所有的 IDE 甚至简单的 Playground 都在使用此方案。不要等到用户点击“执行”才告诉他少了一个 `/`，而是在他输入的瞬间就在编辑器里标红。

- **原理**：利用 CodeMirror 的 Lint 插件体系，配合 Parser。
- **做法**：
  - **CodeMirror 6**：直接使用 `@codemirror/lang-javascript` 包提供的 `javascript()` 和 `linter`。它内部自带了一个容错率很高的 Parser (Lezer)，能实时识别语法错误。
  - **CodeMirror 5**：开启 `lint: true`，通常配合 `JSHint` 或 `ESLint` 的浏览器版本。
- **效果**：用户输入 `/abc` 还没闭合时，编辑器行号旁直接出现红色波浪线，提示 `Unterminated regular expression`。这是解决 SyntaxError 体验最好的方式。

### 2. 第二道防线：执行前预检 (Parser Pre-check) —— 解决 SyntaxError 定位

如果你必须在点击“运行”按钮时才报错，且必须获得精准的行列号，业界的做法是：**不信赖浏览器的 `new Function` 抛出的 SyntaxError，而是自己 Parse 一遍。**

- **为什么**：浏览器（V8/SpiderMonkey）在通过 `new Function` 或 `eval` 解析脚本时，遇到语法错误往往只抛出错误信息，不提供或者提供不准确的堆栈信息。
- **最佳实践工具**：**[Acorn](https://github.com/acornjs/acorn)**。
  - Acorn 是目前 JS 社区最轻量、最广泛使用的纯 JS 解析器（Webpack、Babel 都在用它）。
- **流程**：

  ```javascript
  import * as acorn from 'acorn'

  async function runCode(userCode) {
    // 1. 【预检】 先用 Parser 扫一遍由用户代码组成的字符串
    try {
      // ecmaVersion: 'latest' 确保支持最新语法
      acorn.parse(userCode, { ecmaVersion: 'latest' })
    } catch (e) {
      // Acorn 的报错极其标准，必带 line 和 column，且是基于 userCode 本身的
      // 这里直接返回渲染报错，完全不进入执行环节
      return renderError({
        line: e.loc.line,
        column: e.loc.column,
        message: e.message
      })
    }

    // 2. 【执行】 只有通过了 Parser，才丢给浏览器执行
    try {
      new Function(userCode)()
    } catch (e) {
      // 处理运行时错误
      handleRuntimeError(e)
    }
  }
  ```

- **优点**：完美解决 `Invalid regular expression`、`Unexpected token` 等没有堆栈的报错定位问题。

### 3. 第三道防线：运行时错误标准库 (Error Stack Parsing)

对于运行时错误（如 `undefined works`），浏览器给出的 `error.stack` 格式千奇百怪。业界不会自己写正则去匹配，因为 Chrome、Safari、Firefox、IE 的格式都不一样。

- **最佳实践工具**：**[error-stack-parser](https://github.com/stacktracejs/error-stack-parser)** 或 **[stacktrace-parser](https://www.npmjs.com/package/stacktrace-parser)**。
- **做法**：

  ```javascript
  import ErrorStackParser from 'error-stack-parser'

  try {
    // ...执行代码
  } catch (e) {
    const frames = ErrorStackParser.parse(e)
    if (frames && frames[0]) {
      // 获取栈顶（最近的一个报错点）
      const topFrame = frames[0]
      const offsetLine = topFrame.lineNumber - WRAPPER_OFFSET // 减去你的包装代码行数
      const offsetCol = topFrame.columnNumber

      highlight(offsetLine, offsetCol, e.message)
    }
  }
  ```

### 4. 高级实践：沙箱与 SourceMap

如果你的产品比较复杂（例如像 CodeSandbox），代码经过了 Babel 编译或打包，那么行号肯定对不上了。

- **Source Map**：这是终极解决方案。
  - 在编译代码时生成 SourceMap。
  - 报错时，利用 `source-map` 库，将编译后代码的 `line/col` 映射回源码的 `line/col`。
- **Iframe/Worker 沙箱**：
  - 不要在主线程直接 `eval`。
  - 创建一个 `iframe` 或 `Web Worker`。
  - 利用 `window.onerror` 或 `worker.onerror` 捕获全局错误，通过 `postMessage` 将错误信息传回主线程编辑器显示。这能防止用户代码死循环卡死编辑器 UI。

### 总结

针对你的需求，最快落地且效果最好的方案路径：

1.  **首选**：配置 CodeMirror 的 **Linter 插件**。让编辑器自己在界面上处理掉 90% 的语法错误。
2.  **补救**：在 `execJavaScript` 入口处，引入 **Acorn** 进行一次 `parse` 校验。如果 Acorn 报错，直接使用 Acorn 提供的精准 Line/Column 并不再继续执行。
3.  **最后**：对于通过了 Acorn 校验但运行出错的代码，捕获 `Error`，手动减去 Wrapper 的行号偏移。

---

- 什么时候报错是有行列的
- 报错一般长什么样

在浏览器或 Node.js 环境中，报错信息的完整程度（是否包含行列号）取决于**错误的类型**以及**捕获错误的方式**。

为了让你直观地看到区别，我将在你的工作区 playground.js 中编写并执行一段测试代码，模拟几种典型的报错场景，然后为你详细分析。

```
// 1. 运行时错误 (Runtime Error)
console.log("--- 1. 运行时错误 ---");
try {
    // @ts-ignore
    console.log(undefinedVariable); // 引用不存在的变量
} catch (e) {
    printErrorDetails(e);
}

// 2. 语法错误 (Syntax Error) - 通过 new Function 触发
console.log("\n--- 2. 语法错误 (Syntax Error) ---");
try {
    // 少了分号前的赋值，或者不合法的语法
    new Function("var a = ;");
} catch (e) {
    printErrorDetails(e);
}

// 3. 正则语法错误 (Syntax Error - Regex)
console.log("\n--- 3. 正则语法错误 ---");
try {
    new Function("var r = /abc"); // 缺少闭合斜杠
} catch (e) {
    printErrorDetails(e);
}

function printErrorDetails(e) {
    console.log("类型 (name):", e.name);
    console.log("消息 (message):", e.message);

    // 某些浏览器特有属性 (非标准，Node环境通常为undefined)
    if (e.lineNumber) console.log("行号 (lineNumber - Firefox/Old):", e.lineNumber);
    if (e.columnNumber) console.log("列号 (columnNumber - Firefox/Old):", e.columnNumber);

    console.log("堆栈 (stack):");
    console.log(e.stack);
}

```

### 1. 什么时候报错会有行列号？

报错是否包含精确的行列号，主要取决于**错误的类型**和**浏览器的实现**：

- **运行时错误 (Runtime Error)**：**绝大数情况下都有行列号。**

  - 例如：`ReferenceError` (变量未定义), `TypeError` (null 用于计算), `RangeError` (数组越界)。
  - 只要代码成功编译并开始运行，一旦出错，引擎就能捕捉到当前的执行上下文（Stack Frame），因此能提供精确的堆栈跟踪。
  - _例如刚才运行的演示代码中，Accessing `undefinedVariable` 准确指向了第 55 行。_

- **语法错误 (Syntax Error)**：**情况很复杂。**
  - **脚本直接加载**：如果是 `<script src="app.js">` 加载的文件里有语法错误，浏览器控制台会显示行号，但 `window.onerror` 捕获到的信息可能不全（受跨域限制）。
  - **动态执行 (`new Function` / `eval`)**：
    - **普通语法错误**（如少写分号、括号）：现代浏览器通常能在堆栈中指出是 `eval` 或 `<anonymous>` 的第几行。
    - **正则/早期的词法错误**（如 `Invalid regular expression`）：**往往没有行号**。如前面的测试所示，V8 引擎（Chrome/Node）在解析正则失败时，经常只抛出一个错误对象，堆栈只指向 `new Function` 调用的那一行，而不知道字符串内部哪一行错了。这就是为什么这时必须用 Parser（如 Acorn）来辅助定位。

### 2. 报错一般长什么样？

一个标准的 Error 对象通常包含三个核心属性：`name`、`message` 和 `stack`。

#### A. 核心结构 (Chrome/V8 示例)

```text
Error: 错误具体的描述信息             <-- 第一部分: name + message
    at funcB (file.js:10:5)        <-- 第二部分: stack (调用堆栈)
    at funcA (file.js:5:10)
    at global (file.js:1:1)
```

#### B. 真实环境中的差异

我在刚才的 playground.js 中模拟了三种错误，结果如下：

**1. 运行时错误 (Runtime Error)**

- **特征**：堆栈清晰，直接指向代码文件。
- **实际输出**：
  ```text
  ReferenceError: undefinedVariable is not defined
      at Object.<anonymous> (.../playground.js:55:15) // 精确的 :55:15
  ```

**2. 动态代码的语法错误 (Syntax Error - Variable)**

- **特征**：堆栈指向 `new Function`。
- **实际输出**：
  ```text
  SyntaxError: Unexpected token ';'
      at new Function (<anonymous>) // 注意这里，它指向的是 create Function 的动作
      at Object.<anonymous> (.../playground.js:64:3)
  ```
  _注意：如果在浏览器控制台看，它通常会显示 `VM123:1` 这种虚拟文件名，提示你是在动态脚本的第一行出错。_

**3. 正则错误 (Syntax Error - Regex)**

- **特征**：这是最难处理的，VS Code 或 Chrome 有时甚至无法给出它是字符串里的第几个字符。
- **实际输出**：
  ```text
  SyntaxError: Invalid regular expression: missing /
      at new Function (<anonymous>)
      at Object.<anonymous> (.../playground.js:72:3)
  ```

#### C. 不同浏览器的“方言”

解析报错时最头疼的是不同浏览器 `stack` 格式不同：

- **Chrome / Node (V8)**: `at FunctionName (Url:Line:Col)`
- **Firefox**: `FunctionName@Url:Line:Col` （Firefox 的 Error 对象上直接有非标准的 `.lineNumber` 和 `.columnNumber` 属性，非常方便，但不能跨浏览器依赖）。
- **Safari**: 类似于 Firefox，格式是 `FunctionName@Url:Line:Col`。

**结论**：
做通用报错解析时，**不能只读 `error.lineNumber`**（那是 Firefox 独有的）。必须解析 `error.stack` 字符串，通过正则表达式提取 `:行:列`，并且要时刻警惕 `new Function` 带来的行号偏移。

---

要系统地把握 JavaScript 中的 `Error`，不能只把它看作一个会打印红字的报错。你需要从 **“解剖学”、“分类学”、“生命周期” 和 “工程化实践”** 四个维度建立心智模型。

以下是关于 `Error` 的完整系统图谱：

### 一、 解剖学：Error 对象到底包含什么？

一个标准的 `Error` 对象并没有你想象的那么标准（ECMAScript 规范定义的很少，很多是浏览器实现的）。

1.  **标准属性 (Standard)**：

    - **`name`**: 错误名称（类名），如 `"TypeError"`, `"SyntaxError"`。
    - **`message`**: 描述信息，如 `"undefined is not a function"`。
    - **`cause`** (ES2022 新增): **非常重要**。用于错误链式传递（Error Chaining），保留原始错误上下文。
      ```javascript
      try {
        doSomething()
      } catch (err) {
        throw new Error('高层业务失败', { cause: err }) // 核心用法
      }
      ```

2.  **非标准核心属性 (De facto Standard)**：

    - **`stack`**: 堆栈字符串。**这是最混乱的地方**。V8 (Chrome/Node) 和 SpiderMonkey (Firefox) 的格式完全不同。
      - _V8_: `Error: msg \n at func (file:row:col)`
      - _Firefox_: `func@file:row:col`

3.  **特定环境属性**：
    - `lineNumber`, `columnNumber`, `fileName` (Firefox 独有)。
    - `code` (Node.js 系统错误特有，如 `ENOENT`, `ECONNREFUSED`，非常利于程序判断)。

### 二、 分类学：Error 的物种多样性

要处理错误，首先要识别错误。Node.js 社区有一个经典的二分法（Joyent 提出）：

#### 1. 程序员错误 (Programmer Errors) —— bug，需要修代码

这是你写出了有问题的代码。

- **Built-in 7 大金刚**：
  1.  **`Error`**: 基类。
  2.  **`SyntaxError`**: 解析时错误（如正则写错、少括号）。**特点：无法在当前 `try-catch` 块中捕获（除非是 eval/new Function）**。
  3.  **`ReferenceError`**: 引用不存在的变量。
  4.  **`TypeError`**: 类型不对（如 `null.f()`）。
  5.  **`RangeError`**: 递归爆栈，数组长度为负。
  6.  **`URIError`**: `decodeURIComponent('%')` 失败。
  7.  **`EvalError`**: 几乎不用。
- **策略**：这些错误通常意味着程序逻辑漏洞，最佳处理方式通常是 **Crash (在服务端) 或 报警 (在前端)**，而不是试图“自动恢复”。

#### 2. 操作型错误 (Operational Errors) —— 并非 bug，需要处理

这是系统运行中的正常异常情况（网络断了、文件找不到、用户输入不对）。

- 通常不仅仅是 `throw new Error`，而是包含错误码。
- **策略**：这些是必须 log 并在 UI 层面提示用户的，**必须 catch**。

---

### 三、 生命周期：从诞生到消亡

#### 1. 生产 (Throwing)

- **黄金法则**：永远只 `throw new Error(...)`，不要 `throw "string"` 或 `throw null`。
  - 原因：只有 `Error` 对象会自动收集堆栈信息（`stack trace`）。抛字符串会导致堆栈丢失，调试极其痛苦。
- **自定义错误**：在业务复杂时，继承 Error。
  ```javascript
  class DatabaseError extends Error {
    constructor(msg) {
      super(msg)
      this.name = 'DatabaseError'
    }
  }
  ```

#### 2. 传播 (Propagating)

- **同步代码**：沿着调用栈向上冒泡，直到被 `catch`。
- **异步代码**：这是 JS 最棘手的地方。
  - **Promise / Async-Await**：如果没有 `.catch()`，会触发 `unhandledrejection` 事件。在 Node.js 中，未来版本可能会导致进程退出。
  - **EventEmitter**：如果 `error` 用于没有监听器，会抛出异常导致 Crash。

#### 3. 消费 (Catching & Handling)

- **不要吞没错误**：

  ```javascript
  // ❌ 极差实践
  try { ... } catch (e) { /* 空 */ }

  // ✅ 推荐实践
  try { ... } catch (e) { logger.error(e); }
  ```

- **全局兜底**：
  - 浏览器：`window.addEventListener('error', fn)` (捕获同步+DOM) + `window.addEventListener('unhandledrejection', fn)` (捕获 Promise)。
  - Node.js: `process.on('uncaughtException')` + `process.on('unhandledRejection')`。

---

### 四、 工程化实践：如何驯服 Error

在开发一个类似 CodeSandbox 或生产级应用时，你需要引入工具链。

#### 1. 标准化 (Normalization)

因为 `stack` 格式不一致，不要尝试自己写正则解析。

- **工具**：`error-stack-parser` (解析堆栈为对象数组), `serialize-error` (解决 Error 对象无法 JSON.stringify 的问题)。

#### 2. 定位源码 (Source Mapping)

打包后的代码（Webpack/Vite）报错行号是乱的。

- **原理**：利用 `.map` 文件。
- **工具**：`mozilla/source-map` 库。通过 `consumer.originalPositionFor({ line, column })` 还原真实报错位置。

#### 3. 监控与指纹 (Fingerprinting)

如果你用 Sentry 等监控系统，如何判断两个错误是“同一个 Bug”？

- **Fingerprint**: 通常不只看 `message`（因为 message 可能包含动态 ID），而是看 **Stack Trace 的哈希值**。如果堆栈结构一样，就是一个问题。

### 五、 总结图谱

如果要用一句话概括如何把握：

> **区分“代码写错了”和“运行时异常”，熟练使用 `cause` 做错误包装，利用 `error-stack-parser` 做堆栈标准化，最后通过全局 `unhandledrejection` 做兜底。**

你可以使用下面的代码片段作为你“错误处理系统”的基石：

```javascript
// 通用的错误增强函数
function normalizeError(err) {
  // 1. 确保是 Error 对象
  if (!(err instanceof Error)) {
    err = new Error(String(err))
  }

  // 2. 解析堆栈 (伪代码，建议用库)
  // const frames = ErrorStackParser.parse(err);

  return {
    name: err.name,
    message: err.message,
    stack: err.stack,
    // 3. 提取业务需要的错误码 (如果是 Node.js 系统错误)
    code: err.code || 'UNKNOWN',
    // 4. 递归获取原因
    cause: err.cause ? normalizeError(err.cause) : null
  }
}
```
