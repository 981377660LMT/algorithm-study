## Memcached

### 核心观点

Facebook 的 Memcached 架构是一个典型的、为应对海量读请求而演化出的工程实践范例。其核心思想是，在传统的数据库（MySQL）前端部署一个庞大的、分布式的**旁路缓存（Lookaside Cache）**层，将绝大多数读请求挡在缓存层，从而保护后端脆弱的数据库。这种架构的哲学是**性能优先，一致性其次**：它首先通过缓存和复制来获得极致的吞吐能力和可用性，然后针对由此引发的各种一致性问题（如数据陈旧、更新竞争）和性能瓶颈（如惊群、冷启动）设计一系列“补丁”式的解决方案（如租约、失效策略）。这套系统并非一个理论上完美的“一体化设计”，而是一个在实践中不断迭代、充满权衡的、极其成功的工程产物。

---

### 逻辑梳理

#### 1. 架构演进与核心模式

Facebook 的架构遵循了大型网站的典型演进路径，最终形成“客户端 -> 缓存 -> 数据库”的模式。

- **基本读写模式 (Lookaside Caching):**

  1.  **读 (Read):** 应用程序（Web 前端）先向 Memcached 请求数据。
      - **命中 (Hit):** 直接返回数据。
      - **未命中 (Miss):** 从后端 MySQL 数据库读取数据，然后将数据**写回 (Set)** 到 Memcached 中，以便下次读取。
  2.  **写 (Write):** 应用程序先更新 MySQL 数据库。
      - 更新成功后，向 Memcached 发送一个**删除 (Delete)** 命令，使缓存中对应的旧数据**失效 (Invalidate)**。

- **为何是“删除”而非“更新”缓存？**
  - **避免竞争条件：** 如果两个客户端并发地更新同一个数据，采用“更新缓存”策略很容易导致时序错乱，最终在缓存中留下一个旧版本的数据（例如，C1 更新 DB -> C2 更新 DB -> C2 更新 Cache -> C1 更新 Cache，最终 Cache 中是 C1 的旧值）。而“删除”策略虽然可能导致一次额外的缓存未命中，但能保证下次读取时一定能从数据库获取最新值，从根本上避免了数据被永久污染。

#### 2. 性能与可用性挑战及其解决方案

当系统规模扩大后，简单的缓存模式会遇到一系列问题。

- **问题一：惊群效应 (Thundering Herd)**

  - **场景：** 一个“热点”数据被更新并从缓存中删除。瞬间，成百上千个请求同时穿透缓存，涌向数据库请求同一个数据，导致数据库过载。
  - **解决方案：租约 (Lease)**
    1.  当一个热点数据未命中时，Memcached 不会立即让所有请求都去访问数据库。它会向**第一个**请求者颁发一个有时效的“租约”（一个唯一的 token）。
    2.  其他后续的请求者会被告知“请稍后重试”。
    3.  只有持有租约的请求者才有资格去数据库取回数据，并用该租约将新数据写回缓存。
    4.  **效果：** 将“多对一”（多个客户端到单个数据库）的请求压力，变成了“一对一”，有效保护了数据库。

- **问题二：跨数据中心复制与延迟**

  - **场景：** Facebook 在东西海岸有多个数据中心（Region），每个数据中心都有完整的数据库和缓存副本，以降低用户访问延迟。写操作发生在主数据中心，然后异步复制到其他数据中心。
  - **挑战：** 如何处理跨区域的缓存一致性？
  - **解决方案：数据库驱动的失效**
    1.  写操作在主数据中心的数据库执行后，会触发对**本地缓存**的删除。
    2.  该写操作的日志被异步复制到从数据中心的数据库。
    3.  从数据中心的数据库应用该日志后，同样会触发一个删除操作，去失效其**本地缓存**中的数据。
    4.  **效果：** 保证了最终所有区域的缓存都会被失效，尽管存在秒级的延迟。

- **问题三：缓存节点故障**
  - **场景：** 一台 Memcached 服务器宕机，原本由它处理的所有读请求都会穿透到数据库，可能瞬间压垮数据库。
  - **解决方案：Gutter 服务器池**
    1.  预留一小部分空闲的服务器作为“Gutter 池”。
    2.  当客户端访问一台 Memcached 服务器超时失败后，它不会立即访问数据库，而是将请求重定向到 Gutter 服务器。
    3.  Gutter 服务器作为一个临时的、小规模的缓存池，接管了失效服务器的工作，吸收了大部分冲击，直到故障服务器被替换。

#### 3. 核心一致性挑战及其解决方案

旁路缓存和并发操作天然会导致数据不一致，Facebook 的核心任务是防止**永久性**的数据不一致。

- **问题：读/写竞争导致缓存数据永久陈旧 (Read/Write Race)**
  - **场景：**
    1.  客户端 C1 读 Key A，缓存未命中。
    2.  C1 从数据库读到旧值 V1。
    3.  与此同时，客户端 C2 更新了 Key A 的值为 V2，并删除了缓存。
    4.  C1 将它之前读到的旧值 V1 写回了缓存。
  - **结果：** 缓存中永久地存储了错误的数据 V1，并且后续没有任何机制可以自动修复它。
- **解决方案：扩展租约机制**
  1.  当 C1 读未命中时，Memcached 不仅返回“未命中”，还同时授予 C1 一个**租约 token**。
  2.  当 C2 的写操作导致缓存被删除时，Memcached 会检查与该 Key 关联的租约，并将其**作废**。
  3.  当 C1 带着它的（已被作废的）租约 token 来写回数据 V1 时，Memcached 会拒绝这次写入，因为它持有的租约已经无效。
  - **效果：** 通过在写回缓存时验证租约的有效性，成功阻止了因竞争而导致的脏数据写入，保证了缓存不会被永久污染。
