## go

### 核心观点

这部分讲座从理论转向实践，提供了一系列在 Go 中编写并发程序的、可直接用于 Raft 实验的“生存法则”和设计模式。其核心思想是，**编写正确、易于推理的并发代码，远比追求极致的性能优化更重要**。为此，讲座强调了几个关键原则：

1.  **模式优于技巧：** 遵循既定的、经过验证的并发模式（如循环中传递变量、使用 `defer` 释放锁、条件变量的标准用法），而不是试图“聪明地”绕过它们。
2.  **锁保护的是“不变量”，而非“数据”：** 加锁的真正目的是保护一个逻辑操作的原子性，确保在操作期间，数据可能暂时违反的“不变量”（如银行账户总额不变）不会被外部观察到。
3.  **避免持有锁进行阻塞操作：** 绝不能在持有锁的同时发起 RPC 调用或执行其他可能长时间阻塞的操作，因为这极易导致整个系统的死锁。
4.  **警惕“陈旧状态”：** 在释放锁并执行耗时操作（如 RPC）后，必须重新检查并验证系统的状态（如任期号、角色），因为在你释放锁的这段时间里，状态可能已经被其他并发的 Goroutine 改变了。

---

### 逻辑梳理

#### 1. 核心理念：为正确性而非性能编写并发代码

- **目标：** 在 Raft 实验中，并发的主要目的是为了清晰地表达并行逻辑（如同时向所有 Follower 发送心跳），而不是为了榨干 CPU 的多核性能。
- **推论：** 应当优先使用简单、易于理解的**粗粒度锁（“大锁”）**来保护大块的临界区，避免使用复杂的细粒度锁。代码的**可读性和可维护性**是第一位的。

#### 2. 常见并发模式与陷阱

讲座通过一系列具体示例，展示了“应该做什么”和“不应该做什么”。

- **陷阱一：循环变量捕获 (Loop Variable Capture)**

  - **问题：** 在 `for` 循环中直接启动的 Goroutine，如果其闭包函数引用了循环变量 `i`，它捕获的是 `i` 的内存地址。当 Goroutine 真正执行时，循环早已结束，所有 Goroutine 看到的都是 `i` 的最终值。
  - **正确模式：** 必须将循环变量作为参数传递给 Goroutine 的闭包函数 `go func(i int) { ... }(i)`，从而为每个 Goroutine 创建一个值的副本。

- **陷阱二：忙等待 (Busy Waiting)**
  - **问题：** 在一个循环中反复加锁、检查条件、解锁，会浪费大量 CPU 资源，甚至可能拖慢整个程序的进度。
  - **不完美的修复：** 在循环中加入 `time.Sleep()`。这能缓解 CPU 消耗，但引入了“魔法数字”，并且响应不及时。
  - **正确模式：使用条件变量 (Condition Variable)**
    - **场景：** 一个线程（如 Raft 主线程）需要等待某个由其他并发线程（如 RPC 回复处理线程）改变的条件成立（如“已收到多数票”）。
    - **用法：**
      - **等待方：** `mu.Lock()`, `for !condition { cv.Wait() }`, ... , `mu.Unlock()`。`cv.Wait()` 会原子性地释放锁并挂起线程。
      - **通知方：** `mu.Lock()`, ...修改共享数据..., `cv.Broadcast()`, `mu.Unlock()`。`cv.Broadcast()` 会唤醒所有等待的线程，让它们重新检查条件。
    - **原则：** 永远使用 `Broadcast()` 而非 `Signal()`，并总是在 `while` 或 `for` 循环中调用 `Wait()`，以防止“虚假唤醒”。

#### 3. Raft 实现中的两个致命 Bug

这两个例子是上述原则在 Raft 场景下的具体体现。

- **Bug 1：持有锁发起 RPC 调用导致死锁**

  - **场景：** 两个 Candidate 同时发起选举，Candidate A 持有自己的锁，然后向 Candidate B 发起 `RequestVote` RPC。同时，Candidate B 也持有自己的锁，向 Candidate A 发起 RPC。
  - **死锁成因：** A 的 RPC handler 在 B 上等待获取 B 的锁，但 B 正持有该锁等待 A 的 RPC 响应。同时，B 的 RPC handler 在 A 上等待获取 A 的锁，但 A 也正持有该锁。形成经典的死锁环路。
  - **核心法则：** **绝不持有锁进行 RPC 调用。** 正确的做法是：加锁 -> 复制所需参数到局部变量 -> 解锁 -> 发起 RPC -> （需要时）重新加锁处理 RPC 结果。

- **Bug 2：因状态陈旧而错误地成为 Leader**
  - **场景：** Candidate A 在任期 T1 发起选举。在等待 RPC 回复期间，它收到了来自另一个 Candidate B 的、更高任期 T2 的选举请求。A 投票给 B，并根据 Raft 规则将自己的任期更新为 T2，角色变回 Follower。之后，A 之前在 T1 发出的 RPC 回复终于到达，并且票数足够。
  - **问题：** A 的代码在收到足够票数后，没有重新检查自己当前的状态，直接将自己设置为 Leader。但此时它的任期已经是 T2，并且角色是 Follower。这违反了 Raft 的规则，导致在同一个任期内出现了多个 Leader。
  - **核心法则：** **在耗时操作（如等待 RPC 回复）前后，必须重新检查状态。** 在收到 RPC 回复并准备更新状态时，必须在锁的保护下，再次确认当前任期号和角色是否与发起操作时一致。如果不一致，则应放弃此次操作。

#### 4. 调试技巧

- **`DPrintf`：** 使用课程提供的带开关的打印函数，可以方便地添加和移除调试信息。
- **`Ctrl+\`：** 在程序卡住（疑似死锁）时，按 `Ctrl+\` 可以强制 Go 程序打印出所有 Goroutine 的当前调用栈，这是定位死锁位置的“杀手锏”。
- **`-race` 标志：** 运行测试时务必带上 `-race` 标志（`go test -race`）。它能动态检测出绝大多数数据竞争问题，是保证并发代码正确性的必备工具。
