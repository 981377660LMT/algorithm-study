好的，我们来详细讲解 MIT 6.824 的第十二讲：**L12 Distributed Transactions**。

这一讲是分布式系统中的一个核心且经典的话题。在了解了如何复制数据（Raft）和如何保证缓存一致性（Frangipani）之后，我们面临一个更复杂的问题：如何让一个跨越**多个独立数据库或服务**的操作，要么全部成功，要么全部失败？这就是分布式事务要解决的问题。

---

### 1. 什么是分布式事务？问题在哪里？

**单机事务**:
在一个数据库中，我们可以使用 `BEGIN TRANSACTION; ... COMMIT;` 来包裹一系列操作。数据库通过 ACID 属性保证这些操作的原子性（要么全做，要么全不做）和隔离性（事务之间互不干扰）。

**分布式事务**:
现在想象一个场景：一个银行转账操作，需要从用户 A 在**数据库 X** 的账户中扣款，然后给用户 B 在**数据库 Y** 的账户中加款。数据库 X 和 Y 是两台独立的服务器。

```
BEGIN_DISTRIBUTED_TRANSACTION;
  // 操作1: 在数据库 X 上
  UPDATE accounts SET balance = balance - 100 WHERE user = 'A';
  // 操作2: 在数据库 Y 上
  UPDATE accounts SET balance = balance + 100 WHERE user = 'B';
COMMIT_DISTRIBUTED_TRANSACTION;
```

**问题在哪里？**
如果在操作 1 成功提交后，但在操作 2 执行前，数据库 Y 宕机了，或者网络断了，会发生什么？

- 用户 A 的钱被扣了。
- 用户 B 的钱没有到账。
- 系统状态不一致，钱“消失”了！

分布式事务的目标就是确保这种跨多个节点的事务也具有 **ACID** 属性，尤其是 **A (Atomicity, 原子性)**。

---

### 2. 目标：分布式环境下的 ACID

- **原子性 (Atomicity)**: 这是分布式事务的核心挑战。必须保证一个事务中的所有操作，在所有参与的节点上，要么**全部提交 (commit)**，要么**全部中止 (abort)**。绝不允许部分提交。
- **一致性 (Consistency)**: 保证事务将系统从一个有效的状态转移到另一个有效的状态。这通常由应用逻辑和数据库的 A、I、D 属性共同保证。
- **隔离性 (Isolation)**: 保证并发执行的多个事务互不干扰，其最终结果等同于这些事务以某种顺序串行执行的结果。最高隔离级别是**可序列化 (Serializable)**。
- **持久性 (Durability)**: 一旦事务被提交，其结果就是永久性的，即使系统崩溃也不会丢失。这在每个参与节点上由其自身的日志和恢复机制来保证。

为了实现原子性和隔离性，业界发展出了两个经典的协议：**两阶段提交 (Two-Phase Commit, 2PC)** 和 **两阶段锁定 (Two-Phase Locking, 2PL)**。

---

### 3. 两阶段提交 (Two-Phase Commit, 2PC)：实现原子性

2PC 是解决分布式原子性问题的标准算法。它引入了两个角色：

- **协调者 (Coordinator)**: 驱动整个事务的节点，通常是发起事务的应用服务器。
- **参与者 (Participants)**: 事务涉及到的各个数据库节点（如上面的数据库 X 和 Y）。

顾名思义，协议分为两个阶段：

#### 阶段一：准备/投票阶段 (Prepare/Voting Phase)

1.  **协调者**向所有**参与者**发送一个 `PREPARE` 消息，询问：“你们是否准备好提交这个事务？”
2.  **参与者**收到 `PREPARE` 消息后，会执行以下操作：
    a. 执行事务所需要的所有操作（例如，在内存中扣款），但**不真正提交**。
    b. 将所有变更和事务状态（例如，`PREPARED`）写入到自己**持久化的预写日志 (WAL)** 中。这是至关重要的一步，因为它做出了一个承诺。
    c. 如果一切顺利，参与者向协调者回复 `VOTE-COMMIT`。如果遇到任何问题（如违反约束、磁盘空间不足），则回复 `VOTE-ABORT`。

**关键点**: 一旦参与者投票 `VOTE-COMMIT`，它就进入了“准备”状态，并失去了单方面中止事务的权利。它必须等待协调者的最终决定，哪怕协调者崩溃了也要等。

#### 阶段二：提交/执行阶段 (Commit/Execution Phase)

协调者收集所有参与者的投票：

- **情况一：所有参与者都回复 `VOTE-COMMIT`**

  1.  协调者做出**提交 (Commit)** 的最终决定。
  2.  协调者将这个决定写入自己的持久化日志。
  3.  协调者向所有参与者发送 `COMMIT` 消息。
  4.  参与者收到 `COMMIT` 消息后，正式提交事务（应用内存中的变更），并释放事务所持有的资源（如锁）。
  5.  参与者向协调者回复一个 `ACK` 消息。
  6.  协调者收到所有 `ACK` 后，事务完成。

- **情况二：任何一个参与者回复 `VOTE-ABORT`，或在超时内未响应**
  1.  协调者做出**中止 (Abort)** 的最终决定。
  2.  协调者将这个决定写入自己的持久化日志。
  3.  协调者向所有**参与者**（包括那些投了 `VOTE-COMMIT` 的）发送 `ABORT` 消息。
  4.  参与者收到 `ABORT` 消息后，回滚所有变更，并释放资源。
  5.  事务完成。

#### 2PC 的问题

2PC 虽然能保证原子性，但它有几个严重的缺点：

1.  **同步阻塞 (Synchronous Blocking)**: 在阶段一和阶段二之间，所有参与者都必须锁定资源并等待协调者的最终命令。如果协调者处理缓慢，整个系统的吞吐量会急剧下降。
2.  **协调者单点故障**:
    - 如果协调者在**阶段二**发送 `COMMIT` 消息之前崩溃，所有已经投票 `VOTE-COMMIT` 的参与者都会被**永久阻塞**，它们不知道该提交还是中止，只能永远等待协调者恢复。这是一个灾难性的问题。
3.  **性能开销**: 一次事务需要多轮网络通信，延迟很高。

---

### 4. 两阶段锁定 (Two-Phase Locking, 2PL)：实现隔离性

**注意：2PL 和 2PC 是两个完全不同的东西！**

- **2PC** 是一个**原子提交协议**。
- **2PL** 是一个**并发控制协议**，用于保证可序列化隔离级别。

2PL 的规则很简单：

1.  **增长阶段 (Growing Phase)**: 事务可以根据需要获取锁（读锁、写锁），但不能释放任何锁。
2.  **缩减阶段 (Shrinking Phase)**: 一旦事务释放了第一个锁，它就进入缩减阶段。在此阶段，它只能释放锁，不能再获取任何新的锁。

在实际的数据库（包括分布式数据库）中，通常使用一种更严格的变体——**严格两阶段锁定 (Strict 2PL)**：

> 事务持有的所有锁，必须在**事务提交或中止之后**才能释放。

**如何工作**:

- 当事务需要读写一个数据项时，它必须先获取对应的锁。
- 如果锁已经被其他事务持有，该事务必须等待。
- 这确保了在事务的整个生命周期内，它操作的数据不会被其他事务所修改，从而保证了隔离性。
- **死锁 (Deadlock)**: 2PL 很容易产生死锁（事务 A 等待 B 的锁，B 等待 A 的锁）。系统需要一个死锁检测机制（例如，构建等待图）来发现并打破死锁（例如，中止其中一个事务）。

### 总结

L12 讲解了实现分布式 ACID 事务的经典理论基础：

- 使用 **2PC** 来保证跨多个节点的**原子性**。
- 使用 **2PL** 来保证事务之间的**隔离性**。

一个典型的分布式数据库系统会**同时使用**这两个协议。当一个分布式事务执行时，它会在各个参与者节点上使用 2PL 来获取所需数据的锁。当应用请求提交时，系统会启动 2PC 协议来协调所有参与者，以确保原子提交。

这一讲揭示了构建强一致性分布式数据库的巨大复杂性和性能权衡。它也为下一讲 **Spanner** 奠定了基础——Spanner 正是建立在这些经典理论之上，并利用创新的 TrueTime 技术来优化和解决 2PC 的部分问题。
