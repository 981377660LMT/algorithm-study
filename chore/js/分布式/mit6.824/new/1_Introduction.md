好的，我们来详细讲解 MIT 6.824 的第一讲：**L1 Introduction**。

这一讲的目标是为整个课程奠定基础，它主要回答三个问题：

1.  什么是分布式系统？
2.  为什么我们需要分布式系统？（动机）
3.  构建分布式系统为什么这么难？（挑战）

---

### 1. 什么是分布式系统？

**定义**:
一个分布式系统是多个独立的计算单元（计算机、服务器），通过网络互联，共同协作完成一个任务，并且对外部用户来说，它看起来像一个单一的、统一的系统。

**核心特征**:

- **多台计算机**: 系统由不止一台机器构成。
- **通过网络通信**: 它们之间没有共享内存或共享时钟，所有协调和数据交换都必须通过网络发送消息来完成。
- **共同的目标**: 它们协同工作，以提供一个比单机更强大的服务。

**课程关注点**:
6.824 课程主要关注**基础设施（Infrastructure）**层面的分布式系统，例如：

- 分布式存储 (如 GFS, HDFS)
- 分布式计算 (如 MapReduce, Spark)
- 分布式协调 (如 Zookeeper)
- 分布式数据库 (如 Spanner, Aurora)

而不是直接关注构建在这些基础设施之上的应用（如网页搜索、社交网络）。

---

### 2. 为什么需要分布式系统？（动机）

构建和维护分布式系统远比单机应用复杂，我们之所以选择它，是因为它能带来单机无法企及的好处：

- **可扩展性 (Scalability)**:

  - 当用户量或数据量增长时，单机的性能（CPU、内存、磁盘 I/O）会达到瓶颈。
  - 分布式系统允许我们通过简单地增加机器数量（水平扩展/Scale Out）来线性地提升系统的总处理能力，而不是昂贵地升级单机硬件（垂直扩展/Scale Up）。

- **可用性 (Availability) & 容错性 (Fault Tolerance)**:

  - 单机系统是一个**单点故障 (Single Point of Failure)**。如果这台机器宕机、硬盘损坏或断电，整个服务就不可用了。
  - 在分布式系统中，可以通过数据复制（Replication）和任务冗余来容忍部分节点的失败。例如，如果一个 Web 服务器集群中的某台机器宕机，负载均衡器可以将其余流量导向其他健康的机器，服务得以继续。

- **性能 (Performance)**:

  - 通过并行计算，可以将一个大任务分解成许多小任务，交由多台机器同时处理，从而大大缩短总处理时间。MapReduce 就是典型的例子。

- **地理分布 (Geography)**:
  - 为了降低全球用户的访问延迟，可以将数据和服务器部署在靠近用户的不同地理位置的数据中心。这天然就形成了一个分布式系统。

---

### 3. 构建分布式系统为什么这么难？（核心挑战）

这是第一讲最核心的部分。分布式系统的复杂性根源于一个关键特性：**局部故障 (Partial Failure)**。

在单机系统中，故障通常是**全局的**：要么整个程序工作，要么整个程序崩溃。但在分布式系统中，情况要复杂得多：

- **网络是不可靠的**:

  - **消息丢失**: 发送的消息可能永远不会到达目的地。
  - **消息延迟**: 消息可能花费任意长的时间才到达。
  - **消息乱序**: 先发送的消息可能比后发送的消息晚到。
  - **网络分区 (Network Partition)**: 网络可能断裂，将节点分割成多个无法相互通信的孤岛。

- **节点故障**:

  - 服务器可能会崩溃、重启、或者由于负载过高而暂时无响应（表现得像崩溃一样）。
  - 你很难区分一个节点是“真的宕机了”还是“只是响应很慢”。这个问题被称为**故障检测 (Failure Detection)** 的不确定性。

- **并发 (Concurrency)**:

  - 成千上万的客户端和服务器节点在同时进行操作。如何协调它们之间的行为，以避免数据损坏或状态不一致（例如，两个用户同时预订最后一张机票）？这比单机多线程并发要复杂得多，因为没有共享内存和锁可以用。

- **性能**:
  - **网络延迟是瓶颈**: 一次网络来回通信（RTT）通常在毫秒（ms）级别，而一次内存访问在纳秒（ns）级别，相差百万倍。糟糕的设计会导致系统大部分时间都在等待网络通信。
  - **权衡**: 很多时候，你必须在各种目标之间做出艰难的权衡。最著名的就是 **CAP 定理**（在后续课程中会详细讲），它指出在网络分区发生时，你无法同时保证**一致性 (Consistency)** 和**可用性 (Availability)**。

#### 一个简单的例子来说明挑战

假设我们要实现一个简单的、容错的键值存储服务，由一个主节点（Primary）和一个备份节点（Backup）组成。

**流程**:

1.  客户端向 Primary 发送 `Put("k1", "v1")` 请求。
2.  Primary 更新自己的状态。
3.  Primary 将更新转发给 Backup。
4.  Backup 更新自己的状态。
5.  Primary 响应客户端，操作完成。

**问题来了（局部故障）**:

- **场景 1**: Primary 在第 2 步之后、第 3 步之前崩溃了。
  - 结果：Primary 有新数据，Backup 是旧数据。如果 Backup 接管成为新的 Primary，数据就丢失了。
- **场景 2**: Primary 在第 3 步之后、第 5 步之前崩溃了。
  - 结果：Backup 有了新数据，但客户端没有收到确认，它会认为操作失败了。客户端可能会重试，导致 Backup 重复执行操作，可能产生非预期的结果。
- **场景 3**: Primary 和 Backup 之间的网络暂时中断。
  - 结果：Primary 无法联系到 Backup，它该怎么办？是继续服务（可能导致数据不一致）还是停止服务（降低了可用性）？

仅仅两个节点就如此复杂，一个成百上千个节点的真实系统，其可能遇到的故障组合是爆炸性的。

### 总结

L1 Introduction 通过定义、动机和挑战，为学习者描绘了分布式系统的全貌。它强调了这门课的重点不是教你使用某个现成的框架，而是通过亲手实现一个复杂的分布式系统（课程实验），让你深刻理解并掌握应对**局部故障**和**并发**这些核心挑战的原则与技术。
