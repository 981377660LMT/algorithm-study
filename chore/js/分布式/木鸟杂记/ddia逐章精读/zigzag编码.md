# Zigzag 编码详解

Zigzag 编码是一种用于有效编码有符号整数的技术，特别适用于二进制序列化协议（如 Protocol Buffers、Thrift 的 CompactProtocol 和 Avro）。它的主要目的是将**有符号整数转换为无符号整数，以便在使用变长编码（如 Varint）时实现更高效的压缩。**

## Zigzag 编码原理

### 基本思想

Zigzag 编码将有符号整数映射到无符号整数，使小的正数和负数都映射为小的无符号值。这种方式下，**无论正负，较小的数字都使用较少的字节表示。**

### 编码公式

对于 n 位整数：

- 32位整数: `(n << 1) ^ (n >> 31)`
- 64位整数: `(n << 1) ^ (n >> 63)`

简单来说，它将最高位（符号位）的信息分散到整个编码中，使小的负数不再需要所有位都为1。

### 解码公式

- `(n >>> 1) ^ -(n & 1)`
  - `>>>` 表示无符号右移
  - `&` 是位与操作
  - `-` 是取负

## 工作示例

以下是一些数字的 Zigzag 编码示例（32位整数）：

| 原始值 (十进制) | 二进制表示 | Zigzag 编码值 | 编码后二进制 |
| --------------- | ---------- | ------------- | ------------ |
| 0               | 00000000   | 0             | 00000000     |
| -1              | 11111111   | 1             | 00000001     |
| 1               | 00000001   | 2             | 00000010     |
| -2              | 11111110   | 3             | 00000011     |
| 2               | 00000010   | 4             | 00000100     |
| -3              | 11111101   | 5             | 00000101     |

## Zigzag 编码的优势

1. **变长编码效率**：

   - 与普通有符号整数相比，小的负数在 Zigzag 编码后可以用更少的字节表示
   - 例如，-1 在标准二进制中是全 1，但 Zigzag 编码后变成 1，只需要 1 个字节

2. **协议优化**：

   - 在 ProtoBuf、Thrift 等协议中，当与 Varint 结合使用时，可以显著减少负数的编码大小
   - 特别适合数字分布在零附近（正负都有）的场景

3. **实际应用场合**：
   - 时间戳差值
   - 位置坐标差值
   - 温度变化
   - 任何可能有正负值的增量数据

## 代码示例

以下是 Zigzag 编码的简单实现：

```java
// 32位整数的 Zigzag 编码
public static int encodeZigZag32(int n) {
    return (n << 1) ^ (n >> 31);
}

// 32位整数的 Zigzag 解码
public static int decodeZigZag32(int n) {
    return (n >>> 1) ^ -(n & 1);
}

// 64位整数的 Zigzag 编码
public static long encodeZigZag64(long n) {
    return (n << 1) ^ (n >> 63);
}

// 64位整数的 Zigzag 解码
public static long decodeZigZag64(long n) {
    return (n >>> 1) ^ -(n & 1);
}
```

Zigzag 编码是二进制序列化协议中的重要优化技术，特别适用于需要紧凑表示有符号整数的场景。
