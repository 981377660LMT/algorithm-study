# Thrift BinaryProtocol、Thrift CompactProtocol 和 Protocol Buffers 编码详解

## 1. Thrift BinaryProtocol

Thrift BinaryProtocol 是 Apache Thrift 框架中的一种基本二进制编码方案，直观且实现简单。

### 编码结构：

对于上例中的 JSON 数据：

```json
{
  "userName": "Martin",
  "favoriteNumber": 1337,
  "interests": ["daydreaming", "hacking"]
}
```

在 Thrift BinaryProtocol 中的编码流程：

1. **字段编码格式**：`<类型标识符(1字节)> <字段ID(2字节)> <值>`

2. **类型标识符**：

   - STRING: 0x0B
   - I64 (64位整数): 0x0A
   - LIST: 0x0F
   - STOP (结构结束): 0x00

3. **实际编码示例**：

   ```
   // 字符串字段 "userName": "Martin"
   0x0B 0x00 0x01 0x00 0x00 0x00 0x06 'M' 'a' 'r' 't' 'i' 'n'
   │     │         │              │     └───── 字符串内容 ─────┘
   │     │         │              └─ 字符串长度(6)
   │     │         └─ 字段名长度字节数(未使用)
   │     └─ 字段ID(1)
   └─ 类型标识(STRING)

   // 整数字段 "favoriteNumber": 1337
   0x0A 0x00 0x02 0x00 0x00 0x00 0x00 0x00 0x00 0x05 0x39
   │     │         └──────────── 64位整数值(1337) ────────────┘
   │     └─ 字段ID(2)
   └─ 类型标识(I64)

   // 列表字段 "interests": ["daydreaming", "hacking"]
   0x0F 0x00 0x03 0x0B 0x00 0x00 0x00 0x02
   │     │         │           └─ 列表元素数(2)
   │     │         └─ 列表元素类型(STRING)
   │     └─ 字段ID(3)
   └─ 类型标识(LIST)

   // 第一个列表元素 "daydreaming"
   0x00 0x00 0x00 0x0B 'd' 'a' 'y' 'd' 'r' 'e' 'a' 'm' 'i' 'n' 'g'
        └─ 字符串长度(11) ─┘ └──────── 字符串内容 ─────────────┘

   // 第二个列表元素 "hacking"
   0x00 0x00 0x00 0x07 'h' 'a' 'c' 'k' 'i' 'n' 'g'
        └─ 字符串长度(7) ──┘ └─── 字符串内容 ────┘

   // 结构结束标记
   0x00
   ```

### 特点：

- 简单直观，编解码实现简单
- 固定长度字段开销较大
- 对小整数编码效率低，总是使用完整的字节数
- 总体大小大约为83字节（相比JSON的77字节略大）

## 2. Thrift CompactProtocol

Thrift CompactProtocol 是 BinaryProtocol 的改进版，针对数据大小进行了优化。

### 主要改进：

1. **字段头部压缩**：

   - 将字段类型和字段ID合并到一个字节中
   - 前4位存储类型，后4位存储ID差值

2. **变长整数编码**：

   - 使用ZigZag编码处理有符号整数
   - 使用变长（Varint）编码表示整数值

3. **字符串长度压缩**：
   - 使用变长编码表示字符串长度

### 实际编码示例：

```
// "userName": "Martin" 字段
0x18 0x06 'M' 'a' 'r' 't' 'i' 'n'
│     │    └─────── 字符串内容 ────────┘
│     └─ 长度(变长编码的6)
└─ 合并的字段类型(STRING=8)和字段ID(1)

// "favoriteNumber": 1337 字段
0x26 0xA2 0x15
│     └──── 变长编码后的ZigZag值(1337) ─────┘
└─ 合并的字段类型(I64=6)和字段ID(2)

// "interests": ["daydreaming", "hacking"] 字段
0x38 0x02
│     └─ 列表长度(2)
└─ 合并的字段类型(LIST=8)和字段ID(3)

// 列表元素类型
0x18
└─ 元素类型(STRING=8)

// "daydreaming"
0x0B 'd' 'a' 'y' 'd' 'r' 'e' 'a' 'm' 'i' 'n' 'g'
└─ 变长编码长度(11) ─┘ └──── 字符串内容 ────────────┘

// "hacking"
0x07 'h' 'a' 'c' 'k' 'i' 'n' 'g'
└─ 变长编码长度(7) ─┘ └─── 字符串内容 ───┘

// 结构结束
0x00
```

### 特点：

- 比BinaryProtocol更紧凑，通常减少20-40%大小
- 变长编码对小整数尤其高效
- 编解码复杂度略高
- 上例大约为56字节（比JSON的77字节小约27%）

## 3. Protocol Buffers

Protocol Buffers (protobuf) 是Google开发的二进制序列化格式，专注于高效的编码和解码。

### 关键编码特性：

1. **标签-长度-值 (TLV) 格式**：

   - 字段键是字段号和类型的组合
   - 格式：`(field_number << 3) | wire_type`

2. **五种线路类型** (wire type)：

   - 0: Varint (变长整数)
   - 1: 64位定长
   - 2: 长度前缀
   - 5: 32位定长
   - (其他类型用于分组)

3. **变长编码**：
   - 使用Varint编码整数
   - 使用ZigZag编码处理有符号整数

### 实际编码示例：

```
// "userName": "Martin" (字段号1, 字符串类型)
0x0A 0x06 'M' 'a' 'r' 't' 'i' 'n'
│     │    └────── 字符串内容 ──────┘
│     └─ 字符串长度(6)
└─ 标签(字段号1 << 3 | 线路类型2 = 10)

// "favoriteNumber": 1337 (字段号2, int64类型)
0x10 0xB9 0x0A
│     └── 变长编码值(1337) ──┘
└─ 标签(字段号2 << 3 | 线路类型0 = 16)

// "interests": ["daydreaming", "hacking"] (字段号3, 重复字符串)
// 第一个元素
0x1A 0x0B 'd' 'a' 'y' 'd' 'r' 'e' 'a' 'm' 'i' 'n' 'g'
│     │    └─────────── 字符串内容 ────────────┘
│     └─ 长度(11)
└─ 标签(字段号3 << 3 | 线路类型2 = 26)

// 第二个元素
0x1A 0x07 'h' 'a' 'c' 'k' 'i' 'n' 'g'
│     │    └────── 字符串内容 ───────┘
│     └─ 长度(7)
└─ 标签(相同字段号和类型)
```

### 特点：

- 高效紧凑，专为网络传输设计
- 优化的变长整数编码
- 良好的前向/后向兼容性设计
- 对重复字段有专门优化
- 上例大约为51字节（比JSON的77字节小约34%）

## 比较与总结

| 特性       | Thrift Binary | Thrift Compact | Protocol Buffers     |
| ---------- | ------------- | -------------- | -------------------- |
| 估计大小   | ~83字节       | ~56字节        | ~51字节              |
| 编码复杂度 | 低            | 中等           | 中等                 |
| 整数编码   | 固定长度      | 变长+ZigZag    | 变长+ZigZag          |
| 字段标识   | 显式类型+ID   | 合并类型和ID   | 合并字段号和线路类型 |
| 兼容性     | 一般          | 好             | 很好                 |
| 语言支持   | 广泛          | 广泛           | 非常广泛             |
| 最适用场景 | 简单应用      | 资源受限环境   | 大规模分布式系统     |

这些二进制编码格式比文本格式（如JSON）更紧凑，特别适合网络传输和存储大量数据的场景，同时保持了良好的前向兼容性，允许架构随时间演变。### 特点：

- 高效紧凑，专为网络传输设计
- 优化的变长整数编码
- 良好的前向/后向兼容性设计
- 对重复字段有专门优化
- 上例大约为51字节（比JSON的77字节小约34%）

## 比较与总结

| 特性       | Thrift Binary | Thrift Compact | Protocol Buffers     |
| ---------- | ------------- | -------------- | -------------------- |
| 估计大小   | ~83字节       | ~56字节        | ~51字节              |
| 编码复杂度 | 低            | 中等           | 中等                 |
| 整数编码   | 固定长度      | 变长+ZigZag    | 变长+ZigZag          |
| 字段标识   | 显式类型+ID   | 合并类型和ID   | 合并字段号和线路类型 |
| 兼容性     | 一般          | 好             | 很好                 |
| 语言支持   | 广泛          | 广泛           | 非常广泛             |
| 最适用场景 | 简单应用      | 资源受限环境   | 大规模分布式系统     |

这些二进制编码格式比文本格式（如JSON）更紧凑，特别适合网络传输和存储大量数据的场景，同时保持了良好的前向兼容性，允许架构随时间演变。
