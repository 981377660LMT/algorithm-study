# 代码依赖判定

包之间的依赖，一般是通过 `dependencies` 字段来判断的。一般不用发布顺序判断。
依赖反转实现方法：构造函数/inject/DI 容器 => 详见 `获取依赖的方法` 笔记。

---

一个案例：
A 依赖 B，A 调用了 B 的某个方法。
A 某天需要增加校验逻辑，需要在 B 修改，那么就需要修改 B 的方法，可选。
一种思路是，B 提供一个钩子函数，让 A 传入校验逻辑，这样 B 就不需要修改。

---

这个案例是一个非常经典和重要的软件设计思想的体现，它展示了如何从**紧耦合**走向**松耦合**，并应用了**依赖反转原则**和**开闭原则**。

我们可以从以下几个角度来理解这个案例：

### 1. 问题分析：紧耦合与违反开闭原则

- **初始状态 (紧耦合)**：`A` 依赖 `B`。当 `A` 的需求（增加校验逻辑）发生变化时，却需要去修改 `B`。这说明 `A` 和 `B` 的耦合度太高了。`B` 被它本不应该关心的、属于 `A` 的业务逻辑“污染”了。
- **违反开闭原则 (Open/Closed Principle)**：该原则指出“软件实体（类、模块、函数等）应该对扩展开放，对修改关闭”。在这个案例中，为了“扩展”`A` 的功能，我们却要去“修改”`B` 的代码，这明显违反了开闭原则。如果将来 `C` 也依赖 `B`，并且有自己独特的校验逻辑，我们难道要再去修改 `B` 吗？这显然是不可持续的。

### 2. 解决方案分析：控制反转与依赖反转

你提到的“B 提供一个钩子函数，让 A 传入校验逻辑”正是解决这个问题的核心方法，它体现了**控制反转 (Inversion of Control, IoC)**。

- **控制权的转移**：

  - **之前**：`B` 控制着所有的执行流程，包括那个（可能存在的）写死在内部的校验逻辑。
  - **之后**：`B` 将“是否需要校验”以及“如何校验”这个**控制权**交还给了调用者 `A`。`B` 只负责在正确的时机调用这个钩子函数，执行 `A` 传入的逻辑。`B` 的角色从一个“万事通”变成了一个“流程执行者”。

- **依赖反转 (Dependency Inversion Principle, DIP)**：
  - **之前**：`B` 的方法内部隐式地依赖了一个**具体**的校验逻辑。
  - **之后**：`B` 不再依赖任何具体的校验逻辑。相反，它依赖于一个**抽象**——这个“钩子函数”的签名（例如，一个接受数据并返回布尔值的函数）。而**具体**的校验逻辑（由 `A` 提供）现在反过来依赖于这个抽象。依赖关系被“反转”了。

### 3. 代码示例

让我们用代码来更清晰地说明这个过程。

#### 方案一：修改 B (不推荐)

```typescript
// B.ts - 低层模块
class B {
  // 这个方法被 A 的特定需求污染了
  public doSomething(data: any, fromA: boolean = false) {
    // 如果是 A 调用的，就执行 A 的特殊校验
    if (fromA) {
      if (data.value < 0) {
        console.log("A's validation failed!")
        return
      }
    }
    console.log('B is doing something with data:', data)
  }
}

// A.ts - 高层模块
class A {
  private b = new B()

  public run() {
    const myData = { value: -10 }
    // 需要传递一个额外的标志位，B 的内部逻辑变得复杂
    this.b.doSomething(myData, true)
  }
}
```

这种方式非常糟糕，`B` 必须知道调用者的身份，代码会迅速变得混乱不堪。

#### 方案二：使用钩子函数 (推荐)

```typescript
// 定义钩子函数的类型（抽象）
type ValidatorHook = (data: any) => boolean

// B.ts - 低层模块
class B {
  // B 依赖于抽象 (ValidatorHook)，而不是具体实现
  public doSomething(data: any, validator?: ValidatorHook) {
    // B 控制流程：先校验，再执行
    // 如果传入了校验器并且校验失败，则提前返回
    if (validator && !validator(data)) {
      console.log('Validation failed, execution stopped by hook.')
      return
    }

    // B 只负责自己的核心逻辑
    console.log('B is doing something with data:', data)
  }
}

// A.ts - 高层模块
class A {
  private b = new B()

  // A 定义自己的具体校验逻辑
  private myValidator: ValidatorHook = data => {
    const isValid = data.value >= 0
    if (!isValid) {
      console.log("A's specific validation: value cannot be negative.")
    }
    return isValid
  }

  public run() {
    const myData1 = { value: 100 }
    const myData2 = { value: -10 }

    // A 将自己的校验逻辑“注入”到 B 中
    this.b.doSomething(myData1, this.myValidator) // 成功执行
    this.b.doSomething(myData2, this.myValidator) // 被钩子函数中止
  }
}

// 另一个调用者 C，它不需要校验
class C {
  private b = new B()
  public run() {
    const someData = { name: 'test' }
    // C 可以不提供钩子，B 依然能正常工作
    this.b.doSomething(someData)
  }
}
```

### 总结

这个案例的核心是**将变化的、属于调用者的逻辑，从稳定的、通用的模块中分离出去**。

- **“钩子函数”** 是实现这种分离的有效工具，是依赖注入的一种形式。
- 这样做使得 `B` 变得更加**通用、稳定和可复用**，因为它不再关心调用者的具体业务细节。
- `A` 也获得了更高的**灵活性和控制力**，因为它可以随时改变自己的校验逻辑而无需触碰 `B`。

这是一种非常强大且基础的设计模式，在框架设计、库开发和日常业务逻辑中都随处可见。
