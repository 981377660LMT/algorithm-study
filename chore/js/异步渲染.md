# 异步渲染

为什么 prosemirror/vue/react 多次修改状态，不会频繁触发视图更新

ProseMirror、Vue 和 React 之所以能避免因多次状态修改而导致频繁的视图更新，核心在于它们都实现了**批量更新（Batching）**和**异步渲染（Asynchronous Rendering）**机制。

以下是它们的具体做法以及设计此类系统时的思路：

### 1. 它们的具体做法

#### React (Fiber 架构 & 调度器)

React 不会在每次 `setState` 时立即更新 DOM。

- **批处理 (Batching):** 在 React 18 之前，只有在事件处理函数中的多次状态更新会被合并。在 React 18+ 中，自动批处理（Automatic Batching）覆盖了 Promise、setTimeout 等所有场景。React 会收集一段时间内的所有状态变更，合并成一次更新。
- **虚拟 DOM (Virtual DOM):** 即使触发了更新流程，React 首先在内存中构建新的虚拟 DOM 树，与旧树进行 Diff 算法比较。只有真正发生变化的部分才会生成 DOM 操作指令。
- **并发模式 (Concurrent Mode):** React 可以中断渲染任务。如果一次更新耗时过长，它会暂停工作，优先响应用户输入，然后再恢复渲染，避免阻塞主线程。

#### Vue (响应式系统 & 异步队列)

Vue 利用响应式系统（Dependency Tracking）精确知道哪些组件需要更新。

- **异步更新队列 (Async Update Queue):** 当响应式数据发生变化时，Vue 不会立即更新 DOM。它会开启一个队列，并缓冲在同一事件循环（Event Loop）中发生的所有数据变更。
- **去重 (Deduplication):** 如果同一个 watcher 被多次触发，只会被推入队列一次。
- **`nextTick`:** 在下一个“tick”（通常是微任务 Promise.resolve()）中，Vue 刷新队列并执行实际（去重后的）DOM 更新工作。

#### ProseMirror (事务 & 视图同步)

ProseMirror 是一个富文本编辑器框架，它处理的是文档状态（State）到编辑器视图（View）的映射。

- **事务 (Transactions):** ProseMirror 的状态更新是通过应用“事务”完成的。你可以连续应用多个步骤（Steps）到一个事务中，或者连续派发多个事务。
- **受控更新:** 通常 ProseMirror 的集成代码如下：
  ```javascript
  let state = EditorState.create({ schema })
  let view = new EditorView(document.body, {
    state,
    dispatchTransaction(transaction) {
      // 计算新状态
      let newState = view.state.apply(transaction)
      // 更新视图状态
      view.updateState(newState)
    }
  })
  ```
  虽然 `dispatchTransaction` 看起来是同步的，但 ProseMirror 的 `view.updateState` 内部极其高效。它会对比新旧文档结构（类似 Virtual DOM Diff，但针对文档树优化），只更新变动的 DOM 节点。
- **合并操作:** 插件或命令通常会在一个 Transaction 中组合多个操作，而不是分发多次 Transaction。

---

### 2. 自己设计代码时的思路

如果你要设计一个高性能的状态管理或视图渲染系统，应遵循以下原则：

#### A. 读写分离与缓冲 (Buffering)

不要在写入数据时立即执行昂贵的副作用（如 DOM 操作、网络请求）。

- **思路:** 设置一个 `pendingState` 或 `dirty` 标记。
- **实现:** 当状态改变时，只标记“脏”状态，不执行更新。

#### B. 利用事件循环 (Event Loop) 进行合并

利用 JavaScript 的微任务（Microtasks）或宏任务（Macrotasks）将多次同步修改合并为一次异步执行。

```javascript
class Batcher {
  constructor() {
    this.queue = new Set()
    this.isPending = false
  }

  add(task) {
    this.queue.add(task)
    if (!this.isPending) {
      this.isPending = true
      // 使用 Promise.resolve() 将执行推迟到微任务阶段
      // 此时当前同步代码块中的所有 add 操作都已完成
      Promise.resolve().then(() => this.flush())
    }
  }

  flush() {
    this.queue.forEach(task => task())
    this.queue.clear()
    this.isPending = false
  }
}

// 使用示例
const batcher = new Batcher()
const updateView = () => console.log('Updating View...')

// 即使调用三次，flush 只会执行一次
batcher.add(updateView)
batcher.add(updateView)
batcher.add(updateView)
```

#### C. 中间层抽象 (Virtual Representation)

不要直接操作最终目标（如 DOM）。

- **思路:** 维护一个轻量级的中间数据结构（如 JS 对象树）。
- **实现:** 状态改变 -> 生成新中间层 -> 对比旧中间层 (Diff) -> 仅对差异部分应用补丁 (Patch)。

#### D. 不可变数据 (Immutability)

像 React 和 ProseMirror 一样使用不可变数据结构。

- **思路:** 如果对象引用没有变，就假设数据没有变。
- **优势:** 极大地加速了“是否需要更新”的检测过程（`prevProps === nextProps`），避免了深层比较。

#### E. 节流与防抖 (Throttling & Debouncing)

对于高频触发的输入（如 `resize`, `scroll`, `mousemove`），在设计系统时应内置节流机制，限制单位时间内的更新频率。

---

这是一个基于 TypeScript 的状态管理与视图更新抽象系统。它模拟了 Vue/React 的核心机制：**响应式状态**、**异步批量更新**以及**中间层 Diff（简化版）**。

这个抽象包含三个核心部分：

1.  **`ReactiveStore`**: 负责状态管理，利用 Proxy 拦截修改。
2.  **`Scheduler`**: 负责利用微任务（Microtask）合并更新，防止抖动。
3.  **`Component`**: 抽象组件基类，实现生命周期和渲染逻辑。

### 核心代码实现

```typescript
/**
 * 1. 调度器 (Scheduler)
 * 负责将多次更新请求合并为一次异步执行
 */
class Scheduler {
  private queue: Set<() => void> = new Set()
  private isFlushing = false
  private p = Promise.resolve()

  // 将任务推入队列
  queueJob(job: () => void) {
    this.queue.add(job)
    this.flushJobs()
  }

  // 触发异步刷新
  private flushJobs() {
    if (this.isFlushing) return
    this.isFlushing = true

    // 利用微任务在当前同步代码执行完毕后立即执行
    this.p.then(() => {
      try {
        this.queue.forEach(job => job())
      } finally {
        this.queue.clear()
        this.isFlushing = false
      }
    })
  }
}

// 全局单例调度器
const scheduler = new Scheduler()

/**
 * 2. 虚拟节点 (VNode - 简化版)
 * 用于描述视图结构，避免直接操作真实 DOM
 */
interface VNode {
  tag: string
  props: Record<string, any>
  children: (VNode | string)[]
}

/**
 * 3. 组件基类 (Component)
 * 包含状态管理、渲染逻辑和自动更新机制
 */
export abstract class Component<State extends object> {
  public state: State
  private _vnode: VNode | null = null
  private _isMounted = false

  constructor(initialState: State) {
    // 创建响应式状态
    this.state = this.createReactive(initialState)
  }

  // 抽象方法：由子类实现具体的渲染逻辑
  abstract render(): VNode

  // 抽象方法：模拟 DOM 更新 (实际框架会在这里做 Diff 算法)
  abstract patch(oldVNode: VNode | null, newVNode: VNode): void

  // 创建响应式代理
  private createReactive(target: State): State {
    return new Proxy(target, {
      set: (obj, prop, value, receiver) => {
        const oldValue = Reflect.get(obj, prop, receiver)
        // 只有值真正改变时才触发更新
        if (oldValue !== value) {
          const result = Reflect.set(obj, prop, value, receiver)
          // 触发更新调度
          this.scheduleUpdate()
          return result
        }
        return true
      }
    })
  }

  // 调度更新
  private scheduleUpdate() {
    scheduler.queueJob(() => this.update())
  }

  // 执行实际更新
  private update() {
    const newVNode = this.render()

    console.log(`[System] Component Updating...`)
    this.patch(this._vnode, newVNode)

    this._vnode = newVNode

    if (!this._isMounted) {
      this._isMounted = true
      console.log(`[System] Component Mounted.`)
    }
  }

  // 手动挂载方法
  public mount() {
    this.update()
  }
}

/**
 * 4. 示例实现：一个具体的计数器组件
 */
interface CounterState {
  count: number
  text: string
}

class CounterComponent extends Component<CounterState> {
  // 模拟 DOM 容器
  container: string[] = []

  render(): VNode {
    return {
      tag: 'div',
      props: { id: 'app' },
      children: [`Count is: ${this.state.count}`, `Text is: ${this.state.text}`]
    }
  }

  // 模拟 Patch：这里只是简单打印，实际会操作 DOM
  patch(oldVNode: VNode | null, newVNode: VNode): void {
    // 简单的 Diff 演示
    if (oldVNode) {
      const oldText = oldVNode.children.join(', ')
      const newText = newVNode.children.join(', ')
      if (oldText !== newText) {
        console.log(`   >>> DOM Patch: "${oldText}" -> "${newText}"`)
      }
    } else {
      console.log(`   >>> Initial Render: ${newVNode.children.join(', ')}`)
    }
  }
}

// --- 测试代码 ---

async function runDemo() {
  const counter = new CounterComponent({ count: 0, text: 'Hello' })

  console.log('--- 1. Mount ---')
  counter.mount()

  console.log('\n--- 2. Multiple Synchronous Updates ---')
  // 连续修改多次状态
  counter.state.count++ // 1
  counter.state.count++ // 2
  counter.state.count++ // 3
  counter.state.text = 'World' // Change text

  console.log('(Code executed, waiting for microtask...)')

  // 等待微任务队列执行
  await Promise.resolve()

  console.log('\n--- 3. Another Update ---')
  counter.state.count = 100
}

runDemo()
```

### 设计思路解析

1.  **Proxy 拦截 (`createReactive`)**:

    - 这是 Vue 3 的核心。我们拦截了 `set` 操作。
    - **关键点**: 只有当 `oldValue !== value` 时才触发更新，避免无意义的渲染。

2.  **调度器 (`Scheduler`)**:

    - 这是 React Batching 和 Vue `nextTick` 的核心。
    - 使用 `Set` 存储任务，自动去重（如果同一个组件触发多次更新，Set 只会存一个 update 函数）。
    - 使用 `Promise.resolve().then(...)` 将执行推迟到当前同步代码块结束之后。这就是为什么连续写 `count++` 三次，`update` 只会打印一次的原因。

3.  **组件生命周期 (`Component`)**:
    - 分离了 `state` (数据) 和 `render` (视图描述)。
    - `scheduleUpdate` 是连接数据变化和视图更新的桥梁。

### 运行结果预期

当你运行这段代码时，你会看到：

1.  **Mount**: 首次渲染。
2.  **Multiple Synchronous Updates**: 虽然代码里修改了 4 次状态（3 次 count，1 次 text），但控制台只会打印**一次** `[System] Component Updating...` 和 Patch 操作。最终结果直接变成了 `Count is: 3, Text is: World`。
3.  **Another Update**: 异步之后再次修改，会触发新的更新周期。
