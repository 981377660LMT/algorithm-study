好的，我们来详细讲解《垃圾回收的算法与实现》第十一章的核心内容：**DalvikVM 的垃圾回收**。

这一章将我们的视角从通用语言（Python）转向一个非常特定的、资源受限的平台——早期的 Android 系统。Dalvik 虚拟机（Dalvik Virtual Machine, DVM）是 Android 4.4（KitKat）及更早版本中用于运行应用程序的虚拟机。分析它的 GC 机制，是理解移动端内存管理演进和挑战的绝佳案例。

---

### 11.1 本章前言 (Preface)

本章旨在剖析一个在**资源极其有限（内存、CPU）的移动设备**上运行的 GC 实现。与服务器或桌面环境不同，移动端的 GC 必须在保证应用基本流畅的同时，尽可能地节省内存。

Dalvik VM 的 GC 设计反映了那个时代的权衡：

- 它是一个**寄存器 기반**的虚拟机，而非像 JVM 那样的栈 기반。
- 它的 GC 算法相对**简单直接**，主要是经典的**标记-清除 (Mark-Sweep)** 算法，并且在早期版本中**不是分代的**。
- 这意味着它的 GC 会引发相对较长的“Stop-the-World”(STW)暂停，这也是早期 Android 应用偶尔出现卡顿的原因之一。

通过学习 Dalvik 的 GC，我们可以看到在一个真实的、有商业压力的产品中，GC 理论是如何被简化和改造以适应严苛的运行环境的。

---

### 11.2 重新学习 mmap (Re-learning mmap)

在深入代码之前，本节特意强调了`mmap`这个 Linux 系统调用，因为它是 Dalvik 堆内存管理的基石。

- **`mmap`是什么**：它是一个能将文件或设备映射到内存的系统调用。在 Dalvik 中，它被用于**匿名映射 (Anonymous Mapping)**，即不关联任何文件，直接向操作系统内核申请一块虚拟内存空间。

- **为什么不用`malloc`**：

  - `malloc`是 C 库函数，它内部可能自己管理一个内存池，行为对上层应用不够透明。
  - 使用`mmap`直接与内核交互，Dalvik 可以更精确地控制堆的创建、增长、收缩和释放，对内存布局有完全的掌控权。

- **Dalvik 如何使用`mmap`**：
  Dalvik 的堆（称为**Zygote 堆**或**App 堆**）就是通过`mmap`向系统申请的一大块连续的虚拟内存。后续所有的对象分配和 GC 操作，都在这块内存上进行。

---

### 11.3 DalvikVM 的源代码 (DalvikVM's Source Code)

本节通常会指导读者如何在 Android 开源项目（AOSP）的源码树中找到与 GC 相关的关键文件，例如：

- `dalvik/vm/alloc/HeapSource.cpp`：堆的管理和分配。
- `dalvik/vm/alloc/MarkSweep.cpp`：标记-清除算法的核心实现。
- `dalvik/vm/oo/Object.h`：对象头和结构的定义。

这体现了本书“理论与实践结合”的特点，鼓励读者对照真实代码来理解算法。

---

### 11.4 DalvikVM 的 GC 算法 (DalvikVM's GC Algorithm)

Dalvik 的 GC 算法在不同版本中有所演进，但其核心是**并发标记-清除 (Concurrent Mark-Sweep, CMS)** 的一种变体。

- **基本流程**：

  1.  **并发标记 (Concurrent Mark)**：GC 的标记阶段大部分时间与应用程序**并发**执行，以减少 STW。
  2.  **短暂 STW**：在标记的开始和结束阶段，需要两次短暂的 STW 来处理根集合和同步状态。
  3.  **并发清除 (Concurrent Sweep)**：清除阶段也是并发执行的。

- **注意**：虽然名为“并发”，但由于早期移动设备多为单核，这里的“并发”更多是“交替执行”的含义，并且为了保证正确性，其同步开销不小。

---

### 11.5 对象管理 (Object Management)

Dalvik 中的对象布局与 GC 息息相关。

- **对象头 (`Object` struct)**：每个对象都有一个头，包含了 GC 所需的信息，如类型指针、锁信息等。
- **位图 (Bitmap)**：Dalvik 使用**两个独立的位图**来管理堆，而不是在对象头里放标记位。
  - **Live Bitmap (活动对象位图)**：每个比特位对应堆中的一个字（word）。如果一个对象是活动的，其对应的所有比特位都会被置 1。
  - **Mark Bitmap (标记位图)**：在 GC 标记阶段使用，用于记录正在被标记的对象。
- **堆的结构**：堆被划分为多个**HeapSource**，每个 HeapSource 内部通过位图进行管理。这种设计为后续的堆增长和管理提供了灵活性。

---

### 11.6 标记阶段 (Mark Phase)

这是 Dalvik GC 中最复杂的部分，旨在尽可能地减少 STW。

- **工作流程**：
  1.  **根标记 (Root Marking) - (STW)**：
      - 暂停应用程序。
      - 快速扫描所有 GC Roots（如虚拟机栈、全局变量、JNI 引用），将根直接引用的对象在**Mark Bitmap**中进行标记，并放入一个**标记栈 (Mark Stack)**。
      - 恢复应用程序。
  2.  **并发标记 (Concurrent Marking)**：
      - GC 线程启动，从标记栈中取出对象。
      - 遍历该对象的子对象，如果子对象未被标记，则在 Mark Bitmap 中标记它，并将其压入标记栈。
      - 这个过程与应用程序**并发**（或交替）执行。
      - **写屏障 (Write Barrier)** 在这里不起作用。Dalvik 采用的是一种更简单的方式：如果并发标记期间，应用程序修改了对象引用，GC 在后续阶段会重新处理。
  3.  **重新标记 (Remark) - (STW)**：
      - 再次暂停应用程序。
      - 由于并发标记期间应用可能修改了对象图，导致“对象丢失”，因此需要一个最终的修正阶段。
      - 重新扫描根和在并发期间被修改过的“脏”对象，完成最后的标记。这个阶段必须是 STW，但目标是尽可能地快。
  4.  **交换位图**：标记完成后，将**Mark Bitmap**的内容与**Live Bitmap**进行交换。此时，Live Bitmap 准确地反映了所有活动对象的状态。

---

### 11.7 清除阶段 (Sweep Phase)

- **工作流程**：

  1.  **并发清除 (Concurrent Sweep)**：
      - GC 线程从头到尾扫描堆。
      - 它比较**新的 Live Bitmap**和**旧的 Live Bitmap**。
      - 如果一个对象在旧图中是活的，但在新图中是死的，那么这个对象就是本次 GC 产生的垃圾。
      - GC 将这些垃圾对象所占用的空间回收，并将其合并到**空闲链表 (Free List)** 中。
  2.  **无需 STW**：清除过程可以与应用程序并发进行，因为它只操作那些已经被确认为垃圾的内存，不会影响活动对象。

- **分配**：当应用程序需要分配新对象时，它会从这个空闲链表中查找合适大小的内存块。

---

### 11.8 Q&A (Questions and Answers)

本节可能会解答一些常见问题，例如：

- **Dalvik GC 为什么慢？** 因为它是非分代的标记-清除，每次 GC 都要扫描整个堆，且会产生内存碎片，导致分配变慢。STW 时间也相对较长。
- **为什么不用复制算法？** 移动设备内存宝贵，浪费一半内存的复制算法在当时是不可接受的。
- **ART 的 GC 有何改进？** 后来的 ART（Android Runtime）引入了更先进的 GC 策略，包括**分代收集**和**标记-压缩**，显著改善了 GC 性能和应用流畅度。

**总结**：第十一章通过对 Dalvik VM 的深入剖析，展示了一个经典的、为适应资源受限环境而设计的并发标记-清除 GC 的完整实现。它让我们看到，在真实的工程世界里，GC 算法的设计充满了妥协与权衡，并且随着硬件和软件的发展，这些设计也在不断演进。
