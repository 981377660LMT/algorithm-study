好的，我们来详细讲解《垃圾回收的算法与实现》第二章的核心内容：**GC 标记-清除算法 (Mark-Sweep GC)**。

这一章介绍了基于可达性分析的最基础、最古老的垃圾回收算法。虽然它本身存在一些问题，但它是后续许多高级算法（如标记-压缩、分代收集）的思想源头。

---

### 2.1 什么是 GC 标记-清除算法 (What is Mark-Sweep GC)

标记-清除算法的执行过程分为两个明确的阶段：

1.  **标记阶段 (Mark Phase)**
2.  **清除阶段 (Sweep Phase)**

这两个阶段执行期间，通常需要暂停整个应用程序，即 **“Stop-the-World” (STW)**。

#### 1. 标记阶段 (Mark Phase)

此阶段的任务是**找出所有活动对象**。

- **过程**：

  1.  算法从 **根 (Roots)** 集合开始。
  2.  它会遍历所有从根直接引用的对象，并给这些对象打上一个“存活”的**标记**（通常是在对象头中设置一个“标记位”，如 `mark_bit = 1`）。
  3.  然后，算法会递归地访问这些已被标记对象的所有子对象（即它们引用的其他对象），并同样给这些子对象打上标记。
  4.  这个过程持续进行，就像一个图的深度优先或广度优先遍历，直到所有从根可达的对象都被标记完毕。

- **比喻**：可以想象成“点名”。老师（GC）从几个“班干部”（Roots）开始点名，被点到名字的同学（活动对象）举手（设置标记位）。然后老师让举手的同学喊出他所有好朋友的名字，这些好朋友也举手。这个过程一直持续下去，最后所有举着手的同学都是“活动”的。

#### 2. 清除阶段 (Sweep Phase)

此阶段的任务是**回收所有非活动对象（垃圾）所占用的内存**。

- **过程**：

  1.  算法会从头到尾线性地**遍历整个堆（Heap）**。
  2.  在遍历过程中，它会检查每一个分块（Chunk）或对象。
  3.  如果一个对象**有标记**（`mark_bit == 1`），说明它是活动对象。此时，算法会**清除它的标记**（将 `mark_bit` 重置为 0），为下一次 GC 做准备，然后继续遍历下一个对象。
  4.  如果一个对象**没有标记**（`mark_bit == 0`），说明它是垃圾。算法会**回收它所占用的内存空间**。回收的方式通常是将其作为一个空闲分块，链接到一个被称为“**空闲链表 (Free List)**”的数据结构上。

- **比喻**：点名结束后，老师（GC）从教室门口开始检查每个座位。座位上是举着手的同学（有标记），老师让他把手放下（清除标记），然后看下一个座位。如果座位上的人没举手（无标记），老师就认为他不是这个班的，把他请出去，这个座位就空出来了（回收内存）。

当应用程序需要分配新对象时，**分配器 (Allocator)** 就会去这个“空闲链表”中寻找一个大小合适的空闲分块来使用。

---

### 2.2 优点 (Advantages)

1.  **实现简单**：算法逻辑直观，容易实现。
2.  **解决循环引用**：与引用计数法不同，即使对象之间存在循环引用，只要它们从根不可达，就无法在标记阶段被标记，最终会被清除。这是它相较于朴素引用计数法的最大优势。

---

### 2.3 缺点 (Disadvantages)

1.  **内存碎片化 (Fragmentation)**：这是最主要的缺点。清除阶段会回收掉不连续的内存块，导致整个堆空间中散布着大量细小的、不连续的空闲分块。这就像一个停车场，虽然总的空位数很多，但都是单个的，导致一辆大巴车开进来却找不到连续的停车位。这会造成：

    - **分配大对象困难**：即使总空闲内存足够，也可能因为没有足够大的连续空间而导致分配失败，从而提前触发下一次 GC。
    - **分配速度慢**：分配器不能简单地“指针碰撞”式分配，而必须遍历空闲链表来查找合适的分块，这增加了分配的时间开销。

2.  **暂停时间长 (Long Pause Time)**：标记和清除两个阶段都需要 STW。特别是清除阶段需要遍历整个堆，当堆非常大时，这个过程会非常耗时，导致应用程序长时间无响应。

3.  **与 mutator 的局部性不佳**：算法不会移动对象，所以活动对象会散乱地分布在堆的各个角落，这不利于 CPU 缓存的利用，可能会降低应用程序（mutator）的运行效率。

---

### 针对缺点的改进方法

接下来的小节都是为了解决上述缺点而提出的优化方案。

#### 2.4 多个空闲链表 (Multiple Free Lists)

- **目的**：解决“分配速度慢”的问题。
- **方法**：不再使用单一的空闲链表，而是根据空闲分块的大小，维护**多个空闲链表**。例如，一个链表专门存放大小为 8 字节的分块，另一个存放 16 字节的，以此类推。还有一个链表用于存放所有大于某个阈值的大分块。
- **效果**：当需要分配一个特定大小（如 8 字节）的对象时，分配器可以直接去对应的链表中取出一个分块，分配速度接近 O(1)，大大提高了分配效率。

#### 2.5 BiBOP 法 (Big Bag of Pages)

- **目的**：解决“内存碎片化”和“对象头开销”的问题。
- **方法**：BiBOP 是“Big Bag of Pages”的缩写。它将堆划分为多个大小相同的“页(Page)”。**每个页只能存放相同大小的对象**。例如，一个页专门存放 8 字节的对象，另一个页专门存放 16 字节的对象。
- **效果**：
  - **消除碎片**：由于页内对象大小统一，回收一个对象后留下的“空洞”正好可以容纳一个同尺寸的新对象，从而消除了页内的碎片问题。
  - **减少头开销**：对象的大小信息可以由其所在的页来记录，对象头中就不再需要存储大小字段，减小了内存开销。

#### 2.6 位图标记 (Bitmap Marking)

- **目的**：解决“对象头中标记位开销”和“清除阶段遍历效率”的问题。
- **方法**：不再将标记位直接存储在每个对象的头中，而是使用一块**独立的、连续的内存区域（称为位图）**来统一管理所有对象的标记状态。位图中的每一个比特（bit）对应堆中一个特定大小的内存单元（例如，一个字或一个最小对象的大小）。
- **效果**：
  - **空间效率**：用 1 个 bit 就能标记一个对象，空间开销极小。
  - **清除效率**：在清除阶段，GC 可以快速地扫描位图，而不是遍历整个堆去检查每个对象头。位图是连续的内存，CPU 可以高效地进行批量操作（如按字进行与/或运算），速度远快于在堆中跳跃式地访问对象头。

#### 2.7 延迟清除法 (Lazy Sweep)

- **目的**：缩短“最大暂停时间”。
- **方法**：将清除阶段的工作**分摊**到应用程序的运行过程中。
  1.  标记阶段仍然需要 STW，标记所有活动对象。
  2.  标记结束后，**应用程序立即恢复运行**。
  3.  清除操作被“延迟”了。只有当应用程序**请求分配新内存**，并且空闲链表中没有合适的空间时，才触发一小段清除工作，扫描堆的一部分，回收一些垃圾以满足当前的分配需求。
- **效果**：将原本一次性的、长时间的清除暂停，分解成了多次微小的、不易察觉的暂停，从而显著降低了最大暂停时间，改善了应用的响应性。但这也使得 GC 的逻辑变得更复杂。
