好的，我们来详细讲解《垃圾回收的算法与实现》第五章的核心内容：**GC 标记-压缩算法 (Mark-Compact GC)**。

这一章介绍的算法旨在结合“标记-清除”和“复制”算法的优点，既能解决内存碎片问题，又能避免“复制”算法高达 50%的空间浪费。它在很多场景下，特别是对于老年代的回收，是一种非常重要和实用的策略。

---

### 5.1 什么是 GC 标记-压缩算法 (What is Mark-Compact GC)

标记-压缩算法，顾名思义，也分为两个主要阶段：标记阶段和压缩阶段。

1.  **标记阶段 (Mark Phase)**：

    - 这个阶段与“标记-清除”算法的标记阶段**完全相同**。
    - 算法从根（Roots）开始，递归地遍历所有可达的活动对象，并给它们打上“存活”标记。

2.  **压缩阶段 (Compact Phase)**：
    - 这是与“标记-清除”算法的关键区别所在。它不是简单地回收未标记的垃圾对象，而是**移动所有存活的对象**。
    - 算法会把所有被标记的活动对象，全部向堆内存的一端进行移动，让它们紧凑地、连续地排列在一起。
    - 移动完成后，堆的另一端就全部是连续的空闲空间了。
    - **最关键的挑战**：在移动对象的同时，必须**更新所有指向这些被移动对象的指针**。如果一个对象从地址 A 被移动到了地址 B，那么程序中所有原来指向 A 的指针，都必须被修改为指向 B。

- **比喻**：
  想象一个电影院，一场电影结束后，观众（对象）零零散散地坐着。管理员（GC）不是去清理每个空座位上的垃圾，而是：
  1.  **标记**：首先确认哪些座位上的人是下一场电影的观众（活动对象）。
  2.  **压缩**：然后通过广播通知所有下一场的观众：“请大家全部移动到前五排就坐，不要留空位。”（移动活动对象）。
  3.  **更新引用**：如果小明原来在第 10 排，他朋友小红的票根上写着“找第 10 排的小明”，现在小明移动到了第 2 排，那么小红的票根信息必须被更新为“找第 2 排的小明”。
  4.  最后，从第 6 排到最后一排，就形成了一大片连续的空座位（连续的空闲内存），可以方便地安排新观众入座。

---

### 5.2 优点 (Advantages)

1.  **无内存碎片 (No Fragmentation)**：与复制算法一样，它通过移动对象来消除碎片，使得分配器可以高效地使用“指针碰撞”技术进行快速内存分配。

2.  **空间效率高 (High Space Efficiency)**：与标记-清除算法一样，它不需要预留额外的空间。整个堆空间都可以被利用，内存使用率接近 100%。

---

### 5.3 缺点 (Disadvantages)

1.  **暂停时间长 (Long Pause Time)**：这是它最主要的缺点。压缩阶段不仅要遍历活动对象，还要移动它们，并且最复杂的是要更新所有相关的引用。这个过程通常比“标记-清除”的清除阶段和“复制”算法的复制阶段都要耗时，导致“Stop-the-World”的时间更长。

2.  **算法实现复杂**：如何高效地找到并更新所有指向被移动对象的引用，是该算法实现中的难点。

---

### 压缩阶段的具体实现算法

如何实现复杂的压缩阶段？书中介绍了几种经典算法。

#### 5.4 Two-Finger 算法

这是一种直观的、就地（in-place）进行压缩的算法思路，但它本身只是描述了对象移动的过程，还需要配合其他机制来解决指针更新的问题。

- **核心思想**：使用两个指针在堆上进行操作。

  - 一个指针 `live`（或 `scan`），从头到尾扫描整个堆，寻找**活动对象**。
  - 另一个指针 `free`，指向下一个可用于**放置活动对象**的空闲位置。`free` 指针从堆的起始位置开始。

- **移动过程**：

  1.  `live` 指针不断向后移动，跳过所有垃圾对象。
  2.  当 `live` 指针找到一个活动对象时，就将这个活动对象**移动**到 `free` 指针所指向的位置。
  3.  移动完成后，`free` 指针向后移动该对象的大小，指向下一个空闲位置。
  4.  `live` 指针继续向后扫描，重复此过程，直到扫描完整个堆。

- **遗留问题**：这个算法只描述了如何移动对象，但没有说明如何解决最关键的**指针更新**问题。因此，它通常需要与其他算法（如下面的表格算法）结合使用。

#### 5.5 表格算法 (Table Algorithm / LISP 2 Algorithm)

这是解决指针更新问题的一种经典但多遍（multi-pass）扫描的方法。

- **核心思想**：使用一个**外部表格（或映射表）**来记录所有活动对象的“新旧地址映射关系”。

- **工作流程（通常分为 3-4 个阶段）**：

  1.  **标记阶段**：同上，标记所有活动对象。
  2.  **计算转发地址阶段**：
      - 第二次遍历堆，只看**活动对象**。
      - 为每一个活动对象计算出它将被移动到的**新地址**。
      - 将这个映射关系 `(旧地址 -> 新地址)` 存入一个外部的表格中。
  3.  **更新引用阶段**：
      - 第三次遍历堆，再次只看**活动对象**。
      - 检查每个活动对象内部的所有指针域。
      - 对于每一个指针，拿着它指向的“旧地址”去表格里查询，找到对应的“新地址”，然后用新地址覆盖旧地址。
  4.  **移动对象阶段**：
      - 第四次遍历堆，将所有活动对象从它们的旧地址，物理移动到在第二阶段计算出的新地址。

- **评价**：
  - **优点**：逻辑清晰，容易理解。
  - **缺点**：需要多次遍历整个堆，效率低下；并且需要一个额外的表格来存储地址映射，有空间开销。

#### 5.6 ImmixGC 算法

ImmixGC 是一种更现代、更实用的垃圾回收设计，它不是一个纯粹的标记-压缩算法，而是融合了多种思想的混合策略，旨在取得更好的性能平衡。

- **核心思想**：

  - **分块与分行 (Blocks and Lines)**：Immix 不把堆看作一个整体，而是将其划分为固定大小的**块（Blocks）**。每个块又被进一步划分为更小的、固定大小的**行（Lines）**。对象只能从行的起始位置开始分配。
  - **非移动式回收为主**：在大多数情况下，Immix 的行为类似一个**标记-清除**算法。它会标记活动对象，然后回收那些完全由垃圾对象组成的**行**。如果一行中既有活动对象又有垃圾对象，它默认**不会**去整理，从而避免了移动对象的开销。
  - **选择性复制（压缩）**：只有在回收过程中，当发现某些块的“碎片化程度”（空闲行的比例）很高时，Immix 才会触发**选择性的复制操作**。它会选择一个或多个碎片化严重的块，将其中所有的活动对象**复制**到一个新的、干净的块中。这个过程本质上就是一种局部的“压缩”。

- **优点**：

  - **平衡性能**：它在大部分时间里避免了耗时的对象移动操作，获得了接近“标记-清除”的吞吐量。
  - **处理碎片**：当碎片问题变得严重时，它又能通过局部的复制来整理内存，保持了良好的分配性能。
  - **良好的局部性**：通过将相关对象分配在同一个块中，并在复制时一起移动，它也能提供不错的缓存局部性。

- **总结**：ImmixGC 代表了现代 GC 设计的一种趋势——不再拘泥于某一种“纯粹”的算法，而是根据实际情况，在不同的策略（不移动、复制、压缩）之间进行动态权衡，以达到整体性能的最优化。
