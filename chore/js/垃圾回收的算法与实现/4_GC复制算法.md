好的，我们来详细讲解《垃圾回收的算法与实现》第四章的核心内容：**GC 复制算法 (Copying GC)**。

这一章介绍了一种优雅且高效的垃圾回收算法，它的核心思想与“标记-清除”完全不同。它不是去清理“垃圾”，而是将“有用的东西”搬到新家，然后将旧家整个推倒。这种策略从根本上解决了“标记-清除”算法的内存碎片化问题。

---

### 4.1 什么是 GC 复制算法 (What is Copying GC)

复制算法是一种基于可达性分析的算法，它以一种独特的方式来整理内存。

- **核心思想**：
  将可用的堆内存平均划分为两块大小相等的、独立的空间，一块称为 **From 空间 (From-space)**，另一块称为 **To 空间 (To-space)**。在任何时候，只有一块空间是活动的，用于分配新对象，这块空间就是 From 空间。To 空间则完全空闲，等待下一次 GC。

- **工作流程**：

  1.  **分配 (Allocation)**：应用程序（mutator）在 From 空间中分配新对象。由于 From 空间是连续的，分配可以非常快（通过“指针碰撞”方式）。
  2.  **GC 触发**：当 From 空间被占满，无法再分配新对象时，触发 GC（需要“Stop-the-World”）。
  3.  **遍历与复制 (Traversal & Copy)**：
      - GC 从 **根 (Roots)** 开始，遍历所有活动对象。
      - 每找到一个活动对象，就将它**复制**到**To 空间**中。复制是按顺序进行的，所以对象在 To 空间中是紧密排列的。
      - 当一个对象从 From 空间被复制到 To 空间后，通常会在其**旧址（From 空间中的位置）留下一个“转发指针”(Forwarding Pointer)**，指向它在 To 空间的新地址。这个转发指针至关重要，当后续遍历到另一个也指向该对象的指针时，GC 看到转发指针，就知道这个对象已经被复制过了，只需更新指针到新地址，而无需重复复制。
  4.  **清空 (Sweep)**：当所有活动对象都被复制到 To 空间后，From 空间中剩下的就全都是垃圾了。此时，算法可以**一次性地、无差别地清空整个 From 空间**，这个过程非常快。
  5.  **角色互换 (Flip)**：最后，From 空间和 To 空间的角色互换。原来的 To 空间（现在填满了活动对象）成为新的 From 空间，而原来的 From 空间（现在是空的）成为新的 To 空间，等待下一次 GC。

- **比喻**：
  想象你有两间一模一样的书房，A 和 B。你一直在书房 A 里工作，书、文件、草稿纸越堆越乱（分配对象）。当书房 A 乱到没地方下脚时（内存耗尽），你决定整理一下。你并没有在 A 房里捡垃圾，而是：
  1.  把你所有**还需要用**的书和文件（活动对象）全部搬到空着的书房 B 里，并且整齐地码放好。
  2.  搬完后，书房 A 里剩下的就全是没用的废纸了（垃圾）。
  3.  你直接把书房 A 的门一锁，当它不存在（清空 From 空间）。
  4.  从现在开始，你就在整洁的书房 B 里工作（角色互换）。

---

### 4.2 优点 (Advantages)

1.  **无内存碎片 (No Fragmentation)**：这是它最大的优点。每次 GC 后，所有活动对象都被紧凑地排列在新空间中，内存是完全连续的。

2.  **极快的分配速度 (Fast Allocation)**：由于活动内存空间是连续的，分配器只需维护一个指向空闲内存起始位置的指针。每次分配，只需检查剩余空间是否足够，然后移动指针即可。这个过程被称为“**指针碰撞（Bump-the-Pointer）**”，速度极快，几乎和栈上分配一样高效。

3.  **良好的访问局部性 (Good Locality)**：在复制过程中，相互引用的对象（如一个对象和它的子对象）很可能被复制到相邻的内存位置，这大大提高了 CPU 缓存的命中率，从而提升了应用程序的运行性能。

4.  **GC 效率高**：GC 的工作量只与**活动对象的数量**成正比，而与堆的总大小或垃圾对象的数量无关。如果存活对象很少（这在新生代中很常见），复制算法的效率会非常高。

---

### 4.3 缺点 (Disadvantages)

1.  **空间代价高 (High Space Cost)**：这是它最主要的缺点。算法需要时刻保留一半的堆空间处于空闲状态，导致内存利用率最高只有 50%，非常浪费。

2.  **复制开销 (Copying Overhead)**：如果活动对象的比例很高，那么复制大量对象本身就是一个耗时的操作，会导致 GC 暂停时间变长。因此，复制算法不适合用于存活对象很多的场景（如老年代）。

---

### 改进与实现方法

#### 4.4 Cheney 的 GC 复制算法

这是复制算法的一种经典、优雅且高效的实现方式，它巧妙地利用 To 空间本身来作为遍历队列，无需额外的数据结构（如栈）。

- **核心思想**：使用两个指针 `scan` 和 `free` 在 To 空间中进行操作，实现**广度优先搜索（BFS）**。

  - `free` 指针：指向 To 空间中下一个可用于分配（复制）新对象的位置。
  - `scan` 指针：指向 To 空间中下一个需要扫描其内部引用的对象。

- **工作流程**：

  1.  **初始化**：`scan` 和 `free` 都指向 To 空间的起始位置。
  2.  **根复制**：首先，将所有根直接引用的对象从 From 空间复制到 To 空间，`free` 指针随之移动。
  3.  **循环扫描**：进入一个循环，条件是 `scan < free`。
      - 从 `scan` 指针指向的对象开始，检查它内部的所有域（字段）。
      - 如果一个域指向 From 空间中的一个对象（设为 O），则检查 O 的旧址。
        - 如果 O 还没有被复制（没有转发指针），则将其复制到 `free` 指针所在的位置，更新 `free` 指针，并在 O 的旧址留下指向新位置的转发指针。然后，更新当前扫描对象的域，使其指向这个新地址。
        - 如果 O 已经被复制过（有转发指针），则直接读取转发指针得到新地址，并更新当前扫描对象的域。
      - 当 `scan` 指针指向的对象的所有域都扫描并更新完毕后，将 `scan` 指针移动到下一个对象的位置。
  4.  **结束**：当 `scan` 指针追上 `free` 指针时（`scan == free`），意味着 To 空间中所有已被复制的活动对象都已被扫描完毕，它们的子对象也都被复制了。GC 过程结束。

- **优点**：算法非常紧凑，空间效率高（不需要额外的栈），实现简单。

#### 4.5 近似深度优先搜索方法 (Approximate Depth-First Search)

这是对 Cheney 算法的一种变体，旨在改善缓存局部性。Cheney 的 BFS 算法在扫描和复制时可能会在内存中来回跳跃，而 DFS 倾向于沿着一条引用链深入，可能具有更好的缓存性能。

- **方法**：在复制一个对象后，**立即递归地处理它的子对象**，而不是像 Cheney 算法那样先把它放到队列末尾。这需要一个显式的栈来辅助，或者通过一些技巧来模拟。由于纯粹的 DFS 可能会导致很深的递归和栈溢出，实践中通常采用一些近似或受控的 DFS 策略。

#### 4.6 多空间复制算法 (Multi-Space Copying)

- **目的**：解决标准复制算法“浪费一半内存”的缺点。
- **方法**：不再使用 2 个空间，而是使用**N 个（N > 2）空间**。
  - 例如，使用 3 个空间（A, B, C）。
  - 在某一时刻，2 个空间（如 A 和 B）用于分配，1 个空间（C）是空闲的。
  - 当 A 和 B 都满了，触发 GC，将 A 和 B 中所有的活动对象都复制到 C 中。
  - 然后，C 和 A（或 B）成为新的分配空间，B（或 A）成为新的空闲空间。
- **效果**：内存利用率从 50%提高到了 `(N-1)/N`。例如，3 个空间时利用率为 66.7%，4 个空间时为 75%。这是一种在空间开销和算法复杂性之间的权衡。

**总结**：复制算法因其无碎片和分配快的特性，在现代 GC 中扮演着至关重要的角色。虽然它不适合单独用于整个堆，但它完美地契合了**分代收集中新生代（Young Generation）**的场景——因为新生代中的对象绝大多数都是“朝生夕死”的，存活对象极少，这使得复制算法的优点最大化，缺点最小化。
