好的，我们来详细讲解 Java 的垃圾回收（Garbage Collection, GC）机制。

Java 的 GC 是其最重要的特性之一，它将程序员从繁琐、易错的手动内存管理（如 C/C++ 中的 `malloc`/`free`）中解放出来。Java 的 GC 机制经过几十年的发展，已经变得非常成熟、复杂和高效，并提供了多种回收器以适应不同的应用场景。

---

### 一、 核心思想：什么是垃圾？

在 Java 中，GC 的任务是自动识别并回收那些不再被使用的对象所占用的内存。那么，如何判断一个对象“不再被使用”？

Java 采用的是**可达性分析算法 (Reachability Analysis)**。

1.  **GC Roots (根对象)**：算法首先确定一系列必须存活的“根”对象。这些根是程序运行的起点，包括：

    - **虚拟机栈（栈帧中的本地变量表）中引用的对象**：即当前正在执行的方法中的所有局部变量所引用的对象。
    - **方法区中类静态属性引用的对象**：即类的静态变量引用的对象。
    - **方法区中常量引用的对象**：如字符串常量池里的引用。
    - **本地方法栈中 JNI (Java Native Interface) 引用的对象**。
    - **被同步锁（`synchronized`）持有的对象**。

2.  **可达性分析**：从这些 GC Roots 开始，沿着对象之间的引用链进行遍历。所有能够被遍历到的对象，都被认为是**“可达的” (Reachable)**，即存活对象。

3.  **垃圾判断**：遍历结束后，所有**不可达 (Unreachable)** 的对象，就被判定为“垃圾”，可以被回收。

> **注意**：即使是循环引用的对象（A 引用 B，B 引用 A），只要它们都从 GC Roots 不可达，也会被判定为垃圾。这解决了早期引用计数算法无法处理循环引用的问题。

---

### 二、 核心策略：分代收集 (Generational Collection)

这是现代 Java GC 的基石。它基于一个重要的经验观察——**“分代假说” (Generational Hypothesis)**：

1.  **弱分代假说**：绝大多数对象都是“朝生夕死”的。
2.  **强分代假说**：经过越多次垃圾回收依然存活的对象，越难以消亡。

基于此，JVM 将堆内存划分为不同的“代”，并对不同代使用不同的回收策略，以实现最高的回收效率。

#### Java 堆内存结构

1.  **新生代 (Young Generation)**

    - **特点**：存放新创建的对象和生命周期短的对象。空间较小，GC 频繁。
    - **内部结构**：
      - **Eden 区 (Eden Space)**：绝大多数新对象诞生的地方。
      - **两个 Survivor 区 (S0 和 S1)**：大小相等，用于在 GC 期间存放从 Eden 区和另一个 Survivor 区存活下来的对象。
    - **回收算法**：主要使用**复制算法 (Copying Algorithm)**。
    - **回收过程 (Minor GC / Young GC)**：
      1.  当 Eden 区满时，触发 Minor GC。
      2.  将 Eden 区和当前正在使用的 Survivor 区（比如 S0）中的**存活对象**复制到另一个空闲的 Survivor 区（S1）。
      3.  同时，为每个存活对象增加一个“年龄”计数器（每经历一次 Minor GC，年龄加 1）。
      4.  一次性清空 Eden 区和 S0 区。
      5.  下次 Minor GC 时，S0 和 S1 的角色互换。
    - **优点**：由于新生代存活对象极少，复制成本低，回收速度快，且不会产生内存碎片。

2.  **老年代 (Old Generation / Tenured Generation)**

    - **特点**：存放生命周期长的对象，或者体积超过一定阈值的大对象。空间较大，GC 频率较低。
    - **晋升 (Promotion)**：当一个对象在新生代的年龄达到某个阈值（默认为 15）后，它就会被“晋升”到老年代。
    - **回收算法**：主要使用**标记-清除 (Mark-Sweep)** 或 **标记-整理 (Mark-Compact)** 算法。
    - **回收过程 (Major GC / Full GC)**：对老年代进行的 GC 称为 Major GC。通常 Major GC 会伴随着 Minor GC，这种对整个堆进行的回收被称为 Full GC，其速度较慢，STW 时间较长。

3.  **元空间 (Metaspace)**
    - 在 JDK 8 之前，这部分被称为**永久代 (Permanent Generation)**，它位于堆内存中。
    - 从 JDK 8 开始，永久代被移除，取而代之的是**元空间**，它使用的是**本地内存（Native Memory）**，而非 JVM 堆内存。
    - **作用**：主要存储类的元数据信息（如类名、字段、方法信息等）、运行时常量池。
    - **GC**：元空间的回收由其自身的机制触发，通常在加载大量类或动态生成类导致元空间不足时发生。

---

### 三、 核心算法

Java 的 GC 回收器是基于以下几种基础算法的组合与优化：

1.  **标记-清除算法 (Mark-Sweep)**

    - **过程**：分为“标记”和“清除”两个阶段。先标记出所有存活对象，然后统一清除所有未被标记的对象。
    - **缺点**：会产生大量不连续的**内存碎片**，导致后续分配大对象时可能找不到足够的连续空间而提前触发 GC。

2.  **复制算法 (Copying)**

    - **过程**：将内存分为两块大小相等的空间，每次只使用其中一块。GC 时，将正在使用的空间中的存活对象复制到另一块空闲空间，然后清空当前空间。
    - **优点**：实现简单，无内存碎片。
    - **缺点**：内存利用率只有 50%，空间代价高。非常适合存活率低的新生代。

3.  **标记-整理算法 (Mark-Compact)**
    - **过程**：标记阶段与“标记-清除”相同。但在标记后，不是直接清除垃圾，而是将所有存活对象向内存的一端移动，然后直接清理掉端边界以外的内存。
    - **优点**：解决了内存碎片问题，且空间利用率高。
    - **缺点**：移动对象并更新所有引用的过程比较耗时。适合存活率高的老年代。

---

### 四、 主要的垃圾回收器

JVM 提供了多种垃圾回收器，它们是上述算法的具体实现，各有侧重。

| 回收器                          | 特点                                                                                         | 适用场景                                                    |
| :------------------------------ | :------------------------------------------------------------------------------------------- | :---------------------------------------------------------- |
| **Serial**                      | 单线程，简单高效。GC 时 STW。                                                                | 客户端模式、单核 CPU、内存小的环境。                        |
| **Parallel (Scavenge/Old)**     | 多线程并行版 Serial。**关注吞吐量**。JDK 8 默认。                                            | 后台计算、批处理等对停顿不敏感，但希望 CPU 高效利用的场景。 |
| **CMS (Concurrent Mark Sweep)** | 并发标记，**关注低延迟**。首次实现让 GC 线程与用户线程大部分时间并发执行。                   | 对响应时间有高要求的互联网应用。                            |
| **G1 (Garbage-First)**          | **兼顾吞吐量和低延迟**。将堆划分为多个小区域 (Region)，优先回收垃圾最多的区域。JDK 9+ 默认。 | 大内存（4G+）服务器，要求可预测的 GC 停顿时间。             |
| **ZGC / Shenandoah**            | **追求极致低延迟**（亚毫秒级 STW）。几乎所有工作都并发执行。                                 | 超大内存（几十 G 到 TB 级），对停顿时间有极严苛要求的服务。 |

#### 回收器详解

- **Parallel GC (吞吐量优先)**：目标是让单位时间内，STW 的总时间最短，CPU 利用率最高。它不在乎单次 STW 的时间有多长，适合科学计算、数据分析等后台任务。

- **CMS (低延迟的里程碑)**：通过并发标记和并发清除，极大地缩短了 STW 时间。但它有三个主要缺点：

  1.  对 CPU 资源敏感（会与应用争抢 CPU）。
  2.  无法处理“浮动垃圾”（并发清理阶段产生的新垃圾）。
  3.  基于“标记-清除”，会产生内存碎片。

- **G1 (平衡的革命者)**：G1 是一个分水岭。它将整个堆划分为大量大小相等的独立区域（Region），每个 Region 都可以扮演 Eden、Survivor 或 Old 的角色。

  - **优点**：
    - **可预测的停顿**：用户可以设定一个期望的最大停顿时间（`-XX:MaxGCPauseMillis`），G1 会尽力满足。
    - **无碎片**：从整体上看是基于“标记-整理”，从局部（两个 Region 之间）看是基于“复制”，不会产生碎片。
    - **高效回收**：它会跟踪每个 Region 的回收价值（垃圾数量），在有限的时间内优先回收价值最高的 Region，即“Garbage-First”之名的由来。

- **ZGC / Shenandoah (未来的方向)**：这两个是最新一代的“超低延迟”回收器。它们通过更复杂的并发技术（如着色指针、读屏障等），将标记、整理、引用更新等几乎所有耗时操作都变成了并发执行，使得 STW 时间与堆大小完全无关，稳定在亚毫秒级别。

**总结**：Java 的 GC 是一个庞大而精密的系统。它从简单的可达性分析出发，通过引入分代收集策略，并结合多种基础回收算法，演化出了适应不同需求的、从关注吞吐量到追求极致低延迟的各种高级回收器。理解其工作原理，对于编写高性能、高可用的 Java 应用至关重要。
