# [前端漫谈](https://www.zhihu.com/column/c_158541431)

[blog](https://github.com/yinguangyao/blog)

## LeaferJS，全新的 Canvas 渲染引擎

好的，我们来对这篇关于 LeaferJS 的技术分析文章进行一次深入、详细的讲解。

这篇文章是一位开发者对新兴国产 Canvas 渲染引擎 LeaferJS 的技术探究。作者通过阅读源码和分析其设计，从**架构设计、更新机制、事件拾取**这三个核心维度，揭示了 LeaferJS 实现高性能的秘密。

---

### 1. 前言 & 初步印象

- **引子**: 作者被 LeaferJS 宣传的“1.5s 渲染 100 万个矩形”的惊人性能所吸引，决定一探究竟。
- **初步分析 (火焰图)**:
  - 创建节点的操作非常轻量，只做了属性设置 (`setAttr`)。
  - 大部分耗时集中在**创建节点**和**布局**上，真正的**渲染**环节耗时极短 (3ms)。
  - 这暗示了其渲染管线和更新机制有独到之处。

---

### 2. 架构设计

作者通过一个官方 Demo 入手，剖析了 LeaferJS 的核心架构。

#### 2.1 核心概念

- **App**: 整个应用的顶层实例，可以管理多个 `Leafer` 实例。
- **Leafer**: 核心渲染单元，每个 `Leafer` 实例对应一个独立的 `<canvas>` 元素。这天然支持了**Canvas 分层优化**，可以将不常变化的背景层和频繁变化的交互层分离开，避免不必要的重绘。这个设计与 Konva 的 `Layer` 概念相似。
- **UI 元素 (Rect, Image 等)**: 具体的图形节点，可以被添加到 `Leafer` 中。

#### 2.2 Leafer 类的剖析

作者深入 `Leafer` 类的源码，分析了其关键组成部分：

- **装饰器**:
  - `@registerUI()`: 将类注册到全局，方便后续通过统一的 API 创建实例。
  - `@boundsType()`: 通过 `Object.defineProperty` 拦截属性的 `set` 操作，底层统一调用 `__setAttr` 方法，这是实现响应式更新的关键。
- **核心模块**:
  - `interaction`: 事件处理模块，负责监听 DOM 事件并分发给内部的图形节点。
  - `canvasManager`: 一个 Canvas 池，用于复用和管理 `<canvas>` 元素，优化资源。
  - `imageManager`: 图片资源管理器，负责图片的加载和缓存。
  - `Watcher`: **观察者**，监听节点属性变化，并将变化的节点放入更新队列，触发重绘。这是响应式更新的核心。
  - `Selector`: 选择器，用于根据坐标点查找对应的图形节点，是事件拾取的基础。
- **继承关系**: `Leafer` 继承自 `Group`，`Group` 又混入 (mixin) 了 `Branch` 的能力。这表明 `Leafer` 本身就是一个容器节点（分支节点）。

#### 2.3 Leaf 类的剖析 (以 Rect 为例)

作者接着分析了最基础的图形节点 `Leaf` 的设计，以 `Rect` 为例：

- **绘制逻辑**:
  - `__drawPathByData`: 定义了如何绘制图形的路径（如矩形或圆角矩形）。
  - `__drawFast`: 一个优化的快速绘制方法。
  - **区分复杂与简单绘制**: 系统会根据节点的属性（如 `fill` 是否为纯色字符串）来判断是走“复杂绘制”流程（需要解析渐变、图案等）还是“简单绘制”流程，这是一种性能优化策略。
- **继承关系**: `Rect` -> `UI` -> `Leaf`。
  - `UI`: 封装了通用的绘制方法调用和 `fill`, `stroke`, `x`, `y` 等基础属性。
  - `Leaf`: **最底层的基类**，通过 mixin 混入了一系列核心能力：
    - `LeafMatrix`: 矩阵变换。
    - `LeafBounds`: 包围盒计算。
    - `LeafEventer`: 事件派发。
    - `LeafDataProxy`: **数据代理**，提供了 `__setAttr` 和 `__getAttr` 方法。

**架构总结**: LeaferJS 采用了一种基于**装饰器、Mixin 和继承**的模块化架构。通过数据代理 (`LeafDataProxy`) 和观察者 (`Watcher`) 模式，实现了**响应式的数据驱动更新机制**。

---

### 3. 更新机制

这是 LeaferJS 高性能的关键所在。

1.  **触发更新**: 当用户修改一个节点的属性时（如 `rect.x = 100`），会触发 `LeafDataProxy` 中的 `__setAttr` 方法。
2.  **事件派发**: `__setAttr` 方法会派发一个 `CHANGE` 事件。
3.  **观察者响应**: `Watcher` 监听到 `CHANGE` 事件，将发生变化的节点放入一个**更新队列**。
4.  **请求渲染**: `Watcher` 接着发送一个 `RenderEvent.REQUEST` 事件，请求下一帧进行渲染。
5.  **批量更新**: 渲染请求被放入 `requestAnimationFrame` 中。这样做可以将一帧内发生的多次属性修改**合并为一次渲染**，极大地提升了性能，避免了频繁重绘。

#### 3.1 可视区域渲染 (Culling)

- **全量渲染 (fullRender)**: 在初次渲染或关闭局部渲染时触发。
- **核心优化**: 在遍历渲染节点树时，会判断每个节点（或其包围盒 `__world`）是否与当前**可视区域 (Bounds)** 相交 (`bounds.hit`)。
- **效果**: **只渲染视口内可见的图形**，对于视口外的图形直接跳过。这是一种非常有效的剔除（Culling）优化，尤其在场景非常大时效果显著。作者指出，这是 LeaferJS 性能优于 Konva 的一个原因。

#### 3.2 局部渲染 (Dirty Rectangle)

- **触发时机**: 当节点属性发生变化时，默认走局部渲染 (`partRender`)。
- **核心原理**:
  1.  **计算脏区 (Dirty Rectangle)**: 合并节点**变化前**和**变化后**的两个包围盒，得到一个需要重绘的最小矩形区域（作者称之为 `Block`）。
  2.  **裁剪 (Clip)**: 在重绘前，使用 Canvas 的 `clip()` 方法，将绘制区域限制在这个“脏区”内。
  3.  **清空与重绘**: 清空脏区 (`clear`)，然后遍历**所有**节点，判断哪些节点与这个脏区相交。
  4.  **重绘相交节点**: 只重绘那些与脏区相交的节点。
- **优势**: 避免了全局重绘，只更新画布上发生变化的一小块区域，大大降低了绘制开销。
- **作者的洞察**: 作者正确地指出了局部渲染的权衡——计算相交本身也有 CPU 开销，在某些大范围变化的场景下，性能可能不如全量渲染。

---

### 4. 事件拾取

事件拾取是 Canvas 引擎的另一个核心难点。

- **对比 Konva**: Konva 使用“色值法”（离屏绘制一个每个形状颜色都不同的画布，通过读取点击位置的颜色来识别形状），这种方法开销很大。
- **LeaferJS 的方案**:
  1.  **触发**: `interaction` 模块监听到 DOM 事件（如点击），调用 `selector.getByPoint` 方法。
  2.  **遍历查找**: 从根节点开始递归遍历子节点。
  3.  **命中测试**:
      - 对于容器节点 (`Branch`)，先做一次简单的包围盒命中测试。
      - 对于叶子节点 (`Leaf`)，调用 `__hitWorld` 方法进行精确命中测试。
  4.  **`__hitWorld` 的原理**:
      - 在一个**离屏的 hitCanvas** 上，只将**当前正在测试的这一个节点**绘制出来。
      - 然后利用浏览器原生的 `isPointInPath()` 或 `isPointInStroke()` API 来判断点击坐标是否命中了该节点的路径。
- **性能分析**:
  - **优点**:
    - 相比 Konva 在首屏就绘制两遍，LeaferJS 将离屏绘制的开销**延迟**到了事件触发时，并且是**按需绘制**（只绘制当前测试的节点），因此首屏渲染性能更好。
    - 不需要存储色值映射表 (`colorKey`)，内存占用更低。
    - 能方便地处理不规则图形的拾取。
  - **缺点**: 仍然存在绘制两遍的开销（主画布一遍，hitCanvas 一遍），只是这个开销被分摊和延迟了。

---

### 5. 总结

作者最后对 LeaferJS 给予了高度评价，认为它虽然处于起步阶段，但设计精良，野心不小（计划支持 Canvaskit、小程序等），未来有潜力成为一个非常有竞争力的 Canvas 库。

**总的来说，这篇文章是一篇高质量的技术分析。作者不仅清晰地梳理了 LeaferJS 的核心技术点，还将其与 Konva 等成熟框架进行对比，指出了其设计上的优劣和权衡，展现了扎实的技术功底和优秀的分析能力。**

---

## 浅谈 Canvas 渲染引擎

好的，我们来对这篇关于 Canvas 渲染引擎的科普文章进行一次深入、详细的讲解。

这篇文章是一篇极佳的综述性技术科普。作者以清晰的结构和易于理解的语言，系统地介绍了现代 Canvas 渲染引擎的核心设计理念、关键技术点以及不同框架之间的实现差异。它不是一篇深入源码的分析，而是一幅描绘 Canvas 渲染引擎技术全景的地图。

文章的核心脉络分为三个主要部分：

1.  **为什么需要渲染引擎？** (引言)
2.  **渲染引擎的核心封装技术** (虚拟节点、包围盒、排版系统)
3.  **渲染引擎的关键实现技术** (事件处理、性能优化、跨平台)

---

### 1. 引言：渲染引擎的价值

作者开篇点明了 Canvas 渲染引擎诞生的根本原因：原生 Canvas API 虽然强大，但使用起来非常繁琐和过程化（“调用一堆 API 画一个圆”），开发体验不佳。

渲染引擎的核心价值在于解决了这个痛点，并提供了三大特性：

- **封装 (Encapsulation)**: 将底层的绘制命令封装成声明式的、类似 DOM 的对象，提升开发效率。
- **性能 (Performance)**: 内置了多种优化策略（如脏区渲染），弥补了因封装而失去的底层优化能力，保证了应用的流畅度。
- **跨平台 (Cross-Platform)**: 通过抽象渲染层，实现“一套代码，多端渲染”（Canvas, WebGL, SVG 等）。

---

### 2. 核心封装技术

这部分讲解了引擎如何将繁琐的绘制 API 封装成对开发者友好的工具。

#### 2.1 虚拟节点 (Virtual Node)

- **核心思想**: 将要绘制的图形（圆、矩形等）封装成**类 (Class)**，每个类的实例就是一个“虚拟节点”，类似于 DOM 节点。开发者通过操作这些对象来间接控制画布。
- **场景图 (Scene Graph)**: 这些虚拟节点通过父子关系组织成一棵树状结构，称为“场景图”。文章以 Konva 为例，展示了典型的场景图结构：
  - `Stage`: 根节点，代表整个应用舞台。
  - `Layer`: 对应一个独立的 `<canvas>` 元素，是分层优化的基础。
  - `Group`: 节点的集合，用于对一组图形进行整体变换（缩放、旋转），但自身不绘制。
  - `Shape`: 叶子节点，是真正要绘制的具体图形（Rect, Circle 等）。
- **自定义图形**: 优秀的引擎允许开发者通过继承基类并实现一个特定的绘制方法（如 Konva 的 `sceneFunc`）来创建自定义图形。

#### 2.2 包围盒 (Bounding Box)

- **作用**: 为每个虚拟节点计算一个矩形的边界框。这是进行**碰撞检测**和**事件拾取**的基础。
- **两种类型**:
  - **AABB (Axis-Aligned Bounding Box)**: 轴对齐包围盒。实现简单，计算速度快，但当图形旋转时，包围盒不会跟着旋转，导致包含大量空白区域，不够精确。Konva 和 AntV 使用此方案。
  - **OBB (Oriented Bounding Box)**: 定向包围盒。实现复杂，但能紧密地包裹旋转后的图形，更加精确。Cocos2d 使用此方案。

#### 2.3 排版系统 (Layout System)

- **痛点**: 原生 Canvas 依赖绝对的 `x, y` 坐标进行定位，复杂的布局需要大量手动计算。
- **解决方案**: 引入成熟的布局模型，让开发者像写 CSS 一样进行布局。
  - **盒模型 & Flex 布局**: AntV 等引擎通过集成 Facebook 的 **Yoga** 布局引擎（React Native 同款），实现了完整的 Flex 布局能力。
  - **Widget 系统**: 飞书文档则借鉴了 **Flutter** 的思想，实现了 `Padding`, `Column`, `Row` 等布局组件 (Widget)，提供了更丰富的声明式布局能力。
- **价值**: 极大地提升了 Canvas 应用的布局能力，降低了开发心智负担，使得从 DOM 开发过渡到 Canvas 开发更加平滑。

---

### 3. 关键实现技术

这部分讲解了引擎内部为了实现事件交互和高性能所采用的核心技术。

#### 3.1 事件处理 (Event Handling)

- **核心难题**: 整个 Canvas 在 DOM 中只是一个节点，如何知道用户点击的是画布内部的哪个图形？
- **两种主流方案**:
  1.  **取色值法 (Color Picking)** - Konva 采用
      - **原理**: 在主画布绘制图形的同时，在内存中创建一个隐藏的、大小相同的“事件画布”(hitCanvas)。在 hitCanvas 的相同位置绘制同样的图形，但填充色为一个**唯一的随机颜色 (colorKey)**。当用户点击时，通过 `getImageData` 获取 hitCanvas 上对应坐标的颜色，再通过这个 colorKey 找到对应的图形对象。
      - **优点**: 实现简单，对**不规则图形**的拾取非常精确。
      - **缺点**: 需要绘制两遍，性能开销大；`getImageData` 本身在高频事件（如 `mousemove`）中性能较差。
  2.  **几何法 (Geometric Method)** - AntV、飞书文档采用
      - **原理**: 利用图形的包围盒或路径数据进行数学计算。常见的是**射线法 (Ray Casting)**：从点击点向任意方向发射一条射线，计算它与图形边界的交点数量。**奇数个交点则在图形内部，偶数个则在外部**。通常会配合 **R-Tree** 等空间索引来快速筛选可能命中的图形。
      - **优点**: 无需重复绘制，内存占用小。
      - **缺点**: 实现复杂，涉及大量几何计算，对于大量复杂不规则图形的场景，计算成本较高。

#### 3.2 性能优化 (Performance Optimization)

- **异步批量渲染 (Async Batch Rendering)**
  - **原理**: 类似于 React 的 `setState`。将一帧内发生的多次属性修改、节点增删等操作收集起来，通过 `requestAnimationFrame` 在下一帧进行**一次性**的批量渲染。
  - **效果**: 避免了因连续修改属性而导致的多次无效重绘。
- **离屏渲染 (Offscreen Rendering)**
  - **原理**: 将不常变化但内容复杂的图形（如一个 Group）预先绘制到一个离屏的 Canvas 上。在主画布渲染时，直接通过 `drawImage` 将这个离屏 Canvas 的内容一次性“贴”上来，而不是重新绘制 Group 内的所有子元素。
  - **应用**: Konva 提供了 `cache()` 方法让开发者手动开启。飞书文档则将其应用于**虚拟列表**组件，对可复用的列表项进行离屏渲染，优化滚动性能。
- **脏区渲染 (Dirty Rectangle Rendering)**
  - **原理**: 这是最高级的优化之一。引擎会追踪发生变化的图形，并计算出其变化前后的包围盒所覆盖的最小矩形区域（即“脏区”）。在重绘时，只 `clearRect` 这个脏区，并重新绘制与该脏区相交的所有图形。
  - **效果**: 避免了全局清空和重绘，将渲染开销限制在最小范围，极大地提升了交互响应速度。ZRender 和飞书文档都实现了此技术。

#### 3.3 跨平台 (Cross-Platform)

- **服务端渲染 (SSR)**:
  - **node-canvas**: 使用 Node.js 端的 Canvas 实现，直接输出图片。缺点是文本排版与浏览器不一致，且无法自适应。
  - **SVG**: 将 Canvas 绘制命令转换为 SVG 字符串输出。优点是矢量、可交互，但难以 100% 还原 Canvas 效果。
  - **飞书文档的 FVG 方案 (创新)**:
    1.  飞书的渲染引擎统一使用 Widget 作为绘制单元。
    2.  在服务端，不直接渲染，而是将经过布局计算后的最终 Widget 树结构序列化成一种自定义格式 **FVG**。
    3.  浏览器端加载 JS 后，直接接收 FVG 数据，跳过数据处理和布局计算阶段，直接将 FVG “水合”(hydrate) 成 Widget 并渲染到 Canvas。
    4.  **评价**: 这是一个非常巧妙的方案，类似于 React 的服务端渲染与客户端激活，极大地提升了首屏渲染速度。

### 总结

这篇文章为读者构建了一幅关于 Canvas 渲染引擎的完整知识图谱。它清晰地阐述了：

- **封装层**: 如何将底层 API 包装成开发者友好的、声明式的对象和布局系统。
- **实现层**: 如何通过事件拾取、批量渲染、脏区渲染等核心技术来保证应用的交互性和高性能。
- **生态层**: 如何通过抽象设计来实现跨平台渲染，并给出了服务端渲染的多种解决方案。

通过对 Konva、AntV、ZRender、飞书文档等不同产品的技术选型对比，文章让读者深刻理解了各种技术方案背后的设计权衡，是一篇极具价值的入门和进阶参考。

## 腾讯文档 SmartSheet 渲染层 Feature 设计

好的，我们来对这篇关于腾讯文档 SmartSheet 渲染层 Feature 设计的文章进行一次深入、详细的讲解。

这篇文章是作者对腾讯文档智能表格（SmartSheet）中一个关键渲染层——**Feature Canvas**——的设计思路的总结。文章的核心在于阐述如何通过**插件化**和**数据驱动**这两种设计模式，来优雅地管理和组织复杂的、与用户交互相关的 Canvas 渲染逻辑。

文章可以分为三个主要部分来理解：

1.  **背景与问题**：为什么要设计一个独立的 Feature Canvas？
2.  **解决方案一：插件化**：如何用插件模式来组织和管理各种交互功能 (Feature)？
3.  **解决方案二：数据驱动**：如何用数据驱动（MobX）来解耦 UI 与状态，提升代码质量？

---

### 1. 背景与问题：分层渲染

文章开篇就点明了其渲染架构的核心前提——**双层 Canvas 分层渲染**。

- **分层原因**: 出于性能考虑。在电子表格这类应用中，大部分内容（表格单元格、数据）是不常变化的，而用户的交互行为（如选区、Hover、填充柄）是频繁变化的。将两者绘制在不同的 Canvas 层上，可以做到只重绘频繁变化的部分，而无需触动开销巨大的背景层。
- **两层定义**:
  - **BoardCanvas**: 背景层，绘制不常变化的内容（表格本身）。
  - **Feature Canvas**: 交互层，绘制所有与用户交互相关的、频繁变化的内容。
- **核心问题**: 如何高效、规范地管理 Feature Canvas 上种类繁多且逻辑各异的交互功能（Feature）？

---

### 2. 解决方案一：插件化 (Plugin Architecture)

为了解决 Feature 的管理问题，作者团队引入了**插件化**的设计思想。

#### 2.1 定义 Feature

- **概念**: 所有和用户交互相关的视觉元素和行为，都被定义为 Feature。例如：选区、单元格选中态、行列 Hover 效果、行列拖拽移动、智能填充柄等。
- **目标**: 为这些功能各异的 Feature 提供一套统一的代码组织和管理范式。

#### 2.2 插件类的设计

- **核心**: 每个 Feature 都被实现为一个独立的**插件类 (Plugin Class)**。
- **生命周期 (Lifecycle Hooks)**: 为了规范插件的行为，定义了一个包含标准生命周期钩子的抽象基类 `BaseFeature`。
  - `bootstrap()`: 初始化。在插件实例化时调用，适合做一些一次性的设置，如绑定全局事件。
  - `updated()`: 更新。在需要重绘 Feature 时调用。
  - `addActivedEvents()`: 激活事件。当 Feature 进入“活跃”状态时调用，用于绑定只有在活跃时才需要的事件（如滚动事件）。
  - `removeActivedEvents()`: 失活事件。与 `addActivedEvents` 对应，用于解绑事件。
  - `destroy()`: 销毁。在插件被销毁时调用，用于清理资源。
- **状态管理 (Active/Deactivated)**: 插件内部维护一个 `isActived` 状态。通过 `toActived()` 和 `toDeactivated()` 方法来切换状态并触发相应的事件绑定/解绑。这是一种**性能优化**，避免了在 Feature 非活跃时监听不必要的事件（例如，只有在用户选中了单元格后，才需要开始监听滚动事件来更新选区位置）。

#### 2.3 插件的注册与管理

- **统一入口**: 在一个主管理类（如 `FeatureCanvas`）中，通过一个数组来统一注册所有需要加载的插件。
- **按需加载**: 注册时可以附带配置项（如 `requiredEdit`），允许根据当前用户的权限或环境来决定是否加载某个插件。
- **实例化**: 管理类遍历注册列表，实例化每个插件，完成整个插件系统的启动。

**插件化总结**: 通过插件化的设计，将原本散乱的交互逻辑封装到了一个个独立的、遵循统一生命周期的类中，使得代码结构清晰、易于管理、易于扩展。

---

### 3. 解决方案二：数据驱动 (Data-Driven)

插件化解决了代码组织问题，但随之而来的是**状态管理和通信**问题。

#### 3.1 原始方式的问题 (命令式)

作者指出了直接在 Feature 内部维护状态并暴露方法的弊端：

- **获取状态**: `(this.getFeature('highLight') as HighLight).cell;`
- **修改状态并更新 UI**:
  ```javascript
  const highLight = this.getFeature('highLight') as HighLight;
  highLight.cell = { row: 100, column: 100 };
  highLight.paint(); // 手动调用绘制方法
  ```
- **问题分析**:
  1.  **封装性差**: 外部模块需要知道 Feature 的内部实现细节（如 `cell` 属性和 `paint` 方法）。
  2.  **命令式写法**: 需要手动调用方法来更新 UI，而不是状态变更后 UI 自动更新。
  3.  **类型问题**: 需要手动进行类型断言，不安全且繁琐。

#### 3.2 引入数据驱动 (以 MobX 为例)

为了解决上述问题，作者团队引入了**数据驱动**的思想，选择 **MobX** 作为状态管理库。

- **核心思想**:
  1.  **建立 Model 层**: 创建一个独立的 Model 层，专门存放所有共享的、与 UI 相关的状态（如当前高亮的单元格 `count`）。
  2.  **状态与 UI 分离**: Feature 类不再自己维护状态，而是**响应 (react to)** Model 层中状态的变化。
  3.  **自动更新**: 当 Model 中的状态变化时，相关的 Feature UI 会**自动更新**。

#### 3.3 实现方式

作者展示了如何通过封装两个自定义装饰器 `observer` 和 `watch` 来将 MobX 与插件类结合。

- **`@watch('count')`**:
  - **作用**: 装饰在 Feature 类的一个方法上（如 `refresh`）。
  - **功能**: 监听 Model 中指定路径 (`count`) 的属性。当该属性变化时，**自动调用**被装饰的 `refresh` 方法，并将新值作为参数传入。
- **`@observer()`**:
  - **作用**: 装饰在 Feature 类本身。
  - **功能**: 这是一个巧妙的“启动器”。它会拦截类的构造函数，在实例创建后，找到所有通过 `@watch` 注册的监听器 (`$watchers`)，并执行它们。这一步是触发 MobX **依赖收集**的关键，从而建立起 Model 属性与 Feature 更新方法之间的响应式关联。

**数据驱动总结**: 引入 MobX 和自定义装饰器后，代码变得**声明式**和**响应式**。开发者只需要在 Model 中修改状态，相关的 UI 就会自动更新。这极大地简化了状态管理，解耦了模块，提升了代码的可读性和可维护性。

---

### 总结

这篇文章提供了一个在复杂 Canvas 应用中进行架构设计的优秀范例。其核心思想可以概括为：

1.  **分层**: 通过物理分层（双 Canvas）将动静内容分离，是性能优化的基础。
2.  **插件化**: 通过逻辑分层（插件模式）将功能模块化，解决了代码的**组织和扩展**问题。
3.  **数据驱动**: 通过引入状态管理（MobX）将数据与视图分离，解决了插件间的**通信和状态管理**问题。

这套设计展示了从**过程化**（手动调用 `paint`）到**面向对象**（插件类封装）再到**响应式/声明式**（数据驱动）的架构演进思想，对于任何需要构建复杂前端应用的开发者来说，都具有非常高的参考价值。

## 异步分片计算在腾讯文档的实践

```js
const schduler = tasks => {
  const DEFAULT_RUNTIME = 16
  const { port1, port2 } = new MessageChannel()

  let sum = 0
  let isAbort = false

  const promise = new Promise((resolve, reject) => {
    // 运行器
    const runner = () => {
      const prevTime = performance.now()
      do {
        if (isAbort) {
          return reject()
        }
        // 如果任务队列已经空了
        if (tasks.length === 0) {
          return resolve(sum)
        }
        const task = tasks.shift()
        const value = task()
        sum += value
      } while (performance.now() - prevTime < DEFAULT_RUNTIME)
      // 当前分片执行完成后开启下一个分片
      port2.postMessage('')
    }

    port1.onmessage = function () {
      runner()
    }

    port2.postMessage('')
  })

  promise.abort = () => {
    isAbort = true
  }

  return promise
}
```

好的，我们来对这篇关于腾讯文档异步分片计算实践的文章进行一次深入、详细的讲解。

这篇文章是作者对腾讯文档智能表格（Smart Sheet）中一个典型性能瓶颈——**大规模排版计算**——所做的优化实践总结。文章以“看板视图”为例，详细阐述了如何借鉴 React Fiber 的思想，设计并实现一套**异步分片计算**机制，来解决因长时间计算任务导致的页面卡顿和白屏问题。

文章的逻辑脉络非常清晰，可以分为以下几个部分：

1.  **背景与问题**：在什么场景下遇到了什么性能问题？
2.  **问题分析**：为什么排版计算会这么慢？
3.  **方案选型**：为什么选择异步计算而非 Web Worker？
4.  **核心实现**：如何从零开始构建一个异步分片调度器？
5.  **业务结合**：如何将调度器与看板排版业务逻辑相结合，实现最优的用户体验？
6.  **增量优化**：如何处理更新阶段的计算和缓存？

---

### 1. 背景与问题

- **场景**: 腾讯文档智能表格中的多个视图（表格列统计、看板排版、甘特图时间条）在数据量大时，存在计算量巨大的问题。
- **核心问题**: **长时间的同步计算任务会阻塞主线程**，导致：
  - **白屏**: 在看板视图中，排版计算优先于渲染，导致页面长时间无法显示内容。
  - **卡顿/无响应**: 在更新或滚动时，用户的操作（点击、滚动等）无法得到及时响应。
- **初步尝试的失败**: 作者提到曾用 `requestIdleCallback` 做过初步优化，但效果不佳，原因在于：
  - **计算粒度粗糙**: 手动设置分片大小（如 300 个卡片），粒度太大依然会卡顿。
  - **调度优先级低**: `requestIdleCallback` 优先级很低，可能长时间得不到执行。

---

### 2. 问题分析：为什么会慢？

作者深入分析了看板视图排版计算慢的根本原因。

- **排版逻辑**: 看板视图中，每个卡片的高度是不固定的，需要根据其内容（如多行文本、多选项）动态计算。整个分组的高度又是所有卡片高度的累加。
- **性能瓶颈**: **计算文本在给定宽度下如何换行**。由于 Canvas 没有 DOM 的自动换行能力，这需要手动计算。
  - **`measureText` 的滥用**: 最初使用二分法来查找换行点，这会导致对同一个文本片段进行大量重复的 `measureText` 调用，性能极差。
  - **根本原因**: 即使后续通过分词和缓存优化了 `measureText` 的调用，但当卡片数量巨大时，总体计算量依然庞大。

---

### 3. 方案选型：异步计算 vs. Web Worker

面对计算量大的问题，作者对比了两种主流方案：

- **Web Worker**:
  - **优点**: 可以将计算任务完全放到另一个线程，不阻塞主线程。
  - **缺点**: 内存不共享，会增加整体内存占用；与主线程的通信存在开销。
- **异步分片计算 (Time Slicing)**:
  - **核心思想**: 借鉴 React Fiber，将一个大的、连续的计算任务，切分成许多小的、不连续的“时间片”。每执行完一个时间片，就将控制权交还给浏览器，让浏览器有机会响应用户输入和进行渲染。
  - **优点**: 在单线程内实现协作式多任务，不增加内存开销，实现相对简单。

作者团队最终选择了**异步分片计算**，因为它更轻量，且能很好地解决当前问题。

---

### 4. 核心实现：异步分片调度器

这是文章的技术核心。作者展示了如何一步步构建一个类似 React Scheduler 的调度器。

#### 步骤一：基本原型

- **思路**: 使用 `do...while` 循环来执行任务，循环的条件是**当前时间片已用时间**没有超过一个阈值（如 16ms）。
- **调度**: 使用 `setTimeout` 在一个时间片结束后调度下一个时间片。
- **代码示例**:
  ```javascript
  const runner = tasks => {
    const prevTime = performance.now()
    do {
      // ...执行任务...
    } while (performance.now() - prevTime < 16)
    setTimeout(() => runner(tasks))
  }
  ```

#### 步骤二：优化调度方式

- **问题**: `setTimeout` 有最小 4ms 的延迟，在一帧（16ms）中这是巨大的浪费。
- **解决方案**: 使用 **`MessageChannel`**。它可以在当前宏任务执行完毕后，立即将一个新的宏任务推入队列，几乎是 0 延迟。这是 React Scheduler 采用的核心技术。

#### 步骤三：增加可控性 (Promise & Abort)

- **问题**: 调用方无法知道任务何时结束，也无法中途取消任务。
- **解决方案**:
  - **结束通知**: 将整个调度过程包装在一个 `Promise` 中。当所有任务执行完毕时，调用 `resolve`。
  - **取消任务**: 在返回的 `Promise` 对象上挂载一个 `abort` 方法。该方法通过设置一个标志位 (`isAbort`) 来中断后续所有时间片的执行，并 `reject` Promise。

#### 步骤四：动态调整分片时间

- **洞察**: 16ms (对应 60fps) 是一个理论值。现代高刷新率屏幕（如 120Hz）的帧时间更短（约 8.3ms）。
- **优化**: 使用 `requestAnimationFrame` 来动态检测用户设备的**实际帧率**，并根据实际帧率来动态调整每个时间片的执行时长，实现更精细的控制。

---

### 5. 业务结合：中心扩散计算策略

有了调度器，如何组织计算任务（即如何切分卡片的计算）是关键。

- **问题**:
  - 按分组顺序计算，如果第一个分组卡片很多，会延迟后面分组的渲染。
  - 用户可能通过滚动记录，直接打开文档的中间部分。
- **解决方案：中心扩散策略**
  1.  **阈值判断**: 对于小文档（如 1000 卡片以下），继续使用**同步计算**，因为异步的总耗时更长，没必要。
  2.  **可视区域优先**: 对于大文档，首先**同步计算**当前**可视区域内**（以及上下少量缓冲区域）的所有卡片。
  3.  **立即渲染**: 可视区域计算完毕后，**立即执行一次渲染**，让用户能最快看到首屏内容，消除白屏。
  4.  **异步扩散计算**: 以可视区域为中心，**横向地**（即所有分组的第 N 个卡片，然后是第 N+1 个...）向两边异步分片计算剩余的卡片。
  5.  **中断与恢复**: 如果在异步计算过程中，用户滚动导致可视区域变化，之前的计算结果应被缓存，并从新的可视区域重新开始计算。

---

### 6. 增量优化：更新与缓存

- **目标**: 在用户编辑文档时，实现高效的增量更新，避免不必要的重算。
- **策略：差量计算 + 缓存**
  - **无高度变化**: 如果用户操作（如勾选复选框）不影响卡片高度，则无需重新排版，直接渲染。
  - **移动卡片**: 只需重新计算受影响的两个分组的总高度。由于每个卡片的高度已有缓存，这个计算几乎是 0 耗时的简单加减法。
  - **修改文本**: 只重新计算被修改的那个卡片的高度，并更新其缓存。其他卡片高度走缓存。
  - **全局变化**: 对于隐藏/显示列这种会影响所有卡片高度的操作，则必须触发全局的异步分片重算。

### 总结

这篇文章是一篇极具价值的前端性能优化实战案例。它清晰地展示了从发现问题、分析根源、技术选型到方案设计、业务结合、持续优化的完整流程。

其核心亮点在于：

1.  **问题定位精准**: 准确地找到了性能瓶颈在于大规模同步计算对主线程的阻塞。
2.  **技术方案经典**: 成功地将 React Scheduler 的核心思想（时间分片、协作式多任务）应用到了具体的业务场景中。
3.  **业务结合紧密**: 设计了“中心扩散”和“可视区域优先”等策略，在技术优化的同时，极大地考虑了用户的主观体验。
4.  **增量思维**: 通过精细化的缓存和脏检查机制，将更新阶段的计算开销降至最低。

这篇文章不仅教会了读者如何实现一个异步调度器，更重要的是，它提供了一套解决大型、复杂应用性能问题的系统性方法论。

## 介绍 Preact Signals

好的，我们来对这篇介绍 Preact Signals 的文章进行一次深入、详细的讲解。

这篇文章是一篇优秀的技术科普文，它清晰地介绍了 Preact 团队推出的一个新的状态管理方案——Signals。文章从“为什么需要 Signals”出发，阐述了现有状态管理方案的痛点，然后详细介绍了 Signals 的核心概念、独特优势以及具体用法，最后给出了一个总结。

文章的逻辑结构可以分为以下几个部分：

1.  **引言：什么是 Signals？**
2.  **动机：为什么需要 Signals？** (对比传统状态管理方案)
3.  **核心特性与用法** (API 讲解)
4.  **总结与展望**

---

### 1. 引言：什么是 Signals？

- **定义**: Signals 是一种新的状态管理方式，其灵感来源于 SolidJS。
- **核心目标**: 无论应用多复杂，都能保证 UI 的快速响应。
- **核心机制**: 通过**自动状态绑定**和**依赖跟踪**，实现状态变更时 UI 的**最高效更新**。

---

### 2. 动机：为什么需要 Signals？

这部分是文章的关键，它深刻地剖析了传统 React (及 Preact) 状态管理的痛点，从而凸显出 Signals 的价值。

#### 2.1 传统状态管理的困境

1.  **状态提升 (Lifting State Up) + Props Drilling**

    - **问题**: 为了共享状态，需要将状态提升到公共祖先组件。当状态更新时，会导致整个子组件树的重新渲染（re-render）。
    - **传统优化**: 使用 `memo` 和 `useMemo` 进行性能优化。
    - **痛点**:
      - **心智负担**: 随着项目变大，很难确定在哪里添加这些优化。
      - **优化失效**: `memo` 依赖于 props 的浅比较，常常因为不稳定的依赖（如每次渲染都重新创建的函数或对象）而失效。
      - **难以调试**: Hooks 的依赖关系是隐式的，没有明确的依赖树，难以用工具分析性能问题。

2.  **Context API**
    - **问题**: `Context.Provider` 的 `value` 只能作为一个整体被更新。任何消费该 Context 的子组件，只要 `value` 发生变化，都会重新渲染，无法做到细粒度更新。
    - **传统优化**: 将一个大的 Context 拆分成多个小的 Context。
    - **痛点**: 导致“Context 套娃”现象，代码变得臃肿和难以维护。

#### 2.2 Signals：通向未来的解决方案

Signals 通过一种全新的范式解决了上述问题。

- **核心概念**: `signal` 是一个包含 `.value` 属性的对象。
  - `const count = signal(0);`
  - 读取值: `count.value`
  - 更新值: `count.value++`
- **关键特性 1：传递引用而非值**
  - 当一个 `signal` 对象作为 props 或通过 context 传递时，传递的是对这个**对象本身的引用**。
  - 由于 `signal` 对象本身是**不可变的**（它的引用地址不变），只有其内部的 `.value` 在变，所以从组件的角度看，props 没有发生变化。
  - **效果**: 这使得 Signals 可以**完全跳过**从父到子的 VDOM diff 和重新渲染过程，直接“瞬移”到真正使用了 `.value` 的那个组件（或 DOM 节点）进行更新。
- **关键特性 2：自动依赖跟踪**
  - 当一个 `signal` 的 `.value` 在组件内部被访问时，Signals 会自动将该组件注册为这个 `signal` 的订阅者。
  - 当这个 `signal` 的 `.value` 发生变化时，它只会**精确地通知**那些订阅了它的组件进行重新渲染。

#### 2.3 惊人的细粒度更新

作者通过一个例子生动地展示了 Signals 的威力：

```jsx
const count = signal(0)
const App = () => (
  <>
    <h1 onClick={() => count.value++}>+</h1>
    <span>{count}</span>
  </>
)
```

当点击 `<h1>` 时，`count.value` 改变。

- **传统 React**: 整个 `App` 组件会重新渲染。
- **Preact Signals**:
  - `App` 组件**不会**重新渲染。
  - `<h1>` **不会**重新渲染。
  - `<span>` **不会**重新渲染。
  - **唯一更新的**是 `<span>` 内部的那个**文本节点**。

这是一种极致的性能优化，更新的粒度从“组件级”降低到了“DOM 节点级”甚至“文本节点级”。

---

### 3. 核心特性与用法 (API 讲解)

这部分通过一个 TodoList 的例子，系统地介绍了 Signals 的主要 API。

- **`signal(initialValue)`**: 创建一个基础的 signal 状态。
  - `const todos = signal([...]);`
- **`computed(fn)`**: 创建一个**衍生状态**。
  - **原理**: `computed` 接收一个函数，该函数内部依赖了其他的 signal。当这些依赖的 signal 变化时，`computed` 会自动重新计算其值。
  - **惰性求值**: `computed` 的值只有在被访问时才会计算，并且结果会被缓存，直到其依赖变化。
  - `const completed = computed(() => todos.value.filter(...).length);`
- **`useSignal(initialValue)` / `useComputed(fn)`**: 在组件内部使用的 Hooks 版本，其内部使用 `useMemo` 来保证 signal 在组件多次渲染之间只被创建一次。
- **`effect(fn)`**: **副作用钩子**，用于订阅 signal 的变化并执行操作（类似于 React 的 `useEffect` 或 MobX 的 `autorun`）。
  - 当 `effect` 回调函数内部依赖的 signal 变化时，该回调会自动重新执行。
  - `effect` 会返回一个 `dispose` 函数，用于取消订阅。
  - **`.peek()`**: 在 `effect` 内部读取一个 signal 的值但**不建立订阅关系**，避免循环更新。
- **`batch(fn)`**: **批量更新**。
  - 将多个 signal 的更新操作包裹在 `batch` 回调中，可以确保这些更新只触发**一次**UI 更新或 `effect` 的执行，类似于 React 的自动批处理。

#### 状态管理模式

- **全局状态**: 在组件树外部创建 signal，可以通过 `export` 或 `Context.Provider` 来共享。
- **局部状态**: 在组件内部使用 `useSignal` 创建，其生命周期与组件绑定。

---

### 4. 总结与展望

- **现状**: Signals 是 Preact 的一个新特性，尚不稳定，不建议在生产环境大规模使用。
- **展望**: 作者预告了下一篇文章将深入讲解 Signals 的实现原理。

### 总结

这篇文章以一种非常易于理解的方式，向读者介绍了 Preact Signals 这一前沿的状态管理范式。它精准地抓住了传统方案的痛点，并用生动的例子和清晰的 API 讲解展示了 Signals 的革命性优势——**极致的性能和简单的开发心智模型**。

通过阅读这篇文章，我们可以深刻地理解到：

1.  **范式转变**: Signals 将状态管理的关注点从“组件树的更新”转移到了“状态依赖图的更新”，这是一种从“拉”（组件重新渲染时拉取最新状态）到“推”（状态变化时精确推送更新）的转变。
2.  **性能优势**: 其核心优势在于能够绕过 VDOM 的 diff 过程，实现外科手术刀式的精确更新，将性能优化到极致。
3.  **开发体验**: 开发者不再需要手动添加 `memo` 或拆分 `Context`，只需自然地使用状态，Signals 会自动处理所有复杂的依赖跟踪和性能优化，大大降低了心智负担。

## KonvaJS 原理解析

好的，我们来对这篇关于 KonvaJS 原理的解析文章进行一次深入、详细的讲解。

这篇文章是一篇非常出色的技术深度剖析。作者通过阅读源码，系统地拆解了 KonvaJS 这个流行的 Canvas 库的内部工作机制。文章从顶层架构设计到底层实现细节，覆盖了渲染、事件、滤镜、跨框架集成等多个方面。

我们可以将文章的逻辑脉络分为以下几个核心部分：

1.  **架构设计**：Konva 是如何组织图形和 DOM 元素的。
2.  **渲染机制**：Konva 是如何将图形绘制到画布上并进行优化的。
3.  **事件系统**：Konva 是如何在一个 Canvas 上实现图形的事件交互的。
4.  **高级功能**：滤镜、选择器、序列化等。
5.  **生态集成**：如何与 React 和 Vue 结合。
6.  **局限性分析**：Konva 存在的性能短板。

---

### 1. 架构设计

作者首先介绍了 Konva 的核心组织结构——**Konva Tree**，这是一个类似于 DOM 树的场景图（Scene Graph）模型。

- **核心概念**:

  - **Stage (舞台)**: 整个应用的根节点。它在页面上创建一个 `<div>` 容器，作为所有内容的父级和**事件监听层**。
  - **Layer (图层)**: **这是理解 Konva 性能的关键**。每个 `Layer` 都会创建一个独立的 `<canvas>` 元素。这意味着你可以将不常变化的内容（如背景）和频繁变化的内容（如动画元素）放在不同的 `Layer` 上，从而实现**分层渲染**，避免不必要的全局重绘。
  - **Group (分组)**: 一个逻辑容器，用于将多个 `Shape` 组合在一起。对 `Group` 进行的变换（如缩放、旋转）会统一应用到其所有子节点上。它本身不对应 `<canvas>`。
  - **Shape (图形)**: 真正的绘制单元，如 `Rect`、`Circle`、`Text` 等。

- **DOM 构建 (`_buildDOM`)**:
  - `Stage` 初始化时，会创建 `content` 这个 `<div>` 容器。
  - 当向 `Stage` 添加 `Layer` 时，该 `Layer` 对应的 `<canvas>` 元素会被 `appendChild` 到 `content` 容器中。
  - `Stage` 还会创建两个内存中的 `canvas`：`bufferCanvas` 和 `bufferHitCanvas`，它们分别用于 `perfectDrawEnabled` 功能和事件拾取。

---

### 2. 渲染机制

这部分讲解了 Konva 如何高效地将场景图绘制出来。

- **批量渲染 (`batchDraw`)**:

  - **问题**: 如果在短时间内连续修改一个图形的多个属性（如位置、颜色），不应该每次修改都重绘一次画布。
  - **Konva 的解决方案**: 使用 `requestAnimationFrame` 实现批量更新。当一个图形属性改变时，它会请求一次 `batchDraw`。`batchDraw` 会设置一个标志位 `_waitingForDraw`，并安排在下一帧执行真正的 `draw()` 方法。这样，一帧内的所有修改都会被合并到一次重绘中，极大地提升了性能。这与 React 的 `setState` 批量更新思想类似。

- **离屏渲染 (`cache`)**:

  - **概念**: 将一个复杂的、不常变化的部分（如一个 `Group`）预先绘制到一个内存中的、不可见的 Canvas（即离屏 Canvas）上。
  - **工作方式**: 当需要渲染这部分内容时，不再重新绘制其内部的所有子图形，而是直接使用 `drawImage` 方法将这个预渲染好的离屏 Canvas “贴”到主画布上。
  - **优势**: 对于重复或复杂的静态内容，可以极大地提升渲染速度。

- **`perfectDrawEnabled`**:
  - **问题**: 在 Canvas 中，当一个半透明的 `fill` (填充) 和一个 `stroke` (描边) 同时存在时，描边的一部分会和填充重叠，导致颜色混合，效果不符合预期。
  - **Konva 的解决方案**:
    1.  使用 `Stage` 创建的 `bufferCanvas`。
    2.  先在 `bufferCanvas` 上完整地绘制图形的 `fill` 和 `stroke`（此时没有透明度）。
    3.  然后回到主画布 (`sceneCanvas`)，先应用透明度 (`globalAlpha`)。
    4.  最后通过 `drawImage` 将 `bufferCanvas` 的内容绘制到主画布上。
  - **效果**: 通过一个中间画布，完美地分离了形状绘制和透明度应用，保证了视觉效果的正确性。

---

### 3. 事件系统

这是 Konva 设计中**最巧妙**的部分之一。

- **事件分发**:

  1.  Konva 在 `Stage` 的 `content` `<div>` 上监听原生的 DOM 事件（如 `mousedown`, `mousemove` 等）。
  2.  当事件触发时，获取鼠标相对于 `content` 的坐标。
  3.  通过 `getIntersection` 方法，根据坐标找出被“击中”的 `Shape`。
  4.  找到 `Shape` 后，触发 Konva 内部的自定义事件，并沿着 `Shape` -> `Group` -> `Layer` -> `Stage` 的路径向上**模拟事件冒泡**。

- **核心：如何匹配 Shape (取色值法)**
  - **问题**: 如何根据一个坐标点 (x, y) 知道它下面是哪个（可能是不规则的）图形？
  - **Konva 的巧妙方案**:
    1.  **双画布**: 每个 `Layer` 除了有用于显示的 `sceneCanvas`，还有一个在内存中、大小完全相同的 `hitCanvas`。
    2.  **颜色键 (`colorKey`)**: 每个 `Shape` 在初始化时，都会被分配一个**全局唯一的随机颜色**，并建立 `Map<colorKey, Shape>` 的映射关系。
    3.  **同步绘制**: 当在 `sceneCanvas` 上绘制一个图形时，**同时**在 `hitCanvas` 的相同位置用它的 `colorKey` 作为填充色绘制完全相同的形状。
    4.  **拾取**: 当用户点击时，获取点击坐标。然后使用 `getImageData(x, y, 1, 1)` 方法读取 `hitCanvas` 上该像素点的颜色。
    5.  **查找**: 根据读取到的颜色值（即 `colorKey`），从映射表中瞬间找到对应的 `Shape` 对象。
  - **评价**: 这是一个非常聪明的“空间换时间”的方案。它将复杂的几何碰撞检测问题，转换成了一次简单的颜色读取和哈希表查找，对不规则图形的拾取效率极高。

---

### 4. 高级功能

- **滤镜 (Filter)**: Konva 的滤镜是基于离屏渲染和 `getImageData` 实现的。它将需要应用滤镜的图形先绘制到一个离屏 Canvas 上，然后获取其像素数据 (`ImageData`)，对数据进行逐像素处理，最后再用 `putImageData` 写回，并最终绘制到主画布上。
- **选择器 (Selector)**: 实现了类似 CSS 的选择器 (`#id`, `.name`, `TypeName`)，通过 `find()` 方法遍历场景图树，并使用 `_isMatch` 方法进行匹配，方便开发者快速查找节点。
- **序列化 (Serialization)**: `toObject()` 方法可以将整个 `Stage` 的结构和属性导出为一份 JSON 数据，`_createNode()` 则可以根据这份 JSON 反向构建出整个场景图。这为**服务端渲染 (SSR)** 提供了可能性。

---

### 5. 生态集成

- **React (`react-konva`)**: Konva 的 React 版本没有采用简单的组件包装，而是使用了更底层的 **`react-reconciler`**。它实现了一套自定义的 `hostConfig`，告诉 React 如何创建 (`new Konva.Rect`)、添加 (`parent.add(child)`)、删除 (`child.destroy()`) Konva 的节点。这使得 `react-konva` 成为 React 的一个“一等公民”渲染器，就像 `react-dom` 和 `react-native` 一样。
- **Vue (`vue-konva`)**: Vue 版本的实现相对直接，通过 `Vue.use` 注册插件，将每个 Konva 节点封装成一个 Vue 组件，并在 Vue 的生命周期钩子（`created`, `updated`, `destroyed`）中调用 Konva 实例的相应方法。

---

### 6. 局限性分析

作者在文末指出了 Konva 的一个重要性能缺陷：**缺少脏矩形（Dirty Rectangle）渲染**。

- **问题**: 当 `Layer` 中有大量图形时，即使只更新其中一个很小的 `Shape`，Konva 默认会重绘整个 `Layer` 的 `<canvas>`。
- **理想方案 (脏矩形)**: 只计算出发生变化的区域（脏区），并只重绘这个小区域内的内容。这需要更精确的包围盒计算和碰撞检测能力。
- **结论**: 由于 Konva 在这方面的缺失，其在复杂场景下的渲染性能相比 ZRender 等实现了脏矩形优化的库要稍逊一筹。

### 总结

这篇文章是一篇典范级的源码解析文章。它不仅清晰地解释了 KonvaJS 的各项功能是如何实现的，更重要的是揭示了其背后的设计思想和技术权衡，特别是其精妙的“取色值法”事件系统和基于 `react-reconciler` 的深度集成方案，让读者对 Canvas 渲染引擎的设计有了非常深刻的理解。
