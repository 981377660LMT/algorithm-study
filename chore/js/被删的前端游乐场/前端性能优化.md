# 前端性能优化--归纳篇

性能优化不是一劳永逸的解决方案，项目在发展过程，代码不断地迭代和变更。
越是使用时间越长的产品，用户对体验的要求越高，如果出现卡顿或是加载缓慢，最坏的情况下会导致用户的流失。

1. 常见的性能优化方案
   - 1.1. 时间角度优化：减少耗时
     - 1.1.1. 1. `网络请求`优化：请求链路、数据大小
     - 1.1.2. 2. `首屏加载`优化：减少白屏、懒加载、骨架屏、SSR
     - 1.1.3. 3. `渲染过程`优化：60FPS、离屏渲染
     - 1.1.4. 4. `计算/逻辑`运行提速：拆大为小、多路并行
   - 1.2. 空间角度优化：降低资源占用：合理使用缓存、避免存在内存泄露(全局变量等)、避免复杂/异常的递归调用、享元
     - 1.2.1. 结束语
       除了遇到问题的时候进行优化，更优的方案是在工作流中搭建一个`监控性能指标`的步骤，每次变更发布前都跑一遍，发现性能下降之后进行及时的告警，推动开发者解决。

# 前端性能优化--加载流程篇

1. 常见的页面加载流程

   - 1.1. 资源获取

     - 1.1.1. 资源大小
       - 分包，例如使用 Webpack 将代码拆到不同的 bundle 包中(code splitting)
       - 移除不需要的代码(tree shaking)
       - peerDependency 来进行管理，避免多次安装依赖、以及版本不一致导致的多次打包和安装等情况
       - 资源压缩和合并(雪碧图、gzip、uglify 等)
     - 1.1.2. 资源缓存
       跟我们的资源获取的链路有关

   - 1.2. 资源加载

     - 1.2.1. 加载流程拆分
       页面可见、页面可交互
     - 1.2.2. 资源懒加载
     - 1.2.3. 资源预加载
       在页面空闲的时候，对一些用户可能会用到的资源做提前加载
       useIdleCallback

2. 复杂场景下的加载流程
   -2.1. `复杂加载流程`管理
   在 Web 端加载 VsCode
   可能需要考虑以下各个功能的加载：

   - 整体页面框架
   - 顶部菜单栏
   - 左侧工具栏
   - 底部状态栏
   - 文件目录栏
   - 文件详情
     - 内容展示
     - 编辑功能
     - 菜单功能
   - 搜索功能
   - 插件功能

   我们可以简单分成几个`加载阶段`：

   - 页面整体框架加载完成。此时可以看到`各个功能区域的分布`，包括顶部菜单栏、左侧工具栏、底部状态栏、项目内容区域等等，但这些区域的内容未必都完全加载完成。
   - `通用功能`加载完成。比如顶部菜单栏、左侧工具栏、底部状态栏等等，一些具体的菜单或是工具的功能可以做按需加载和预加载，比如搜索功能。
   - 项目`内容相关`框架加载完成。此时可以看到项目相关的内容区域，比如文件目录、当前文件的内容详情等等。
   - `插件`功能。用户安装的插件，在核心功能都加载完成之后再获取和加载。

   -2.2. 长耗时任务的`拆离`(map-reduce)
   还是回到 Web 端加载 VsCode 的场景。假设我们在加载某个特别大的文件，则可以考虑分别对该文件的内容获取、数据转换做任务拆分，比如分片获取该文件的内容，根据分片的内容做渲染的计算，计算过程如果耗时较长，也可以做异步任务的拆分，甚至可以结合 Web Worker 和 WebAssembly 等技术做更多的优化

   -2.3. 读写分离(差异化服务)
   如果用户的权限只是可读，那么对于`编辑相关的功能可以做资源拆离`，对于有权限的用户才进行编辑能力的加载

3. 结束语

# 前端性能优化--渲染篇

1. 首屏渲染
   首屏加载优化核心点在于：将页面内容尽快展示给用户，减少页面白屏时间。

   - 1.1. 首屏内容`加载`
     更常用的点是`骨架屏`、数据`分片/分屏加载`、`SSR` DOM 直出渲染这几种
     如果是想要对项目做差异化服务、做资源的拆分和优化，则可能随着项目的复杂度增加，方案难度提升、实现成本也增长
   - 1.2. 首屏内容`渲染`
     - 将 CSS 放在<head>里，可用来避免浏览器渲染的重复计算
     - 将 JavaScript 脚本放在<body>的最后面，避免资源阻塞页面渲染
     - 减少 DOM 数量，减少浏览器渲染过程中的计算耗时
     - 通过合理使用浏览器 GPU 合成，提升浏览器渲染效率

2. 页面更新
   页面内容的更新，一般有两种情况：

   1. 用户自身操作（点击、输入、拖拽等）的页面响应。
   2. 实时内容的变更（比如聊天室的消息提醒、弹幕等等）。

   - 2.1. 用户操作
     **该过程应该是优先级最高的，一般需要同步进行**

     - 2.1.1. 事件委托

   - 2.2. 页面渲染

     - 2.2.1. DOM 操作合并

     - 2.2.2. 页面滚动渲染
       以考虑仅渲染可见区域的部分

# 前端性能优化--卡顿篇

计算任务耗时太长，阻塞了浏览器的主线程，导致用户的一些操作无法及时响应

1. 卡顿优化
   大多数的渲染场景，我们都可以使用浏览器的 Performance 来录制和分析性能问题

   1.1. 赋值和取值

   1.2. 优化计算性能/内存
   在 VSCode 的 1.21 发布版本中包含了一项重大改进：全新的文本缓冲区实现，在内存和速度方面都有大幅的性能提升。
   https://code.visualstudio.com/blogs/2018/03/23/text-buffer-reimplementation

   1.3. 大任务拆解
   考虑将任务执行耗时控制在 50 ms 左右。每执行完一个任务，如果耗时超过 50 ms，将剩余任务设为异步，放到下一次执行，给到页面响应用户操作和更新渲染的时间

   1.4. 其他计算优化

2. 卡顿的监控和定位
   2.1. Performance
   2.2. requestAnimationFrame
   一般来说我们监控卡顿，可以考虑使用 window.requestAnimationFrame 方法。该方法会在绘制下一帧绘制前被调用，这意味着`当前的同步计算任务即将结束`。
   卡顿大多数是因为长耗时的计算任务导致的。那么，我们就可以考虑在某个函数执行之前记下时间戳，而在 window.requestAnimationFrame 的时候再取其中的时间差，判断当前函数的执行耗时是否合理。
3. 结束语
   大多数的卡顿场景，都是由于页面渲染掉帧导致的。因此针对页面的更新渲染，不管是 DOM 渲染还是 Canvas 渲染，需要注意将帧率保持在 50~60 FPS 的范围内，这样用户的体验会流程很多。

# 前端性能优化--Canvas 篇

1. Canvas 性能优化

   - 1.1. Canvas 上下文切换
     context 不是一个普通的对象，当我们对其赋值的时候，性能开销远大于普通对象
     可以考虑使用先将相同样式的绘制内容收集起来，结合享元的方式将其维护起来。在绘制的时候，则可以针对每种样式做切换，切换后`批量绘制相同样式的所有内容`
   - 1.2. Canvas 拆分
     我们在 Canvas 里绘制的内容，都可以根据`变更频率`来拆分，简称动静分离。
     Canvas 拆分的关键点在于：尽量避免进行不必要的渲染，减少频繁变更的渲染范围。

     - 1.2.1. 绘制范围的拆分
       假设我们现在需要实现 Web 端 VsCode，而整个界面都是由 Canvas 绘制（当然这样不大合理，这里假设只是为了更好地举例）。
       我们可以简单地将 VsCode 拆分成几个区域：顶部栏、左侧栏、底部栏、编辑区。显然这个几个区域的`变更频率、触发变更`的前提都不一致，我们可以将其做拆分。
     - 1.2.2. 堆叠层次的拆分

     - 1.2.3. Canvas 拆分的开销

   - 1.3. 离屏渲染
     使用一个不可见（或是屏幕外）的 Canvas 对即将渲染的内容的某部分进行提前绘制，然后频繁地将屏幕外图像渲染到主画布上，避免重复生成该部分内容的步骤。

     - 1.3.1. 各种离屏渲染场景
       (1) 使用离屏 Canvas 提前绘制特定内容。
       (2) 使用双 Canvas 交替绘制。
       (3) 使用 OffscreenCanvas 达到真正的离屏。
     - 1.3.2. OffscreenCanvas API 能力

   - 1.4. 其他 Canvas 优化方式
     做内容的增量更新渲染，避免频繁地绘制大范围的内容

     - 1.4.1. 增量渲染
       recycle 机制

       假设我们的画布内容支持向下滚动，那么我们在滚动的时候可以考虑：

       - 根据滚动的距离，将上一帧可复用的内容做裁剪保存
       - 在下一帧绘制中，先将上一帧中重复的内容在新的位置绘制
       - 原有内容绘制完成后，新增的部分内容再进行重新绘制
         通过这样的方式，可以节省掉一部分的内容绘制和生成过程，提升每次渲染的速度。

# 前端性能优化--容器篇

本文中提到的容器，基本上都是指 `Web 页面的宿主`，比如浏览器、APP 客户端、小程序，它们提供了 WebView 环境来运行 Web 应用。

1. 容器性能优化
   - 1.1. 加速页面打开
     - 1.1.1. 资源准备
     - 1.1.2. 预加载
   - 1.2. 加速页面切换
     - 1.2.1. 容器预热
     - 1.2.2. 容器切换
     - 1.2.3. 客户端直出渲染
2. 结束语

# 前端性能优化--SSR 篇

SSR 指 Server-Side Rendering，即服务端渲染，属于首屏直出渲染的一种方案

1. SSR 性能优化
   - 1.1. SSR 渲染方案
     - 1.1.1. 框架自带 SSR 渲染
     - 1.1.2. 同构 SSR 渲染：一份代码可分别在服务器和客户端上运行
     - 1.1.3. 非同构 SSR 渲染
   - 1.2. SSR 利弊

# 前端性能优化--项目管理篇

1. 确定优化的`目标和预期`
2. 确定`技术方案`
3. 项目排期和执行
   3.1. 进行合理的分工`排期`
   3.2. 对项目`风险`进行把控
4. 进行`项目复盘`
   结束语
