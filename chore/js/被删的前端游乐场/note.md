https://godbasin.github.io/categories/
https://godbasin.github.io/front-end-playground/front-end-basic/front-end/front-end-1.html

# 前端 CHANGELOG 生成指南

https://godbasin.github.io/2019/11/10/change-log/
https://zhuanlan.zhihu.com/p/51894196

conventional-changelog
主要介绍 commitizen、conventional-changelog-cli 、standard-version 这三工具了。

# 数据驱动 vs 事件驱动

事件驱动

构建页面：设计 DOM => 生成 DOM => 绑定事件
监听事件：操作 UI => 触发事件 => 响应处理 => 更新 UI

数据驱动

构建页面：设计数据结构 => 事件绑定逻辑 => 生成 DOM
监听事件：操作 UI => 触发事件 => 响应处理 => 更新数据 => 更新 UI
在使用数据驱动的时候，模板渲染的事情会交给框架去完成，我们需要做的就是数据处理而已。

# 前端模板引擎流程

https://godbasin.github.io/2017/10/21/template-engine/
数据绑定已经作为一个框架最基础的功能。我们常常使用的单向绑定、双向绑定、事件绑定、样式绑定等，里面具体怎么实现，而当我们数据变动的时候又会触发怎样的底部流程呢

`模板生成 AST => AST 生成模板 => 数据/事件/属性绑定的监听 => 数据变更 Diff => 局部更新模板`

1. 模板数据绑定
   1.1. 解析语法生成 AST
   1.1.1. 捕获特定语法
   1.1.2. DOM 元素捕获
   1.1.3. 数据绑定捕获
   1.2. AST 生成模版
   1.2.1. 生成模版的方法
   1.2.2. 浏览器的渲染机制
2. 模版数据更新
   2.0.1. 数据更新监听
   脏监测/getter-setter/手动更新
   脏检测是 Angular 的一大特色。由于事件触发的时候，并不能知道哪些数据会有变化，所以会进行大面积数据的新旧值 Diff，这也毫无疑问会导致一些性能问题。在 Angular2 版本之后，由于使用了`zone.js对异步任务进行跟踪，把这个计算放进worker，完了更新回主线程`，是个类似多线程的设计，也提升了性能。

   2.0.2. 数据更新 Diff

# 页面区块化与应用组件化

1. 页面区块化
   - 1.1. 什么是区块
2. 应用组件化

   - 2.1. 什么是组件
     组件可以扩展 HTML 元素，封装可重用的代码。

   - 2.2. 组件的划分

     1. 视觉和交互上是一个完整的组件。
     2. 写代码的时候，可重复的内容即可视为一个组件。

     在一个团队内，最好是使用一种方式来进行划分。因为对于成员的相互配合和项目的维护来说，统一的规范是比较重要的。

   - 2.3. 组件的封装
     - 2.3.1. 组件内维护自身的数据和状态
     - 2.3.2. 组件内维护自身的事件
     - 2.3.3. 通过初始化事件，来初始化组件状态，激活组件
     - 2.3.4. 对外提供配置项，来控制展示以及具体功能
     - 2.3.5. 通过对外提供查询接口，可获取组件状态
   - 2.4. 组件的通信
   - 2.5. 组件化程度
     组件的封装是会消耗维护性的，过度的封装会导致代码难维护，可读性也差。所以我们需要根据项目的大小以及复杂度，来进行什么程度的封装
     适度也是很重要的，个人认为`好的架构是变化的，跟随着项目变化而变化，保持着拓展性和维护性`。如果说我们只是为了抽象而抽象，那想必会把简单的事情复杂化，整个应用和代码会变得难以理解。适度的抽象很重要，但相比错误的抽象过程，没有抽象可能会更好。

# 一个组件的自我修养

1. 组件的划分
   1.1. 通过视觉和交互划分
   1.2. 通过代码复用划分
2. 组件的封装
   2.1. 独立的组件 -> 维护自身数据、事件
   2.2. 组件与外界 -> 对外提供钩子、配置项、查询接口(获取组件状态)

# 组件配置化

1. 配置化思想

   - 1.1. 可配置的数据
     - 1.1.1. 应用中的可配置数据
       搭起一整套的运营管理平台，一些简单的文字或是数据，则可以通过平台进行配置
     - 1.1.2. 代码中的可配置数据
       常量配置
     - 1.1.3. 文件里的可配置数据
       把这样的可配置数据，单独写到某个文件里维护。当需要调整的时候，只需要下发一个配置文件就好啦
   - 1.2. 可配置的接口
     配置化的实现有两点很重要的东西：`规范`和`解决方案`。如果说目前较好的从前端到后台的规范，可能 GrapgQL 和 Restful ，大家不熟悉的也可以去看看啦。

   - 1.3. 可配置的页面

     这种页面的配置，基本上有两种实现方式：

     - 配置后`生成静态页面`的代码，直接加载生成的页面代码。
       适用于一些移动端的模版页面开发，例如简单的活动页面、商城页面等等
     - 写通用的配置化逻辑，在`加载页面的时候拉取配置数据，动态生成页面`。
       一些管理平台的实现，毕竟大多数都是增删查改，形式无非列表、表单和菜单等

   - 1.4. 可配置的应用

2. 组件配置化

   - 2.1. 可配置的数据
   - 2.2. 可配置的样式

     - 2.2.1. 根据子元素配置 CSS （缺点：`DOM 结构调整影响大`）
     - 2.2.2. 根据子 class 配置 CSS（BEM，`缺点：名字太长`）
       block：可以与组件和模块对应的命名，如 card、dialog 等
       element：元素，如 header、footer 等
       modifier：修饰符，可视作状态等描述，如 actived、closed 等

       ```less
       .my-dialog {
        background: white;
        &__header {}
        &__section {}
        &__footer {}
        &__btn {
          &--inactived
        }
       }
       ```

       当然，如今很多框架都支持样式的作用域，通常是通过在 class 里添加随机 MD5 等，来保持局部作用域的 class 样式。常见的话，我们是搭配第一和第二种方式一起使用的。

   - 2.3. 可配置的展示
   - 2.4. 可配置的功能
     灰度？

配置化思想：**把相似的部分提取出来抽象封装，把可变的部分结合配置来高效地调整（interface、config、event）**

# 数据抽离与数据管理

从事件驱动脱离，来到了数据驱动的世界
在把数据与逻辑分离到极致的时候，你再看一个应用，会看到一具静态的逻辑躯壳，以及数据如灵魂般地注入到应用里，使其获得生命。

**数据的抽离，其实与配置化的思想有相通的地方**，即把可变部分分离，然后通过注入的方式，来实现具体的功能和展示。

1. 应用数据抽离
   - 1.1. 状态数据(state)
     怎么定义状态数据？最浅显的办法就是`这些数据，可以直接影响模块的状态`，如对话框的出现、隐藏，标签的激活、失活，长流程的当前步骤等
   - 1.2. 动态数据(props)
     不会跟随着应用的生命周期而改变，也不会随着应用的关闭而消失。它们独立存在于外界，通过注入的方式进入应用，并影响具体的展示和功能逻辑
     例如从数据库拉取回来的
   - 1.3. 将数据与应用抽离
     办公室上班例子，人涌入公司，给公司注入灵魂，公司得以运作。
     我们要做的，不只是如何划分数据、将数据与应用`抽离`，我们还需要将其有规律地`管理`。
2. 应用数据管理

   - 2.1. 数据的流动

     - 2.1.1. 事件通知(event)
       事件通知机制很方便，可以随意地定义触发的时机，也可以任意地点使用监听或是触发。
       但事件机制的弊端也是很明显，就是每一个事件的触发对应一个监听，关系是一一对应。在整个应用中看，则是`散落在各处，随意乱窜的数据流动`。需要定位的时候，只能通过`全局搜索`的方式来跟踪数据的去向。
       当然，也有些人会定义一个**中转站，所有的事件数据流都会经过那**，这样的维护方式会有所改善。
     - 2.1.2. 共享对象(store) 通过注入对象的引用，来在不同组件中获取相同的数据源
     - 2.1.3. 单方向流动(setState) Vuex、Redux
     - 2.1.4. 树状作用域(context) golang 的 context

   - 2.2. 适度的管理
     一个状态管理工具则可以轻松解决乱糟糟的数据流问题

# 前端构建大型应用(2018 年文)

1. 项目设计
   定位: to B/C，大小，框架和工具的选型，项目和团队规范

   - 1.1. 框架选择
     - 1.1.1. Angular
       这里的 Angular 是指 Angular 2.0+ 版本，v1.0 我们通常称之为 AngularJS，目前已经不更新了
       项目中使用 Angular，最大的体验感受则是项目`有完备的结构和规范`，新加入的成员能很快地通过复制粘贴完成功能的开发。身边有- 人说过，`好的架构设计，能让高级程序员和初入门的程序员写出相似的代码`，这样对于整体管理和项目的维护有非常好的体验。
       很多人说 Angular 难上手，其实主要在于开始的项目搭建、以及 Angular 独有的一套设计方案的理解。
       但是依赖注入的设计方式，我们`几乎不用考虑很多数据和状态管理的问题`。当然脏检查的方式曾经也带来性能问题，后面在加入树状的模块化、Zone.js 之后，即使没有虚拟 DOM，性能也是有大大的提升。
       > https://godbasin.github.io/2021/05/01/angular-design-zonejs/ zonejs
     - 1.1.2. React
     - 1.1.3. Vue
     - 1.1.4. 开源框架？
   - 1.2. 项目代码结构
     就是公共组件、工具等同类的文件，放置一起维护会比较好。而且还有个小 tips，我们可以在搭建项目的时候，在 README.md 里面描述下该项目下的代码和文件结构
   - 1.3. 代码流程规范

2. 大型应用优化

   - 2.1. 路由管理
   - 2.2. 抽象和组件化
     在我们开始写重复的代码、或是进行较多的复制粘贴的时候，大概我们需要考虑对组件进行适当的抽象了。
     > 不过 copilot 用多了，好像注意不到？？？
   - 2.3. 状态和数据管理
   - 2.4. 代码打包
     - 2.4.1. 路由异步加载
     - 2.4.2. Webpack 分块打包
     - 2.4.3. Source map
     - 2.4.4. Tree-shaking
   - 2.5. 编写可测试代码
     项目中功能的快速迭代、开发工作量饱满等原因，导致甚至单元测试这种都很少编写。Emmmmm。。。

# Angular 框架解读--Zone 区域之 zone.js

https://blog.csdn.net/kingslave1/article/details/135630112

提供了一种跟踪和管理异步操作的机制。它的核心概念是 Zone，它可以帮助我们捕获和处理异步操作的上下文
Zone 在 Angular 中有很多用途

1. 变更检测
   Angular 的变更检测机制是依赖于 zone.js 的
   每当发生异步操作时，zone.js 会通知 Angular 进行变更检测，以确保视图能够及时更新
2. 错误处理
   捕获和处理异步操作中的错误
3. 性能监控
   监控异步操作的执行时间，以便评估和优化应用程序的性能

- NgZone：Angular 中的 zone.js
  当我们在 Angular 应用程序中执行异步操作时，NgZone 会自动创建一个 Zone，并把这些操作放入该 Zone 中。这样做的好处是，我们可以在异步操作完成后触发变更检测，以确保视图能够及时更新
  通过使用 NgZone 的 run()方法，我们确保异步任务的结束能够触发变更检测

## 原理

https://godbasin.github.io/2021/05/01/angular-design-zonejs/
https://juejin.cn/post/6859348400463314951
https://segmentfault.com/a/1190000044163634
https://github.com/JLQmiller/angularindepth/blob/master/articles/angular-35.%5B%E7%BF%BB%E8%AF%91%5D-%E7%BF%BB%E9%98%85%E6%BA%90%E7%A0%81%E5%90%8E%EF%BC%8C%E6%88%91%E7%BB%88%E4%BA%8E%E7%90%86%E8%A7%A3%E4%BA%86Zone.js.md
https://ithelp.ithome.com.tw/m/articles/10220772

context???

zone.js 接管了浏览器提供的异步 API，比如点击事件、计时器等等。也正是因为这样，它才能够对异步操作有更强的控制介入能力，提供更多的能力。
为每个点击函数安排了一个事件任务

先了解 run 与 runOutsideAngular 两个 API 即可
