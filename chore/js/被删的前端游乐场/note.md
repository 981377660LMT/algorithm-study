https://godbasin.github.io/categories/
https://godbasin.github.io/front-end-playground/front-end-basic/front-end/front-end-1.html

# 前端 CHANGELOG 生成指南

https://godbasin.github.io/2019/11/10/change-log/
https://zhuanlan.zhihu.com/p/51894196

conventional-changelog
主要介绍 commitizen、conventional-changelog-cli 、standard-version 这三工具了。

# 数据驱动 vs 事件驱动

事件驱动

构建页面：设计 DOM => 生成 DOM => 绑定事件
监听事件：操作 UI => 触发事件 => 响应处理 => 更新 UI

数据驱动

构建页面：设计数据结构 => 事件绑定逻辑 => 生成 DOM
监听事件：操作 UI => 触发事件 => 响应处理 => 更新数据 => 更新 UI
在使用数据驱动的时候，模板渲染的事情会交给框架去完成，我们需要做的就是数据处理而已。

# 前端模板引擎流程

https://godbasin.github.io/2017/10/21/template-engine/
数据绑定已经作为一个框架最基础的功能。我们常常使用的单向绑定、双向绑定、事件绑定、样式绑定等，里面具体怎么实现，而当我们数据变动的时候又会触发怎样的底部流程呢

`模板生成 AST => AST 生成模板 => 数据/事件/属性绑定的监听 => 数据变更 Diff => 局部更新模板`

1. 模板数据绑定
   1.1. 解析语法生成 AST
   1.1.1. 捕获特定语法
   1.1.2. DOM 元素捕获
   1.1.3. 数据绑定捕获
   1.2. AST 生成模版
   1.2.1. 生成模版的方法
   1.2.2. 浏览器的渲染机制
2. 模版数据更新
   2.0.1. 数据更新监听
   脏监测/getter-setter/手动更新
   脏检测是 Angular 的一大特色。由于事件触发的时候，并不能知道哪些数据会有变化，所以会进行大面积数据的新旧值 Diff，这也毫无疑问会导致一些性能问题。在 Angular2 版本之后，由于使用了`zone.js对异步任务进行跟踪，把这个计算放进worker，完了更新回主线程`，是个类似多线程的设计，也提升了性能。

   2.0.2. 数据更新 Diff

# 页面区块化与应用组件化

1. 页面区块化
   - 1.1. 什么是区块
2. 应用组件化

   - 2.1. 什么是组件
     组件可以扩展 HTML 元素，封装可重用的代码。

   - 2.2. 组件的划分

     1. 视觉和交互上是一个完整的组件。
     2. 写代码的时候，可重复的内容即可视为一个组件。

     在一个团队内，最好是使用一种方式来进行划分。因为对于成员的相互配合和项目的维护来说，统一的规范是比较重要的。

   - 2.3. 组件的封装
     - 2.3.1. 组件内维护自身的数据和状态
     - 2.3.2. 组件内维护自身的事件
     - 2.3.3. 通过初始化事件，来初始化组件状态，激活组件
     - 2.3.4. 对外提供配置项，来控制展示以及具体功能
     - 2.3.5. 通过对外提供查询接口，可获取组件状态
   - 2.4. 组件的通信
   - 2.5. 组件化程度
     组件的封装是会消耗维护性的，过度的封装会导致代码难维护，可读性也差。所以我们需要根据项目的大小以及复杂度，来进行什么程度的封装
     适度也是很重要的，个人认为`好的架构是变化的，跟随着项目变化而变化，保持着拓展性和维护性`。如果说我们只是为了抽象而抽象，那想必会把简单的事情复杂化，整个应用和代码会变得难以理解。适度的抽象很重要，但相比错误的抽象过程，没有抽象可能会更好。

# 一个组件的自我修养

1. 组件的划分
   1.1. 通过视觉和交互划分
   1.2. 通过代码复用划分
2. 组件的封装
   2.1. 独立的组件 -> 维护自身数据、事件
   2.2. 组件与外界 -> 对外提供钩子、配置项、查询接口(获取组件状态)

# 组件配置化

1. 配置化思想

   - 1.1. 可配置的数据
     - 1.1.1. 应用中的可配置数据
       搭起一整套的运营管理平台，一些简单的文字或是数据，则可以通过平台进行配置
     - 1.1.2. 代码中的可配置数据
       常量配置
     - 1.1.3. 文件里的可配置数据
       把这样的可配置数据，单独写到某个文件里维护。当需要调整的时候，只需要下发一个配置文件就好啦
   - 1.2. 可配置的接口
     配置化的实现有两点很重要的东西：`规范`和`解决方案`。如果说目前较好的从前端到后台的规范，可能 GrapgQL 和 Restful ，大家不熟悉的也可以去看看啦。

   - 1.3. 可配置的页面

     这种页面的配置，基本上有两种实现方式：

     - 配置后`生成静态页面`的代码，直接加载生成的页面代码。
       适用于一些移动端的模版页面开发，例如简单的活动页面、商城页面等等
     - 写通用的配置化逻辑，在`加载页面的时候拉取配置数据，动态生成页面`。
       一些管理平台的实现，毕竟大多数都是增删查改，形式无非列表、表单和菜单等

   - 1.4. 可配置的应用

2. 组件配置化

   - 2.1. 可配置的数据
   - 2.2. 可配置的样式

     - 2.2.1. 根据子元素配置 CSS （缺点：`DOM 结构调整影响大`）
     - 2.2.2. 根据子 class 配置 CSS（BEM，`缺点：名字太长`）
       block：可以与组件和模块对应的命名，如 card、dialog 等
       element：元素，如 header、footer 等
       modifier：修饰符，可视作状态等描述，如 actived、closed 等

       ```less
       .my-dialog {
        background: white;
        &__header {}
        &__section {}
        &__footer {}
        &__btn {
          &--inactived
        }
       }
       ```

       当然，如今很多框架都支持样式的作用域，通常是通过在 class 里添加随机 MD5 等，来保持局部作用域的 class 样式。常见的话，我们是搭配第一和第二种方式一起使用的。

   - 2.3. 可配置的展示
   - 2.4. 可配置的功能
     灰度？

配置化思想：**把相似的部分提取出来抽象封装，把可变的部分结合配置来高效地调整（interface、config、event）**

# 数据抽离与数据管理

从事件驱动脱离，来到了数据驱动的世界
在把数据与逻辑分离到极致的时候，你再看一个应用，会看到一具静态的逻辑躯壳，以及数据如灵魂般地注入到应用里，使其获得生命。

**数据的抽离，其实与配置化的思想有相通的地方**，即把可变部分分离，然后通过注入的方式，来实现具体的功能和展示。

1. 应用数据抽离
   - 1.1. 状态数据(state)
     怎么定义状态数据？最浅显的办法就是`这些数据，可以直接影响模块的状态`，如对话框的出现、隐藏，标签的激活、失活，长流程的当前步骤等
   - 1.2. 动态数据(props)
     不会跟随着应用的生命周期而改变，也不会随着应用的关闭而消失。它们独立存在于外界，通过注入的方式进入应用，并影响具体的展示和功能逻辑
     例如从数据库拉取回来的
   - 1.3. 将数据与应用抽离
     办公室上班例子，人涌入公司，给公司注入灵魂，公司得以运作。
     我们要做的，不只是如何划分数据、将数据与应用`抽离`，我们还需要将其有规律地`管理`。
2. 应用数据管理

   - 2.1. 数据的流动

     - 2.1.1. 事件通知(event)
       事件通知机制很方便，可以随意地定义触发的时机，也可以任意地点使用监听或是触发。
       但事件机制的弊端也是很明显，就是每一个事件的触发对应一个监听，关系是一一对应。在整个应用中看，则是`散落在各处，随意乱窜的数据流动`。需要定位的时候，只能通过`全局搜索`的方式来跟踪数据的去向。
       当然，也有些人会定义一个**中转站，所有的事件数据流都会经过那**，这样的维护方式会有所改善。
     - 2.1.2. 共享对象(store) 通过注入对象的引用，来在不同组件中获取相同的数据源
     - 2.1.3. 单方向流动(setState) Vuex、Redux
     - 2.1.4. 树状作用域(context) golang 的 context

   - 2.2. 适度的管理
     一个状态管理工具则可以轻松解决乱糟糟的数据流问题

# 前端构建大型应用(2018 年文)

1. 项目设计
   定位: to B/C，大小，框架和工具的选型，项目和团队规范

   - 1.1. 框架选择
     - 1.1.1. Angular
       这里的 Angular 是指 Angular 2.0+ 版本，v1.0 我们通常称之为 AngularJS，目前已经不更新了
       项目中使用 Angular，最大的体验感受则是项目`有完备的结构和规范`，新加入的成员能很快地通过复制粘贴完成功能的开发。身边有- 人说过，`好的架构设计，能让高级程序员和初入门的程序员写出相似的代码`，这样对于整体管理和项目的维护有非常好的体验。
       很多人说 Angular 难上手，其实主要在于开始的项目搭建、以及 Angular 独有的一套设计方案的理解。
       但是依赖注入的设计方式，我们`几乎不用考虑很多数据和状态管理的问题`。当然脏检查的方式曾经也带来性能问题，后面在加入树状的模块化、Zone.js 之后，即使没有虚拟 DOM，性能也是有大大的提升。
       > https://godbasin.github.io/2021/05/01/angular-design-zonejs/ zonejs
     - 1.1.2. React
     - 1.1.3. Vue
     - 1.1.4. 开源框架？
   - 1.2. 项目代码结构
     就是公共组件、工具等同类的文件，放置一起维护会比较好。而且还有个小 tips，我们可以在搭建项目的时候，在 README.md 里面描述下该项目下的代码和文件结构
   - 1.3. 代码流程规范

2. 大型应用优化

   - 2.1. 路由管理
   - 2.2. 抽象和组件化
     在我们开始写重复的代码、或是进行较多的复制粘贴的时候，大概我们需要考虑对组件进行适当的抽象了。
     > 不过 copilot 用多了，好像注意不到？？？
   - 2.3. 状态和数据管理
   - 2.4. 代码打包
     - 2.4.1. 路由异步加载
     - 2.4.2. Webpack 分块打包
     - 2.4.3. Source map
     - 2.4.4. Tree-shaking
   - 2.5. 编写可测试代码
     项目中功能的快速迭代、开发工作量饱满等原因，导致甚至单元测试这种都很少编写。Emmmmm。。。

# Angular 框架解读--Zone 区域之 zone.js

https://blog.csdn.net/kingslave1/article/details/135630112

提供了一种跟踪和管理异步操作的机制。它的核心概念是 Zone，它可以帮助我们捕获和处理异步操作的上下文
Zone 在 Angular 中有很多用途

1. 变更检测
   Angular 的变更检测机制是依赖于 zone.js 的
   每当发生异步操作时，zone.js 会通知 Angular 进行变更检测，以确保视图能够及时更新
2. 错误处理
   捕获和处理异步操作中的错误
3. 性能监控
   监控异步操作的执行时间，以便评估和优化应用程序的性能

- NgZone：Angular 中的 zone.js
  当我们在 Angular 应用程序中执行异步操作时，NgZone 会自动创建一个 Zone，并把这些操作放入该 Zone 中。这样做的好处是，我们可以在异步操作完成后触发变更检测，以确保视图能够及时更新
  通过使用 NgZone 的 run()方法，我们确保异步任务的结束能够触发变更检测

## 原理

https://godbasin.github.io/2021/05/01/angular-design-zonejs/
https://juejin.cn/post/6859348400463314951
https://segmentfault.com/a/1190000044163634
https://github.com/JLQmiller/angularindepth/blob/master/articles/angular-35.%5B%E7%BF%BB%E8%AF%91%5D-%E7%BF%BB%E9%98%85%E6%BA%90%E7%A0%81%E5%90%8E%EF%BC%8C%E6%88%91%E7%BB%88%E4%BA%8E%E7%90%86%E8%A7%A3%E4%BA%86Zone.js.md
https://ithelp.ithome.com.tw/m/articles/10220772

context???

zone.js 接管了浏览器提供的异步 API，比如点击事件、计时器等等。也正是因为这样，它才能够对异步操作有更强的控制介入能力，提供更多的能力。
为每个点击函数安排了一个事件任务

先了解 run 与 runOutsideAngular 两个 API 即可

# 数据库事务

- 所谓事务是用户定义的一个数据库操作序列，这些操作要么全做要么全不做，是一个不可分割的工作单位。
  当事务被提交给了 DBMS（数据库管理系统），则 DBMS（数据库管理系统）需要确保该事务中的所有操作都成功完成且其结果被永久保存在数据库中，如果事务中有的操作没有成功完成，则事务中的所有操作都需要被回滚，回到事务执行前的状态;同时，该事务对数据库或者其他事务的执行无影响，所有的事务都好像在独立的运行。

- 数据库事务拥有以下四个特性，习惯上被称之为 ACID 特性。

  - 原子性（Atomicity）：包含在其中的对数据库的操作要么全部被执行，要么都不执行；一个事务是不可分割的，事务中的任何一条 SQL 执行失败，已经执行成功的语句也必须撤销，`状态回退`到执行事务之前。
  - 一致性（Consistency）：一个事务执行之前和执行之后都必须处于一致性状态。拿转账来说，假设用户 A 和用户 B 两者的钱加起来一共是 5000，那么不管 A 和 B 之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是 5000，这就是事务的一致性。
  - 隔离性（Isolation）：数据库中的数据应满足完整性约束，事务开始和结束之间的`中间状态不会被其他事务看到`
  - 持久性（Durability）：已被提交的事务对数据库的修改应该`永久保存在数据库中`。即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。

    一般来说，事务的 ACID 由 RDBMS 来实现的，`RDBMS 采用日志来保证事务的原子性，一致性，持久性。采用锁的机制来实现事务的隔离性`。

- 事务的隔离级别
  在事务并发操作时，可能出现的问题有：

  - 脏读：一个事务读取到了另一个事务`未提交的数据`
  - 不可重复读：一个事务读取到了另一个事务已提交的数据，导致两次读取的数据`内容`不一致
    不可重复读出现的原因就是事务并发修改记录，要避免这种情况，最简单的方法就是对要修改的记录加锁，这回导致锁竞争加剧，影响性能。另一种方法是通过 `MVCC 可以在无锁的情况下，避免不可重复读`。
  - 幻读：一个事务读取到了另一个事务已提交的数据，导致两次读取的数据`总量`不一致。幻读是由于并发事务增加记录导致的，这个不能像不可重复读通过记录加锁解决，因为对于`新增的记录根本无法加锁。需要将事务串行化，才能避免幻读`。

  **不可重复读和幻读到底有什么区别呢？**
  (1) 不可重复读是读取了其他事务更改的数据，`针对 update 操作`
  解决：使用行级锁，锁定该行，事务 A 多次读取操作完成后才释放该锁，这个时候才允许其他事务更改刚才的数据。
  (2) 幻读是读取了其他事务新增的数据，`针对 insert 和 delete 操作`
  解决：使用表级锁，锁定整张表，事务 A 多次读取数据总量之后才释放该锁，这个时候才允许其他事务新增数据。

  脏读、幻读、不可重复读是在`并发事务`的情况下才发生的，为了解决这些问题，数据库引入了隔离级别，并且不同的隔离级别可以解决不同的问题。

  - 读未提交（Read Uncommitted）：什么都不需要做，允许脏读。所有的并发事务问题都会发生。
  - 读已提交（Read Committed）：只有在事务提交后，其更新结果才会被其他事务看见。可以解决脏读问题。Oracle 等多数数据库默认都是该级别 (不重复读)。
  - 可重复读（Repeatable Read）：保证在同一事务中多次读取同样记录的结果是一致的。可以解决不可重复读问题。MySQL/InnoDB 默认级别，可以解决脏读、不可重复读。
  - 可串行化（Serializable）：最高的隔离级别，`通过强制事务串行执行，避免了幻读问题`。可以解决脏读、不可重复读、幻读。

- MVCC（多版本并发控制）
  英文全称为 Multi-Version Concurrency Control，乐观锁为理论基础的 MVCC（多版本并发控制），`MVCC 的实现没有固定的规范。每个数据库都会有不同的实现方式。`
  mysql 中，默认的事务隔离级别是可重复读（repeatable-read），为了解决不可重复读，innodb 采用了 MVCC（多版本并发控制）来解决这一问题。
  MVCC 是利用在每条数据后面加了隐藏的两列（`创建版本号和删除版本号`）: create_version 和 delete_version，`每个事务在开始的时候都会有一个递增的版本号`。

  - 增：直接 insert，创建版本号设为当前事务的版本号
  - 删: 直接将数据的删除版本号更新为当前事务的版本号
  - 改：采用 delete+add 的方式来实现，首先将当前数据`标志为删除`，然后新增一条新的数据：
  - 查：`查询操作为了避免查询到旧数据或已经被其他事务更改过的数据`，需要满足如下条件：

    - 查询时当前事务的版本号需要大于或等于创建版本号
    - 查询时当前事务的版本号需要小于删除的版本号
      即：`create_version <= current_version < delete_version`
      这样就可以避免查询到其他事务修改的数据

- MySQL 如何解决幻读
  https://juejin.cn/post/6971741501273407518
  幻读：在一个事务中使用相同的 SQL 两次读取，第二次读取到了其他事务新插入的行，则称为发生了幻读。
  谈到幻读，首先我们要引入“当前读”和“快照读”的概念，通过名字就可以理解：

  `快照读`：生成一个事务快照（ReadView），之后都从这个快照获取数据。普通 select 语句就是快照读。(clone 一份数据?)
  `当前读`：读取数据的最新版本。常见的 update/insert/delete、还有 select ... for update、select ... lock in share mode 都是当前读。
  对于快照读，`MVCC 因为因为从 ReadView 读取，所以必然不会看到新插入的行，所以天然就解决了幻读的问题。`
  而对于当前读的幻读，MVCC 是无法解决的。需要使用 Gap Lock 或 Next-Key Lock（Gap Lock + Record Lock）来解决。
  用上面的例子稍微修改下以触发当前读：`select * from user where id < 10 for update`，当使用了 Gap Lock 时，Gap 锁`会锁住 id < 10 的整个范围，因此其他事务无法插入 id < 10 的数据`，从而防止了幻读。

- InnoDB 引擎通过什么技术来保证事务的这四个特性的呢？
  持久性是通过 redo log （重做日志）来保证的，保证可以在数据库重启后恢复数据；
  原子性是通过 undo log（回滚日志） 来保证的，保证事务失败后可以回滚；
  隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的，解决 data race；
  一致性则是通过持久性+原子性+隔离性来保证；

# 数据库索引

数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。
数据库管理系统（RDBMS）通常决定索引应该用哪些数据结构。

- B-TRee 索引
- 哈希索引
- R-Tree 索引
- 位图索引

基本原则是只如果表中某列在查询过程中使用的非常频繁，那就在该列上创建索引。

- 索引类型
  根据数据库的功能，可以在数据库设计器中创建三种索引：唯一索引、主键索引和聚簇索引。
  唯一索引：唯一索引确保列中的每个值都是唯一的。唯一索引允许空值。
  主键索引：主键索引是唯一索引的特定类型。主键索引要求列中的每个值都是唯一的，且不为空。
  聚簇索引：聚簇索引对表中的行进行排序，并将行存储在磁盘上。聚簇索引只能有一个。

# NoSQL 和关系数据库结合

一般把 NoSQL 和关系数据库进行结合使用，`各取所长`，需要使用关系特性的时候我们使用关系数据库，需要使用 NoSQL 特性的时候我们使用 NoSQL 数据库，各得其所。NoSQL 数据库是关系数据库在某些方面（性能，扩展）的一个弥补。
举个简单的例子吧，比如用户评论的存储，评论大概有主键 id、评论的对象 aid、评论内容 content、用户 uid 等字段。我们能确定的是评论内容 content 肯定不会在数据库中用 where content=’’ 查询，评论内容也是一个大文本字段。`那么我们可以把主键 id、评论对象 aid、用户 id 存储在数据库，评论内容存储在 NoSQL`，这样数据库就节省了存储 content 占用的磁盘空间，从而节省大量 IO，对 content 也更容易做 Cache。
