复杂渲染引擎架构与设计
https://godbasin.github.io/2023/05/13/render-engine-render-and-collect/

# 复杂渲染引擎架构与设计--1.收集与渲染

针对 Canvas 绘制的场景，来考虑将绘制的流程分为收集和渲染两部分

1. 渲染数据的收集
   需要在拿到数据之后，再根据页面进行排版计算，完成后才能渲染到页面
   我们需要对内容宽高进行测量，比如使用 CanvasRenderingContext2D.measureText()测量文本宽度，这依赖了浏览器环境下的 API 能力。这意味着我们无法在后台提前计算好这些数据，因此无法通过提前计算来加速渲染过程
   如果说一边计算一边绘制，则整个过程的耗时会比较长，用户也可能会看到绘制过程，该体验不是很友好。
   因此，我们可以在计算过程中，先把`要最终绘制的数据结果先收集到一起，Canvas 绘制的时候则可以直接用`。
2. 收集与绘制的功能划分
   我们可以根据绘制内容，划分为以下的收集器和渲染器：

   线段数据收集和绘制（如表头、边框线等）
   矩形数据收集和绘制（如背景色）
   图像数据收集和绘制（如图片）
   文本数据收集和绘制（如文字内容）
   其他数据收集和绘制

   层级堆叠问题：
   即相同的收集器和不同的收集器类型里，绘制内容有重叠时，需要考虑绘制堆叠的顺序。
   举个例子，`单元格的文字需要在背景色上面，也就是说单元格的绘制需要比背景色要晚。`
   这意味着我们在收集的时候，还需要给收集的数据添加堆叠顺序，在绘制的时候，则按照堆叠顺序先后绘制。
   我们使用一个收集器，通过给数据`添加渲染类型，来将不同类型的数据放在一起，方便统一管理`。
   在渲染的时候，则先根据绘制类型和堆叠顺序进行排序，再进行绘制。

3. 渲染数据享元
   将同类型同样式的渲染数据进行享元。对于样式完全一样的数据，收集器可通过对样式进行 hash 享元存储在一起。
   这样绘制的时候，就可以将样式一样的内容一起绘制，减少 Canvas 上下文的切换。

4. 结束语

# 复杂渲染引擎架构与设计--2.插件的实现

我们设计了渲染引擎，只能满足基础图形的收集和绘制，包括文本、线段、矩形、图像等。

而应用到具体的业务中，则是使用这些基础图形来绘制出业务相关的内容。
`因此，我们可以考虑将基础的能力进行封装，提供更便利的能力给到业务侧使用。`

1. 支撑业务的快速发展
   1.1. **分层封装底层能力(api)**
   由于大多数内容都是以单元格为基本单位来进行绘制的，我们则可以封装出一个提供按单元格绘制的中间层能力
   而当业务侧进行编辑操作时，更新的范围除了单个格子，也会包括整行、整列、整表、所选区域等情况，因此我们可以封装给到业务侧这些能力。

   1.2. **业务侧插件**的设计
   除了给上层业务提供封装好的能力，业务侧可以指定单元格范围进行重新渲染以外，还需要考虑另外一种的`业务拓展场景`：
   业务需要在单元格内绘制自己的内容，比如单元格背景高亮、一些特殊的图形属性单元格、图片绘制等等。
   所以我们还需要给业务提供控制单元格绘制内容的能力。

   渲染器的能力可以说是通用的能力，
   因此，我们可以考虑在收集过程中，通过提供插件的能力，让业务侧把想要绘制的内容收集起来。

2. 结束语
