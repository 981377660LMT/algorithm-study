复杂渲染引擎架构与设计
https://godbasin.github.io/2023/05/13/render-engine-render-and-collect/

# 复杂渲染引擎架构与设计--1.收集与渲染

针对 Canvas 绘制的场景，来考虑将绘制的流程分为收集和渲染两部分

1. 渲染数据的收集
   需要在拿到数据之后，再根据页面进行排版计算，完成后才能渲染到页面
   我们需要对内容宽高进行测量，比如使用 CanvasRenderingContext2D.measureText()测量文本宽度，这依赖了浏览器环境下的 API 能力。这意味着我们无法在后台提前计算好这些数据，因此无法通过提前计算来加速渲染过程
   如果说一边计算一边绘制，则整个过程的耗时会比较长，用户也可能会看到绘制过程，该体验不是很友好。
   因此，我们可以在计算过程中，先把`要最终绘制的数据结果先收集到一起，Canvas 绘制的时候则可以直接用`。
2. 收集与绘制的功能划分
   我们可以根据绘制内容，划分为以下的收集器和渲染器：

   线段数据收集和绘制（如表头、边框线等）
   矩形数据收集和绘制（如背景色）
   图像数据收集和绘制（如图片）
   文本数据收集和绘制（如文字内容）
   其他数据收集和绘制

   层级堆叠问题：
   即相同的收集器和不同的收集器类型里，绘制内容有重叠时，需要考虑绘制堆叠的顺序。
   举个例子，`单元格的文字需要在背景色上面，也就是说单元格的绘制需要比背景色要晚。`
   这意味着我们在收集的时候，还需要给收集的数据添加堆叠顺序，在绘制的时候，则按照堆叠顺序先后绘制。
   我们使用一个收集器，通过给数据`添加渲染类型，来将不同类型的数据放在一起，方便统一管理`。
   在渲染的时候，则先根据绘制类型和堆叠顺序进行排序，再进行绘制。

3. 渲染数据享元
   将同类型同样式的渲染数据进行享元。对于样式完全一样的数据，收集器可通过对样式进行 hash 享元存储在一起。
   这样绘制的时候，就可以将样式一样的内容一起绘制，减少 Canvas 上下文的切换。

4. 结束语

# 复杂渲染引擎架构与设计--2.插件的实现

我们设计了渲染引擎，只能满足基础图形的收集和绘制，包括文本、线段、矩形、图像等。

而应用到具体的业务中，则是使用这些基础图形来绘制出业务相关的内容。
`因此，我们可以考虑将基础的能力进行封装，提供更便利的能力给到业务侧使用。`

1. 支撑业务的快速发展
   1.1. **分层封装底层能力(api)**
   由于大多数内容都是以单元格为基本单位来进行绘制的，我们则可以封装出一个提供按单元格绘制的中间层能力
   而当业务侧进行编辑操作时，更新的范围除了单个格子，也会包括整行、整列、整表、所选区域等情况，因此我们可以封装给到业务侧这些能力。

   1.2. **业务侧插件**的设计
   除了给上层业务提供封装好的能力，业务侧可以指定单元格范围进行重新渲染以外，还需要考虑另外一种的`业务拓展场景`：
   业务需要在单元格内绘制自己的内容，比如单元格背景高亮、一些特殊的图形属性单元格、图片绘制等等。
   所以我们还需要给业务提供控制单元格绘制内容的能力。

   渲染器的能力可以说是通用的能力，
   因此，我们可以考虑在收集过程中，通过提供插件的能力，让业务侧把想要绘制的内容收集起来。

2. 结束语

# 复杂渲染引擎架构与设计--3.底层渲染适配

1. 多渲染方式适配

   - Canvas 渲染
   - SVG 渲染
   - DOM 渲染
   - 其他渲染方式（如 WEBGL 渲染等）

   - 1.1. 适配架构设计
     从收集器收集到的数据，通过适配的方式，转换成不同的绘制结果。举个例子，同样是一个单元格内容：

     Canvas 将需要分别绘制单元格背景（矩形）、单元格边框（线段）、单元格内容（文本）
     SVG 与 Canvas 相似，但 SVG 需要注意元素的层级关系，组合成单元格
     DOM 则可以通过一个<div>元素或是<table>/<tr>/<td>等表格元素来绘制

   - 1.2. 各种渲染方式的选择
     最常见的是 Canvas 渲染和 SVG 渲染，我们也可以从 ECharts 官网中找到两者的对比描述：
     一般来说，Canvas 更适合绘制图形元素数量较多（这一般是由数据量大导致）的图表（如热力图、地理坐标系或平行坐标系上的大规模线图或散点图等），也利于实现某些视觉特效。
     但在不少场景中，SVG 具有重要的优势：它的内存占用更低（这对移动端尤其重要）、并且用户使用浏览器内置的缩放功能时不会模糊。
     `考虑到首屏渲染的情况，Canvas 则需要一系列的数据计算和渲染过程，不适合首屏直出的方式，因此会适配上 DOM 或者 SVG 进行首屏直出。`

     谷歌表格使用了 Canvas/DOM 两种渲染方式，其中 DOM 渲染主要用于首屏直出
     金山表格使用了 Canvas/SVG 两种渲染方式，其中 SVG 渲染主要用于首屏直出
     飞书表格使用了 Canvas 渲染

     Canvas 渲染有一个比较致命的弱点：交互性很差。比如用户选择某个格子，进行拖拽、调整宽高、右键菜单等操作，在 Canvas 上是`很难命中具体的元素`的。因为 Canvas 绘制过程中并不像 DOM 和 SVG 一样有层次结构，最终的渲染结果也只是一个图像。因此，在线表格场景下大多数 Canvas 绘制都需要`结合 DOM 引擎一起，获取到用户选择的元素、处理用户交互事件，然后进行二次计算和响应。`

# 复杂渲染引擎架构与设计--4.渲染计算

1. 渲染引擎完整的数据流向

   - 1.1. 渲染引擎为什么需要计算

     - 1.1.1. 1. 分行/换行计算（计算范围：格子）

     - 1.1.2. 2. 行高计算（计算范围：整行）

     - 1.1.3. 3. 覆盖格/隐藏格计算（计算范围：整行）

     - 1.1.4. 4. 边框线计算（计算范围：整行）

2. 计算过程优化

   对于较大型的前端应用，即使并非使用 Canvas 自行排版，依然可能会面临计算耗时过大的计算任务。当然，更合理的方式是将这些`计算放在后台进行`，直接将计算完的结果给到前端使用。

   也有一些场景，尤其是前端与用户交互很重的情况下，比如游戏和重编辑的产品。这类产品`无法将计算任务放置在后端`，甚至无法将计算任务拆分到 Web Worker 进行计算，因为`请求的等待耗时、Worker 的通信耗时`都会影响用户的体验。

   对该类产品，最简单又实用的方法便是：`拆`。

   - 2.1. 将计算任务做拆分

     - 只加载和计算最少的资源，比如`首屏`的数据
     - 只进行`可视范围`内的计算和渲染更新
     - `增量`计算
     - `降级`计算，对计算任务做优先级拆分
     - 设计`任务调度器`，对计算任务做拆分，并设计优先级进行调度
       比如，React16 中新增了调度器（Scheduler），调度器能够`把可中断的任务切片处理`，能够调整优先级，重置并复用任务。
       调度器会根据任务的优先级去分配各自的过期时间，在过期时间之前按照优先级执行任务，可以在不影响用户体验的情况下去进行计算和更新。
       通过这样的方式，React 可在`浏览器空闲的时候进行调度并执行任务`。

   - 2.2. 预计算/异步计算
     还有一种同样常见的方式，便是将计算任务进行拆分后，通过`预判用户行为，提前执行将用到的计算任务`。

     举个例子，当前屏幕内的数据都已计算和渲染完毕，页面加载处于空闲时，可以提前将下一屏幕的资源获取，并进行计算。
     `这种预计算和渲染的方式，有些场景下也会称之为离屏渲染。`
     离屏渲染同样可以作用于 Canvas 绘制过程，比如使用两个 Canvas 进行交替绘制，或是使用 worker 以及浏览器提供的 OffscreenCanvas API，提前将要渲染的内容计算并渲染好，等用户进入下一屏的时候可以直接拿来使用。
     如果是`页面滚动的场景，还可以考虑复用滚动过程中重复的部分内容`，来节省待计算和渲染的任务数量。

     **例如：可以在浏览器空闲时触发排序任务**

# 复杂渲染引擎架构与设计--5.分片计算

https://godbasin.github.io/2023/09/16/render-engine-calculate-split/

1. 渲染引擎计算任务分片优化
   1.1. 核心优化方案
   本次渲染引擎计算任务分片的方案核心点在于：
   **只进行可视区域的渲染计算，非可视区域的部分做异步计算。**
   ![任务分片](%E4%BB%BB%E5%8A%A1%E5%88%86%E7%89%87.png)

   - 对于当前可视区域的部分，会进行同步的计算和渲染。
   - 对于非可视区域的部分，会进行异步分片（约 50ms 为一次计算分片）。
   - 异步计算时，会优先计算当前可视区域附近范围的部分区域。
   - `异步计算过程中，如涉及当前可视区域的变动，会触发重新渲染；对于非可视区域部分的计算，不会触发重新渲染`。
   - 对多次的操作，未计算部分的区域会进行合并计算，可减少整体的计算量。

2. 待计算区域管理
   提供了一个区域管理的能力，里面存储了未计算完成的区域。

   首先，我们提供了一个区域管理的能力，里面存储了未计算完成的区域。区域管理的能力需要满足：

   - 区域生成：生成一个区域，包括行/列范围、计算任务的类型（分行/覆盖格/边框线等）；
   - 区域合并：对两个区域进行合并，并更新区域范围；
   - 区域获取：根据提供的区域范围，获取该区域内的待计算任务；
   - 区域更新：行/列变化快速更新区域范围。
     由于渲染引擎计算的特殊性（大多数计算为按行计算），`区域考虑以行为首要维度、列为次要维度的方式来管理`，因此区域的设计大概为：

     ```ts
     export type IAreaRange = {
       // 开始行 index
       rowStart: number
       // 结束行 index
       rowEnd: number
       // 列范围 [开始列 index, 结束列 index]
       colRanges: [number, number][]
       // 行范围的计算类型
       calculateTypes: CalculateType[]
     }
     ```

   - 2.1. 区域合并
   - 2.2. 区域更新
     由于区域本身依赖了行列位置，因此当行列发生改变时，比如插入/删除/隐藏/移动（即插入+删除）等场景，我们需要及时更新区域。

3. 异步任务管理

   ```ts
   class AsyncCalculateManager {
     // 每次执行任务的耗时
     static timeForEachTask = 50

     /**
      * 跑下一次任务
      */
     private runNext() {
       if (this.timer) clearTimeout(this.timer)

       this.timer = setTimeout(() => {
         // 一个任务跑 50 ms
         const calculateRange = this.calculateRunner.calculateNextTask(
           AsyncCalculateManager.timeForEachTask
         )

         // 处理完之后，剩余任务做异步
         this.runNext()
       }, 10)
     }
   }
   ```

   `每个任务执行耗时满 50ms 后，会结束当前任务，并设置下一个异步任务。`通过这样的方式，我们将每次计算任务控制在 50ms 左右，避免计算过久而导致的卡顿问题。

   - 3.1. 异步任务设计

   - 3.2. 异步计算的问题
     - 各个计算任务之间的顺序，比如边框线依赖覆盖格、行高依赖分行等；
     - 一致性问题：确保每次计算后，行列宽高、可视区域、画布偏移等位置数据的一致性。要做到所有数据的一致性，需要对各个节点的流程做整体梳理，这里就不详细展开了。

# 复杂渲染引擎架构与设计--6.增量渲染

1. 增量渲染设计
   即更新仅需要更新的部分内容，而不是每次都重新计算和渲染

   - 1.1. React 增量渲染
     React 里结合了虚拟 DOM 以及 Fiber 引擎来实现完整的 Diff 计算和渲染调度，这些我之前在其他文章也有说过。在 React 里，状态的更新机制主要由两个步骤组成：
     1. 找出变化的组件，每当有更新发生时，协调器会做如下工作：
        调用组件 `render` 方法将 JSX 转化为虚拟 DOM
        进行虚拟 DOM Diff 并找出变化的虚拟 DOM
     2. 通知`渲染器`。渲染器接到协调器通知，将变化的组件渲染到页面上。
   - 1.2. 收集增量
     我们需要做到：

     收集：支持特定范围的渲染数据收集。
     重绘：支持特定范围的 Canvas 画布重绘。
     这里的特定范围取决于业务，可以是单元格，也可以是列。
     `更重要的增量能力在于收集过程的增量。`

2. 在线表格增量渲染

   - 2.1. 局部修改

   - 2.2. 页面滚动

# 复杂渲染引擎架构与设计--7.离屏渲染

1. 离屏渲染
   离屏渲染可以提前将更大范围的内容绘制好，在滚动时可直接取对应的区域进行截取和绘制。
   当然，两个 Canvas 的维护和绘制成本会比一个 Canvas 要更高，同时如果需要提前绘制更大区域的单元格范围，那么必然会面临一个问题：需要更多的计算和渲染消耗。
   我们可以考虑另外一个优化方案：使用 OffscreenCanvas 实现真正的离屏。
   - 1.1. OffscreenCanvas API 能力
   - 1.2. 渲染引擎与 Worker

# 复杂渲染引擎架构与设计--8.元素与事件

1. Canvas 元素选择的难题
   对于 DOM/SVG 渲染，我们可以直接使用浏览器提供的元素选择能力。在这样的场景下，不管是父子元素的管理、事件冒泡和捕获等都比较容易实现。因此，我们今天主要讨论 Canvas 渲染要如何实现元素选择。

   - **1.1. 几何检测法：点在某个多边形内**
   - 1.2. 像素检测法
   - **1.3. Canvas + DOM 交互**
     使用简单的几何检测法来获取到对应单元格位置，然后生成一个对应的 DOM 元素覆盖在对应的 Canvas 上，之后所有的交互都由这个 DOM 元素来完成
     这是一种比较简单又取巧的解决方案，但同样需要考虑一些问题：
     - 页面滚动的时候，DOM 元素是否需要跟随滚动
     - 页面发生变化的时候，DOM 元素是否需要刷新
