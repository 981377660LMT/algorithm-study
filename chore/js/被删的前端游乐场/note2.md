# 补齐 Web 前端性能分析的工具盲点

最近依然在研究大型项目，而大型项目最容易遇到的问题便是性能问题。一般来说，当我们遇到性能瓶颈的时候，才会开始去进行相应的分析。

1. 前端性能`分析工具`（Chrome DevTools）
   时间：常见耗时，如页面`加载`耗时、`渲染`耗时、`网络`耗时、`脚本执行`耗时等
   空间：资源占用，包括 CPU 占用、`内存`占用、本地`缓存`占用等
   - 1.1. Lighthouse
     - 1.1.1. 架构
     - 1.1.2. 主要功能
   - 1.2. Performance 面板
     记录和分析`运行时`性能
     - 1.2.1. 使用步骤
     - 1.2.2. 主要功能
       - 查看 FPS 图表
       - 查看 CPU 图表
       - 查看 火焰图：横轴是时间，纵轴是调用指针，调用栈最顶端的函数在最下方
       - 查看 Buttom-up：此视图可以看到某些函数对性能影响最大，并能够检查这些函数的`调用路径`
     - 1.2.3. Performance Monitor
       打开 Chrome 控制台后，按组合键 ctrl + p(Mac 快捷键为 command + p)，输入`> Show Performance Monitor`，就可以打开 Performance Monitor 性能监视器。
       CPU usage：CPU 占用率
       JS head size：JS 内存使用大小
       DOM Nodes：内存中挂载的 DOM 节点个数
       JS event listeners：事件监听数
       …：其他等等
2. 前端性能监控
   - 2.1. 合成监控
     Lighthouse 就是合成监控
   - 2.2. 真实用户监控
     性能指标上传到我们的日志服务器上
     我们要做的，则是在力所能及的地方进行打点、计算、采集、上报
3. 性能分析自动化
   - 3.1. 使用 Lighthouse
     自动化任务跑脚本的方式，使用 Lighthouse 跑分析报告
   - 3.2. Chrome DevTools Protocol
     - 3.2.1. 认识 Chrome DevTools 协议
     - 3.2.2. Chrome DevTools 协议域划分
     - 3.2.3. 与性能相关的域
     - 3.2.4. 自动化性能分析

# 前端监控体系搭建

https://godbasin.github.io/2020/10/07/monitor-and-report/

1. 前端监控体系搭建
   通常前端建立搭建监控体系，主要是为了解决两个问题：
   `如何及时发现问题、如何快速定位并解决问题。`
   一般来说，结合开发和产品的角度来看，前端监控体系需要做的事情包括：
   页面的整体`访问`情况，包括常见的 PV、UV、用户行为上报。
   页面的`性能`情况，包括加载耗时、接口耗时统计。
   ` 灰度`发布与有效的监控能力，方便及时发现问题。
   用户反馈问题，需要足够的`日志`定位问题。
   这些问题可以从两个角度来解决：`数据收集、数据上报`。

   - 1.1. 数据收集

     - 1.1.1. 异常收集
     - 1.1.2. 生命周期数据：一般来说，我们可以通过 `PerformanceTiming` 属性获取到一些生命周期相关的数据
     - 1.1.3. HTTP 测速数据
     - 1.1.4. 用户行为数据
     - 1.1.5. 用户日志

   - 1.2. 埋点方案
     - 1.2.1. 标准化埋点数据
   - 1.3. 数据上报
     - 1.3.1. 上报方式
       - 1.3.1.1. 批量上报
       - 1.3.1.2. 关键生命周期上报
       - 1.3.1.3. 用户主动提交
   - 1.4. 数据监控
     主要包括三部分的数据：
     - 性能监控
       - 网页加载性能
       - 网络请求性能
     - 异常监控
       - JS Error
     - 数据监控
       - 页面 PV/UV
       - 页面来源
     - 1.4.1. 发布过程监控
       除了自动化测试、改动相关的功能自测之外，我们`上报过程会带上每次的版本号`，同时可以根据版本来观察新版本的曲线情况

# 在线 Excel 项目到底有多刺激

腾讯文档 Excel 开发团队

1. 实时协同编辑的挑战
   说到实时协同编辑的难点，大家的第一反应基本上是`协同冲突处理`。

   - 1.1. 冲突处理
     冲突处理的解决方案其实已经相对成熟，包括：

     - 编辑锁：当有人在编辑某个文档时，系统会将这个文档锁定，避免其他人同时编辑。
     - diff-patch：基于 Git 等版本管理类似的思想，对内容进行差异对比、合并等操作，包括 GNU diff-patch、Myer’s diff-patch 等方案。
     - 最终一致性实现：包括 Operational Transformation（OT）、 Conflict-free replicated data type(CRDT，称为无冲突可复制数据类型)。

     - 1.1.1. OT 和 CRDT
       对于富文本编辑等更高级的结构，OT 用复杂性换来了对用户预期的实现，而 CRDT 则更加关注数据结构，随着数据结构的复杂度上升，算法的时间和空间复杂度也会呈指数上升的，会带来性能上的挑战。
       因此，如今大多数实时协同编辑都基于 OT 算法来实现。

       https://www.jianshu.com/p/e09ef405faf5
       **Easysync 双边 OT**
       站在 A 用户的角度，A 用户先执行了 A 操作，再执行 Follow(A,B)操作，得到预期的结果。
       B 用户来说，B 用户先执行了 B 操作，同理这时候就需要执行 Follow(B,A)操作，才能得到预期的结果。
       **本地应用的操作和协同给别人的操作不相同**，对于 A 来说，B 操作协同过来后，本地应用的是 Follow(A,B)，而协同给 B 的是 Follow(B,A)，这也是称之为双边的原因。
       Follow 函数需要保证:B(Follow(A,B(doc))) = A(Follow(B,A(doc))) = doc
       即满足`交换律`，A 和 B 互相协同后的结果是一致的，多冲突处理更加复杂。

       **基于 undo 的单边 OT (git rebase)**
       对于 B 用户来说，B 用户先执行了 B 操作，那么其实我们可以对 B 操作先执行一次 undo，让 B 用户当前的文档状态和 A 用户的初始状态一致，再执行和 A 用户同样的操作序列。
       `abc—B—abce—undo B—abc—A—abdc—Follow(A,B)—abdce`
       本地应用的操作和协同给别人的操作相同，对于 Follow 函数的要求更低，无需保证顺序 Follow 的幂等，需要额外的 undo 支持，undo 操作也需要 Follow，多冲突处理更为简单

       https://juejin.cn/post/7074092429862764575
       `版本变更提示`(现在的多维表格)这种方案只是避免了用户未知情况的版本覆盖问题，但是最终还是只能选择进行版本覆盖或者舍弃当前版本，不能解决多人协作时的冲突问题。
       **优化：版本合并(例如 ot-json?)**
       diff 和 patch 是一对工具，diff 可以比较两个内容之间的差异并记录下来，根据差异`生成一个 patch`，然后将 patch 应用于其他内容从而更新内容。
       基于字符的 diff-patch

       ```js
       import DiffMatchPatch from 'diff-match-patch'
       const dmp = new DiffMatchPatch()

       const patchA = dmp.patch_make(data, dataA)
       const result = dmp.patch_apply(patchA, dataB)
       console.log(result)
       // result 结果是一个数组，数组第一项是合并后的结果，第二项是一个 patch 是否成功的数组：
       // 注意不可避免的冲突，最大程度的保留用户的操作意图
       ```

       CRDT：CRDT (Conflict-free Replicated Data Type)即“无冲突复制数据类型”，主要被应用在分布式系统中，保证分布式应用的数据一致性。文档**协同编辑可以理解为分布式应用的一种**，它的本质是数据结构，**通过数据结构的设计保证并发操作数据的最终一致性。**
       CRDT 主要应用于分布式系统，`那么它的数据操作，都需要符合可交换性和幂等性`

       - 可交换性为了解决网络问题导致发送接收顺序不一致问题；
       - 幂等性为那么放到我们的编辑场景中，首先要保证操作的可交换性，那么我们只需要知道所有操作的顺序，最后对操作进行排序就可以了。我们可以依据每个操作的 timeStamp，对操作进行排序。每个用户都有一个 UID，多个不同用户如果出现 timeStamp 相同的情况下，我们可以按照 UID 进行升序，保证并发操作的顺序。UID 和 timeStamp 组合在一起，就保证了每一个操作都具备唯一的 ID，可以实现幂等性，`解决统一操作多次发送的问题`。

       OT 特点：需要中心化服务器、高性能、保留用户操作意图(step)、不影响内存占用、实现复杂
       CRDT 特点：去中心化、消耗内存、损失用户操作意图(数据结构读不出来)、影响内存占用、实现简单、稳定性高

       针对不同场景，我们可以选择不同的方案。

       - 如果只是想解决内容覆盖问题，没有多人协作的要求，那么推荐使用编辑锁
       - 如果有多人协作需求，但对内容的实时性要求低，那么可以考虑采用版本合并的方案
       - 如果想要实现多人实时协作，那么只能考虑采用 OT 或者 CRDT 实现协同编辑。

   - 1.2. 版本管理

     - 1.2.1. 数据版本更新
       数据版本能按照预期有序更新，需要几个前提：

       - 协同数据版本正常更新
       - 丢失数据版本成功补拉
       - 提交数据版本有序递增

     - 1.2.2. 维护数据任务队列
       要管理好这些版本，我们需要维护一个用户操作的数据队列，用来有序提交数据。这个队列的职责包括：

       - 用户操作数据正常进入队列
       - 队列任务正常提交到接入层
       - 队列任务提交异常后进行重试
       - 队列任务确认提交成功后移除

       这样一个队列可能还会面临用户突然关闭页面等可能，我们还需要维护一个缓存数据，当用户再次打开页面的时候，将用户编辑但未提交的数据再次提交到服务器。除了浏览器关闭的情况，还有用户在编辑过程中网络状况变化而导致的网络中断，这种时候我们也需要将用户的操作离线到本地，当网络恢复的时候继续上传。(indexDB)

   - 1.3. 房间管理
     但文档和一般的房间聊天不一样的地方在于，用户的操作不可丢失，同时还需要有严格的版本顺序的保证。用户的操作内容可能会很大，`例如用户复制粘贴了一个 10W、20W 的表格内容，这样的消息显然无法一次性传输完`。在这种情况下，除了考虑像 Websocket 这种需要自行进行数据压缩（HTTP 本身支持压缩）以外，我们还需要实现自己的分片逻辑。当涉及数据分片之后，紧接而来的还有如何分片、分片数据丢失的一些情况处理。
     **TODO：大 step 如何传输，如何分片、分片数据丢失**
   - 1.4. 多种通信方式

2. 每个格子都是一个富文本编辑器

   - 2.1. 富文本
   - 2.2. 复制粘贴
     复制粘贴相关功能模块复制粘贴根据使用场景可以分成两种：

     内部复制粘贴。
     外部复制粘贴。

     涉及列类型转换

3. 表格渲染有多复杂

   - 3.1. 自动换行

   - 3.2. 冻结区域

   - 3.3. 对齐与单元格溢出

4. 数据管理的难题
   当每个格子都支持富文本内容，在十万、百万单元格的场景下，对落盘数据的存储、用户操作的数据变更也提出了不小的挑战。

   - 4.1. 原子操作
     和数据库的事务相类似，对于电子表格来说，我们可以将用户的操作拆分成不可分割的原子操作。为什么要这么做呢？`其实主要是方便进行 OT 算法的冲突处理，可针对每个不可拆分的原子操作进行特定逻辑的冲突计算和转换，最终落盘到存储中。`
     除了客户端收到服务器的协同消息之后需要进行本地的冲突处理，服务器也可能存在先后接收到两个基于同一版本的消息之后进行冲突处理。在本地和服务器都有一套一致的冲突处理逻辑，才能保证算法的最终一致性。
   - 4.2. 版本回退/重做
     基于 OT 算法的 Undo 其实思路相对简单，通常是针对每个原子操作实现对应的 invert()方法，进行该原子操作的逆运算，生成一个新的原子操作并应用。
     OT 用于撤消的基本思想是根据操作之后执行的那些操作的效果，将操作的逆操作（待撤消的操作）转换为新形式，从而使转换后的逆操作可以实现正确的 Undo 影响。
     **Undo 后的 Step 需要 transform**：但如果用户在编辑的时候接收到了新的协同操作，当该用户在进行 Undo 的时候，通过逆运算生成的原子操作同样需要和这些新来的协同消息进行冲突处理，才能保证最终一致性。
   - 4.3. 数据
     对于支持富文本的单元格来说，每个单元格除了自身的一些属性设置，包括数据格式验证、函数计算、宽高、边框、填充色等，还需要维护该单元格内富文本格式、关联图片的一些数据。这些数据在面临十万甚至百万单元格的时候，对数据传输和存储也带来了不小的挑战。
     修订记录的版本和还原、如何优化内存、如何优化数据大小、如何高效利用数据、如何降低计算时空复杂度等都成为了数据层面临的一些难题。

     飞书是后端数据库团队做的

   - 4.4. END
     以上列举的，只占整个 Excel 项目的一小部分，而除此之外还有 Worker、菜单栏、各种各样的 feature 功能，像数据格式、函数、图片、图表、筛选、排序、智能拖拽、导入导出、区域权限、查找替换，每一个功能都会因为项目的复杂性而面临各式各样的挑战。
     除此以外，各个模块之间功能解耦、100W+的代码怎么进行组织和架构设计、代码加载流程如何优化、多人协作导致的问题、项目的维护性/可读性、性能优化等都是我们经常需要思考的问题。

   - 4.5. 结束语
     参与这样的项目，最大的感受是`不需要再抓破脑袋去想某个项目还可以做出哪些亮点，因为可以做的事情实在是太多了`。对于很多业务来说，代码质量、维护性和可读性也常常不受重视。我们常常因为项目本身的局限性（相对简单）而无法找到自己可以深挖的点，因此最后都是只能通过自动化、配置化的方式去尽可能地提升效能，但可以做的其实也很局限，自身的成长也因此受限。

     大家经常调侃说前端的天花板太低，又说自己面临 35 岁被淘汰。抛去个人兴趣、热情和自身瓶颈这些原因，很多时候也是因为条件不允许、业务场景较简单，因此没有场景可以发挥自己的能力。以前我也觉得下班之后学习也是可以的，但如果上班就做着自己喜欢的工作，岂不是一举两得？

# 如何设计一个任务管理器

一般来说，我们在遇到`对顺序要求严格的任务执行时，就需要维护一个任务管理器`，保证任务的执行顺序。
理解任务管理器比较好的场景大概是协同文档编辑的场景，比如 Google Docs、腾讯文档、Sketch 协同等。我们在进行协同编辑的时候，对版本和消息时序有比较严格的要求，因此常常需要维护一个任务管理器来管理版本相关的任务。

1. 单个任务的设计(Task)
   一个任务的作用就是用来运行的，那么对于任务来说，可能会有几个状态：待执行、正在执行、执行失败、执行成功等：

   ```ts
   enum TASK_STATUS {
     INIT = 'INIT', // 初始状态
     READY = 'READY', // 可执行
     RUNNING = 'RUNNING', // 执行中
     SUCCESS = 'SUCCESS', // 执行成功
     FAILED = 'FAILED', // 执行失败
     DESTROY = 'DESTROY' // 已销毁(dispose)
   }
   ```

   1.1. 生命周期
   既然涉及到任务的各个状态，我们也可以赋予任务一些生命周期。这里我们举一些例子，但最终的生命周期设计应该要`和自己业务实际情况结合`。
   1.2. 任务执行
   由于每个任务都会有状态、生命周期、执行功能、重置功能，我们可以实现一个通用的任务：

   ```ts
   abstract class CommonTask implements ICommonTask {
     /** 生命周期钩子 **/

     // 该 Promise 包括一个布尔值，用于判断任务是否继续执行
     abstract onReady: () => Promise<boolean>
     // 一个任务执行的过程中，可能会产生新的任务，也可能由于其他条件限制，导致它需要创建一个别的任务先执行完毕，才能继续执行自己原本的任务。比如，B 任务在执行的时候，如果条件不满足，则需要先执行一个 A 任务：

     /**
       *      class BTask implements ICommonTask {
          // 其他省略
          async onRun() {
              if (needATask) {
                  return [new ATask(), this.resetTask()];
              }
              // 其他正常执行任务逻辑
          }
      }
       */
     abstract onRun: () => Promise<CommonTask[] | void>
     abstract onDestroy: () => Promise<void>

     /** 执行任务 **/
     public async execute(): Promise<CommonTask[] | void> {
       // step 1 准备任务
       if (!(await this.onReady())) {
         // 任务准备校验不通过，直接没必要执行了
         return this.onDestroy()
       }
       // step 2 执行任务
       const runResult = await this.onRun()
       if (runResult) {
         // 若分裂出新的任务，返回并不再继续执行了
         return runResult
       }
       // step 3 销毁任务
       this.onDestroy()
     }
   }
   ```

   任务里不进行异常处理。当然，这里其实还需要在执行到对应生命周期的时候，扭转任务状态。(其实可以参考 Zone.js 的设计)

2. 任务管理器(TaskManager)
   任务管理器的职责主要是保证任务队列中的任务有序、`顺利地执行`，其中会包括任务执行时的`异常处理`。除此之外，任务管理器还需要对外提供添加任务，以及`暂停、恢复、停止`这样的能力。

   2.1. 任务管理器状态
   既然任务管理器有对任务的管理，当然它也需要维护自身的状态，例如：

   ```ts
   enum QUEUE_STATUS {
     WORKING = 'WORKING', // 工作中
     PAUSE = 'PAUSE', // 暂停
     IDLE = 'IDLE', // 空闲
     SHUTDOWN = 'SHUTDOWN' // 关停
   }
   ```

   对于每一个不同的状态来说，相应的任务管理器也会有一些更新状态的方法。

   ```ts
   class TaskManager {
     status: QUEUE_STATUS = QUEUE_STATUS.IDLE
     // 暂停任务管理器
     public pause() {
       this.status = QUEUE_STATUS.PAUSE
       // 当前正在运行的任务需要处理
     }
     // 恢复任务管理器
     public resume() {
       // 如果被关停了，则不能恢复啦
       if (isShutDown) {
         return
       }
       this.status = QUEUE_STATUS.WORKING
       this.work()
     }
     // 关停任务管理器
     public shutDown() {
       this.status = QUEUE_STATUS.SHUTDOWN
     }
     // 任务管理器工作
     private work() {
       if (!isWorking && hasNextTask) {
         // 如果有会继续执行下一个任务
         // 直到任务管理器被暂停、或者任务队列为空
         runNextTask()
       }
     }
   }
   ```

   暂停任务管理器的时候，需要考虑如何`处理正在运行的任务`。
   执行任务的时候，需要进行一些`异常处理`。同时，任务的运行可能会进行`分裂并产生新的任务，需要对新任务进行处理`。
   有点像 golang Context？

   2.2. 暂停与恢复
   一个简单粗暴的处理方式是，将当前正在运行的任务继续运行完成。但这种处理方式，与我们对于暂停的理解有一些误差。
   因此，我们可以`考虑让任务本身支持重置的功能(delegate)`，比如运行过程中判断任务状态是否需要继续执行，结合销毁当前任务、并将原有任务进行重置。

   > 我不知道做，我只能委托(delegate)给你做。

   ```ts
   abstract class CommonTask {
     /** 重置任务 **/
     // 会返回任务本身，该任务应该是被重置过的最初状态
     abstract reset(): CommonTask
   }

   class ATask extends CommonTask {
     public reset() {
       // 销毁当前任务
       this.destroy()
       // 并返回一个重置后的新任务
       return new ATask()
     }
   }
   ```

   对于任务管理器来说，要做的事情也比较简单了：`暂停任务管理器的时候，将当前任务重置、并扔回任务队列的头部。`

   ```ts
   class TaskManager {
     // 暂停任务管理器
     public pause() {
       this.status = QUEUE_STATUS.PAUSE
       // 将当前任务重置，并扔回任务队列头部
       taskList.unshift(currentTask.reset())
     }
   }
   ```

   2.3. 任务管理器工作
   任务管理器工作的时候，主要工作内容包括依次运行任务、处理任务异常、处理任务运行后分裂产生的新任务。

   ```ts
   class TaskManager {
     // 任务管理器工作
     private async work() {
       if (!isWorking && hasNextTask) {
         // 如果满足条件，会继续执行下一个任务
         currentTask = getNextTask()
         const resultTask = await currentTask.execute().catch(error => {
           // 异常处理
         })
         // 判断是否有分裂的新任务
         if (resultTask) {
           // 如果有，就塞回到任务队列的头部，需要优先处理
           taskList.unshift(resultTask)
         }
         // 继续执行下一个任务
         checkContinueWork()
       }
     }
   }
   ```

   以上大概是我们在设计一个任务管理器的过程中，需要进行思考的一些问题、和简单的实现方式。
   除此之外，在一个更加复杂的应用场景下，我们还可能会遇到多个任务队列的管理和资源`调度`、同步任务和`异步任务`的管理、任务支持`优先级`设置等各式各样的功能设计。
   任务管理也好、队列/堆栈的设计也好，都会在工程中经常遇到。而随着应用场景的不一样，我们的设计并不能简单地进行复用，每一次都可以结合业务本身、工程本身而设计出更加合适的调整，每一次我们也都可以给自己提出不一样的要求。

# 我所理解的前端工程化

前端工程化致力于**提质提效**，贯穿项目设计、开发、测试、上线、维护的整个过程

1. 前端项目开发常见问题

   - 1.1. **系统质量**
     - 1.1.1. 系统质量的下降
       - 人员变动
       - 新功能引入
     - 1.1.2. 提升系统质量
   - 1.2. **开发效率**
     - 1.2.1. 开发效率的下降
       - 用户反馈问题跟进和定位
       - 线上 BUG 修复和紧急发布、迭代运维
       - 新功能灰度发布过程
       - 自动化测试
       - 项目成员的调整
       - 杂事太多
     - 1.2.2. 提升开发效率
       项目研发和发布流程优化的核心点在于：**将一切需要手动操作和关注的内容自动化。开发可从各种杂事中释放，专注于功能开发的实现**
       对于流程自动化，业界比较成熟的解决方案是使用持续集成（continuous integration，简称 CI）和持续部署（continuous deployment，简称 CD）：
       - 持续集成（CI）：目的是让产品可以快速迭代，同时还能保持高质量
       - 持续部署（CD）：目的是代码在任何时刻都是可部署、可进入生产阶段

2. 结束语
   “能用机器解决的问题，就不要依赖人。” – 《被删的开发手册》
   项目维护阶段的最大痛点，其实在于开发`无法聚焦自身`的工作内容，常常需要在各种系统中进行操作和切换，从而带来`开发效率的下降，以及注意力分散`、无法更全面的思考导致了不合理的设计、新的 BUG 引入，而影响了`系统的质量`。

# 前端性能优化--卡顿的监控和定位

卡顿，顾名思义则是代码执行产生长耗时，导致浏览器无法及时响应用户的操作
卡顿产生的时候常常无法进行其他操作，甚至控制台也打开不了

1. 卡顿检测
   1.1. Worker 心跳方案

   Worker 更多时候用于检测`网页崩溃`，用来检测卡顿的效果其实还不如使用 window.requestAnimationFrame，因为`线程通信的耗时和延迟`导致该方案不大准确

   1.2. window.requestAnimationFrame 方案
   setTimeout/setInterval 计时器只能保证将回调添加至浏览器的回调队列(宏任务)的时间，不能保证回调队列的运行时间，因此使用 window.requestAnimationFrame 会更合适
   假设我们认为页面中存在超过特定时间（比如 1s）的长耗时任务即存在明显卡顿，则我们可以判断两次 window.requestAnimationFrame 执行间超过一定时间，则发生了卡顿。

   1.3. Long Tasks API 方案

   1.4. **PerformanceObserver 卡顿检测**

2. 卡顿埋点上报
   2.1. 卡顿打点
   2.2. 心跳打点
   2.3. JavaScript 加载打点
3. 结束语

# 前端性能优化--用户卡顿检测

1. 用户感觉的“卡”

   - 1.1. 用户侧卡顿

     如果你有认真整理用户反馈，便会发现，对于大型应用比如在线表格/网页游戏等，`相比于加载过程中偶尔一两秒的卡顿，更让他们难以接受的问题有频繁出现卡顿、某个操作卡顿耗时过长、某个较频繁的操作必现卡顿等`。

     - 1.1.1. 1. 同步任务卡顿

     可以在监听到用户交互时进行耗时计算：

     ```ts
     window.addEventListener('click', () => {
       const startTime = new Date().getTime()
       requestAnimationFrame(() => {
         const duringTime = new Date().getTime() - startTime
         // 交互后超过 1s 才响应
         if (duringTime > 1000) {
           // 则判断为卡顿
         }
       }, 0)
     })
     ```

     - 1.1.2. 2. 异步任务卡顿
       当页面交互发生卡顿时，用户常常会在页面中进行操作，来确认页面是否无响应。因此，我们可以通过这样的代码判断：

     ```ts
     let clickCount = 0
     let hasClick = false
     window.addEventListener('click', () => {
       clickCount++
       if (hasClick) return
       hasClick = true
       setTimeout(() => {
         // 卡顿过程中发生了连续点击操作
         if (clickCount > 2) {
           // 则判断为卡顿
         }
         // 清空数据
         clickCount = 0
         hasClick = false
       }, 0)
     })
     ```

   - 1.2. 总卡顿指标设计

我们开发在实现功能的时候，常常会从编程出发去思考问题，但实际上我们可以更贴近用户一些滴~

# 前端性能优化--卡顿心跳检测

1. requestAnimationFrame 心跳检测
   1.1. 启动和停止检测
   1.2. 页面隐藏

   ```ts
   class HeartbeatMonitor {
     // 上一次心跳的时间
     private preHeartBeatTime: number
     // 心跳定时器
     private heartBeatTimer: number | null = null

     constructor() {
       document.addEventListener('visibilitychange', () => {
         if (document.visibilityState === 'hidden') {
           this.stop()
         } else {
           this.start()
         }
       })
     }

     /**
      * 开启卡顿监控
      */
     start() {
       if (!this.heartBeatTimer) this.checkNextTick()
     }

     /**
      * 结束卡顿监控
      */
     stop() {
       // 取消 requestAnimationFrame
       if (this.heartBeatTimer) cancelAnimationFrame(this.heartBeatTimer)
       this.heartBeatTimer = null
     }

     private checkNextTick() {
       this.preHeartBeatTime = Date.now()
       this.heartBeatTimer = requestAnimationFrame(() => {
         const currentTime = Date.now()
         // 取出执行耗时
         let timeDistance = currentTime - this.preHeartBeatTime
         // 超过 1s 则认为是卡顿了
         if (timeDistance > 1000) {
           // 注：dispatchEvent 为伪代码，具体可自行实现
           // 对外抛事件表示发生了卡顿
           this.dispatchEvent('jank')
         } else {
           // 对外抛事件表示为普通心跳
           this.dispatchEvent('heartbeat')
         }
         // 继续下一次检测
         this.checkNextTick()
       })
     }
   }
   ```

# 有趣的 PerformanceObserver

1. PerformanceObserver
   1.1. 常见的性能指标数据获取
   1.2. PerformanceObserver 对象
   1.3. PageSpeed Insights (PSI) 前端性能指标
   1.4. resource observe 获取资源加载时机
   1.5. 自定义性能指标
   1.6. 参考

# 前端性能优化--数据指标体系

1. 前端性能指标体系

   - 1.1. 常见的前端性能指标

     - 内容呈现
       First Contentful Paint (FCP)：首次内容绘制，衡量从网页开始加载到网页任何部分呈现在屏幕上所用的时间
       Largest Contentful Paint (LCP)：最大内容绘制，衡量从网页开始加载到屏幕上渲染最大的文本块或图片元素所用的时间
     - 网页交互
       First Input Delay (FID)：首次输入延迟，衡量用户首次与页面交互到页面响应的时间
       Interaction to Next Paint (INP)：衡量与网页进行每次点按、点击或键盘交互的延迟时间，并根据互动次数选择该网页最差的互动延迟时间（或接近最高延迟时间）作为单个代表性值，以描述网页的整体响应速度

   - 1.2. PageSpeed Insights (PSI)
   - 1.3. 核心网页指标
     - 1.3.1. FID：
     - 1.3.2. LCP
     - 1.3.3. CLS
     - 1.3.4. Interaction to Next Paint (INP)
     - 1.3.5. web-vitals JavaScript 库
   - 1.4. 评估体验质量
   - 1.5. 参考

# 让你的长任务在 50 毫秒内结束

考虑将任务执行耗时控制在 50 ms 左右。每执行完一个任务，如果耗时超过 50 ms，将剩余任务设为异步，放到下一次执行，给到页面响应用户操作和更新渲染的时间。

1. 让你的长任务保持在 50 ms 内

   为什么是 50 毫秒呢？

   这个数值并不是随便写的，主要来自于 Google 员工开发的 RAIL 模型。

   - 1.1. RAIL 模型
     RAIL 表示 Web 应用生命周期的四个不同方面：`响应（Response）、动画（Animation）、空闲（Idel）和加载（Load）。`
     由于用户对每种情境有不同的性能预期，因此，系统会根据情境以及关于用户如何看待延迟的用户体验调研来确定效果目标。

     四个阈值：

     - 0-16 ms：大概是用户感受到流畅的动画体验的数值。只要每秒渲染 60 帧，这类动画就会感觉很流畅，也就是每帧 16 毫秒（包括浏览器将新帧绘制到屏幕上所需的时间），让应用生成一帧大约 10 毫秒
     - 100 毫秒：大概是让用户感觉系统立即`做出反应`的极限，这意味着除了显示结果之外不需要特殊的反馈
     - 1 秒：大概是用户`思想流保持不间断`的极限，即使用户会注意到延迟。一般情况下，`大于 0.1 秒小于 1.0 秒的延迟不需要特殊反馈，但用户确实失去了直接操作数据的感觉`
     - 10 秒：大概是让用户的`注意力集中在对话上的极限`。对于较长的延迟，用户会希望在等待计算机完成的同时执行其他任务，因此应该向他们提供反馈，指示计算机预计何时完成。如果响应时间可能变化很大，则延迟期间的反馈尤其重要，因为用户将不知道会发生什么。

   - 1.2. 在 50 毫秒内处理事件
     RAIL 对其他的生命周期也提出了对应的准则，总体为：

     响应（Response）：在` 50 毫秒`内处理事件
     动画（Animation）：在 `10 毫秒`内生成一帧
     空闲（Idel）：最大限度地延长空闲时间
     加载（Load）：提交内容并在 `5 秒`内实现互动

2. 长任务优化
   任何连续不间断的且主 UI 线程繁忙 50 毫秒及以上的时间区间。
   我们录制一段 Performance，当主线程同步执行的任务超过 50 毫秒时，该任务块会被标记为红色
   - 2.1. 识别长任务
     - 2.1.1. 使用 Chrome Devtools
     - 2.1.2. 使用 Long Tasks API
     - 2.1.3. 识别大型脚本
     - 2.1.4. 自定义性能指标
   - 2.2. 优化长任务
     - 2.2.1. 过大的 JavaScript 脚本：拆
     - 2.2.2. 过长的 JavaScript 执行任务
       - 2.2.2.1. 串行任务的拆分：将不同任务的调用从同步改成异步即可
       - 2.2.2.2. 单个超大任务的拆分
   - 2.2.3. 参考
