# 括号对着色快 10,000 倍：技术深度解析

链接：https://code.visualstudio.com/blogs/2021/09/29/bracket-pair-colorization

本文深入剖析 VS Code 团队如何将括号着色性能提升 10,000 倍。这不仅仅是一个功能的移植，更是一场算法与工程的极致优化。

## 0. 核心痛点：为什么插件做不到？

在原生实现之前，流行的 `Bracket Pair Colorizer` 插件拥有数百万用户，但在处理大型文件时存在致命缺陷：

1.  **非增量式更新**：插件 API 设计导致每次哪怕只改一个字符，扩展都必须重新计算整个文件的装饰（Decorations）。
2.  **通信开销**：扩展运行在独立的 Extension Host 进程，必须通过异步 IPC 与渲染进程通信。
3.  **信息壁垒**：扩展无法直接访问 VS Code 内部的高效 Token 信息（用于语法高亮），必须自己重新通过正则或其他方式解析代码。

结果：在 4.2 万行的 TS 文件头部输入一个 `{`，扩展需要 **10秒** 才能更新颜色，CPU 占用 100%。而原生实现将此耗时降到了 **<1ms**。

## 1. 算法核心：从 $O(N)$ 到 $O(\log N)$

原生实现并没有沿用插件的线性扫描思路，而是引入了高级数据结构。

### 1.1 数据结构：(2,3)-平衡树

- **AST 节点列表化**：传统的 AST 可能因为嵌套过深或列表过长（如大数组定义）导致性能问题。VS Code 采用了 **(2,3)-树** 来维护列表结构。
- **平衡性保证**：每个节点包含 2 到 3 个子节点，且所有叶子节点到根节点的路径长度相同。
- **性能收益**：
  - 查询视口内括号：$O(\log N)$
  - 文本编辑更新：$O(\log N)$

### 1.2 关键创新：相对长度 (Relative Lengths)

这是本算法最天才的设计点。**节点不存储绝对起止位置 (Start/End Offset)，只存储自身长度。**

- **传统绝对位置 AST**：
  - 结构：`Node { start: 10, end: 20 }`
  - 缺陷：在文件头部插入 1 个字符，后续所有 10 万个节点的 `start/end` 都要加 1。这是 $O(N)$。
- **相对长度 AST**：
  - 结构：`Node { length: 10 }`
  - 优势：在文件头插入字符，只会改变该节点及其所有父节点的长度值。对于平衡树，受影响节点数仅为树高，即 $O(\log N)$。
  - 坐标计算：遍历时在栈中累加父兄节点的长度即可实时算出绝对坐标。

## 2. 增量更新与节点复用 (Incremental Updates)

当用户输入时，如何避免重建整棵树？

### 2.1 节点复用策略

算法利用**递归下降解析器 (Recursive Descent Parser)** 配合**缓存策略**：

1.  **Position Mapper**：计算新文档中的位置对应旧文档的哪里。
2.  **Node Reader**：在旧树中查找“未被修改且足够长”的节点。
3.  **复用判定**：如果解析器当前位置对应旧树中某节点，且该节点范围未涉及由于编辑引起的变化，直接复用该节点（及其整棵子树），跳过解析。

### 2.2 复杂场景：树的重新平衡

复用了旧节点（可能是高为 H 的树）和新解析的节点（高为 0 的叶子）混合在一起，如何组装回 (2,3)-树？

- 类似于 (2,3)-树的插入操作，处理不同高度子树的拼接，必要时拆分或合并节点，保证树的平衡性。

## 3. 工程挑战：Token 同步与防抖动

VS Code 的 Tokenization（语法分词）是在渲染进程分块进行的（为了不卡顿 UI）。括号解析器需要依赖 Token 来通过判断：是否在**注释**或**字符串**中。

### 3.1 遇到的问题

- 文件刚打开时，Token 还没计算完。
- 用户在文件头加了 `/*`，整个文件变成注释，Token 发生剧烈变化。

### 3.2 双 AST 策略

为了解决“Token 尚未就绪”时的闪烁问题，系统维护了两棵树：

1.  **纯文本 AST**：不依赖 Token，假设所有括号都有效（即不考虑注释/字符串）。用于快速初次渲染。
2.  **准确 AST**：随着 Token 计算完成，逐步更新，排除掉注释/字符串里的括号。
3.  **Copy-On-Write**：为了节省内存，这两棵树起初共享节点，只有当 Token 导致结构差异时才通过写时复制分离。

## 4. 其它细节

### 4.1 错误恢复 (Error Recovery)

- 处理不匹配的括号（如 `( } )`）：使用 **Anchor Sets**（锚点集合）。当遇到意外字符时，检查它是否属于当前上下文的合法结束符集合。如果不属于，则将其视为“未打开的括号”并忽略，而不是强行结束当前层级。

### 4.2 长度编码

- 由于采用行列号表示位置，长度也需要包含 `(lineCount, constantColumnLength)`。VS Code 将其位压缩到一个 `52-bit` 的整数中（JS Number 为双精度浮点，安全整数范围为 $2^{53}-1$），以减少内存占用。

## 总结

VS Code 的括号着色优化展示了教科书级的性能优化路径：

1.  **架构层面**：从扩展下沉到核心，消除 IPC。
2.  **算法层面**：引入平衡树，从线性复杂度降维到对数复杂度。
3.  **数据结构层面**：相对坐标取代绝对坐标，实现极速增量更新。
4.  **工程层面**：双 AST 缓冲、写时复制、位压缩。

---
