# 深入解析 V8 的数字存储：Smi, HeapNumber, MutableHeapNumber

在 JavaScript 中，所有数字的类型都是 `Number`（遵循 IEEE 754 双精度浮点标准），但在引擎（如 V8）内部，为了性能和内存优化，数字的存储方式远比这复杂。

这篇文章将深入讲解 V8 内部的三种主要数字表示：`Smi`、`HeapNumber` 和 `MutableHeapNumber`。

---

## 1. 为什么需要不同的存储方式？

ECMAScript 规范要求所有数字都表现得像 64 位浮点数（Float64）。这意味着：

- 整数 `42`
- 浮点数 `4.2`
- 科学计数 `1e10`
- 特殊值 `NaN`, `Infinity`

在语言层面它们都是一样的。然而，在底层硬件中，**整数运算（如 + - \* / 位运算）比浮点数运算快得多**，且大多数 JavaScript 程序中处理的都是整数（尤其是数组索引、循环计数器）。

如果 V8 总是将数字存为 Float64，会有两个严重问题：

1.  **性能差**：CPU 必须使用浮点指令，无法利用高效的整数指令。
2.  **内存浪费**：Float64 需要 64 位，且通常需要作为对象分配在堆上（Heap），这带来了分配和垃圾回收（GC）的开销。

为了解决这个问题，V8 引入了 **Pointer Tagging（指针标记）** 技术和多种数字表示。

---

## 2. 指针标记 (Pointer Tagging)

V8 中的变量（如对象的属性值、数组元素）通常占用一个字长（32位系统是32位，64位系统是64位）。V8 利用最低有效位（Least Significant Bit, LSB）来区分“这是一个整数”还是“这是一个指向堆对象的指针”。

在 64 位系统上（启用 Pointer Compression 前）：

- **Smi (Small Integer)**: 最低位为 `0`。剩余的高 32 位存储实际的整数值（32 位整数）。
- **HeapObject Pointer**: 最低位为 `1`。减去 1 后得到真实的内存地址。

_(注：在启用了 Pointer Compression 的现代 V8 中，机制略有不同，但区分直接值和指针的核心思想不变)_

---

## 3. 三种核心表示详解

### 3.1 Smi (Small Integer)

- **定义**：直接存储在变量槽位中的小整数，**不是对象**。
- **存储位置**：栈、对象的属性槽（inline slot）、寄存器。
- **内存开销**：0（不需要在堆上分配内存）。
- **范围**：
  - 32位系统：31位有符号整数。
  - 64位系统：32位有符号整数。
- **特点**：
  - **极快**：数学运算直接映射为 CPU 整数指令。
  - **即时性**：没有分配、没有 GC。
  - **Tagging/Untagging**：使用前需要右移（untag），存储前需要左移（tag）。

```javascript
const o = {
  x: 42 // 42 是 Smi，直接存在 o 的结构中，没有额外的内存分配
}
o.x += 10 // 52 依然是 Smi，直接原地更新
```

### 3.2 HeapNumber

- **定义**：一个包装了 Float64 值的**不可变（Immutable）对象**。
- **存储位置**：堆（Heap）。
- **内存开销**：Header + 64-bit value = 12-16 字节（取决于架构）。
- **触发条件**：
  1.  数值超出了 Smi 的范围（例如 `2**32`）。
  2.  数值不是整数（例如 `4.2`）。
- **特点**：
  1.  **不可变**：一旦创建，里面的值不能变。如果你修改变量，必须创建一个**新的** HeapNumber 并让变量指向它。
  2.  **较慢**：需要内存分配、GC、指针解引用。

```javascript
const o = {
  y: 4.2 // 4.2 无法用 Smi 表示，V8 在堆上分配一个 HeapNumber 存 4.2，o.y 指向由于这个 HeapNumber
}

// 假如我们要修改它：
o.y += 1.0
// 过程：
// 1. 读取 o.y 指向的 HeapNumber (4.2)
// 2. 计算 4.2 + 1.0 = 5.2
// 3. 5.2 不是 Smi。V8 分配一个新的 HeapNumber 存 5.2
// 4. 更新 o.y 指向这个新的 HeapNumber
// 5. 旧的 HeapNumber (4.2) 变成垃圾，等待 GC
```

**问题**：如果在循环中频繁修改一个非 Smi 数字，会产生大量的垃圾（短命的 HeapNumber），给 GC 造成巨大压力。

### 3.3 MutableHeapNumber

为了解决 HeapNumber 在高频更新场景下的性能问题，V8 引入了 `MutableHeapNumber`。

- **定义**：一个包装了 Float64 值的**可变（Mutable）对象**。
- **存储位置**：堆（Heap）。
- **触发条件**：
  - 当 V8 发现对象的某个属性频繁存储非 Smi 数字时，它会将该属性的元信息（Shape/Hidden Class）标记为 `Double` 字段。
  - 此时，该属性指向一个 `MutableHeapNumber`。
- **特点**：
  - **可原地更新**：修改值时，不需要分配新对象，直接修改 `MutableHeapNumber` 内部的 Float64 值。
  - **特定上下文**：通常只存在于对象属性的优化存储中，不能随意在变量间传递。

**优化后的流程**：

```javascript
const o = { x: 0.1 } // V8 推测 x 可能是 Double 字段
for (let i = 0; i < 5; i++) {
  o.x += 1
  // V8 意识到 x 是 Double 字段。
  // 它分配一个 MutableHeapNumber 存 0.1。
  // 在循环中：
  // 直接更新那个 MutableHeapNumber 的值为 1.1, 2.1, 3.1...
  // 没有产生额外的垃圾 HeapNumber！
}
```

**陷阱：装箱（Boxing）**
如果你把一个 `MutableHeapNumber` 属性赋值给一个普通便利：

```javascript
let temp = o.x
```

`temp` 不能指向 `MutableHeapNumber`（因为如果在那里改了值，temp 也会变，这违反了 JS 值类型的语义）。所以读取时，V8 必须执行 **Re-boxing**：创建一个新的、不可变的 `HeapNumber` 复制该值，然后赋给 `temp`。

---

## 4. 总结对比表

| 特性            | Smi              | HeapNumber         | MutableHeapNumber           |
| :-------------- | :--------------- | :----------------- | :-------------------------- |
| **全称**        | Small Integer    | Heap Number        | Mutable Heap Number         |
| **存储内容**    | 31/32位 整数     | 64位 Float         | 64位 Float                  |
| **本身是对象?** | 否（立即数）     | 是（堆对象）       | 是（堆对象）                |
| **可变性**      | N/A (值类型)     | Immutable (不可变) | Mutable (可变)              |
| **用途**        | 小整数、数组索引 | 大整数、小数       | 对象属性中频繁更新的 Double |
| **性能**        | 🚀 极快          | 🐢 慢 (分配/GC)    | 🚗 较快 (避免了分配)        |

## 5. 对开发者的启示

1.  **尽量使用 Smi**：如果你的计算可以用整数完成，尽量不要引入小数。
    - _Bad_: `counter += 0.5; counter += 0.5;`
    - _Good_: `counter += 1;`
2.  **避免类型转换**：不要让一个字段在 Smi 和 HeapNumber 之间反复横跳，这会导致 V8 不断调整对象的 Shape（Deprecation/Migration）。
3.  **初始化一致性**：如果你知道一个字段存的是浮点数，初始化时就给个浮点数（如 `0.1` 或 `NaN`），甚至可以用 `Math.fround(0)` 提示这是 Float32（如果环境支持）。这有助于 V8 一开始就分配正确的 MutableHeapNumber，避免后续的 Shape 迁移。
