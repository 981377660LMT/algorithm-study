- 软件架构的终极目标是，用最小的人力成本来满足构建和维护该系统的需求。
- 一个软件架构的优劣，可以用它满足用户需求所需要的成本来衡量。
- 软件架构师必须创建出一个可以让功能`实现起来更容易、修改起来更简单、扩展起来更轻松的软件架构`
- **面向对象编程就是以多态为手段来对源代码中的依赖关系进行控制的能力**
- 如果 A 组件不想被 B 组件上发生的修改所影响，那么就应该让 B 组件依赖于 A 组件
- 软件架构这项工作的实质就是规划如何将系统切分成组件，并安排好组件之间的排列关系，以及组件之间互相通信的方式
- 如果有两段看起来重复的代码，它们走的是不同的演进路径，也就是说它们有着不同的变更速率和变更缘由，那么这两段代码就不是真正的重复
- 插件式架构的好处
  将系统设计为插件式架构，就等于构建起了一面变更无法逾越的防火墙。
  换句话说，`只要 GUI 是以插件形式插入系统的业务逻辑中的，那么 GUI 这边所发生的变更就不会影响系统的业务逻辑`

- `业务逻辑应该保持纯净，不要掺杂用户界面或者所使用的数据库相关的东西。`在理想情况下，这部分代表业务逻辑的代码应该是整个系统的核心，其他低层概念的实现应该以插件形式接入系统中。`业务逻辑应该是系统中最独立、复用性最高的代码`
  反面例子：很多地方的接口性能都由于某个没用的统计数据多耗费了将近 1s 的时间
- 消除循环依赖有两种方式

  1. 依赖反转 DIP。若存在循环依赖 A>B>C>D>B，可在 B 中定义接口，C 实现接口，则依赖关系变为 A>B<C
  2. 创建一个新的组件将循环依赖的地方放到新组件中，原有组件共同依赖新组件，这也是 spring 框架中控制反转(IOC) 的就是使用此方法。若存在循环依赖 A>B>C>D>B，可定义新组件 E，让 B 和 C 同时依赖 E,则依赖关系变为 A>B>E<C

- 软件架构师可以根据相关函数被修改的原因、修改的方式及修改的时间来进行分组隔离，`并将这些相互隔离的函数分组整理成组件结构，使得高阶组件不会因低阶组件被修改而收到影响`

- 一句话总结好的软件架构：围绕业务逻辑和用例而非技术框架展开架构设计，将软件策略分为高低层，层次越高离输入输出越远，离业务逻辑越近，通过 DIP 严格控制依赖关系，让低层依赖于高层
- 整洁的代码可以通过 SOLID 原则来指导
- 组件的构建则可以分为组件聚合和组件耦合：

  - 组件的聚合有三个原则：

  1. 复用/发布等同原则：软件复用的最小粒度应等同于其发布的最小粒度。
  2. 共同闭包原则：应该将那些会同时修改，并且为相同目的而修改的类`放到同一个组件中`。
  3. 共同复用原则：不要强迫一个组件的用户依赖他们不需要的东西。

  - 组件的耦合有三个原则：

  1. 无依赖环原则：组件依赖关系图中不应该出现环。
  2. 稳定依赖原则：依赖关系必须要指向更稳定的方向。
  3. 稳定抽象原则：`一个组件的抽象化程度应该与其稳定性保持一致。`

- 所有的软件系统都可以降解为策略与细节两种元素：

  - 策略体现的是软件中所有的业务规则与操作过程，因此它是系统真正的价值所在。
  - 细节就是具体的框架和数据库等，细节就是可选项。`细节推迟`的好处是：
    - 越到项目的后期，就拥有越多的信息来做出合理的决策。
    - 可以让有机会做不同的尝试。保留这些可选项的时间越长，实验的机会也就越多，做决策的时候就能拥有越充足的信息。

- DIP：
  多态，架构设计上可以实现依赖反转 DIP (程序源码的依赖关系不再受系统控制流方向的限制)！！！
  简单理解：在多态之前，源码的依赖方向受控制方向限制，A 模块要调用控制 B 模块，A 就要依赖 B，不然没法调。这就造成了 A 与 B 的耦合。有了多态，A 调用 B 的时候可以调用接口 C ，B 实现 C。这时候依赖流方向与程序控制流相反，就是依赖反转！`（程序运行时的依赖关系与编译时是相反的）`
  **面对对象编程就是以多态的手段对源码中的依赖关系进行控制，让架构师可以依赖抽象而不是细节从而设计出插件式架构**

- SRP 原则解释：**任何一个软件的模块都应该有且只有一个被修改的原因**
  即多个团队维护同一个模块也是违反 SRP 原则的体现
  `每个模块只应该做一件事的解释是错误的！`
- OCP 原则解释：软件应该易于扩展，抗拒修改
  架构上对 OCP 原则的应用：`将系统划分成一系列的组件（按照函数被修改的原因、方式等维度），将这些组件的依赖关系按照层次结构进行组织，使得高阶组件不依赖低阶组件`
  - 用 DIP 去反转以来方向
  - 用接口进行信息隐藏，避免依赖传递（软件系统不应该依赖其不直接使用的组件）
  - 高阶组件：业务核心逻辑
  - 低阶组件：UI 等实现细节
- ISP：任何层次的软件实际如果依赖了它不需要的东西，就会带来意料之外的麻烦。
- 不要在具体类上创建衍生类：继承的以依赖关系是最重的，最难修改的，`应该避免继承具体类`
- 不要重写(override)包含具体实现的函数：即使我们重写了函数，也无法消除原函数已经存在的一些依赖。这条可以看成是上一条的衍生
- 应该避免在代码中写入任何与具体实现相关的名字
- **DIP 中的接口是调用者维护而不是实现者维护** -> 查找替换控制器依赖的子模块接口
- **非 DIP 中的接口是实现者维护** -> React 函数组件 props 接口
- 正如“Bob 大叔”所言，**“我过去 50 年学到的东西主要是什么不应该做”**，同样，对于软件架构，我们可以从足够多的“坏”的设计中学会什么不应该做。好的架构可能有争论，因为各有各的好处，但是不好的架构是确定的，不会有争论，毕竟还是有普世价值的。
- 总体原则：优秀的设计比糟糕的设计更容易变更。我刚刚做的事情让系统更容易改变，还是更难改变？
