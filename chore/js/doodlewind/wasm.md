如何看待 WebAssembly 这门技术？ - 王译锋的回答 - 知乎
https://www.zhihu.com/question/362649730/answer/974395522

- WASM 运行时性能在原理上就是受限的，跑不到真正的汇编级别。Rust 编译到 WASM 后有不小的性能损失，极致优化后的 JS 不会输它多少——所以真实世界 benchmark 里，WASM 往往并没有压倒性的优势。不要以为这是因为它不够成熟，而是原理上就决定了。

- WASM 不是计算密集型应用的唯一救星。对于真正高度并行且精度要求不高的算法，用 WebGL 做 GPU 加速往往更快，然后才是 WASM 这种 CPU 上运行的字节码。

- 嵌入 WASM 函数到 JS，未必就能提高性能。JS 自身的 JIT 已经内置了机器码级的优化，你手动把算法重写成 C，未必比 Happy Path 上的 JIT 更快。

- JS 与 WASM 的双向调用并不像 Python 嵌入 C 那么简单，你不能随便把 JS 里的对象直接交给 WASM，至于喊着打通一切运行时类型的 WASM Interface Types 才刚有了个影子。

- 主流前端 UI 框架未必值得用 WASM 重写，它们的场景是 IO 密集的，换语言彻底重写的投入产出比很难说。按相同逻辑，既然 JVM 比 V8 快，你愿意用 Java 重写 Node 服务吗？

- WASM 生态跟前端工具链基本无关，它的 Emscripten 工具链搞的完全就是 C++ 系语言交叉编译，从编译器到依赖库都完全跟 JS 这一套无关。

---

好的，我们来详细、容易理解地讲解这篇文章。

这篇文章是一篇极具洞察力且风趣的技术评论。作者王译锋借用了著名恋爱游戏/动漫《白色相簿 2》中的人物关系（俗称“白学”）作为比喻，深入浅出地剖析了 WebAssembly (WASM) 技术在前端领域的真实地位、优势、局限以及与 JavaScript (JS) 之间复杂的关系。

**核心观点摘要：WASM 并非前端性能问题的“银弹”，它的性能有其上限，且与 JS 的集成存在复杂性。它真正的价值更多在于为原生应用（如 C++/Rust 编写的程序）提供一个跨平台的发布渠道（即在浏览器中运行），而不是要全面取代 JS 来编写常规的网页应用。**

为了方便理解，我们先揭示一下贯穿全文的“白学”比喻：

- **JavaScript (JS)** 被比作 **冬马和纱 (Touma Kazusa)**：她是“先来的”，是浏览器这个舞台的原住民。她有自己的脾气和怪癖（弱类型、动态性），但与浏览器深度绑定，并且在特定领域（如 UI 操作）是绝对的主场。她的引擎（V8 等）非常了解她，能把她优化得很好。
- **WebAssembly (WASM)** 被比作 **小木曾雪菜 (Ogiso Setsuna)**：她是“后来的”，是校园偶像，人见人爱，看似完美。她非常通用，能让各种语言（C++, Rust）都编译成她的格式，实现跨平台。她的目标宏大，希望统一跨平台的未来，但她与浏览器和 JS 的关系，并非表面看起来那么简单和谐。

下面，我们逐一解析文章 debunk (揭穿) 的几个常见误解：

### 误解一：WASM == 汇编级性能？

**作者的观点：不对。WASM 是一种字节码，需要虚拟机来解释执行，其性能介于 JS 和原生机器码之间，更接近 Java/C# 的水平，而非 C++。**

- **详细解释**：
  - WASM 的 "Assembly" 名字有误导性。它不是 CPU 能直接运行的机器码，而是一种需要被浏览器内的 WASM 虚拟机解析和编译的中间格式。
  - 性能对比：如果原生 C++ 性能是 100%，那么 WASM 大概在 30-50% 的水平，而经过 JIT (Just-In-Time) 优化的 JS 大概在 5-10% 的水平。
  - **关键论据：JS vs Rust 的“白学现场”**。作者引用了一个著名案例：Mozilla 的开发者用 Rust+WASM 优化了一个库，性能提升 5 倍。但 V8 的开发者不服，用纯 JS 写出了比 Rust 版本更快的代码。经过几轮“高手过招”，最终虽然 Rust 版略胜一筹，但极限优化的 JS 性能也极其强悍，证明了在特定场景下，JS 并不比 WASM 差。
  - **白学比喻**：这场你来我往的性能竞赛，被比作冬马和雪菜之间的高水平对决。JS 那段被引用的台词，就是模仿冬马对男主角的哭诉，生动地表达了“明明我在这里好好的，你却跑到一个我无法企及的高度，反过来还说我不好”的委屈感。

### 误解二：计算密集型任务就该用 WASM？

**作者的观点：不一定。对于高度并行的计算，用 WebGL (GPU 加速) 通常更快。WASM 只是提供了一个新的选择。**

- **详细解释**：
  - WASM 运行在 CPU 上。而像图像处理、AI 推理这类任务，很多计算是可以大规模并行化的，这正是 GPU 的强项。
  - **性能对比**：作者提到，用 WebGL 实现图像滤镜，可以比 JS 快几十倍；而用 WASM 重写，可能只快几倍。在浏览器内 AI 计算的评测中，WebGL/WebMetal 的性能也是顶尖的，优于 WASM。
  - **WASM 的优势**：**计算结果的精确性**。WebGL 在不同 GPU 上可能存在微小的精度差异，而 WASM 能保证与 JS 的计算结果完全一致。Pica 这个图像缩放库从 WebGL 转向 WASM 就是为了这个原因。
  - **白学比喻**：WebGL 就像是另一个“先来的”角色，它在 3D、图像处理、深度学习等领域都先于 WASM 出现并占据了优势。这里引用了《白色相簿 2》中冬马的经典台词：“是我，是我先，明明都是我先来的…”，表达了 WebGL 在这些领域的“正统”地位。

### 误解三：把 JS 函数换成 WASM 就能提速？

**作者的观点：不一定。JS 引擎的 JIT 优化本身就很强大，而且 JS 与 WASM 之间的函数调用有开销。**

- **详细解释**：
  - **JIT 的威力**：现代 JS 引擎（如 V8）会自动分析你的代码。如果一个函数被高频调用，并且参数类型稳定（比如总是在做整数加法），JIT 会自动把它编译成高效的机器码。这个过程相当于引擎在“自动帮你把 JS 转成 C”。
  - **调用开销**：JS 调用 WASM 函数，或者反过来，数据需要在两个不同的内存空间（JS 堆和 WASM 线性内存）之间传递和转换。虽然这个开销已经被优化得很小，但对于非常简单的函数，这个开销可能比 JIT 优化后的纯 JS 调用还要大。
  - **白学比喻**：这里引用了《白色相簿 2》中一句悲伤的台词，比喻当 JS 和 WASM 之间的数据传递变得复杂和低效时，这种“跨界调用”本身就失去了意义。

### 误解四：在 JS 里调 WASM，就像 Python 里调 C 那样简单？

**作者的观点：完全不同，并且更复杂。WASM 无法直接操作 JS 对象，数据交互有“两层胶水”的性能问题。**

- **详细解释**：
  - **FFI vs WASM**：传统的 FFI (外部函数接口) 是在一个运行时（如 Python）里直接调用 C 函数，它们共享内存和对象管理。
  - **WASM 的隔离**：WASM 有自己独立的线性内存。它只能理解数字（整数、浮点数）。对于复杂的 JS 对象（如 DOM 元素），WASM 无法直接访问。
  - **两层胶水**：当 WASM 需要操作浏览器 API (如 WebGL) 时，流程是：`WASM -> JS 胶水代码 -> 浏览器 WebGL API`。这比 `JS -> 浏览器 WebGL API` 多了一层，性能可能更差。
  - **未来的饼：Interface Types**。Mozilla 正在推动一个新规范，试图让 WASM 能更好地理解和操作外部世界（如 DOM）的复杂类型，但这还很遥远。
  - **白学比喻**：这里引用了《白色相簿 2》中最著名的一幕，男主角在面对两位女主角时内心的独白：“为什么会变成这样呢…”。这比喻了浏览器本想通过引入 WASM 获得“双份快乐”（JS 的便利 + 原生语言的性能），结果却带来了意想不到的复杂性和痛苦。

### 误解五：前端框架迟早会用 WASM 重写？

**作者的观点：很难，投入产出比太低。**

- **详细解释**：
  - **瓶颈不同**：主流前端应用是 **IO 密集型**（等待网络、响应用户输入），而不是 **计算密集型**。性能瓶颈通常不在于 JS 的计算速度，而在于 DOM 操作、网络延迟等。WASM 提升的计算能力在这里用处不大。
  - **工程成本**：用 WASM 重写意味着要放弃庞大的 JS 生态，引入一套完全不同的语言和工具链（如 Rust/C++），维护成本极高。
  - **白学比喻**：这里引用了鲁迅的名言，并将其改编为 JS 爱好者的呐喊：“我即使是死了……也要在墓里……喊出：JS 牛逼！！！” 表达了 JS 社区强大的惯性和文化认同。

### 总结：WASM 到底是什么？

作者最后总结，WASM 的生态、工具链（如 Emscripten）都与 JS 无关，它更像是原生开发者的一套工具。它的真正目标是**让复杂的原生应用（游戏、桌面软件）能方便地发布到 Web 平台**，而不是让前端开发者换一种语言写网页。

- **最终的人物画像**：
  - **JS (冬马)**：浏览器是我的主场，我只忠于浏览器。
  - **WASM (雪菜)**：我想成为所有平台的偶像，虽然我和 JS、浏览器关系很好，但我最终的梦想是实现我自己的跨平台幸福。

**结论：WASM 是一项革命性的技术，但前端开发者应理性看待。它不是取代 JS 的“神器”，而是一个强大的“插件”，用于解决特定类型的性能瓶颈，或将非 JS 世界的应用引入浏览器。理解它的适用场景和局限性，才能做出正确的技术选型。**
