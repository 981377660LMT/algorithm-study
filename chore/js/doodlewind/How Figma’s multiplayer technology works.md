https://www.figma.com/blog/how-figmas-multiplayer-technology-works/

好的，我们来详细讲解这篇来自 Figma 团队的技术文章。

这篇文章深入剖析了 Figma 如何从零开始构建其核心的**多人实时协作（multiplayer）**功能。文章的核心在于解释他们**为什么没有选择**传统的技术方案（如 OT），以及他们**如何借鉴**了另一种思想（CRDT），并根据自身业务场景进行改造，最终形成了一套简单、高效且独特的解决方案。

以下是对文章内容的逐段精讲：

### 1. 引言：为什么要做以及为什么分享

- **背景**: 四年前，Figma 决定自研多人协作功能。当时，这是设计工具领域的一个创举。
- **技术选型**: 他们刻意避开了当时业界标准、被 Google Docs 等应用普及的**操作转换（Operational Transforms, a.k.a. OTs）**算法，因为他们认为 OT 对于设计工具这个场景来说“过于复杂”。作为初创公司，他们更看重快速迭代和交付功能的能力。
- **产品决策的风险**: 当时市场并不看好“多人协作设计工具”。设计师们担心这会导致“总监在旁边指指点点”或“委员会式设计”的灾难。
- **Figma 的信念**: 尽管如此，Figma 坚信基于 Web 的工具天然就应该支持多人协作。这能消除文件传来传去（导出、同步、邮件）的麻烦，让更多角色（如文案、开发）无缝参与到设计流程中。
- **分享的目的**: 他们的赌注成功了，多人协作已成为生产力工具的标配。但相关的公开技术案例很少，因此 Figma 决定分享自己的实现细节，希望能帮助到其他开发者。

### 2. 技术背景：Figma 的架构与原型开发

- **基本架构**:
  - **客户端/服务器 (Client/Server) 模式**: Figma 客户端（网页）通过 WebSocket 与服务器集群通信。
  - **服务器是“权威中心”**: 服务器为每个打开的文档启动一个单独的进程，所有编辑该文档的用户都连接到这个进程。服务器是最终状态的决定者。
- **连接与离线流程**:
  - **首次加载**: 客户端下载一份完整的文档副本。
  - **在线同步**: 之后的所有更新都通过 WebSocket 实时同步。
  - **离线编辑与重连**: 用户可以离线编辑。当重新上线时，客户端会：
    1.  下载一份最新的文档副本。
    2.  将离线期间的本地修改**重新应用（reapply）**到这份新副本之上。
    3.  建立新的 WebSocket 连接，继续同步。
  - 这个设计大大简化了连接/重连的逻辑，将所有复杂性都集中在了处理“已连接文档的实时更新”上。
- **原型的重要性**: 在动手修改主代码库之前，他们先创建了一个**原型环境**。这个原型是一个模拟了三个客户端和一个服务器的网页，可以直观地看到整个系统的状态变化。这让他们能快速试验和评估不同的协作算法（如模拟离线、网络延迟等场景），最终才将成熟的想法移植到真实代码中。

### 3. 核心算法的权衡：OT vs. CRDT

这篇文章最重要的部分就是解释了 Figma 在核心算法上的思考和选择。

- **OT (操作转换)**:

  - **是什么**: 一种处理并发编辑的经典算法，常见于协同文本编辑器。它通过转换（transform）操作来确保不同用户在不同状态下执行的操作，最终能合并成一致的结果。
  - **为什么 Figma 不用**:
    1.  **极其复杂**: OT 需要处理各种并发场景的组合，状态爆炸，形式化证明非常困难且容易出错。
    2.  **杀鸡用牛刀**: OT 在处理长文本编辑时内存和性能开销很低，非常强大。但 Figma 不是文本编辑器，其核心是操作图形对象，不需要 OT 那么强大的能力。简单的系统更容易实现、调试、测试和维护。

- **CRDT (无冲突复制数据类型)**:
  - **是什么**: 一种用于分布式系统的数据结构。它允许不同节点独立、并发地更新数据副本，并保证这些副本**最终会收敛到一致的状态**。
  - **Figma 如何借鉴**: Figma 的技术**受到了 CRDT 的启发**。CRDT 保证“最终一致性”的数学特性，正是协同系统所必需的——不能让两个用户的文档永远分裂下去。
  - **为什么 Figma 不完全是 CRDT**:
    1.  **CRDT 为去中心化设计**: 真正的 CRDT 适用于没有中央权威的 P2P 网络，因此需要额外的开销来解决冲突。
    2.  **Figma 是中心化的**: Figma 有一个作为“唯一权威”的服务器。因此，他们可以**简化 CRDT 的设计**，去掉不必要的开销，让实现更轻更快。例如，很多 CRDT 需要用时间戳+节点 ID 来判断谁的修改最新，而 Figma 可以直接由服务器来定义事件的顺序。

### 4. Figma 的数据结构：万物皆对象

- **文档结构**: 一个 Figma 文档本质上是一棵**对象树**，类似于 HTML DOM。根节点是文档，下面是页面，页面下是图层对象。
- **数据模型**: 可以理解为一个两层嵌套的 Map：`Map<ObjectID, Map<Property, Value>>`。
  - 每个对象都有一个唯一的 ID。
  - 每个对象都有一系列属性和对应的值。
- **优点**: 这种模型扩展性极强。添加新功能，通常只是意味着给对象增加新的属性。

### 5. 实现细节：Figma 的多人协作算法

这里是文章的技术核心，解释了 Figma 如何处理不同类型的操作。

- **同步对象属性**:

  - **策略**: **“属性”级别的“最后写入者获胜” (Last-Writer-Wins)**。服务器只记录每个对象、每个属性的最新值。
  - **优点**: 两个客户端修改**同一个对象**的**不同属性**，不会冲突。
  - **缺点/权衡**: 如果两个客户端同时修改**同一个对象**的**同一个属性**（比如文本内容），结果将是最后到达服务器的那个值，而不是合并的结果（例如，A 把 "B" 改成 "AB"，B 把 "B" 改成 "BC"，最终结果是 "AB" 或 "BC"，绝不会是 "ABC"）。Figma 认为这个权衡是值得的，因为它不是文本编辑器。
  - **解决客户端“闪烁”问题**: 客户端会立即应用本地修改以保证响应速度。但如果此时收到一个服务器发来的、针对同一属性的、但比本地修改更“旧”的确认值，界面就会闪烁。Figma 的策略是：**忽略与本地未确认的修改相冲突的服务器消息**，因为本地未确认的修改在时间上是“最新”的，是最终状态的最佳预测。

- **同步对象创建和删除**:

  - **创建**: 客户端生成一个**全局唯一的对象 ID**（通常是 `客户端ID + 时间戳/序列号`），这样可以支持离线创建。
  - **删除**: 删除操作会从服务器上彻底移除对象及其所有属性。被删除的数据仅存在于执行删除操作的那个客户端的“撤销缓冲区”里。如果该用户撤销删除，客户端负责将所有属性数据重新发给服务器。这可以防止文档体积因长期编辑而无限增长。

- **同步对象树**:

  - **核心挑战**: 如何处理“移动对象”（reparenting）操作。
  - **Figma 的方法**:
    1.  **父子关系**: 在**子对象**上存储一个指向父对象的 `parent` 属性。这能保持对象的 ID 不变，从而避免了移动时并发修改丢失的问题。
    2.  **环路问题**: 如果 A 将对象 X 设为 Y 的子节点，同时 B 将 Y 设为 X 的子节点，就会形成一个环。服务器会**拒绝**会导致环路产生的父节点更新。但在客户端，由于网络延迟，可能会临时出现环路。
    3.  **临时环路处理**: 当客户端出现临时环路时，Figma 会**暂时将这些对象从画布中移除**，直到服务器拒绝了客户端的非法操作，再将对象放回正确的位置。这是一个简单但有效的方案，因为这种情况非常罕见。
    4.  **子节点排序**: 使用一种叫**“分数索引” (Fractional Indexing)** 的技术。每个子对象在父节点中的位置由一个 0 到 1 之间的小数表示。要将一个对象插入到两个对象之间，只需将其位置设为那两个对象位置的平均数即可。

- **实现撤销 (Undo)**:
  - **多人撤销的困惑**: 如果你撤销一个操作，但此时别人已经对同一个对象做了修改，应该发生什么？
  - **Figma 的指导原则**: **“撤销 -> 复制 -> 重做”这个常用操作序列不应该改变文档的任何内容。**
  - **实现**: 为了遵循这个原则，Figma 的“撤销”操作不仅会回退操作，还会**修改“重做”的历史记录**；同理，“重做”也会修改“撤销”的历史记录。这避免了简单的“重放我的操作”导致覆盖他人修改的问题。

### 6. 总结与启示

1.  **CRDT 很有用**: 即使你构建的是中心化系统，CRDT 的理论研究也是一个非常好的起点，它能帮助你建立对如何构建一个正确系统的直觉。
2.  **视觉编辑器的多人协作没那么可怕**: 相比于文本编辑器，图形编辑器的并发冲突场景相对简单，可以采用更简化的模型。
3.  **原型开发价值巨大**: 前期的研究和原型设计投入，为后续的顺利开发铺平了道路，回报丰厚。
