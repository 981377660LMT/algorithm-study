# 对可多人协同编辑的在线编辑器，如何设计其 undo/redo 的逻辑？

好的，我们来详细讲解这篇文章。

这篇文章深入浅出地探讨了在设计**可多人协同编辑的在线编辑器**时，一个核心且棘手的难题：**如何实现撤销/重做（Undo/Redo）功能**。作者王译锋以其一线实践经验，总结出了业界主流的设计思想和实现路径。

核心观点可以概括为：**协同环境下的 Undo/Redo 不再是一个简单的后进先出（LIFO）栈，而是一个基于“逆操作”和“可抵消性”的、针对单个用户的历史管理系统。**

以下是对文章主要论点的分点精讲：

### 1. 两条核心设计准则

作者开篇就提出了构建协同 Undo/Redo 系统的两条“基本法”，这是整个设计的基石。

- **准则 1：用户只能撤销自己的改动。**

  - **含义**: 用户的撤销操作不应该影响或回滚其他协作者的任何操作。如果 Alice 点击撤销，只有 Alice 自己做的最后一次修改会被撤销，而 Bob 在此期间做的修改会保持不变。
  - **重要性**: 这是协同系统能正常工作的前提。如果撤销会影响他人，整个协作状态将变得混乱且不可预测，用户的“集体记忆”会被轻易破坏。

- **准则 2：用户从状态 A 独立撤销 N 次之后再重做 N 次，要能回到状态 A。**
  - **含义**: 这条规则定义了 Undo 和 Redo 的“可逆性”和“封闭性”。无论中间状态多么复杂，一个用户的撤销/重做序列必须是自洽的。
  - **技术需求**: 这不仅仅是产品体验要求，更是技术实现上的一个重要约束。它保证了无论用户如何操作自己的历史记录，都不会导致文档进入一个不可恢复的损坏状态。

### 2. 挑战传统栈模型：“釜底抽薪”的场景

作者用一个生动的例子说明了为什么传统的栈模型会失效。

- **场景**: 假设文档的历史操作序列是 `A B C D`，其中 `A, B, C` 来自 Alice，`D` 来自 Bob。
- **问题**: Alice 可能在 `D` 操作之后，想撤销她很久以前做的 `C` 操作。根据准则 1，这是被允许的。
- **结果**: 文档的状态可能会变成类似 `A B D` 的样子。这意味着历史记录不再是线性的栈，我们从中间“抽掉”了一个元素。这种操作被称为“釜底抽薪”。

### 3. 解决方案：引入“逆操作” (Inverse Operation)

面对非线性的历史操作，主流方案不是像 Git Rebase 那样去重写和整理历史，而是引入一个更灵活的概念。

- **核心思想**: 将“撤销”理解为**应用一个“逆操作”**。

  - 对于任何一个操作 `X`（例如：在位置 5 插入 "hello"），我们都能计算出它的逆操作 `X'`（例如：在位置 5 删除 5 个字符）。
  - `X` 和 `X'` 的关键特性是它们可以**互相抵消**。即连续应用 `X` 和 `X'` (`X` 后跟 `X'`)，文档状态应该不变。

- **重新审视场景**: 当 Alice 撤销 `C` 操作时，系统实际上做的是在当前状态 `A B C D` 的基础上，应用 `C` 的逆操作 `C'`。
  - 最终状态变成了 `A B C D C'`。
  - **关键点**: 作者强调，我们**不必关心** `A B C D C'` 是否严格等于我们想象中的 `A B D`。在复杂的 CRDT 或 OT 算法中，它们可能不等价。但只要算法能保证状态的最终一致性和可用性，这就足够了。

### 4. “消消乐”：解释准则 2 的技术内涵

作者通过一个“消消乐”的比喻，生动地解释了为什么我们不必关心中间状态，而只需关心最终的可恢复性。

- **场景**: Alice 连续做了 `A, B, C` 三个操作，Bob 做了 `D`。当前状态为 `A B C D`。
- **步骤**:
  1.  **Alice 连续撤销 3 次**: 系统依次应用 `C'`, `B'`, `A'`。状态变为 `A B C D C' B' A'`。
  2.  **Alice 连续重做 3 次**: 系统依次应用 `A`, `B`, `C`。状态变为 `A B C D C' B' A' A B C`。
  3.  **开始“消消乐”**:
      - `A'` 和 `A` 抵消，状态变为 `A B C D C' B' B C`。
      - `B'` 和 `B` 抵消，状态变为 `A B C D C' C`。
      - `C'` 和 `C` 抵消，状态变为 `A B C D`。
- **结论**: 经过一轮“撤销-重做”循环后，文档状态完美地回到了最初的 `A B C D`。这证明了系统的自洽性。**我们真正关心的是，重做能够精确地抵消掉对应的撤销操作，从而恢复到撤销前的状态。**

### 5. 与 OT/CRDT 的关系

作者明确了 Undo/Redo 模块在整个协同系统中的位置。

- **分层**: Undo/Redo 逻辑是**独立于**（也**依附于**）底层的冲突解决算法（OT 或 CRDT）的一个上层模块。

  - **OT/CRDT 的职责**: 解决来自**不同用户**的**并发操作**之间的冲突，保证数据最终一致。
  - **UndoManager 的职责**: 管理**单个用户**自己的操作历史，并根据用户的撤销/重做指令，生成新的“逆操作”提交给底层的 OT/CRDT 系统。

- **实现**:
  - 这个模块可以基于**事件溯源 (Event Sourcing)** 的思想来设计。
  - 作者推荐了 **Yjs** 这个 CRDT 库，它提供了一个开箱即用的 `UndoManager`，其工作原理与上述两条准则完全一致。它为每个用户（`origin`）维护一个独立的 undo 栈，通过对操作前后的数据模型（model）做 diff 来生成逆操作。

### 6. 行业趋势：CRDT 的未来

文章最后，作者给出了一个带有“八卦”性质的行业观察：**CRDT 正在成为协同领域的未来**。

- **CRDT 的优势**:
  - 易于实现可横向扩展的服务端（因为冲突解决逻辑在客户端）。
  - 易于实现端到端加密（因为服务器不需要理解数据内容）。
  - 性能问题已通过 Yjs 等现代 CRDT 算法得到大幅优化。
- **趣闻**: 连最流行的开源 OT 库 ShareDB 的作者，也转向了 CRDT 阵营，并致力于用 Rust 重写 Yjs 以追求极致性能。

总而言之，这篇文章为我们构建了一个清晰的协同 Undo/Redo 心智模型：它不是一个简单的全局栈，而是一个分布式的、基于用户身份的、通过应用“逆操作”来实现的局部历史管理系统，它与底层的冲突解决算法协同工作，共同保证了复杂协作场景下用户体验的一致性和可靠性。

---

好的，我们来详细讲解一下 **事件溯源 (Event Sourcing)**。

事件溯源是一种强大的软件架构模式。它的核心思想是：**不直接存储系统的当前状态，而是将导致系统状态发生变化的每一个“事件 (Event)”按顺序记录下来。系统的当前状态是通过从头到尾重放（replay）这些事件计算得出的。**

---

### 核心思想：记录“变化”而非“现状”

让我们通过对比来理解：

- **传统方法 (State-Oriented)**:

  - 以一个银行账户为例，数据库里有一张 `Accounts` 表，其中有一行记录着用户的账户信息，包括一个 `balance` 字段。
  - 当用户存入 100 元时，系统执行 `UPDATE Accounts SET balance = balance + 100 WHERE account_id = '123'`。
  - **缺点**: 我们只知道当前余额是多少，但**丢失了“为什么”会变成这个余额**的历史信息。我们不知道这笔钱是分几次存入的，也不知道中间是否有过取款。

- **事件溯源方法 (Event Sourcing)**:
  - 系统不存储 `balance` 这个当前状态。取而代之的是一个只允许追加写入的“事件日志”或“事件存储 (Event Store)”。
  - 当用户存入 100 元时，系统记录一个事件：`{ event: 'MoneyDeposited', amount: 100, timestamp: '...' }`。
  - 当用户取出 30 元时，系统记录另一个事件：`{ event: 'MoneyWithdrawn', amount: 30, timestamp: '...' }`。
  - **获取当前余额**: 系统会读取该账户的所有事件 `['MoneyDeposited(100)', 'MoneyWithdrawn(30)']`，然后依次计算：`0 + 100 - 30 = 70`。
  - **优点**: 我们拥有了完整的、不可变的审计日志。系统的任何状态都是可以从这个事件流中推导出来的。

---

### 关键组件

一个典型的事件溯源系统包含以下几个部分：

1.  **事件 (Event)**

    - 描述**已经发生**的事实。它是不可变的（immutable）。
    - 通常以过去时态命名，例如 `UserRegistered`, `OrderPlaced`, `ItemAddedToCart`。
    - 包含了导致状态变化的所有必要信息。

2.  **命令 (Command)**

    - 表示执行某个操作的**意图**。它描述了**希望发生**的事情。
    - 通常以动词形式命名，例如 `RegisterUser`, `PlaceOrder`, `AddItemToCart`。
    - 命令可以被接受或拒绝。如果被接受，它会产生一个或多个事件。

3.  **聚合 (Aggregate)**

    - 一个业务逻辑处理单元，它接收命令，验证业务规则，并在验证通过后生成事件。
    - 聚合的内部状态完全由它所应用过的事件流来决定。例如，一个 `Order` 聚合的状态（订单项、总价、收货地址）是通过重放 `OrderPlaced`, `ItemAdded`, `ShippingAddressChanged` 等事件来构建的。

4.  **事件存储 (Event Store)**
    - 专门用于存储事件的数据库。它是系统的**唯一事实来源 (Single Source of Truth)**。
    - 它通常是一个只允许追加（append-only）的日志，保证了事件的顺序和不可变性。

### 工作流程

1.  **接收命令**: 应用程序接收到一个来自用户的命令（如“将商品 A 添加到购物车”）。
2.  **加载聚合**: 系统根据命令中的 ID（如购物车 ID）从事件存储中加载所有相关事件，并重放它们来构建出聚合（购物车）的当前状态。
3.  **处理命令**: 聚合接收到命令，并执行其内部的业务逻辑（如检查库存、计算价格）。
4.  **生成事件**: 如果命令有效，聚合会生成一个或多个事件（如 `ItemAddedToCart` 事件）。
5.  **持久化事件**: 系统将新生成的事件追加到事件存储中。
6.  **发布事件 (可选但常见)**: 事件被发布到消息总线，供其他系统部分（如下文提到的“投影”）订阅和处理。

---

### 优点

1.  **完整的审计日志**: 拥有系统从诞生以来的所有变更历史。这对于调试、业务分析、合规性审查非常有价值。
2.  **时间旅行 (Time Travel)**: 可以轻松地将系统的状态重建到过去的任意时间点，这对于重现 Bug 和分析问题是“神器”。
3.  **灵活的读取模型 (Projections)**: 这是事件溯源最强大的优点之一。因为你拥有了全部的事件流，你可以创建出任意多个、为不同查询场景优化的“读取模型”或“投影 (Projection)”。
    - 例如，同一个订单事件流，可以生成一个给用户看的订单详情视图，也可以生成一个给财务看的销售统计报表。这些投影可以独立更新和演进，而不用修改核心的写入逻辑。这通常与 **CQRS (命令查询职责分离)** 模式结合使用。
4.  **高性能写入**: 写入操作只是向日志末尾追加事件，这通常比更新关系型数据库中的多行多列表更快，锁竞争更少。
5.  **业务洞察**: 事件流本身就是宝贵的数据资产，可以用来进行深入的业务智能分析，发现用户行为模式等。

### 缺点与挑战

1.  **复杂性增加**: 这是一种与传统 CRUD (增删改查) 截然不同的思维模式，学习曲线较陡峭。你需要管理事件、版本、投影等更多概念。
2.  **最终一致性 (Eventual Consistency)**: 读取模型（投影）通常是异步更新的。这意味着当一个命令执行成功后，相关的查询结果可能不会立即更新，会存在一个短暂的延迟。UI 设计需要考虑这一点。
3.  **事件模型的设计与演进**: 事件一旦被记录，就应该是不可变的。如果业务发生变化，需要修改事件的结构（例如给 `UserRegistered` 事件增加一个字段），就需要进行“事件版本控制”，这会增加复杂性。
4.  **查询当前状态的开销**: 如果一个聚合的事件非常多（例如一个活跃了十年的账户），每次都从头重放所有事件来获取当前状态会很慢。通常的优化方法是定期创建**快照 (Snapshot)**，即在某个时间点保存一份聚合的完整状态，下次只需要从最近的快照开始重放事件即可。

总而言之，事件溯源是一个非常强大的模式，特别适用于领域逻辑复杂、需要完整审计历史、或需要灵活查询能力的系统（如金融、电商、协同编辑等）。但它也带来了更高的复杂性，不应被滥用在简单的 CRUD 应用中。
