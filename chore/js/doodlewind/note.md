https://www.zhihu.com/people/doodlewind

1. 如何看待微软宣布停用 Atom 编辑器，如何评价 Atom 编辑器的历史？
   好的，我们来详细解读一下这篇文章。

   这篇文章从一位前端开发者的视角，深入分析了微软宣布停用 Atom 编辑器的原因，并对其历史定位和技术架构进行了评价。核心观点是：Atom 的失败根源于其“为可定制而生 (hackable)”的核心设计哲学，这种哲学虽然带来了极高的灵活性，却牺牲了至关重要的性能和用户体验，最终在与 VS Code 的竞争中落败。

   以下是对文章主要论点的分点解析：

   ### 1. “两份快乐”与“梦境般的开发体验”

   - **背景**: 文章开头用一种略带伤感的文学性语言，回顾了 Atom 诞生时的盛况。
   - **第一份快乐**: **JavaScript 成为一等公民**。在 Atom 之前，主流编辑器（如 Sublime Text）的插件主要用 Python 等语言编写。Atom 首次让前端开发者可以使用他们最熟悉的 JavaScript 来编写编辑器插件，极大地降低了生态贡献的门槛。
   - **第二份快乐**: **Electron 框架的诞生**。Atom 开创性地使用了 Electron（当时还叫 Atom Shell）。这个框架允许开发者使用 Web 技术（HTML, CSS, JavaScript）来构建跨平台的桌面应用。这意味着前端开发者可以将在浏览器中积累的知识直接用于桌面开发，比如 `require('fs')` 意味着可以在一个“网页”里直接操作本地文件系统。
   - **结论**: 这两大创新结合，本应为前端开发者带来前所未有的幸福开发体验，但结果却事与愿违。作者由此引出核心问题：为什么会失败？

   ### 2. 核心设计哲学：“Hackable” (可深度定制)

   - **定义**: Atom 的口号是 "A hackable text editor for the 21st Century"。这意味着它的设计目标就是让用户可以“魔改”编辑器的每一个角落。
   - **具体表现**:
     - **UI 完全开放**: 你可以用 CSS 修改编辑器里几乎任何一个可见元素，从按钮到标签页再到状态栏。
     - **核心状态可访问**: 插件可以直接访问和操作编辑器的核心对象和状态。
     - **DOM 直接操作**: 插件可以直接获取和修改编辑器窗口的 DOM 树，就像操作一个普通网页一样。
   - **生动案例**: “你码炸了 (Power Mode)” 插件。这个插件能在你打字时产生酷炫的爆炸和震动效果。在 Atom 上实现非常简单，因为它允许插件直接在整个页面上应用 CSS 动画和 DOM 操作。相比之下，VS Code 出于架构限制，其同类插件的效果要逊色得多。

   ### 3. “Hackable” 的工程代价

   - **违反最小权限原则**: 这是软件工程的一个核心原则，即一个模块（在这里是插件）只应该被授予完成其任务所必需的最小权限。Atom 的做法恰恰相反，它给了插件几乎无限的权限（比如直接操作 DOM）。
   - **带来的问题**:
     - **性能瓶颈**: 任何一个低效的插件都可能直接操作 DOM，导致整个编辑器界面卡顿。编辑器核心团队无法控制第三方插件的行为。
     - **阻碍优化**: 因为暴露了太多内部实现（如 DOM 结构），核心团队一旦想进行底层优化或重构，就极有可能破坏大量现有插件的兼容性，这使得技术演进变得异常困难。
     - **缺乏进程隔离**: 文章提到但未展开。简单来说，VS Code 将插件运行在独立的进程中，即使某个插件崩溃或占用大量资源，也只会影响它自身，而不会拖垮整个编辑器主进程。Atom 的插件与核心 UI 运行在同一个进程中，一荣俱荣，一损俱损。

   ### 4. 失败的改革：Xray 项目

   - **背景**: Atom 团队意识到了性能问题，并启动了名为 Xray 的项目，尝试用高性能的 Rust 语言重写编辑器核心逻辑。
   - **为什么失败了**: 作者一针见血地指出，这个方向是错误的。
     - **瓶颈不在于逻辑**: Atom 的性能瓶颈主要不在于业务逻辑的计算速度，而在于 **渲染**。
     - **Electron 的原罪**: 只要继续使用基于 Chromium 的 Electron，渲染卡顿的问题就无法根治。因为浏览器渲染管线是为了高吞吐量（一次性加载和渲染一个复杂的网页）设计的，而不是为低延迟（响应每一次按键、每一次光标移动）优化的。
     - **两难困境**: 如果为了性能放弃 Electron，那就等于放弃了基于 Web 技术的“Hackable”特性，Atom 将不再是 Atom。

   ### 5. 对前端技术路线的反思

   - **开发体验 (DX) vs. 用户体验 (UX)**: 作者认为，部分前端文化过于强调开发者的体验（比如使用熟悉的技术栈、高度的灵活性），而忽略了最终用户的体验（流畅、稳定、快速）。
   - **与 Linux 桌面的类比**: “可以魔改的编辑器”听起来很像“可以魔改的操作系统 (Linux)”。尽管 Linux 给予了用户极大的自由度，但其桌面发行版的整体用户体验（尤其对非技术用户而言）长期以来都不如 Windows 或 macOS。这说明，对于大多数用户来说，**稳定流畅比天花乱坠的魔改特效更重要**。

   ### 总结 (暴论)

   文章最后给出了三个言简意赅的结论：

   1. **遵守最小权限原则**: 设计 API 时，不要暴露非必要的能力。这既是对自己负责，也是对生态负责。
   2. **架构比语言更重要**: 不要迷信于用某个“更快”的语言（如 Rust）重写就能解决所有问题。底层的架构设计缺陷是换语言无法弥补的。
   3. **用户体验优先**: 对工具类产品（如编辑器）而言，战略上必须将最终用户的体验（性能、稳定性）置于开发者体验（插件开发的便利性）之上。

   总而言之，这篇文章认为 Atom 的衰落是一个技术架构选择导致用户体验失败的典型案例，它的“开放”与“灵活”最终变成了拖垮自己的沉重枷锁。

   ### 1. UI 定制：受控的 API vs. 自由的 CSS

   - **Atom**: 允许插件和用户通过 CSS 直接修改界面中几乎任何元素的样式。你可以直接审查元素，然后编写 CSS 来覆盖它。
   - **VS Code**: **不允许**插件直接注入任意 CSS 来修改主界面。它提供了一套严格且抽象的 **Theming API**：
     - **颜色主题 (Color Theme)**: VS Code 定义了数百个“可主题化颜色”的标识符（如 `editor.background`, `panel.border`, `button.foreground`）。主题或用户配置只能为这些固定的标识符指定颜色值，而不能改变元素的布局、大小或行为。
     - **图标主题 (Icon Theme)**: 类似地，通过 API 指定文件或文件夹对应的图标。
     - **Webview**: 插件唯一可以完全控制 UI 的地方是在一个 `Webview` 面板中。但这块区域与编辑器主 UI 是隔离的，插件可以在自己的“小网页”里为所欲为，但无法影响到编辑器框架本身。

   **设计意图**: 这种抽象设计将“样式”与“结构”解耦。VS Code 核心团队可以随时重构底层的 HTML (DOM) 结构来优化性能，而不会破坏成千上万个主题的外观。

   ### 2. 扩展能力与状态访问：严格的 API 边界 vs. 直接访问

   - **Atom**: 将核心编辑器对象直接暴露给插件，插件可以随意监听事件、修改状态。
   - **VS Code**: 提供了一个定义明确、版本化的 **`vscode` 模块 API**。插件只能通过这个官方 API 与编辑器交互（例如 `vscode.window`, `vscode.workspace`, `vscode.commands`）。
     - **进程隔离**: 这是最关键的区别。VS Code 将所有插件运行在一个独立的 **“扩展主机” (Extension Host) 进程**中。这个进程与编辑器的主 UI 进程是分开的。
     - **异步通信**: 插件与主 UI 之间的所有通信都必须通过异步的进程间通信 (IPC) 来完成。当插件调用 `vscode.window.showInformationMessage("Hello")` 时，它实际上是向主进程发送了一个“请求显示信息框”的异步消息。

   **设计意图**:

   - **性能与稳定性**: 即使某个插件崩溃、死循环或消耗大量内存，它也只会拖垮“扩展主机”进程，而编辑器的主 UI 进程依然能响应用户操作（如打字、保存、关闭窗口）。
   - **安全性与可维护性**: 插件被限制在 API 提供的沙箱内，无法访问或破坏编辑器的内部状态。这同样使得 VS Code 团队可以自由地迭代内部实现，只要保持公开 API 的兼容性即可。

   ### 3. DOM 访问：完全禁止 vs. 随心所欲

   - **Atom**: 插件可以获取并直接操作主窗口的 DOM。
   - **VS Code**: **完全禁止**插件访问编辑器主 UI 的 DOM。这是其进程隔离和 API 优先设计的必然结果。插件对 UI 的唯一感知就是通过官方 API 获取的抽象信息（如当前打开的文档、光标位置等），而不是具体的 HTML 元素。

   ### 总结

   | 特性         | Atom (Hackable)                            | VS Code (Performance & Stability)             |
   | :----------- | :----------------------------------------- | :-------------------------------------------- |
   | **UI 定制**  | 直接、无限制的 CSS 覆盖                    | 通过受控的 Theming API 指定颜色和图标         |
   | **扩展模型** | 插件与核心 UI 在同一进程，直接访问核心对象 | 插件在独立进程中，通过严格的、异步的 API 通信 |
   | **DOM 访问** | 允许插件直接操作主 UI 的 DOM               | 完全禁止插件访问主 UI 的 DOM                  |
   | **核心原则** | 极致的灵活性和可定制性                     | 最小权限原则、性能、稳定性和向后兼容性        |

   简单来说，VS Code 的设计牺牲了 Atom 那种“随心所欲”的魔改能力，换来了更快的性能、更高的稳定性以及更强的工程可维护性。事实证明，对于绝大多数开发者来说，后者远比前者更重要。

2. undo/redo 核心

   1. 用户只能撤销自己的改动，这个对其他人状态的命运有很大的关系。
   2. 用户从状态 A 独立撤销 N 次之后再重做 N 次，要能回到 A。注意这条规则并不只是一条产品需
      求，更是一条重要的技术需求。
      「回放可互相抵消的 operation 逆操作」：我们需要保证的是对任意 operation X 都能获得其逆操作 X'，
      使得 X X’能互相抵消，这样就可以了。
      https://www.figma.com/blog/how-figmas-multiplayer-technology-works/

   - 冲突解决：要么是以 operation 为抓手，打通对轻量 operation 数据的变换，要么是以 model 为抓手，实现出可以任意拥抱变化的 model 数据结构。这两种玩法都有很多「形成闭环赋能业务」的成功案例
