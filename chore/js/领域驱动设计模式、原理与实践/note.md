# 领域驱动设计模式、原理与实践

**推荐小徐先生的公众号文章**

https://mp.weixin.qq.com/s/Gk-tyzx78L6XahZDrMsUYQ
https://blog.csdn.net/weixin_36027743/article/details/113365974
https://fishedee.com/2020/11/28/%E3%80%8A%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%81%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/
https://cloud.tencent.com/developer/article/1423794

## 领域驱动设计（Domain-Driven Design, DDD）：

DDD 是一种软件开发方法，强调将业务领域模型和业务逻辑放在开发的核心位置。通过深入理解业务需求和领域知识，构建出更符合实际业务需求的软件模型。

问：“DDD 到底在什么情况下适用什么情况下适用？”
答：“业务逻辑复杂的系统。”
DDD 的这个回答就很诡异了——到底什么是业务逻辑？到底什么是复杂？

通常大家对于 DDD 所说的领域的白话理解就是：领域就是问题的集合。

---

DDD 的设计过程重新梳理和优化为了以下三个阶段

- 战略设计阶段：对业务问题进行宏观分析和设计。
  澄清业务与问题
- 战术设计阶段：根据战略设计分析结果进行细化和建模。
  RDD 抽象模型建模
- 技术实现阶段：根据实现需要进行细化分析和设计。
  深入实现细节

DDD 是通过协作来达成统一语言从而应对复杂性的，组织背景下的软件开发是一种团队集体运动

---

- 很多时候开发的方式大家倾向于，拿到需求后看表怎么设计，然后看代码怎么写，这其实也是面向过程的一个表现。在软件初期，这样的方式复杂度是很低的，没有复用没有扩展，一人吃饱全家不饿。但随着业务的发展系统的演进，复杂度会陡增。
- 一开始通过领域建模方式，以面向对象思维进行软件设计，复杂度的上升可以得到很好的控制。`先思考我们领域模型的设计，这是我们业务系统的核心，再逐步外延，到接口到缓存到数据库。`但领域的边界，模型的抽象，从刚开始成本是高于数据驱动的。如果刚开始我们直接以数据驱动面向过程的流程式代码，可以很轻松的解决问题，并且之后也不会面向更复杂的场景与业务，那这套模式就是最适合这套系统的架构设计。如果我们的系统会随着业务的发展逐渐复杂，每一次的发布都会提升下一次发布的成本，那么我们应该考虑投入必要的成本来面向领域驱动设计。

---

领域是一个知识的范畴。它指的是我们的软件所要模拟的业务知识。

---

好的，我们来深入讲解一下领域驱动设计（Domain-Driven Design, DDD）。

DDD 不是一个具体的框架或技术，而是一套用于处理复杂软件项目的思想、原则和模式的集合。它的核心目标是通过将软件实现与业务领域模型紧密绑定，来应对日益复杂的业务需求。

### 核心思想

DDD 的核心思想可以概括为两点：

1.  **聚焦核心领域**：将团队的主要精力放在业务的核心和最复杂的部分（核心域），而不是技术细节。
2.  **模型驱动设计**：软件的核心是其领域模型。这个模型不仅仅是数据结构，它还包含了业务规则、行为和逻辑。代码的结构、命名和关系都应该直接反映这个领域模型。

---

### DDD 的两大组成部分

DDD 通常分为两个部分：**战略设计** 和 **战术设计**。

#### 1. 战略设计 (Strategic Design)

战略设计关注的是宏观层面，帮助我们划分和理解复杂的业务领域，定义系统边界。

- **统一语言 (Ubiquitous Language)**

  - 这是 DDD 中最关键的概念。它指的是在项目团队（包括领域专家、产品经理、开发人员、测试人员）之间共享的一套通用的、无歧义的语言。
  - 在会议讨论、文档编写、甚至代码（类名、方法名、变量名）中，都应该使用这套语言。
  - **目的**：消除沟通障碍，确保所有人对业务的理解是一致的，代码即文档。
  - **示例**：在电商领域，"SKU"、"SPU"、"订单快照" 等都属于统一语言的一部分。

- **限界上下文 (Bounded Context)**

  - 任何模型都有其应用的边界。限界上下文就是一个明确的边界（例如一个微服务、一个模块），在这个边界内，统一语言有其唯一的、确切的含义。
  - **目的**：避免模型变得过于庞大和混乱。同一个词在不同的上下文中可以有不同的含义。
  - **示例**：在“商品上下文”中，“商品(Product)”可能包含丰富的属性如库存、规格、详情。但在“售后上下文”中，“商品(Product)”可能只是一个包含 ID、名称和价格的简单对象。

- **上下文映射图 (Context Map)**
  - 它描述了不同限界上下文之间的关系。这有助于我们理解系统各个部分是如何协作的。
  - 常见的关系包括：
    - **合作关系 (Partnership)**：两个上下文紧密合作，共同演进。
    - **共享内核 (Shared Kernel)**：两个上下文共享一部分通用的模型。
    - **客户方-供应方 (Customer-Supplier)**：一个上下文（客户方）使用另一个上下文（供应方）提供的服务。
    - **防腐层 (Anti-Corruption Layer)**：在一个上下文内部创建一个转换层，用于将另一个上下文的模型翻译成本上下文能理解的模型，防止外部系统的“腐化”侵入。

#### 2. 战术设计 (Tactical Design)

战术设计关注的是微观层面，提供了具体的构建块（Building Blocks）来帮助我们在限界上下文中实现领域模型。

- **实体 (Entity)**

  - 具有唯一标识符（ID）并且在生命周期中其状态会发生变化的对象。我们关心的是“它是谁”，而不是“它有什么属性”。
  - **特点**：有唯一 ID，可变。
  - **示例**：一个`用户(User)`对象，即使其姓名或地址改变了，只要用户 ID 不变，它就还是同一个用户。

- **值对象 (Value Object)**

  - 没有唯一标识符，通过其属性值来描述事物的对象。我们关心的是“它是什么”，而不是“它是谁”。
  - **特点**：无唯一 ID，通常是不可变的（Immutable）。两个值对象只要所有属性都相等，我们就可以认为它们是等同的。
  - **示例**：一个`地址(Address)`对象（由省、市、街道组成），或者一个`金额(Money)`对象（由数值和币种组成）。一个地址为“北京市朝阳区”的对象可以被另一个同样地址的对象完全替换。

- **聚合 (Aggregate)**

  - 一组相关对象的集合，作为一个数据修改的单元。聚合有一个根实体，称为**聚合根 (Aggregate Root)**。
  - **目的**：维护业务规则的一致性。外部对象只能通过聚合根来访问聚合内部的对象，不能直接修改聚合内的其他对象。
  - **规则**：
    1.  聚合根是实体，并且是聚合的唯一入口。
    2.  外部只能引用聚合根，不能引用聚合内部的其他对象。
    3.  数据库的查询和持久化操作，应该以聚合为单位。
    4.  一个事务只能修改一个聚合实例。
  - **示例**：一个`订单(Order)`聚合。`Order`是聚合根，它内部包含一组`订单项(OrderItem)`。要添加或删除订单项，必须通过`Order`对象的方法（如`order.addItem(...)`）来操作，而不能直接操作`OrderItem`列表。这可以保证在添加订单项时，订单的总价能够被正确更新，维持了数据的一致性。

- **工厂 (Factory)**

  - 负责创建复杂的对象或聚合。将创建对象的逻辑封装起来，使客户端代码更简洁，并能保证创建出的对象是合法的。
  - **示例**：一个`OrderFactory`，它可以根据客户 ID 和商品列表创建一个完整的、状态合法的`Order`聚合。

- **仓储 (Repository)**

  - 提供一个类似集合的接口，用于访问和持久化聚合根。它封装了数据库操作的细节，让领域层感觉像是在操作内存中的对象集合。
  - **目的**：将领域模型与数据持久化技术解耦。
  - **示例**：`OrderRepository`接口，可能包含`findById(orderId)`、`save(order)`等方法。其具体实现可能是用 JPA、MyBatis 或其他 ORM。

- **领域服务 (Domain Service)**
  - 当某个业务逻辑不适合放在任何一个实体或值对象中时（例如，它需要协调多个实体），就可以使用领域服务。
  - **示例**：一个`转账(transfer)`操作，它涉及到两个`账户(Account)`实体。这个操作不属于任何单个账户，因此可以创建一个`TransferService`来执行此操作。

---

### 经典的四层架构

DDD 通常与分层架构结合使用，最经典的是四层架构：

1.  **用户接口层 (User Interface Layer)**：负责向用户显示信息和解释用户命令。例如 Web 控制器（Controller）、视图（View）。
2.  **应用层 (Application Layer)**：定义软件要完成的任务。它很薄，不包含业务规则，主要负责协调领域对象来完成具体的用例。它调用领域服务和仓储，处理事务等。
3.  **领域层 (Domain Layer)**：软件的核心，包含所有业务逻辑、实体、值对象、聚合和领域服务。这是 DDD 的心脏。
4.  **基础设施层 (Infrastructure Layer)**：为其他层提供通用的技术能力，如数据库访问、消息中间件、缓存、第三方服务集成等。仓储的实现就位于这一层。

### 何时使用 DDD？

- **优点**：

  - 非常适合处理业务逻辑复杂的系统。
  - 促进团队沟通，让技术和业务对齐。
  - 模型清晰，代码可维护性和扩展性强。
  - 天然适合微服务架构（一个限界上下文通常可以对应一个微服务）。

- **缺点**：
  - 学习曲线陡峭，需要团队投入时间和精力。
  - 对于业务逻辑简单的 CRUD（增删改查）系统，使用 DDD 会过度设计，增加不必要的复杂性。

总而言之，DDD 是一种强大的武器，专门用来驯服软件开发中的“业务复杂性”这头猛兽。它的价值在于提供了一套完整的思想和工具，帮助我们构建出能够反映真实业务、易于理解和长期演进的软件系统。

---

好的，我们来详细讲解一下领域驱动设计（DDD）在前端的应用。

传统上，DDD 主要被看作是后端架构的设计方法。但随着前端应用日益复杂，承载的业务逻辑越来越多（例如，复杂的表单、购物车、在线编辑器等），前端项目也开始面临与后端同样的问题：业务逻辑分散、状态管理混乱、代码难以维护和测试。因此，将 DDD 的思想引入前端，是应对这种复杂性的有效手段。

### 为什么要在前端应用 DDD？

1.  **分离业务逻辑与 UI**：将核心的业务规则从 UI 组件中抽离出来，使组件更专注于渲染，业务逻辑更纯粹、更易于测试。
2.  **管理复杂状态**：为复杂的状态交互提供清晰的建模方式，避免状态数据散落在各处，难以追踪。
3.  **提升代码可维护性**：通过统一语言和清晰的领域模型，让代码的意图更加明确，新成员更容易理解和上手。
4.  **促进团队协作**：前端开发者、后端开发者、产品经理和设计师可以使用同一套“统一语言”进行沟通，减少误解。

---

### 如何在前端应用 DDD

我们将同样从**战略设计**和**战术设计**两个层面来探讨。

#### 1. 战略设计 (宏观层面)

这部分关注的是如何组织你的前端应用结构。

- **统一语言 (Ubiquitous Language)**

  - **应用**：和后端一样，这是基础。确保你在代码中的命名（变量、函数、类、状态）与产品经理、UI/UX 设计师讨论时使用的术语保持一致。
  - **示例**：如果业务方称之为“购物车(Shopping Cart)”，那么你的组件、状态、相关函数都应该使用 `ShoppingCart`，而不是 `ShoppingBag` 或 `ItemList`。

- **限界上下文 (Bounded Context)**

  - **应用**：在前端，一个限界上下文通常可以对应一个业务功能模块或一个相对独立的页面/视图集合。这可以作为你划分代码（例如，目录结构）的主要依据。
  - **示例**：在一个大型电商应用中，可以将前端代码划分为不同的限界上下文：
    - `catalog` (商品目录上下文)
    - `checkout` (结算流程上下文)
    - `profile` (用户中心上下文)
    - `shared` (共享的通用组件和逻辑)
  - 每个上下文都有自己独立的领域模型。比如，在 `catalog` 上下文中，“商品”可能有很多展示属性；而在 `checkout` 上下文中，“商品”可能只关心 ID、名称、价格和数量。

- **防腐层 (Anti-Corruption Layer)**
  - **应用**：这是前端 DDD 中非常实用的一个模式。它位于你的应用层和外部服务（通常是后端 API）之间，负责转换数据。
  - **目的**：防止后端 API 的数据结构直接渗透到你的领域模型和 UI 组件中。这样，即使后端 API 发生变化，你也只需要修改防腐层，而不用大规模重构前端业务代码。
  - **示例**：后端返回的用户数据是 `{ user_name: 'test', user_id: 123, is_active: 1 }`。在防腐层中，你可以将其转换为前端领域模型所期望的格式：`{ name: 'test', id: 123, isActive: true }`。这个转换后的对象才在你的应用内部流转。

#### 2. 战术设计 (微观层面)

这部分关注的是如何在代码中实现领域模型。

- **实体 (Entity) & 值对象 (Value Object)**

  - **应用**：在前端的状态管理中，我们可以明确区分哪些是实体，哪些是值对象。
  - **实体**：具有唯一标识符（ID）的对象。例如，购物车中的每个商品项，即使数量改变，它仍然是那个商品项。
  - **值对象**：描述事物属性且没有唯一标识的对象，通常是不可变的。例如，一个 `Money` 对象（包含 `amount` 和 `currency`），或者一个 `Color` 对象。使用值对象类而不是原始类型（如 `string`, `number`）可以让代码更健壮、更具表现力。

- **聚合 (Aggregate) & 聚合根 (Aggregate Root)**

  - **应用**：这是前端 DDD 的核心。一个聚合可以看作是状态管理库（如 Redux, Zustand, Pinia）中的一个“状态切片(State Slice)”或“Store 模块”。
  - **聚合根**：就是这个状态切片本身，它封装了内部的状态（实体和值对象）。
  - **规则**：所有对聚合内部状态的修改，都必须通过聚合根暴露的方法（在 Redux 中是 `Action` 和 `Reducer`，在 Zustand/Pinia 中是 `Actions`）来执行。UI 组件不能直接修改状态。
  - **示例**：`ShoppingCart` 是一个聚合。
    - **State**: `{ items: [ { productId: 'p1', quantity: 2 }, ... ], totalAmount: 100 }`
    - **聚合根暴露的行为 (Actions)**: `addItem(product, quantity)`, `removeItem(productId)`, `updateQuantity(productId, newQuantity)`。
    - 当调用 `addItem` 时，聚合内部的逻辑会负责更新 `items` 数组，并重新计算 `totalAmount`，保证了数据的一致性。UI 组件只需要“调用”这个行为，而不需要关心其内部实现。

- **仓储 (Repository)**

  - **应用**：仓储负责数据的持久化和获取，它封装了所有与数据源（API、LocalStorage 等）的交互细节。
  - **目的**：将数据获取逻辑与业务逻辑分离。应用层或领域服务不关心数据是来自 `fetch` 还是 `axios`，也不关心具体的 API 端点是什么。
  - **示例**：创建一个 `ProductRepository`。

    ```typescript
    // IProductRepository.ts (接口)
    interface IProductRepository {
      findById(id: string): Promise<Product>
      search(query: string): Promise<Product[]>
    }

    // ProductApiRepository.ts (实现)
    class ProductApiRepository implements IProductRepository {
      async findById(id: string): Promise<Product> {
        const response = await fetch(`/api/products/${id}`)
        const rawData = await response.json()
        // 此处可以有一个防腐层来转换数据
        return productDataMapper.toDomain(rawData)
      }
      // ...
    }
    ```

### 结合现代前端框架的目录结构示例

一个采用 DDD 思想的 React/Vue 项目目录结构可能如下所示：

```
src/
├── features/  (或 modules/, contexts/，代表不同的限界上下文)
│   ├── checkout/
│   │   ├── application/      # 应用服务 (e.g., useCheckout.ts hooks)
│   │   ├── domain/           # 领域模型
│   │   │   ├── model/        # 实体、值对象、聚合根 (e.g., Order.ts)
│   │   │   └── repository/   # 仓储接口 (e.g., IOrderRepository.ts)
│   │   ├── infrastructure/   # 基础设施层
│   │   │   └── repository/   # 仓储实现 (e.g., OrderApiRepository.ts)
│   │   └── presentation/     # 表现层 (UI)
│   │       ├── components/   # UI 组件 (e.g., OrderForm.tsx)
│   │       └── views/        # 页面 (e.g., CheckoutPage.tsx)
│   │
│   └── catalog/
│       ├── ... (类似结构)
│
└── shared/                 # 跨上下文共享的代码
    ├── components/         # 通用 UI 组件 (Button, Input...)
    ├── domain/             # 通用领域模型 (e.g., Money.ts)
    └── infrastructure/     # 通用基础设施 (e.g., httpClient.ts)
```

### 总结

在前端应用 DDD，并不是要生搬硬套所有的概念，而是借用其核心思想来解决前端的复杂性问题。

- **从小处着手**：可以先从**防腐层**和**仓储**模式开始，将数据获取和转换逻辑从组件中分离出来。
- **建模状态**：对于复杂的状态，尝试用**聚合**的思路来组织你的 state store，定义清晰的 Actions 来操作状态，保证业务规则的内聚。
- **拥抱统一语言**：这是成本最低但收益最高的一步，在整个团队中推行，可以极大提升沟通效率。

对于简单的、以内容展示为主的前端项目，引入 DDD 可能是过度设计。但对于需要处理复杂业务逻辑、交互和状态的现代 Web 应用（如 SaaS、金融、电商后台），DDD 提供了一个非常宝贵的思想武器库。

---

个人觉得不如 基于角色(职责)设计
