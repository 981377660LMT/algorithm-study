https://go7hic.github.io/A-Philosophy-of-Software-Design/#/

软件设计课程：斯坦福大学的 CS 190

## 第一章：介绍

如果软件开发人员应始终考虑设计问题，而降低复杂性是软件设计中最重要的要素，
则软件开发人员应始终考虑复杂性。
`这本书是关于如何使用复杂性来指导软件设计的整个生命周期。`

两种解决复杂性的通用方法

1. 使代码更简单和更明显来消除复杂性
2. 封装它（模块化设计）

改善设计技能的最好方法之一就是学会识别危险信号：信号表明一段代码可能比需要的复杂。

## 第二章：复杂性的本质(The Nature of Complexity)

- 复杂性的定义
  复杂性可以采取多种形式。

  - `难以理解`：很难理解一段代码是如何工作的
  - `难以修改`：需要花费很多精力才能实现较小的改进，或者可能不清楚必须修改系统的哪些部分才能进行改进，如果不引入其他错误，可能很难修复

  读者比作家更容易理解复杂性
  作为开发人员，您的工作不仅是创建可以轻松使用的代码，而且还要创建其他人也可以轻松使用的代码

- 复杂性的症状

  - 变更放大(Change amplification，令人恼火的)
    看似简单的变更需要在许多不同地方进行代码修改(例如，没有统一的配置文件)
  - 认知负担(Cognitive load，增加改变的成本)
    指开发人员需要多少知识才能完成一项任务。较高的认知负担意味着开发人员必须花更多的时间来学习所需的信息(例如，垂悬指针带来的内存泄漏)
    有时，需要更多代码行的方法实际上更简单，因为它减少了认知负担
  - 未知的未知(Unknown unknowns，`最糟糕的`)
    必须修改哪些代码才能完成任务，或者开发人员必须获得哪些信息才能成功地执行任务，这些都是不明显的

  良好设计的最重要目标之一就是使系统显而易见
  一个显而易见的系统是，开发人员可以在不费力地思考的情况下快速猜测要做什么，同时又可以确信该猜测是正确的
  `第 18 章讨论使代码更明显的技术`

- 复杂性的原因

  - `依赖性`(dependencies)
    无法孤立地理解和修改给定的一段代码
    软件设计的目标之一是`减少依赖关系的数量，并使依赖关系保持尽可能简单和明显`
  - `模糊性`(obscurity)
    当重要的信息不明显时，就会发生模糊(文档不足，变量名不清晰，代码不一致)
    减少模糊性的最佳方法是简化系统设计

  复杂度是递增的 -> “零容忍”

- 总结
  Complexity comes from an accumulation of `dependencies and obscurities`.
  As complexity increases, it leads to `change amplification, a high cognitive load, and unknown unknowns.`
  As a result, it takes more code modifications to implement each new feature.
  In addition, developers spend more time acquiring enough information to make the change safely and, in the worst case, they can’t even find all the information they need.
  The bottom line is that complexity makes it difficult and risky to `modify an existing code base`.

## 第三章：工作代码是不够的，战略与战术编程（Working Code Isn’t Enough，Strategic vs. Tactical Programming)

## 第四章：模块应该是深的

## 第五章：信息隐藏(和泄露)

## 第六章：通用模块更深入

## 第七章: `不同的层，不同的抽象`

## 第八章: 降低复杂性

## 第九章: 在一起更好还是分开更好？

## 第十章: 定义不存在的错误

## 第十一章: 设计它两次

## 第十二章: 为什么写注释？四个理由

## 第十三章: 注释应该描述代码中不明显的内容

## 第十四章: 选择的名字

## 第十五章: 先写注释

## 第十六章: 修改现有的代码

## 第十七章: 一致性

## 第十八章: 代码应该是显而易见的

## 第十九章: 软件发展趋势

## 第二十章: 设计性能

## 第二十一章: 结论

## 总结

---

读完这本书，收获更多的不是具体 design 的方法，而是 mindset。

现在回去看本书的封面觉得很有意思，上方是杂乱的线，代表复杂的 implementation，而下方是整齐的线，代表 interface；这表示本书最重要的一个观点，module should be deep，一个 deep module 有简单的 interface，但是有复杂的 implementation，隐藏了很多 module 使用者不需要的信息。deep module 有助于减少 complexity，对于 module 的使用者来说，需要了解得更少，但是能获得更多的。

另一个收获就是 investment mindset。我工作中也常常会以不知道如何 design，觉得 design 太花时间，改动太大可能会破坏以往已经实现的功能为由，避免 design，停留在 feature-driven development 的舒适区。但长时间地注重实现功能的开发（tactical programming）会导致 complexity 的叠加，此时需要修改一个很小的部分，也常常需要花很多的时间。而 investment mindset 的想法是可以花 20%左右的时间去思考这些问题：为什么要实现这个功能；怎样实现这个 feature 才能让它好像一开始就在 design 中一样；如何用别的办法实现这个功能，和原方法相比有什么利弊；怎样才能让代码的读者更容易理解我的代码；有哪些代码是冗余的。可能我刚开始需要花更多的时间，但我相信长期的训练可以有益于自己对更复杂软件的实现。

investment mindset 是一种视角的转变，之前我 evaluate 我工作的完成可能是以单一的时间维度：如果我能在很快的时间让代码工作起来，就是好的；但是现在加入了 complexity 的维度：我要更多得考虑 design，考虑减少系统的复杂度，让之后 maintain 起来更方便，也要提升自己对 system abstraction 的理解。

investment mindset 也是一种长期主义的心态，我应该做一些长期有益的事情。做项目并不是很短暂的过程，所以需要写 unit test 方便之后项目的重构，写 comment & document 方便之后修改的时候参考。同时生活中也是一样，我没必要纠结于一时的得失因为它会过去；我不能逃避面对问题因为之后同样的问题可能会再出现；我不用焦虑于当下自己做不好一些事情，因为只要我 keep practice，总有一天自然而然就能做好。虽然好像是一些大道理，但是花一些时间想清楚，接下来只要去实践。

总之，这本书相比别的具体介绍 design pattern 之类的设计书而言，并不是非常实用，但它用一整本书讲了为什么我要 design，究竟有什么好处；我没有看过其他 design 类的书籍，但现在也有兴趣去探索一下相关的书籍。而且全书的逻辑非常清晰，例子很多，读起来也不吃力，是一本值得推荐的好书。

---

软件复杂度是日积月累的，如果只是打补丁总有一天会失控。
可以容忍一开始不好的设计，但是之后每次都可以试着去优化一点。
但也不要想动不动就整个大新闻，毕竟业务的稳定和投入产出也是要考虑的。
你必须一直去思考这个问题，如果一切只会完成短期任务，那么复杂度一定会失控。

`模块和类要有深度`。
我觉得这个问题在 Java 的框架里特别明显，一层套一层，理论上是面向对象，可复用可替换，但是对于 99%的应用来说，这个需求根本不存在。
一个模块或类，甚至是函数，要解决一个完整的问题。`能原子化的就不要再为了拆分而拆分`。

`信息隐藏`。在接口层面要暴露的是做什么，至于怎么做留到实现层面。复杂度尽可能下沉，接口的调用者不要去想，也不应该去操心底层实现的细节。

尽量为通用的场景提供`默认的行为`，不要让用户自己去理解。

错误处理不要过度设计。
不要把错误扔给用户处理，很多时候用户也不知道该怎么处理。
如果`索引范围不符合返回一个空字符串`就能解决大部分问题，非得扔个 IndexOutOfBoundsException 异常出来。

写注释，注释一定要有用，要把那些不容易理解的东西解释清楚，而不是翻译代码。

`一致性`，命名，代码风格，处理逻辑尽可能统一。哪怕是低水平的统一也好过各自放飞。

测试驱动开发是伪命题。
`大多数人根本没有先写用例，再写代码的能力`。
另外用例不可能一次写对，但用例摆在那里，开发的时候代码就会已通过测试为目标，很多时候容易导致拼凑补丁。
但是有一种情况必须先写用例，就是处理历史遗留屎山。
当前代码支持的业务场景，以及你对代码功能的所有猜测必须有用例作为支撑，这样在修改完成后可以快速检查有没有影响现有功能

最重要的原则，`把自己的第一个想法毙掉`。至少要想两个方案，有选择才有比较

---

软件设计
