high-level goal: a *small* book that builds a complete, efficient interpreter.
instead of a wide text about programming language*s*, it is a single path
through the language space. aim for 60k words.

possible mission: cover most of the topics needed to understand how mri, cpython, and lua work.

stuff *not* included:
- type systems
- ahead of time compilation
- machine code
- bottom up parsing
- parser generators
- ir
- context-sensitive analysis
- most compile-time optimizations

stuff to maybe include:
- your first language - simple stack-based language
- lexing
- recursive descent parsing
- scopes as dictionaries
- stack-based vm
- name binding of locals
- objects as dictionaries
- objects
- classes
- prototypes
- control flow
- functions
- first-class functions
- closures
- arithmetic
- primitive methods/functions
- external functions
- compiling to bytecode
- tree-walk interpreting
- mark-sweep collection
- copy collection
- lisp2 algorithm?
- bump-pointer allocation
- stack traces and line information
- lexer errors
- compile time errors
- runtime errors
- nan tagging
- object representation
- variables and assignment
- scope
- jitting
- internal representations
- roots
- fibers and coroutines
- passing arguments
- expression parsing
- aesthetics and usability of syntax design
- backjumping and infinite lookahead or context-sensitive grammars
- symbol tables and hash tables
- strings
- tail call optimization
- virtual machine
- stack frames
- stack based bytecode
- register based bytecode
- strings
- arrays
- hash tables (for internal use and as object in language)
- dynamic dispatch
- testing

- kinds of asides
  - historical context and people
  - further things to learn
  - omitted alternatives
