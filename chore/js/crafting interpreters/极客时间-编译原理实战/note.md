# 宫文学-编译原理实战课

## 1 开篇词 | 在真实世界的编译器中游历

平台，很重要的原因就是拥有很强的定制能力，比如流程定制、界面定制、业务逻辑定制，等等。
`而这些定制能力，依托的就是编译技术。`
Serverless 和 FaaS 已经把无状态服务的架构细节透明掉了。但针对有状态的服务，目前还没有答案。

涉及的编译器：

- Java 编译器（javac）
- Java 的 JIT 编译器（Graal）
- Python 编译器（CPython）
- JavaScript 编译器（V8）
- Julia 语言的编译器
- Go 语言的编译器（gc）
- MySQL 的编译器
- Erlang 的编译器(在讲并行的时候)

选择剖析这些语言的编译器，有三方面的原因：

第一，它们足够有代表性，是你在平时很可能会用到的。这些语言中，除了 Julia 比较小众外，都比较流行。而且，虽然 Julia 没那么有名，但它使用的 LLVM 工具很重要。因为 `LLVM 为 Swift、Rust、C++、C 等多种语言提供了优化和后端的支持，所以 Julia 也不缺乏代表性。`
第二，它们采用了各种不同的编译技术。
这些编译器，有的是编译静态类型的语言，有的是动态类型的语言；有的是即时编译（JIT），有的是提前编译（AOT）；有高级语言，也有 DSL（SQL）；解释执行的话，有的是用栈机（Stack Machine），有的是用寄存器机，等等。不同的语言特性，就导致了编译器采用的技术会存在各种差异，从而更加有利于你开阔视野。
第三，通过研究多种编译器，你可以多次迭代对编译器的认知过程，并通过分析对比，发现这些编译器之间的异同点，探究其中的原因，激发出更多的思考，从而得到更全面的、更深入的认知。

## 2 学习指南 | 如何学习这门编译原理实战课？

本课程分为：`预备知识篇`、`真实编译器解析篇`和`现代语言设计篇`三部分

## 3 01 | 编译的全过程都悄悄做了哪些事情？

- 编译是把源代码变成目标代码的过程
  如果源代码编译后要在操作系统上运行，那目标代码就是汇编代码，我们再通过汇编和链接的过程形成可执行文件，然后通过加载器加载到操作系统里执行。
  如果编译后是在解释器里执行，那目标代码就可以不是汇编代码，而是一种解释器可以理解的中间形式的代码即可。

> 西方的儿童，很小的时候就能够给大人读报纸。因为他们懂得发音规则，能念出单词来（词法分析），也基本理解语法结构（他们不见得懂主谓宾这样的术语，但是凭经验已经知道句子有不同的组成部分），可以读得抑扬顿挫（语法分析），但是他们不懂报纸里说的是什么，也就是不懂语义。

- 语义分析：怎样理解源代码的语义呢？
  在 ECMAScript（也就是 JavaScript）标准 2020 版中，Semantic 这个词出现了 657 次。
  语义分析：上下文分析、类型检查等。
  语义分析获得的一些信息（引用消解信息、类型信息等），会附加到 AST 上。
  这样的 AST 叫做带有标注信息的 AST（Annotated AST/Decorated AST），用于更全面地反映源代码的含义。

- IR
  采用中间代码来编写优化算法的好处，是可以把大部分的`优化算法，写成与具体 CPU 架构无关的形式`，从而大大降低编译器适配不同 CPU 的工作量。
  并且，如果采用像 LLVM 这样的工具，我们还可以让多种语言的前端生成相同的中间代码，这样就可以复用中端和后端的程序了。

## 4 02 | 词法分析：用两种方式构造有限自动机

正则
NFA

## 5 03 | 语法分析：两个基本功和两种算法思路

## 6 04 | 语义分析：让程序符合语义规则

## 7 05 | 运行时机制：程序如何运行，你有发言权

## 8 06 | 中间代码：不是只有一副面孔

## 9 07 | 代码优化：跟编译器做朋友，让你的代码飞起来

## 10 08 | 代码生成：如何实现机器相关的优化？

## 11 知识地图 | 一起来复习编译技术核心概念与算法

## 12 09 | Java 编译器（一）：手写的编译器有什么优势？

## 13 10 | Java 编译器（二）：语法分析之后，还要做些什么？

## 14 11 | Java 编译器（三）：属性分析和数据流分析

## 15 12 | Java 编译器（四）：去除语法糖和生成字节码

## 16 13 | Java JIT 编译器（一）：动手修改 Graal 编译器

## 17 14 | Java JIT 编译器（二）：Sea of Nodes 为何如此强大？

## 18 15 | Java JIT 编译器（三）：探究内联和逃逸分析的算法原理

## 19 16 | Java JIT 编译器（四）：Graal 的后端是如何工作的？

## 20 17 | Python 编译器（一）：如何用工具生成编译器？

## 21 18 | Python 编译器（二）：从 AST 到字节码

## 22 19 | Python 编译器（三）：运行时机制

## 23 20 | JavaScript 编译器（一）：V8 的解析和编译过程

## 24 21 | JavaScript 编译器（二）：V8 的解释器和优化编译器

## 25 22 | Julia 编译器（一）：如何让动态语言性能很高？

## 26 23 | Julia 编译器（二）：如何利用 LLVM 的优化和后端功能？

## 27 24 | Go 语言编译器：把它当作教科书吧

## 28 25 | MySQL 编译器（一）：解析一条 SQL 语句的执行过程

## 29 26 | MySQL 编译器（二）：编译技术如何帮你提升数据库性能？

## 30 热点问题答疑 | 如何吃透 7 种真实的编译器？

## 31 划重点 | 7 种编译器的核心概念与算法

## 32 期中考试 | 这些编译原理知识，你都掌握了吗？

## 33 用户故事 | 易昊：程序员不止有 Bug 和加班，还有诗和远方

## 34 27 | 课前导读：学习现代语言设计的正确姿势

## 35 28 | 前端总结：语言设计也有人机工程学

## 36 29 | 中端总结：不遗余力地进行代码优化

## 37 30 | 后端总结：充分发挥硬件的能力

## 38 31 | 运行时（一）：从 0 到语言级的虚拟化

## 39 32 | 运行时（二）：垃圾收集与语言的特性有关吗？

## 40 33 | 并发中的编译技术（一）：如何从语言层面支持线程？

## 41 34 | 并发中的编译技术（二）：如何从语言层面支持协程？

## 42 35 | 并发中的编译技术（三）：Erlang 语言厉害在哪里？

## 43 36 | 高级特性（一）：揭秘元编程的实现机制

## 44 37 | 高级特性（二）：揭秘泛型编程的实现机制

## 45 38 | 综合实现（一）：如何实现面向对象编程？

## 46 39 | 综合实现（二）：如何实现函数式编程？

## 47 40 | 成果检验：方舟编译器的优势在哪里？

## 48 期末答疑与总结 | 再次审视学习编译原理的作用

## 49 不定期加餐 1 | 远程办公，需要你我具备什么样的素质？

## 50 不定期加餐 2 | 学习技术的过程，其实是训练心理素质的过程

## 51 不定期加餐 3 | 这几年，打动我的两本好书

## 52 不定期加餐 4 | 从身边的牛人身上，我学到的一些优秀品质

## 53 结束语 | 实战是唯一标准！

## 54 期末考试 | “编译原理实战课”100 分试卷等你来挑战！
