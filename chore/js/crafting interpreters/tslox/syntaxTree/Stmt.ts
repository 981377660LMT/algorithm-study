// Generated by generateAst.ts

import { type Expr, type VariableExpr } from './Expr' 
import { type IToken } from '../types'

export interface StmtVisitor<R> {
  visitBlockStmt(block: Block): R
  visitClassStmtStmt(classstmt: ClassStmt): R
  visitExpressionStmt(expression: Expression): R
  visitFuncStmt(func: Func): R
  visitIfStmtStmt(ifstmt: IfStmt): R
  visitPrintStmt(print: Print): R
  visitReturnStmtStmt(returnstmt: ReturnStmt): R
  visitVariableDeclStmt(variabledecl: VariableDecl): R
  visitWhileStmtStmt(whilestmt: WhileStmt): R
}

export abstract class Stmt {
  abstract accept<R>(visitor: StmtVisitor<R>): R
}

export class Block extends Stmt {
  readonly statements: Stmt[]

  constructor(statements: Stmt[]) {
    super()
    this.statements = statements
  }

  override accept<R>(visitor: StmtVisitor<R>): R {
    return visitor.visitBlockStmt(this)
  }
}

export class ClassStmt extends Stmt {
  readonly name: IToken
  readonly superclass: VariableExpr|undefined
  readonly methods: Func[]

  constructor(name: IToken, superclass: VariableExpr|undefined, methods: Func[]) {
    super()
    this.name = name
    this.superclass = superclass
    this.methods = methods
  }

  override accept<R>(visitor: StmtVisitor<R>): R {
    return visitor.visitClassStmtStmt(this)
  }
}

export class Expression extends Stmt {
  readonly expression: Expr

  constructor(expression: Expr) {
    super()
    this.expression = expression
  }

  override accept<R>(visitor: StmtVisitor<R>): R {
    return visitor.visitExpressionStmt(this)
  }
}

export class Func extends Stmt {
  readonly name: IToken
  readonly params: IToken[]
  readonly body: Stmt[]

  constructor(name: IToken, params: IToken[], body: Stmt[]) {
    super()
    this.name = name
    this.params = params
    this.body = body
  }

  override accept<R>(visitor: StmtVisitor<R>): R {
    return visitor.visitFuncStmt(this)
  }
}

export class IfStmt extends Stmt {
  readonly condition: Expr
  readonly thenBranch: Stmt
  readonly elseBranch: Stmt|undefined

  constructor(condition: Expr, thenBranch: Stmt, elseBranch: Stmt|undefined) {
    super()
    this.condition = condition
    this.thenBranch = thenBranch
    this.elseBranch = elseBranch
  }

  override accept<R>(visitor: StmtVisitor<R>): R {
    return visitor.visitIfStmtStmt(this)
  }
}

export class Print extends Stmt {
  readonly expression: Expr

  constructor(expression: Expr) {
    super()
    this.expression = expression
  }

  override accept<R>(visitor: StmtVisitor<R>): R {
    return visitor.visitPrintStmt(this)
  }
}

export class ReturnStmt extends Stmt {
  readonly keyword: IToken
  readonly value: Expr|undefined

  constructor(keyword: IToken, value: Expr|undefined) {
    super()
    this.keyword = keyword
    this.value = value
  }

  override accept<R>(visitor: StmtVisitor<R>): R {
    return visitor.visitReturnStmtStmt(this)
  }
}

export class VariableDecl extends Stmt {
  readonly name: IToken
  readonly initializer: Expr|undefined

  constructor(name: IToken, initializer: Expr|undefined) {
    super()
    this.name = name
    this.initializer = initializer
  }

  override accept<R>(visitor: StmtVisitor<R>): R {
    return visitor.visitVariableDeclStmt(this)
  }
}

export class WhileStmt extends Stmt {
  readonly condition: Expr
  readonly body: Stmt

  constructor(condition: Expr, body: Stmt) {
    super()
    this.condition = condition
    this.body = body
  }

  override accept<R>(visitor: StmtVisitor<R>): R {
    return visitor.visitWhileStmtStmt(this)
  }
}

