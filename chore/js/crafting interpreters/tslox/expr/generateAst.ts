import { join } from 'path'
import { existsSync, mkdirSync, writeFileSync } from 'fs'
import { capitalize } from '../utils'

/**
 * Generate the AST classes for the expressions.
 */
function generateAst(outputDirName: string): void {
  defineAst('Expr', [
    'Binary       : left Expr, operator IToken, right Expr',
    'Grouping     : expression Expr',
    'Literal      : value any',
    'Unary        : operator IToken, right Expr',
    'VariableExpr : name IToken'
  ])

  defineAst('Stmt', [
    'Expression     : expression Expr',
    'Print          : expression Expr',
    'VariableDecl   : name IToken, initializer Expr|undefined'
  ])

  function defineAst(baseClassName: string, classPropsStrings: string[]): void {
    if (!existsSync(outputDirName)) {
      mkdirSync(outputDirName, { recursive: true })
    }
    const path = join(outputDirName, `${baseClassName}.ts`)

    writeFileSync(path, '') // clear the file

    const wl = (content: string) => writeFileSync(path, `${content}\n`, { flag: 'a' })

    wl('// Generated by generateAst.ts')
    wl('')
    wl("import { type IToken } from '../types'")
    wl('')
    defineVisitor(classPropsStrings)
    wl('')
    wl(`export abstract class ${baseClassName} {`)
    wl(`  abstract accept<R>(visitor: ${capitalize(baseClassName)}Visitor<R>): R`)
    wl('}')
    wl('')
    for (const v of classPropsStrings) {
      const [className, propsString] = v.split(':').map(s => s.trim())
      defineType(className, propsString)
    }

    function defineVisitor(types: string[]): void {
      wl(`export interface ${capitalize(baseClassName)}Visitor<R> {`)
      for (const t of types) {
        const typeName = t.split(':')[0].trim()
        wl(`  visit${typeName}${baseClassName}(${typeName.toLowerCase()}: ${typeName}): R`)
      }
      wl('}')
    }

    function defineType(className: string, propsString: string): void {
      wl(`export class ${className} extends ${baseClassName} {`)

      const props = propsString.split(', ').map(s => s.split(' '))
      for (const [name, type] of props) {
        wl(`  readonly ${name}: ${type}`)
      }
      wl('')

      const constructorParameters = props.map(([name, type]) => `${name}: ${type}`).join(', ')
      wl(`  constructor(${constructorParameters}) {`)
      wl('    super()')
      for (const [name] of props) {
        wl(`    this.${name} = ${name}`)
      }
      wl('  }')
      wl('')

      wl(`  override accept<R>(visitor: ${capitalize(baseClassName)}Visitor<R>): R {`)
      wl(`    return visitor.visit${className}${baseClassName}(this)`)
      wl('  }')
      wl('}')
      wl('')
    }
  }
}

if (typeof require !== 'undefined' && typeof module !== 'undefined' && require.main === module) {
  generateAst(__dirname)
}
