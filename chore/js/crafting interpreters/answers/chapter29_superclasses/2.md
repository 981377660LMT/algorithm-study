# 我们的向下复制继承(copy-down inheritance)优化之所以有效，是因为 Lox 不允许在类声明后修改类的方法。这意味着我们不必担心子类中被复制的方法会与超类中后来的更改不同步。其他语言（如 Ruby）确实允许事后修改类。类似语言的实现如何在支持类修改的同时保持方法解析的高效性？

I can think of a few approaches:

## 1. Eagerly rebuild the subclass method tables (立即重建子类的方法表)

We could keep doing copy-down inheritance like we do here. But also give each superclass references to the set of subclasses that inherit from it. When a superclass's method table is modified, it walks the subclasses and also updates or rebuilds their now-invalidated method tables. That sounds slow, and it would be. However, meta-programming like this usually happens only a couple of times near the beginning of the program's execution and then stops. It's unusual for a class's set of methods to change frequently during a program's run or inside a hot loop. So this likely doesn't need to be fast.
**继续使用像现在这样的向下复制继承。为每个超类维护一个指向所有继承自它的子类的引用集合children。当超类的方法表被修改时，它会遍历所有子类，并更新或重建它们已失效的方法表。**
**元编程通常只在程序执行的前期几次发生，然后就停止了。一个类的方法集合`在程序运行期间频繁更改，或者在热循环中更改，都是不常见的`。因此，这种优化可能不需要非常快。**

## 2. Lazily rebuild the subclass method tables (延迟重建子类的方法表)

**懒更新：Lazy Tag**
**脏标记：Dirty Flag**
The downside of 1 is that the superclass needs to maintain a list of every subclass. Every single time a method is touched, the entire tree of subclasses must be updated. If it's common to change a number of methods in succession, that's a lot of work. Also, maintaining the list of references from superclass to subclass makes GC harder (they'll need to be weak references if you want to be able ever collect subclasses) and makes classes heavier-weight.
`方法1的缺点是，超类需要维护每个子类的列表。每次方法被修改时，整个子类树必须被更新。如果常常连续修改多个方法，这将是大量的工作。此外，维护从超类到子类的引用列表会使垃圾回收（GC）更加困难（如果你希望能够收集子类，它们需要是弱引用），并且使类变得更加重量级。`

Another option is to have the subclass lazily rebuild its method table when it sees the superclass has changed. In each class, we add a "version" integer field. It starts out at zero and increments any time the class's set of methods is modified. (In principle, this could overflow, but that's pretty unlikely.)
We also add an integer field to each class to track the version of its _superclass_. This stores the version that the superclass was at when this subclass inherited its methods.
When a subclass is declared, it copies the methods from its superclass, and also records the superclass's current version number in its superclass version field. Whenever a class's method set changes after the declaration executes, we also increment its version. If a subclass's own superclass version field is ever out of sync with the version field on its actual superclass, then we know the superclass has changed since the last time its methods were copied down.
When do we check that? The only real natural point in time is right before a method call. Adding overhead to each method call is a drag, but it's a fairly simple check between two numbers. If the two versions are out of sync, we rebuild the subclass's method table and then re-sync the version numbers.
另一种选择是让子类在检测到超类已更改时，延迟重建其方法表。在每个类中，我们添加一个“版本”整数字段。初始值为零，每次类的方法集被修改时递增（理论上，这可能会溢出，但这非常不可能发生）。我们还为每个类添加一个整数字段，用于跟踪其超类的版本。这存储了在子类继承其方法时超类的当前版本号。当子类被声明时，它会从其超类复制方法，并记录超类的当前版本号在其超类版本字段中。每当类的方法集在声明执行后发生更改时，我们也会递增其版本号。**如果子类的超类版本字段与其实际超类的版本字段不同步，那么我们知道自上次复制方法以来，超类已经发生了变化**。当我们检查时，唯一自然的时间点是在方法调用之前。为每个方法调用增加开销是一种拖累，但这只是两个数字之间的相当简单的检查。如果这两个版本不同步，我们会重建子类的方法表并重新同步版本号。

## 3. Lean on inline caching (依赖内联缓存)

This is probably the best approach (though I wouldn't put money on it). If the VM already does some form of inline caching, then method lookup doesn't need to be that. For a given callsite, you'll only do the lookup once and then rely on the fast inline cache for most calls. So in this case, we could keep something like jlox's slow approach where methods are resolved by dynamically walking the inheritance chain. Then once we find the method, we store it in the inline cache, and after that it's as fast as we could want. The only missing piece is handling the fact that the cache can now become invalidated. If a class's method set cannot change, then the only way an inline cache can become stale is if the class of the receiver changes. Now an inline cache on the same receiver can become stale if a method changes and a lookup would now produce a different method. Inline caches usually track the receiver's class by having some kind of numeric ID for each class. Each class stores its ID and in the inline cache, we store the ID of the receiver's class that the method was called one. If those match, the cache is valid. We might be able to extend that by having a method change to a class change its ID. It is as if metaprogramming a class produces a new class with a different ID. Since the inline cache only stores the ID of the leaf-most class of the receiver, we also have to ensure that metaprogramming a _superclass_ also affects the ID of the subclasses. So we'd want to do something like the approach in 1 where changing a superclass means we traverse the tree of subclasses and update their IDs too. There are probably better solutions, but these are the first few that came to mind.
这可能是最好的方法（尽管我对此不抱太大希望）。如果虚拟机已经实现了一定形式的内联缓存，那么方法查找就不需要那么复杂。对于一个特定的调用点，你只需执行一次查找，然后在大多数调用中依赖快速的内联缓存。因此，在这种情况下，我们可以保留类似 jlox 的缓慢方法，即通过动态遍历继承链来解析方法。然后，一旦找到方法，我们将其存储在内联缓存中，之后的调用就会变得尽可能快。唯一缺失的部分是处理缓存可能失效的情况。如果一个类的方法集无法改变，那么内联缓存变得过时的唯一方式是接收者的类发生变化。现在，如果方法发生变化，并且查找将产生不同的方法，那么对同一接收者的内联缓存也可能过时。内联缓存通常通过为每个类分配某种数字 ID 来跟踪接收者的类。每个类存储其 ID，而在内联缓存中，我们存储调用方法时接收者类的 ID。如果它们匹配，缓存就是有效的。我们可能可以通过让方法的变化导致类的 ID 变化来扩展这一点。就好像元编程一个类会生成一个具有不同 ID 的新类。由于内联缓存仅存储接收者最底层类的 ID，我们还必须确保元编程一个超类也会影响其子类的 ID。因此，我们希望采用类似于第一种方法的方式，即更改一个超类意味着我们遍历子类树并更新它们的 ID。可能还有更好的解决方案，但这些是我首先想到的几个。
