# 我们的虚拟机的栈大小是固定的，我们不检查 push 一个值是否会导致溢出。这意味着错误的指令序列可能会导致我们的解释器崩溃或进入未定义行为。通过根据需要动态增长栈来避免这种情况。这样做的成本和收益是什么？

## 将固定大小的栈转换为动态数组

There's nothing super algorithmically interesting about the change. We basically turn it into a dynamic array like we've seen before. A side effect of this change is that `stackTop` becomes `stackCount`, an int. Using a raw pointer to the top makes it a little harder to tell if we've run out of capacity:

```c
typedef struct {
  Chunk* chunk;
  uint8_t* ip;

  Value* stack;
  int stackCount;
  int stackCapacity;
} VM;
```

When we first create the VM, we need to initialize the dynamic array fields:

```c
void initVM() {
  vm.stack = NULL;
  vm.stackCapacity = 0;
  resetStack();
}
```

Resetting is still pretty simple:

```c
static void resetStack() {
  vm.stackCount = 0;
}
```

So is `pop()`:

```c
Value pop() {
  vm.stackCount--;
  return vm.stack[vm.stackCount];
}
```

Where it gets interesting is `push()`:

```c
void push(Value value) {
  if (vm.stackCapacity < vm.stackCount + 1) {
    int oldCapacity = vm.stackCapacity;
    vm.stackCapacity = GROW_CAPACITY(oldCapacity);
    vm.stack = GROW_ARRAY(Value, vm.stack,
                          oldCapacity, vm.stackCapacity);
  }

  vm.stack[vm.stackCount] = value;
  vm.stackCount++;
}
```

We also have to change the way we debug the stack:

```c
for (Value *slot = vm.stack; slot < vm.stack + vm.stackCount; slot++) {
  printf("[ ");
  printValue(*slot);
  printf(" ]");
}
```

That `if` test needs to happen every single time we push a value. That happens
all the time while the VM is running, so this is a significant performance
problem.
We wouldn't want to have to do that. Fortunately, it turns out we won't need
to. If you're willing to limit the generated bytecode to fit within certain
constraints -- which happen to be implicitly true in a language with structured
control flow like Lox -- then you can _statically_ determine the maximum amount
of stack space a chunk of bytecode could ever use.
During compilation, you always know how many stack slots are in use for locals
and temporaries at any point in time. So you just keep a running tally of the
highwater mark -- the greatest amount of stack space used at any point, and then
store that in with the resulting chunk.
So instead of checking on every single push, we check once before evaluating
the bytecode to see if the stack is big enough to cover the worst case.

在每次 push 一个值时，我们都需要都执行` if (vm.stackCapacity < vm.stackCount + 1) {`。这在虚拟机运行期间会频繁发生，因此这是一个显著的性能问题。
我们当然不希望每次都这样做。幸运的是，事实证明我们不需要这么做。
`如果你愿意将生成的字节码限制在某些约束范围内——这些约束在像 Lox 这样具有结构化控制流的语言中是隐含成立的——那么你就可以静态地确定一段字节码可能使用的最大栈空间量。`
**在编译期间，你始终知道在任何时间点本地变量和临时变量使用了多少栈槽。**
因此，你只需保持一个水位标记的运行计数——即任何时候使用的最大栈空间量——然后将其与生成的字节码块一起存储。
因此，我们不再需要在每次推送时都进行检查，`而是在评估字节码之前检查一次，以确保栈的大小足以覆盖最坏情况。`
