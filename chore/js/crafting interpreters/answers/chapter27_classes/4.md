# 由于字段是在运行时按名称访问的，因此处理实例状态的速度很慢。从技术上讲，这是一种恒定时间操作--多亏了哈希表，但恒定系数相对较大。这是动态语言比静态类型语言慢的主要原因。动态类型语言的复杂实现如何应对和优化？

I'll just point you to a resource. Look for the paper "`An Efficient Implementation of Self, a Dynamically-Typed Object-Oriented Language Based on Prototypes`".

动态类型语言在运行时需要通过名称（字符串）来查找对象的属性或方法，这通常会涉及哈希表等数据结构，从而导致访问的常数开销较高。为降低此开销并接近静态类型语言的性能，动态语言的复杂实现（如Self、JavaScript V8、PyPy等）采用了多种优化技术。这些优化的核心思想是尽可能将动态查找转化为更直接、更低成本的操作，并利用运行时反馈不断优化热点代码路径。

以下是一些典型的优化手段：

1. **内联缓存（Inline Caches, IC）**：  
   在动态语言中，方法或属性的查找通常需要先根据名称在对象的元数据中定位目标。内联缓存通过在调用点记录近期成功匹配的对象结构及其方法/属性位置，避免每次都从头开始查找。当代码再次执行到相同位置且对象结构与之前匹配的结构相同（或属于一小类常见的结构集合）时，虚拟机可直接跳过哈希查找，快速定位方法/字段。这种“缓存命中”让后续调用大幅加速。

   - **多态内联缓存（Polymorphic Inline Cache, PIC）**：当同一调用点可能面临多种不同类型（结构）的对象时，PIC会缓存多种可能匹配，将哈希查找开销分散在少数已知的情况中，从而提高多态场景下的性能。

2. **形状/映射（Shape/Map）优化**：  
   Self和后来的JavaScript虚拟机（如V8）引入了“形状（shape）”或“映射（map）”的概念，对对象的属性布局进行元数据抽象。当对象新增或删除属性时，会创建或连接到不同的形状，从而在运行时使用一个快速的整数偏移量来访问属性，而不是总是重新进行哈希查找。这样，对象从“字典式”存储逐渐向类结构化存储（如类似**隐藏类**）过渡，让属性访问趋近于静态类型语言中字段访问的速度。

3. **即时编译（Just-In-Time Compilation, JIT）与自适应优化**：  
   虚拟机通过解释执行程序并对其进行实时分析，识别执行频率较高的“热点代码”，然后将其提交给JIT编译器进行优化。JIT编译器利用从内联缓存、形状分析等收集到的运行时信息，在生成机器码时将访问操作特化（specialize）到特定对象布局。这使得后续执行无需再走通用查找路径，从而显著降低访问属性的时间成本。

4. **类型预测与类型特化（Type Specialization）**：  
   动态语言虽然不在编译期固定类型，但在运行中大部分对象的属性类型与结构往往相对稳定。JIT编译器会基于运行时信息尝试预测对象类型和布局，如果预测正确，则后续访问可以使用高效的直接偏移量访问。如果预测失败（deoptimization），则退回较通用的查找方式，但这一过程对持续运行的热点代码来说往往是有利的。

5. **其它数据结构优化与缓存策略**：
   - **方法查找缓存（Method Lookup Cache）**：将常用的方法分辨信息缓存起来。
   - **属性快速路径（Fast Path）**：对于经常访问的属性设置专用的快速访问路径。
   - **对象分层优化（Object Layout Specialization）**：在JIT阶段对对象进行重新布局，从而让常用字段占据连续内存区域。

通过上述优化策略，动态类型语言实现者能够将频繁的名称查找操作成本逐渐摊薄和内联化，缩短与静态类型语言在性能上的差距。在理想情况下，经过充分的优化，动态语言的字段访问和方法调用可以接近甚至达到静态类型语言的性能水平，从而既保留动态语言的灵活性与表达能力，又获得较好的运行效率。

---

## 隐藏类(hidden class)

**隐藏类（Hidden Class）**是一种在动态语言（如JavaScript）引擎中使用的内部数据结构，用于描述对象的属性布局（即对象内部字段的组织方式），从而实现快速的属性访问。这一概念最初来源于Self语言的“maps”思想，并被后来的高性能JIT引擎（如V8）广泛使用。隐藏类在开发者层面是不可见的，它是引擎在运行时根据对象的属性添加、删除和类型变化情况自动生成和维护的。

由于 JavaScript 对象没有类型信息，几乎所有 JS 引擎都采用隐藏类（Hidden Class/Shape/Map 等）来描述对象的布局信息，用以在虚拟机内部区分不同对象的类型，从而完成一些基于类型的优化。

### 总结

隐藏类的原理就是：

- 每当对象结构改变（添加/删除属性）时，引擎创建或切换到对应的隐藏类，从而记录下对象当前属性集合与布局。
- 对拥有相同属性结构的对象共享同一隐藏类，进而使用固定偏移量快速访问属性，降低动态查找的成本。
- 随着程序运行，JIT编译器或解释器可针对这些具有稳定隐藏类的对象内联优化访问路径，达到几乎与静态语言字段访问同等的性能。

### 为什么需要隐藏类？

在动态语言中，对象的属性是可动态添加和删除的，且没有统一的类定义。相比于静态类型语言中对象有确定的类、属性类型和偏移量，动态语言如果每次访问属性都要通过哈希表按名字查找，那将带来很大的性能开销。

引入隐藏类的主要目的就是让属性访问接近或达到类似静态类型语言中通过固定偏移量访问字段的速度。在隐藏类系统中，相同“形状”（属性名、数量、添加顺序一致）的对象共享同一个隐藏类，使引擎在运行时无需每次为属性访问进行笼统的哈希查找，而是可以利用隐藏类提供的已知布局快速定位属性。

### 隐藏类的运作示例

假设你有这样一段JavaScript代码：

```javascript
function Point(x, y) {
  this.x = x // Step 1: 当创建第一个对象时，它会有一个隐藏类H1。
  this.y = y // Step 2: 添加属性y后，会生成一个新隐藏类H2。
}

// 创建一个点对象
var p1 = new Point(10, 20)
```

隐藏类的生成过程可能是这样的（在V8等引擎中是类似的机制）：

1. **初始空对象**：当`new Point()`时，创建一个新对象`p1`。此时还没为它添加属性，初始化时它有一个默认的隐藏类`H0`（空对象形状）。
2. **添加属性x**：`p1.x = 10`时，引擎检查`p1`当前隐藏类（`H0`），发现是空的，于是创建一个带有`x`属性的隐藏类`H1`。`H1`记录：对象有一个名为`x`的属性，处于偏移量0（只是举例说明），之后`p1`的隐藏类指针指向`H1`。

3. **添加属性y**：`p1.y = 20`时，`p1`目前隐藏类是`H1`，引擎为`H1`添加`y`属性的布局信息，生成新隐藏类`H2`。`H2`表示对象有属性`x`和`y`，`y`在偏移量1处。`p1`的隐藏类现在切换为`H2`。

最终，`p1`的隐藏类`H2`告诉引擎：

- 该对象有两个属性`x`和`y`
- `x`在对象内存结构中偏移量为0，`y`的偏移量为1。

下次访问`p1.x`时，引擎无需查找名字，只要从`p1`的隐藏类中获知`x`位于偏移量0，然后直接访问该内存位置即可。

### 隐藏类的好处与后续对象的共享

现在，如果你再创建一个相同结构的点对象：

```javascript
var p2 = new Point(30, 40)
```

当`p2`按照`Point`构造函数的逻辑初始化属性`x`和`y`时，将重复同样的隐藏类生成轨迹。最后`p2`也将拥有与`p1`相同的隐藏类`H2`（因为两者最终都创建了`x`再创建`y`，属性顺序和名称一致）。这样，每次访问`p2.x`或者`p2.y`，引擎也能直接利用`H2`来快速定位偏移量，不用重复生成和查找。

### 若对象结构发生改变

如果对象后来动态添加一个新属性，比如：

```javascript
p1.z = 50
```

由于`p1`当前的隐藏类是`H2`（描述`x, y`布局），添加`z`将导致生成新的隐藏类`H3`。`H3`表示对象现在有`x, y, z`，其中`z`可能位于偏移量2。`p1`的隐藏类更新为`H3`，而`p2`依旧指向`H2`。此时`p1`和`p2`的隐藏类不同，因为`p1`比`p2`多了一个属性`z`。

通过隐藏类，动态语言实现可以在保持语言灵活性的同时，极大提高属性访问的效率，从而接近静态类型语言的性能。
