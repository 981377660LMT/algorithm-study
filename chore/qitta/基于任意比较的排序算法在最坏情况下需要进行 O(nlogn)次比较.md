# 基于任意比较的排序算法在最坏情况下需要进行 O(nlogn)次比较

下面用“二叉决策树＋叶子数下界”的经典方式，分步说明为什么任意基于比较的排序算法在最坏情况下需要 Ω(n log n) 次比较。

1. 把比较过程看作二叉决策树

   - 每做一次比较，比如比较 `a[i] ≤ a[j]`，就相当于在当前决策树节点分成两条分支：  
     – 左分支：`a[i] ≤ a[j]` 成立  
     – 右分支：`a[i] ≤ a[j]` 不成立
   - 树根对应“尚未比较任何元素”，每往下一层沿某条分支，就对应执行一次具体的比较。

2. 排序结果对应叶子节点

   - 输入数组的初始顺序是一个未知的排列，排序算法要根据一系列比较最终确定一个全局升序排列。
   - 对于长度为 n 的数组，一共有 n! 种可能的初始排列。
   - 决策树的每一条根到叶子的路径，就是该算法在某种输入排列下做比较并走到对应叶子；不同的输入排列必须落到不同的叶子才能被区分并输出正确结果。
   - 因此，这棵二叉树至少要有 n! 个叶子。

3. 二叉树高度 ≥ log₂(叶子数)

   - 一棵高度为 H 的二叉树最多有 2^H 个叶子（满二叉树时叶子最多）。
   - 若叶子数 ≥ n!，则必须有  
     H ≥ log₂(n!)

4. 下界：  
    worst­_comparisons ≥ H ≥ log₂(n!)

5. 用 Stirling 公式估算 log₂(n!)  
   Stirling 提示：  
    n! ≈ √(2πn)·(n/e)ⁿ  
   取对数（以 2 为底）：  
    log₂(n!) = n·log₂n – n·log₂e + O(log n)  
   = Θ(n log n)

6. 结论  
   任意基于两分比较的排序算法，在最坏情况下至少要做  
    ⌈log₂(n!)⌉ = Ω(n log n)  
   次比较。  
   这也说明了归并排序、堆排序等 Θ(n log n) 算法在比较模型下已经是最优的。
