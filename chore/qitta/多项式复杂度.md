### 1. **强多项式时间算法（Strongly Polynomial Time Algorithm）**

- **定义**：算法的运行次数只与输入规模 n（比如元素个数）有关，**与输入数值的大小无关**。
- **举例**：冒泡排序、Dijkstra（用邻接矩阵）、Floyd 等。
- **特征**：即使输入的数字很大，算法的复杂度也不会变。

---

### 2. **弱多项式时间算法（Weakly Polynomial Time Algorithm）**

- **定义**：算法的运行次数不仅与 n 有关，还与输入数值的大小（比如最大整数 M）有关，通常表现为 O(n^k _ log M) 或 O(n^k _ M)。
- **举例**：动态规划解背包问题，复杂度 O(nW)，W 是背包容量。
- **特征**：如果输入的数值很大，算法会变慢。

---

### 3. **伪多项式时间算法（Pseudo-Polynomial Time Algorithm）**

- **定义**：算法的复杂度是输入数值本身的多项式，而不是输入长度的多项式。
- **举例**：同上，背包问题 O(nW)，W 可能是 10^9，但输入长度只有 log W。
- **特征**：当输入数值很大时，算法实际上是指数级的（因为输入长度是 log W）。

---

#### 总结

- **强多项式**：只和 n 有关，最理想。
- **弱多项式**：和 n 及输入数值大小有关。
- **伪多项式**：和输入数值本身有关，不是真正的多项式时间。

这些概念常用于区分算法的实际效率，尤其在组合优化、NP 完全问题领域非常重要。
