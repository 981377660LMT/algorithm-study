#604 **迭代压缩字符串**  
简单
`记录当前的字符串 cur 和剩余数 curRemain；next时mayMove`

#605 **种花问题**  
简单
`为了让头尾符合约束条件，加入哨兵；连续三个0则可种花`

#606 **根据二叉树创建字符串**  
简单
`前序遍历即可`

#609 **在系统中查找重复文件**  
中等
`邻接表`

#611 **有效三角形的个数**  
中等
n<=1000。
`排序+头尾双指针；固定最大的，移动两个小的`

#616 **给字符串添加加粗标签**  
中等
`标记所有bold;while循环，不断寻找下一个bold`

#617 **合并二叉树**  
简单
`构建类的模板`
`if (!root1) return root2`
`if (!root2) return root1`
`然后root.left root.right递归构建`

#621 **任务调度器**  
中等
`间隔相同的任务恰好不能放入同一个桶`
`(maxCount-1)*(n+1)表示除了最多任务的时间`
`然后再加上最多数的任务种类`
`如果任务种类足够多，则取任务长度`

#622 **设计循环队列**  
中等
`head=0；unshift head从-1(数组末尾)开始'向前'存`
`tail=-1；push从0(数组开头)开始向后存`

#623 **在二叉树中增加一行**  
中等
`按照深度1,2区分情况；递归调用`

#624 **数组列表中的最大距离**  
中等
`k个有序数组选绝对值差最大`
`维护min/max;滚动更新`

#625 **最小因式分解**  
中等
`从9开始选,全部放低位`

#628 **三个数的最大乘积**  
简单
`两个最小的负数相乘再乘以最大的正数/最大的三个整数相乘`

#629 **K 个逆序对数组**  
困难
n 的范围是 [1, 1000] 并且 k 的范围是 [0, 1000]
`n,k dp 最大数放在哪`

#630 **课程表 III**  
困难
`事后诸葛`
`进来的越菜,出去的最菜`

#632 **最小区间**  
困难
找到一个 最小 区间，使得 k 个列表中的每个列表至少有一个数包含在其中
`多路归并;最小堆维护最小值,手动维护最大值`

#634 **寻找数组的错位排列**  
中等
`dp[i]:交换第i项与前面第k项 分k放i位置还是k不放i位置`
`dp[i]=(i-1)*(dp[i-1]+dp[i-2])`

#635 **设计日志存储系统**  
中等
`有序哈希映射 TreeMap`

#636 **函数的独占时间**  
中等
`函数独占总是指在栈顶的函数;入栈出栈时关注栈顶元素即可;维护preTime`

#638 **大礼包**  
中等
1 <= n <= 6
`遍历sp套装,记忆化dfs`

#639 **解码方法 II**  
困难
`dp[i-1]与1长度可取,dp[i-2]与2长度可取`

#640 **求解方程**  
中等
`补全系数，一切都是加;x全变成1x;-全变成+-;最后用+分割;再按照带不带x决定系数和常数`

#642 **设计搜索自动补全系统**  
困难
`search回溯搜索所有以word为前缀的单词;TrieNode记录频率`

#643 **子数组最大平均数 I**  
简单
`定长滑窗两个时机`

#644 **子数组最大平均数 II**  
困难
找出 长度大于等于 k 且含最大平均值的连续子数组 并输出这个最大平均值
`二分答案+平均数偏移处理`
`最大和子数组=>滚动更新看过的前缀和最小值,用现在减去之前最小的`

#645 **错误的集合**  
简单
建立双射 值 1-n <=> 索引 0-n-1
`两次遍历, Math.abs(nums[i]) - 1位置上的数*-1`

#646 **最长数对链**  
中等
`优先选择结尾最短的区间,留给后面的空间更多`

#647 **回文子串**  
中等
1 <= s.length <= 1000
`中心扩展O(n^2);helper(s, i, i) + helper(s, i, i + 1)`

#648 **单词替换**  
中等
`trie search不到结果就返回自身`

#649 **Dota2 参议院**  
中等
`stack是战场,queue是军营`

#650 **只有两个键的键盘**  
中等
1 <= n <= 1000
`枚举素因子`

#651 **4 键键盘**  
中等
1 <= n <= 1000
`只需考虑从何时开始按下ctrl C (ctrl V 了多少次)`

#652 **寻找重复的子树**  
中等
`dfs后序序列化`${root.val}#${l}#${r}`；counter存储`

#654 **最大二叉树**  
中等
`dfs(nums,left,right)`

#655 **输出二叉树**  
中等
`dfs(root,depth,pos)`

#656 **金币路径**  
困难
`倒着dfs会比正着找简单`
`要获取路径，我们使用dfs后序,返回(cost,path)`

#658 **找到 K 个最接近的元素**  
中等
从数组中找到最靠近 x（两数之差最小）的 k 个数
`排序+双指针`
`找k个数=>删除n-k个数;排序，从左右两端依次排除数字，最后留下k个数`

#659 **分割数组为连续子序列**  
中等
1 <= nums.length <= 10000
是否可以把这个数组划分成一些由 `至少 3 个`连续数字组成的集合
`每遍历一个数，将该数加入能加入的序列中，不能加入序列则新建一个序列`

#660 **移除 9**  
困难
`找规律，转9进制`

#661 **图片平滑器**  
简单
`遍历 然后判断9个格子的 valid`

#662 **二叉树最大宽度**  
中等
`左子树 parent<<1+1 右子树 parent<<1+2`

#663 **均匀树划分**  
中等
`dfs后序counter统计,检查整棵树的一半权值是否出现,但不能是整棵树之和`

#664 **奇怪的打印机**  
困难
好难 todo
`找到与末尾(新增字符)相等的分隔点，取前后cost之和`

#665 **非递减数列**  
中等
`找到不合理点，看换掉nums[i]还是nums[i-1]`

#666 **路径总和 IV**  
中等
` 结点id(包含深度和位置):结点的值`
`left = (depth + 1) * 10 + 2 * pos - 1`

#667 **优美的排列 II**  
中等
`构造 diff 为 1-k 即可，不超范围，所以要摆动`

#668 **乘法表中第 k 小的数**  
困难
`二分答案`

#669 **修剪二叉搜索树**  
中等
`讨论low,upper与root.val的关系`

#670 **最大交换**  
中等
`从头开始对每一个digit，看后面有没有比它大的`

#672 **灯泡开关 Ⅱ**  
中等
todo

#673 **最长递增子序列的个数**  
中等
`count数组用来记录以nums[i]结尾的最长递增子序列个数`

#674 **最长连续递增序列**  
简单
`求的是子数组，不递增重置0即可`

#675 **为高尔夫比赛砍树**  
困难
1 <= m, n <= 50
`BFS多次,求从[sr,sc] 到 [tr,tc] 的最短距离`

#676 **实现一个魔法字典**  
中等
`用length作为key的邻接表;比较diff数`

#677 **键值映射**  
中等
`求该前缀 prefix 开头的键 key 的值的总和:search先到达前缀的root，再dfs统计weight之和`

#678 **有效的括号字符串**  
中等
`母题，左右遍历统计level`

#679 **24 点游戏**  
困难
`取两个数,6种情况递归`

#680 **验证回文字符串 Ⅱ**  
简单
`双指针找到第一个不同的点，递归一次`

#681 **最近时刻**  
中等
`对四个位置的数暴力枚举所有的情况，如果组成的时间合法并且刚好大于time，就找到结果了；如果不行，就到明天`

#683 **K 个关闭的灯泡**  
困难
请你输出在第几天恰好有两个打开的灯泡，使得它们中间 正好 有 K 个灯泡且这些灯泡 全部是关闭的
`有序集合解法：找左/右边第一个亮灯泡就可以了，看间隔是否为k+1`
`树状数组解法: pos-1和leftCand两个位置处的query值一样，说明中间全是暗的灯泡`

#684 **冗余连接**  
中等
`发现isConnected就加入cand 最后pop`

#685 **冗余连接 II**  
困难
todo
感觉这种题目完全没有一个 generalized 的解法...
`入度为2的节点不合理；形成环的边不合理`

#686 **重复叠加字符串匹配**  
中等
`看重复 Math.ceil(b.length / a.length) 是否includes b ，母题`

#688 **“马”在棋盘上的概率**  
中等
`dfs(x,y,remain)记忆化`

#689 **三个无重叠子数组的最大和**  
困难
`三个滑窗`

#690 **员工的重要性**  
中等
`记录`邻接表`以及`idToEmployee``

#691 **贴纸拼词**  
困难
target 的长度在 [1, 15] 范围内
`dfs(target:str),转移关系为遍历各个Counter删除word里的字符，看最小的步骤数；注意每次都要至少删除第一个字符`

#692 **前 K 个高频单词**  
中等
`堆或者哈希表`

#693 **交替位二进制数**  
简单
`与右移异或，检查结果是否全为1 (n & (n + 1)) === 0`

#694 **不同岛屿的数量**  
中等
`dfs的哈希用每次的转向表示 即for i in range(4) 里的i `

#695 **岛屿的最大面积**  
中等
`dfs 原地标记,同时 cand++`

#696 **计数二进制子串**  
简单
统计并返回具有相同数量 0 和 1 的非空（连续）子字符串的数量
`groupby,取两个相邻的min,reduce`

#697 **数组的度**  
简单
`邻接表，记录index`

#698 **划分为 k 个相等的子集**  
中等
`火柴拼正方形 bt(index:number):boolean回溯`

如果这题没有正数限制,k=3 时

1. 数组对半分为 a，b
2. 对 a，生成所有分为三份的方案 3^9 = 19683，只保存三组的和
3. 对 b，生成所有分为三份的方案 3^9 = 19683，只保存三组的和
4. 把 a 的和的结果存一个 set，对 b 里面的每个方案找补集
5. 例如 b 中的某一种方案,和为(x, y, z)在 a 中找(sum//3 - x, sum//3 - y, sum//3 - z) 6.找到了和之后再生成排列

#699 **掉落的方块**  
困难
`暴力解法，遍历interval(start,end,height)，取最高的重叠高度并更新intervals`
