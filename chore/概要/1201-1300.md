#1201 **丑数 III**  
中等
丑数是可以被 a 或 b 或 c 整除的 正整数 。
`二分答案；容斥原理`
`mid // a + mid // b + mid // c - mid // ab - mid // ac - mid // bc + mid // abc`

#1202 **交换字符串中的元素**  
中等
`记录每个字符串所属的帮派`
`字典序在前的先去 以便之后pop`

#1203 **项目管理**  
困难
`两次topo`
`def get_top_order(graph, indegree)`

#1206 **设计跳表**  
困难
todo

#1208 **尽可能使字符串相等**  
中等
1 <= s.length, t.length <= 10^5
`res = Math.max(res, right - left + 1)`

#1209 **删除字符串中的所有相邻重复项 II**  
中等
`栈；入栈[char,count]`

#1213 **三个有序数组的交集**  
简单
`多路归并ijk`
`三个数值相同，push,指针都动一位;不全相同，则最小数的指针移动一位`
`直接python api`

#1214 **查找两棵二叉搜索树之和**  
中等
`两个有序数组找和为target`

#1215 **步进数**  
中等
`bfs按照顺序加入队列 整个队列都是有序的`

#1216 **验证回文字符串 III**  
困难
`最长回文子串=>区间dfs记忆化递归`

#1217 **玩筹码**  
简单
`odd++ : even++`

#1218 **最长定差子序列**  
中等
`哈希表dp`

#1219 **黄金矿工**  
中等
`dfs后序遍历`

#1220 **统计元音字母序列的数目**  
困难
`有限状态dp endswith`

#1222 **可以攻击国王的皇后**  
中等
`八方旅人:dx,dy,dist`

#1223 **掷骰子模拟**  
困难
` dp[i][j][k] 表示第 i 轮掷骰子掷出数字 j 时 j 连续出现 k 次的组合数`

#1224 **最大相等频率**  
困难
`倒着删，排序然后分类讨论`

#1229 **安排会议日程**  
中等
`双指针归并；start取max,end取min`

#1230 **抛掷硬币**  
中等
`dp[i][j代表前 i 个硬币出现 j 次朝上的概率`

#1231 **分享巧克力**  
困难
`最右能力二分`

#1232 **缀点成线**  
简单
`叉积全为0`

#1233 **删除子文件夹**  
中等
`排序即可`

#1234 **替换子串得到平衡字符串**  
中等
`子串:滑动窗口;counter是记录滑窗外的字符；平衡条件达成时，移动指针`

#1235 **规划兼职工作**  
困难
`出租车问题`

#1236 **网络爬虫**  
中等
`去重+bfs`

#1237 **找出给定方程的正整数解**  
中等
`双指针`

#1239 **串联字符串的最大长度**  
中等
`滚动替换set`

#1240 **铺瓷砖**  
困难
todo

#1243 **数组变换**  
简单
`not changed标记`

#1244 **力扣排行榜**  
中等
`排行榜一般都是dict+treeSet`
`更新操作一般都是删除原来的，重新添加新的`
`注意有序list可传key SortedList(key=lambda x: -x[0])`

#1245 **树的直径**  
中等
`两次bfs`

#1246 **删除回文子数组**  
困难
1 <= arr.length <= 100
`看到回文就想区间dp了 O(n^3)`
`dfs(left,right)`

#1247 **交换字符使得字符串相同**  
中等
`xy yx两种情况统计`

#1248 **统计「优美子数组」**  
中等
`pre存奇数个数前缀和`

#1249 **移除无效的括号**  
中等
`不合法的位置存即可`

#1250 **检查「好数组」**  
困难
`reduce(gcd, nums) == 1`

#1252 **奇数值单元格的数目**  
简单
`行列各一个counter记录和；泡泡堂`
`奇数单元格=奇数和行*偶数和列+偶数和行*奇数和列`

#1253 **重构 2 行二进制矩阵**  
中等
`贪心,谁大就分给谁1`

#1254 **统计封闭岛屿的数目**  
中等
`边界先dfs`

#1255 **得分最高的单词集合**  
困难
`枚举 words 子集，counter子集关系判断可不可取`

#1257 **最小公共区域**  
中等
`parent哈希表记录每个区域的parent；找LCA直接while循环`
`找LCA的一种思路:一边不断上升，把看过的结点保存；另一边不断上升，遇到看过的第一个结点就是LCA`

#1258 **近义词句子**  
中等
`回溯(每个近义词都有很多备选，根据并查集求出)`

#1259 **不相交的握手**  
困难
`卡特兰数`

#1260 **二维网格迁移**  
简单
`flat之后变成旋转数组问题`

#1261 **在受污染的二叉树中查找元素**  
中等
`target + 1 的二进制表示进行二叉树寻路 `

#1262 **可被三整除的最大和**  
中等
`模，有限状态dp`

#1263 **推箱子**  
困难
`估值距离，箱子推动次数，人，箱子`
`visited 记录(person, box)位置`

#1265 **逆序打印不可变链表**  
中等
`输出逆序，后序dfs即可`

#1268 **搜索推荐系统**  
中等
`为了维持搜索出来的词的顺序,trieNode内部可以维护一个堆suggestion`

#1269 **停在原地的方案数**  
困难
`dfs(cur: int, steps: int)`

#1272 **删除区间**  
中等
`判断不重叠还是重叠`

#1273 **删除树节点**  
中等
`dfs两个过程；把subTreeSum和subTreeCount存在外部`
`后序 dfs，由这个分支更新;统计完了 准备回溯`

#1274 **矩形内船只的数目**  
困难
`折半搜索；分成四个区域递归分治`

#1275 **找出井字棋的获胜者**  
简单
`位运算`

#1277 **统计全为 1 的正方形子矩阵**  
中等
`左，上，左上，原地修改；A[i][j] *= min(A[i - 1][j], A[i][j - 1], A[i - 1][j - 1]) + 1`

#1278 **分割回文串 III**  
困难
1 <= k <= s.length <= 100
`看到回文串就dfs dfs(index,remain) 枚举分割点`

#1282 **用户分组**  
中等
`邻接表，到头了就pop出来`

#1283 **使结果不超过阈值的最小除数**  
中等
`二分`

#1284 **转化为全零矩阵的最少反转次数**  
困难
1 <= m <= 3
1 <= n <= 3
`bfs`
`反转相邻位:next ^= 1 << (r * n + c)`

#1286 **字母组合迭代器**  
中等
`直接bt`

#1287 **有序数组中出现次数超过 25%的元素**  
简单
`将 arr[i] 和 arr[i + len] 相比，如果相等，就说明出现次数超过 1 / 4`

#1288 **删除被覆盖区间**  
中等
`intervals.sort((a, b) => a[0] - b[0] || b[1] - a[1])`

#1290 **二进制链表转整数**  
简单
`先左移位，再加当前的值`

#1291 **顺次数**  
中等
`根据位数暴力枚举，最后再过滤`

#1292 **元素和小于等于阈值的正方形的最大边长**  
中等
1 <= m, n <= 300
`二分；二维区域前缀和;n^2logn`

#1293 **网格中的最短路径**  
困难
`bfs+剪枝:贴墙走需要的最大k`
`visited每个点处要保存剩余的k`

#1296 **划分数组为连续数字的集合**  
中等
`counter即可`
`注意与一手顺子的区别`

#1297 **子串的最大出现次数**  
中等
`骗人的题；暴力`

#1298 **你能从盒子里获得的最大糖果数**  
困难
`莫名其妙的bfs;可以获得糖果的 最大数目=>bfs最大深度`

#1299 **将每个元素替换为右侧最大元素**  
简单
`倒序维护最大值`

#1300 **转变数组后最接近目标值的数组和**  
中等
`二分确定 left 后，最后再验证 left-1 与 left 时的值`
