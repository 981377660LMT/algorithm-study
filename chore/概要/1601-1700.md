#1601 **最多可达成的换楼请求数目**  
困难
`枚举requests子集`

#1603 **设计停车系统**  
简单
`二进制分段 big + (medium << 10) + (small << 20)`
`还有车位:(this.state >> mask) & 0x3ff`
`二进制分段压缩存储」的主要目的，不是减少使用一个 intint，而是让「非原子性操作」变为「原子性操作」`

#1604 **警告一小时内使用相同员工卡大于等于三次的人**  
中等
`邻接表+zip(record, record[2:])`

#1605 **给定行和列的和求可行矩阵**  
中等
`遍历 matrix，每次都填这次能填的最大数, min(rowSum[i], colSum[j])`

#1606 **找到处理最多请求的服务器**  
困难
`维护busy和free`
`busy 执行完入队 free,从free取出一个server执行当前任务`

#1610 **可见点的最大数目**  
困难
`atan2 求方位角然后排序，然后二分找哪个区间里的数最多`

#1611 **使整数变为 0 的最少操作次数**  
困难
`格雷码转二进制`

#1612 **检查两棵二叉表达式树是否等价**  
中等
`counter,res`

#1616 **分割两个字符串得到回文串**  
中等
`两端相等，看中间是不是回文`

#1617 **统计子树中城市之间最大距离**  
困难
2 <= n <= 15
`1.求每个点到所有点的最短距离--多源最短路径算法 floyd`
`2.二进制枚举所有状态（子集）`
`3.形成树的条件vertex === edges + 1`

#1618 **找出适应屏幕的最大字号**  
中等
`最右二分+最后要再检查一下`

#1620 **网络信号最好的坐标**  
中等
`模拟，遍历，比较`

#1621 **大小为 K 的不重叠线段的数目**  
中等
`组合题,如果线段端点可以重合/如果线段端点不能重合`

#1622 **奇妙序列**  
困难
`逆元`

#1624 **两个相同字符之间的最长子字符串**  
简单
`哈希表存字符首次出现位置`

#1625 **执行操作后字典序最小的字符串**  
中等
2 <= s.length <= 100
`记忆化+bfs`

#1626 **无矛盾的最佳球队**  
中等
1 <= scores.length, ages.length <= 1000
`对年龄排序后对分数寻找LIS`

#1627 **带阈值的图连通性**  
困难
`公因数并查集问题:枚举因子，union因子和因子的倍数;枚举因子复杂度nlogn`

#1628 **设计带解析函数的表达式树**  
中等
todo 题目很精彩

#1629 **按键持续时间最长的键**  
简单
`处理start与end,然后zip得出duration`

#1630 **等差子数组**  
中等
`暴力,排序后看len(set(相邻diff)) == 1`

#1631 **最小体力消耗路径**  
中等
`二分答案/并查集/最短路`

`1.最左二分+dfs看联通`
`2.并查集：将所有边按照长度进行排序并依次添加进并查集，直到左上角和右下角连通为止`
`3.最短路:maxWeight变形定义`

#1632 **矩阵转换后的秩**  
困难
todo

#1634 **求两个多项式链表的和**  
中等
`while poly1 or poly2:循环；讨论哪个系数大；系数一样时相加，需要注意等于0的情况`

#1637 **两点之间不包含任何点的最宽垂直面积**  
中等
`zip(p, p[1:])`

#1638 **统计只差一个字符的子串数目**  
中等
1 <= s.length, t.length <= 100
`O(mn*min(m,n))`
`ijk大法：枚举起点,找到一个不同的字符,统计diff数`

#1639 **通过给定词典构造目标字符串的方案数**  
困难
1 <= words.length <= 1000
`dfs(targetIndex: int, wordIndex: int)`
`每个位置的储备counter[i][char]`
`每个index处可以选或不选`

#1640 **能否连接形成数组**  
简单
`不允许 对每个数组 pieces[i] 中的整数重新排序=>记录每一块的首部元素`

#1641 **统计字典序元音字符串的数目**  
中等
`x1+x2+x3+x4+x5=n的非负整数解个数`

#1642 **可以到达的最远建筑**  
中等
`事后诸葛：优先使用梯子，将diff保存最小堆，梯子不够了用砖头兑换最小的diff`

#1643 **第 K 条最小指令**  
困难
`计算下一步放'H'的组合数；如果放'H'都不足以凑够k个，说明这个字典序太小了`

#1644 **二叉树的最近公共祖先 II**  
中等
`后序遍历，找LCA`

#1647 **字符频次唯一的最小删除次数**  
中等
`while count in visited:`

#1648 **销售价值减少的颜色球**  
中等
`二分查找 `最后一次卖出时，球的价格 x`(最左二分)`
注意最低价格要超出限制，然后减去`超出的数量*最低价值`

#1649 **通过指令创建有序数组**  
困难
`BIT`

#1650 **二叉树的最近公共祖先 III**  
中等
`带parent的树找LCA：找相交链表交点`

#1653 **使字符串平衡的最少删除次数**  
中等
1 <= s.length <= 10^5
`dp[i];删这个a或删前面所有的b`

#1654 **到家的最少跳跃次数**  
中等
`bfs；根据范围合理剪枝`

#1655 **分配重复整数**  
困难
1 <= m <= 10
`回溯bt(index)`
`defaultdict第二个参数可以是一个初始化字典`

#1656 **设计有序流**  
简单
`visited哈希表`

#1657 **确定两个字符串是否接近**  
中等
`交换任意两个 现有 字符的位置 => set 一样，即集合无序性。`
`交换两种字符的值 => counter(freq) 一样，即freq数组相等`

#1658 **将 x 减到 0 的最小操作数**  
中等
`求和为定值sum(nums)-x的最长子数组: 滑动窗口`

#1659 **最大化网格幸福感**  
困难
`dfs(x, y, intro, extro, state: Tuple[int])`
`state:最近的n个安排，上面的人是state[0]，左边的人是state[-1]`

#1660 **纠正二叉树**  
中等
`根右左遍历`

#1663 **具有给定数值的最小字符串**  
中等
`后面全部填z,diff > 25 就继续减`

#1664 **生成平衡数组的方案数**  
中等
`奇偶差的和,leftDiff与rightDiff`

#1665 **完成所有任务的最少初始能量**  
困难
`倒推,min-actual(装逼程度)排序`

#1666 **改变二叉树的根节点**  
中等
todo

#1668 **最大重复子字符串**  
简单
`最右二分`

#1670 **设计前中后队列**  
中等
`维护left与right两个deque，left不超过right+1，right不超过left`

#1671 **得到山形数组的最少删除次数**  
困难
3 <= nums.length <= 1000
`枚举山顶,LIS`

#1673 **找出最具竞争力的子序列**  
中等
`移掉 K 位数字字典序删除问题，记得最后切片取前k项`

#1674 **使数组互补的最少操作次数**  
中等
`差分数组的精髓`
`差分数组，在临界值处添加1(即进行一次操作)`
`给 [l, r] 的区间加上一个数字 a, 只需要 diff[l] += a，diff[r + 1] -= a。,diff[0...i] 的和，就是更新后 res[i] 的值`

#1675 **数组的最小偏移量**  
困难
`m 个一维数组中各取出一个数字，重新组成新的数组 A，使得新的数组 A 中最大值和最小值的差值（diff）最小`

#1676 **二叉树的最近公共祖先 IV**  
中等
`返回 nodes 中所有节点的最近公共祖先（LCA）`

#1678 **设计 Goal 解析器**  
简单
`记录bufferCount `

#1679 **K 和数对的最大数目**  
中等
`counter组合计数`

#1680 **连接连续二进制数字**  
中等
`遇到二的整数次幂移位量就加一;res = (res << shiftLen) + num`

#1681 **最小不兼容性**  
困难
`状压dfs；排序剪枝，每组的第一个元素必定是剩下元素中最小的那个`

#1682 **最长回文子序列 II**  
中等
`区间dfs,dp(i,j,c)代表i到j之间且两端字母为c时的解,复杂度(状态数)：O(26n^2)`

#1684 **统计一致字符串的数目**  
简单
`set子集`

#1685 **有序数组中差绝对值之和**  
中等
第 i 项等于
`ni*(i+1)-preSum[i+1]`+`preSum[-1]-preSum[i]-ni*(n-i)`

#1686 **石子游戏 VI**  
中等
`按恶心值排序`

#1687 **从仓库到码头运输箱子**  
困难
todo

#1688 **比赛中的配对次数**  
简单
`几个队淘汰就有几个配对`

#1689 **十-二进制数的最少数目**  
中等
`取决于最大digit`

#1690 **石子游戏 VII**  
中等
`dfs(left: number, right: number, sum: number): number`

#1691 **堆叠长方体的最大高度**  
困难
`排序前面的箱子放上面，LIS二维dp解法；注意高要取最长的那条边`

#1692 **计算分配糖果的不同方式**  
困难
`第二类斯特林数,dp[i][j]表示i个盒子 j颗糖,讨论新的那颗糖是否独占1盒`

#1694 **重新格式化电话号码**  
简单
`cursor大法处理分组`

#1695 **删除子数组的最大得分**  
中等
`3. 无重复字符的最大和子串,判断nums[right]是否已经看过`

#1696 **跳跃游戏 VI**  
中等
单调队列解决：有长度限制的最大`子序列和`问题：
i 这个位置的最佳得分其实是前面[i-k,i-1]区间最大值加 nums[i]
`单减队列维护窗口最大值：出队，更新答案，入队`

#1697 **检查边长度限制的路径是否存在**  
困难
`离线查询按limit从严格到宽松排序，不断链接边`

#1698 **字符串的不同子字符串个数**  
中等
`暴力`

#1700 **无法吃午餐的学生数量**  
简单
`生产消费模型；三明治来选择学生，学生生产，三明治消费`
