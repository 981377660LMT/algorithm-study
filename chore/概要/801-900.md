#801 **使序列递增的最小交换次数**  
困难
n<=1000
`dp；如果交换之前有序，则可以不交换，否则至少需要交换一次（交换当前项或者前一项）`

#802 **找到最终的安全状态**  
中等
`若起始节点位于一个环内，或者能到达一个环，则该节点不是安全的`

#803 **打砖块**  
困难
`倒推打砖块`

#805 **数组的均值分割**  
困难
A 数组的长度范围为 [1, 30].
`meet in the middle`
`选择i个数的和为target=>回溯剪枝`

#807 **保持城市天际线**  
中等
`维护xMax 与 yMax`

#808 **分汤**  
中等
`dfs+cache`

#809 **情感丰富的文字**  
中等
`groupby`

#810 **黑板异或游戏**  
困难
`面对偶数个数的选手必赢；`
`面对奇数个数，且两两异或的值为 0 的选手开局即赢`

#812 **最大三角形面积**  
简单
`combinations(points, 3)；叉乘模除以2`

#813 **最大平均值和的分组**  
中等
`dfs(cur: int, remain: int)；枚举分割点`

#815 **公交路线**  
困难
`就是bfs`

#816 **模糊坐标**  
中等
`枚举分割点；left right dfs 后序`

#818 **赛车**  
困难
`bfs数据范围剪枝`

#821 **字符的最短距离**  
简单
`栈`

#823 **带因子的二叉树**  
中等
`排序+枚举根；dp`

#825 **适龄的朋友**  
中等
`counter组合问题`

#826 **安排工作以达到最大收益**  
中等
`排序，记录curMax`

#827 **最大人工岛**  
困难
`并查集`

#828 **统计子串中的唯一字符**  
困难
`邻接表，计算贡献`
` 对每一个字符i，向前找到相同的字符j，向后找到相同的字符k。当前字符对最终结果的贡献是：（i-j）*(k-i)。`

#833 **字符串中的查找与替换**  
中等
`倒着替换,不会影响到前面的`

#834 **树中距离之和**  
困难

1. 前序 dfs 获取每个节点的深度，用 cur 更新 next
2. 后序 dfs 获取每个结点的子树个数，用 next 更新 cur
3. 根的距离和等于所有点的 depth 和
4. next 的距离和等于 cur 减去 next 子树结点加上 next 上面的结点

#835 **图像重叠**  
中等
`直接对偏移量计数:检查grid1中每个点与grid2中每个点的偏移量 `

#836 **矩形重叠**  
简单
`Math.max(0, Math.min(b, d) - Math.max(a, c))`

#838 **推多米诺**  
中等
`统计合力`

#839 **相似字符串组**  
困难
`两两union 看连通分量数`

#845 **数组中的最长山脉**  
中等
`dp扫两边 记录 up down`

#846 **一手顺子**  
中等
`counter`

#847 **访问所有节点的最短路径**  
困难
`每个点处状压 visites[cur][state]=cost`

#849 **到最近的人的最大距离**  
中等
`遍历,groupby;间距>>1即为最大距离`
`考虑首尾为1的特情况`

#850 **矩形面积 II**  
困难
`记录pre，宽度等于cur-pre`
`SortedList维护高度`
`让x重合的左边界排在右边界前`

#854 **相似度为 K 的字符串**  
困难
`bfs`
`寻找转移状态`

#855 **考场就座**  
中等
`直接遍历,SortedList维护有序`
`curMaxDist = (cur - pre) >> 1`

#856 **括号的分数**  
中等
`记录 level 得分 1<<level`

#857 **雇佣 K 名工人的最低成本**  
困难
`排序；进来的越菜，出去的最菜`

#858 **镜面反射**  
中等
`分奇偶讨论`

#861 **翻转矩阵后的得分**  
中等
`遍历行，首位 1 则异或；遍历列，让 1 尽可能多`

#862 **和至少为 K 的最短子数组**  
困难
求满足其和 ≥ target 的长度最小的 连续子数组
`和 209 的区别就是 209 不允许负数`

#864 **获取所有钥匙的最短路径**  
困难
`1. 二维遍历预处理，找起点和钥匙个数，每把🔑赋值一个id`
`2. bfs 队列存 row,col,visitedKeys,dist`
`3. 使用三维数组来表示visited (每个点的每个状态是否访问过)`
`visited[row][col][state]`

#865 **具有所有最深节点的最小子树**  
中等
`后序dfs 比较子树高度`

#868 **二进制间距**  
简单
`32位，记录preIndex`

#869 **重新排序得到 2 的幂**  
中等
`counter暴力`

#870 **优势洗牌**  
中等
`排序+bisectRight 查找`

#871 **最低加油次数**  
困难
`事后诸葛；油全部入堆`

#873 **最长的斐波那契子序列的长度**  
中等
`dp[i][j]：表示最后两项是arr[i],arr[j]的斐波那契数列的最大长度`

#877 **石子游戏**  
中等
`def dfs(left: int, right: int) -> int:`

#878 **第 N 个神奇数字**  
困难
`二分+容斥原理`

#879 **盈利计划**  
困难
`二维01背包，dp[人数][收益]`
`dp[person][prof] += dp[person - needperson][max(0, prof - getprof)]`

#880 **索引处的解码字符串**  
中等
`获取总长度+倒着解锁`

#881 **救生艇**  
中等
`贪心，首尾配对`

#882 **细分图中的可到达结点**  
困难
`对每一对大端点，计算可到达的小端点：容斥原理`

#884 **两句话中的不常见单词**  
简单
如果某个单词在其中一个句子中恰好出现一次，在另一个句子中却 没有出现 ，那么这个单词就是 不常见的
`可以理解成拼接字符串A+B，然后返回拼接后的字符串中只出现过一次的单词`

#885 **螺旋矩阵 III**  
中等
`计算步数与转向次数的关系`

#886 **可能的二分法**  
中等
`colors -1 0 1`

#887 **鸡蛋掉落**  
困难

```JS
const calFloor = (eggs, throws) => {
    if (eggs === 1 || throws === 1) return throws + 1
    return calFloor(eggs, throws - 1) + calFloor(eggs - 1, throws - 1)
}
```

#889 **根据前序和后序遍历构造二叉树**  
中等
`preorder第二个元素（如果存在的话）一定是左子树，即后序遍历(0, index + 1)全是左子树`

#890 **查找和替换模式**  
中等
`双射`
`len(set(s)) == len(set(t)) == len(set(zip(s, t)))`

#891 **子序列宽度之和**  
困难
`排序，对每个数，统计他作为最大/最小值在多少个取他的子集pow(2,n,mod)里出现`

#892 **三维形体的表面积**  
简单
`2个底面 + 所有的正方体都贡献了4个侧表面积`
`减去四周重叠的侧面积`

#893 **特殊等价字符串组**  
中等
奇数位的字母一样，偶数位的字母一样，这样的字符串相互等价
`''.join(sorted(sub[::2]) + sorted(sub[1::2]))`

#894 **所有可能的满二叉树**  
中等
`yield大法`

#895 **最大频率栈**  
困难
`keyToFreq freqToStack 并维护maxFreq`

#896 **单调数列**  
简单

```Python
 if not inc and not dec:
    return False
```

#898 **子数组按位或操作**  
中等
`set滚动替换`

#899 **有序队列**  
困难
`最小表示法/暴力切片`
