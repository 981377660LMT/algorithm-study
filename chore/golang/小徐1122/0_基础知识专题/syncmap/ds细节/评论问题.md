### 问题解答

#### 1. 将 `dirty` 全量拷贝到 `read` 后，为什么将 `dirty` 设置为 `nil`？

**核心原因**：

- **状态重置**：`dirty` 晋升为 `read` 后，新的 `read` 已包含所有有效数据。将 `dirty` 置为 `nil` 是为了：
  1. **避免数据冗余**：`dirty` 和 `read` 可能包含相同数据，保留 `dirty` 会导致内存浪费。
  2. **保证一致性**：后续写操作需基于最新的 `read` 构建新的 `dirty`，而不是旧的残留数据。
  3. **触发懒初始化**：下次写入新键时，若 `dirty` 为 `nil`，会触发 `dirtyLocked` 流程，从 `read` 中拷贝未删除的键，确保 `dirty` 始终是 `read` 的超集。

**示例**：  
假设 `read` 包含键 `A`（存活）、`B`（软删除），`dirty` 晋升为 `read` 后：

- 若保留旧 `dirty`，新写入的键 `C` 需要同时修改 `read` 和 `dirty`，违背无锁读的设计目标。
- 将 `dirty` 置为 `nil` 后，写入 `C` 时重新构建 `dirty`（包含 `A` 和 `C`），保持逻辑清晰。

---

#### 2. 为什么 `sync.Map` 不直接用单 `map` + CAS 实现？

**根本原因**：

- **CAS 无法直接操作 `map` 结构**：  
  CAS 只能原子替换指针，但 `map` 的修改（如插入、删除）需要操作内部结构（如哈希桶），无法通过单一指针交换实现原子性。
- **锁粒度与性能矛盾**：
  - 若用全局锁保护单 `map`，写操作会阻塞所有读写，无法满足高并发需求。
  - 若用分段锁（如分片），实现复杂度高，且内存开销大。

**sync.Map 的优化**：

- **无锁读**：`read` 通过原子指针提供无锁访问，适合高频读场景。
- **写时分离**：新增和修改操作集中在 `dirty`，通过 `amended` 标记差异，避免全局锁。
- **批量同步**：通过 `misses` 计数器触发 `dirty` 晋升，将写开销分摊到多次读操作。

**对比示例**：

- **单 `map` + 全局锁**：100 万次读操作需 100 万次加锁，性能低下。
- **sync.Map**：100 万次读操作中，99% 命中 `read`（无锁），1% 触发加锁兜底，性能显著提升。

---

#### 3. `expunged` 状态的意义与替代方案分析

**`expunged` 的作用**：

1. **区分删除类型**：
   - **软删除（`nil`）**：键逻辑删除，但物理存在于 `read`，可通过 CAS 直接恢复。
   - **硬删除（`expunged`）**：键已从 `dirty` 移除，重新写入需加锁并添加到 `dirty`。
2. **优化内存与性能**：
   - 在 `dirtyLocked` 时，将 `read` 中的软删除键（`nil`）转为 `expunged`，避免将其拷贝到新 `dirty`。
   - 避免 `dirty` 包含大量无效键，减少内存占用和遍历开销。

**状态转换时机**：

- **`nil` → `expunged`**：仅在 `dirtyLocked` 过程中发生。当从 `read` 拷贝键到 `dirty` 时，若发现键为 `nil`，则将其标记为 `expunged` 并跳过拷贝。
- **`expunged` → `nil`**：在 `Store` 操作中，若尝试写入 `expunged` 键，需加锁将其恢复为 `nil` 并插入 `dirty`。

**替代方案：Key 粒度读写锁**

- **实现思路**：为每个键分配独立的读写锁，读操作加读锁，写操作加写锁。
- **优点**：
  - 高并发：不同键的操作完全并行。
  - 直观：逻辑简单，类似数据库行级锁。
- **缺点**：
  1. **内存开销**：每个键需维护锁结构，内存占用随键数量线性增长。
  2. **锁管理成本**：频繁增删键时，锁的创建和销毁成为性能瓶颈。
  3. **死锁风险**：跨键事务可能需按顺序加锁，增加复杂度。
  4. **全局操作代价高**：遍历（如 `Range`）需对所有键加锁，性能极差。

**对比 sync.Map**：  
| **场景** | **sync.Map** | **Key 粒度锁** |
|------------------------|-----------------------------|-----------------------------|
| **高频读** | ✅ 无锁，性能极致 | ❌ 读锁竞争，性能一般 |
| **高频写（键分散）** | ❌ 频繁触发 `dirtyLocked` | ✅ 写锁分散，性能较好 |
| **内存占用** | ✅ 固定冗余（双 map） | ❌ 随键数量线性增长 |
| **遍历操作** | ✅ 无锁遍历 `read` | ❌ 需全局加锁，阻塞所有操作 |
| **实现复杂度** | ✅ 高（状态机优化） | ❌ 中（但需处理锁膨胀） |

**结论**：

- **`expunged` 是必要的**：它通过状态机优化内存和写操作，避免无效数据拷贝。
- **Key 粒度锁不适用通用场景**：仅在键分布均匀且写操作极度频繁时可能有优势，但牺牲了内存和全局操作性能。
- **sync.Map 的复杂性是权衡结果**：通过状态标记和双 map 分离，在保证线程安全的前提下，最大化无锁读的性能。
