https://leetcode.cn/problems/design-memory-allocator/solutions/3089967/golang-nei-cun-ye-fen-pei-qi-shi-xian-yu-8h9d/

下面给出一个总结和讲解，重点介绍了该提案中如何利用 Radix Tree 来加速内存页的分配查找过程：

---

### 1. 背景概述

传统的 Go 内存页分配器在高并发、频繁分配的场景下容易出现锁竞争问题。为了解决这一瓶颈，该提案提出用位图来替换原有的 span 结构，用来跟踪整个堆中各个 8 KiB 页的使用情况。每一位表示一个页面：1 表示已使用，0 表示空闲。

为了高效地查找连续的空闲页面（尤其是大多数分配只需要一个页面的情况），将位图划分为固定大小的块（chunk），例如每个块 512 位，覆盖 4 MiB 内存区域。对每个块，还会维护三个摘要信息：

- **start**：从块起始位置开始连续空闲的页面数。
- **end**：从块末尾开始连续空闲的页面数。
- **max**：块内连续空闲的最大页面数。

这些摘要不仅能快速判断某个块内是否存在足够的连续空闲页面，还能通过简单的状态机（或表查）将多个相邻块的摘要合并，进一步加速查找。

---

### 2. Radix Tree 的设计与作用

尽管单个块的摘要已经能提高查找效率，但在堆比较大时，单纯遍历所有块的时间复杂度依然是线性的。为此，提案在块级摘要的基础上构建了一棵**Radix Tree**，其核心思想包括：

- **隐式树结构**：Radix Tree 并非采用指针链接的显式树，而是由多个数组构成的隐式树。最底层（叶节点）存储每个块的摘要信息，上层节点聚合下层一定范围内的块的摘要。

- **扇出（Fanout）设计**：为了保证数据结构的缓存友好性，每个节点的扇出被设计为 8（例如，64 字节一行，每个摘要 8 字节）。这样不仅能快速加载节点内容，还能在 L1 缓存中容纳多个摘要。

- **多层次聚合**：在 48 位地址空间下，树被设计为 5 层结构：

  - **Level 4（叶节点）**：每个节点代表一个 512 位（即一个 chunk）。
  - **Level 3 到 Level 1**：每个上层节点聚合 8 个下层节点的摘要，计算合并后的 start、max、end 信息。
  - **Level 0（根节点）**：每个条目代表 2^21 个 8 KiB 页（大约 16 GiB 内存），作为查找的起点。

- **查找过程**：当需要分配页面时，分配器会从根节点开始，检查该区域的聚合摘要（主要关注 max 值），判断该区域是否可能存在满足需求的连续空闲页面。如果聚合信息表明有足够空间，则递归地进入下一层直到达到叶节点，从而精确定位到具体的 chunk。

- **高效剪枝**：由于每个节点都携带了区域内最大连续空闲页面数的信息，若某个上层节点的 max 值不足，则整个该子树可以被快速跳过。这大大减少了查找时遍历的区域数量，即使在大堆空间下也能保持一致的性能。

- **缓存友好与紧凑性**：为了使摘要结构更紧凑、适合缓存使用，提案建议将 start、max、end 三个计数值打包到 64 位中（例如，每个字段 21 位），这不仅减小了内存占用，也保证了在读取时只需要一个内存加载即可获取完整的摘要数据。

---

### 3. 总结

- **位图管理**：整个堆的内存页使用位图来管理，0 表示空闲，1 表示已分配，减少了对 span 结构的依赖。
- **摘要与 Radix Tree**：每个固定大小的块有一个摘要信息，Radix Tree 通过多层聚合这些摘要，从根节点到叶节点形成一个层级索引，能快速跳过已满区域，只在可能有空闲空间的区域进行详细查找。
- **高效分配**：这种设计使得内存分配器能够在大并发环境下，快速定位连续空闲页面，从而大幅降低锁竞争，提升整体分配性能和一致性。

通过这种基于位图与 Radix Tree 的设计，Go 内存页分配器在面对高并发、大规模堆内存的场景时，能够更高效、更可预测地完成内存分配任务。

---

科技：

- 叶子结点(底层)是bitmap
- pre、suf、max 压成了 uint64
- 每个结点有 8 个子结点
