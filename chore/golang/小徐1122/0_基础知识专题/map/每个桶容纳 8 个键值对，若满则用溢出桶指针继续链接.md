在 Go 的哈希表（即 `map`）实现中，每个桶（bucket）可以一次性容纳 8 个键值对（key-value）。当某个桶的 8 个槽位都被占满，但依然有哈希冲突产生、需要插入更多元素时，就需要**额外的存储空间**来存放新元素。Go 使用了一种**“溢出桶（overflow bucket）”链式结构**来解决这个问题：一旦第一个桶满了，就通过一个指针链接到下一个“溢出桶”，继续存放多余的元素。

之所以采用“一个桶最多容纳 8 个键值对 + 溢出桶指针”的设计，主要有以下考虑：

1. **减少指针开销，节省内存**

   - 如果为每个元素都单独分配一个小结构、然后靠指针链起来，那么指针本身就会带来额外的内存和管理开销。
   - 采用固定大小（8 个 key-value）的小块可以一次容纳多个键值，大部分情况下就不需要额外的“溢出桶”。只有当哈希冲突非常密集时才会分配额外桶。

2. **提高缓存友好性（cache locality）**

   - 将多个 key-value 紧挨着存放在同一个连续的内存块里，有利于 CPU 缓存命中，减少访问时间。
   - 相比“所有冲突都用链表节点分散在内存各处”而言，把一部分冲突放在同一个桶里命中率更高。

3. **结合了开地址法与链式冲突的混合思路**

   - 在其他语言/系统的哈希表实现里，要么采用开地址法（如线性探测、二次探测），要么采用链式法（桶里直接挂链表）。各有优缺点。
   - Go 通过限制“桶的大小为 8”，并在确实需要时才使用“溢出桶链表”的方式，取得了**相对平衡的**内存利用率与性能表现。

4. **简化桶分裂（Bucket Split）逻辑**
   - Go 的 `map` 会在特定条件下进行扩容和桶分裂（rehash），如果桶大小过于灵活，会让分裂过程难以管理。
   - 固定长度有助于在分裂时只需考虑“把桶里的 n 个 key-value 拆分到两个桶里”即可，只有溢出桶部分需要特殊处理，不会出现无限制的链式结构。

综上，**“每个桶容纳 8 个键值对，若满则用溢出桶指针继续链接”** 是出于在“内存开销、CPU 缓存友好、冲突处理灵活性”之间做综合权衡的结果。大部分情况下，一个桶就够用，只有在哈希冲突严重时才需要额外溢出桶，从而在总体上获得不错的性能与空间利用率。
