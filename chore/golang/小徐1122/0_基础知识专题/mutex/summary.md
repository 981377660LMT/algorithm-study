### Golang 单机锁实现原理总结

#### 1. `sync.Mutex` 互斥锁

**核心机制：**

- **状态管理**：通过 `state` 字段（int32）的低 3 位表示锁状态（锁定、唤醒、饥饿模式），高 29 位记录等待的协程数量。
- **CAS 操作**：加锁时先尝试快速路径（CAS），失败后进入慢路径处理竞争。
- **自旋优化**：在低竞争时，协程通过自旋（循环尝试）减少上下文切换开销。自旋条件包括：自旋次数 < 4、多核 CPU、当前 P 无其他待运行 G。
- **阻塞升级**：自旋失败后，协程进入阻塞队列（通过信号量 `sema`），等待被唤醒。
- **饥饿模式**：当协程等待超过 1ms，锁进入饥饿模式，新请求直接排队，确保公平性。饥饿模式在队列清空或等待时间不足 1ms 时解除。

**数据结构：**

```go
type Mutex struct {
    state int32 // 状态字段（低3位：锁状态；高29位：等待协程数）
    sema  uint32 // 信号量，用于阻塞/唤醒协程
}
```

**加锁流程（Lock）：**

1. **快速路径**：CAS 尝试直接加锁，成功则返回。
2. **慢路径**：
   - 自旋尝试，期间标记 `mutexWoken` 避免重复唤醒。
   - 构造新状态：若未饥饿则尝试加锁，否则排队。
   - CAS 更新状态，失败则循环重试。
   - 若最终未获锁，进入阻塞队列挂起。

**解锁流程（Unlock）：**

1. 原子操作解除锁定状态。
2. 若有等待协程：
   - **正常模式**：唤醒队首协程，竞争锁。
   - **饥饿模式**：直接移交锁所有权给队首协程。

#### 2. `sync.RWMutex` 读写锁

**核心机制：**

- **读写分离**：读锁共享（允许多个读），写锁独占（阻塞所有读写）。
- **优先级控制**：写锁优先于读锁，防止写饥饿。

**数据结构：**

```go
type RWMutex struct {
    w          Mutex   // 底层互斥锁，保护写操作
    writerSem  uint32  // 写阻塞信号量
    readerSem  uint32  // 读阻塞信号量
    readerCount int32  // 读者数（写锁存在时为负）
    readerWait  int32  // 写锁需等待的读者数
}
```

**读锁流程：**

- **RLock**：原子增加 `readerCount`，若结果为负（存在写锁），阻塞等待 `readerSem`。
- **RUnlock**：原子减少 `readerCount`，若结果为负（存在写锁等待），减少 `readerWait`，若归零则唤醒写锁。

**写锁流程：**

- **Lock**：
  1. 获取底层 `w` 锁。
  2. 原子减少 `readerCount` 为负（标记写锁存在）。
  3. 等待现有读者释放（通过 `readerWait`），阻塞于 `writerSem`。
- **Unlock**：
  1. 恢复 `readerCount` 为正，唤醒所有阻塞的读锁（通过 `readerSem`）。
  2. 释放底层 `w` 锁。

#### 3. 关键设计思想

- **性能与公平权衡**：Mutex 通过自旋减少阻塞，饥饿模式保障公平；RWMutex 通过读写分离优化读多场景。
- **原子操作与状态压缩**：使用位运算高效管理复合状态（如 `state` 字段）。
- **信号量调度**：通过 `sema` 实现阻塞队列，依赖 Go 调度器管理协程切换。

**应用场景建议：**

- **Mutex**：适用于临界区较小、竞争强度未知的场景。
- **RWMutex**：适合读多写少，且读操作耗时的场景（如配置读取）。

通过上述机制，Golang 的锁实现在高并发下兼顾性能与公平性，为开发者提供了简洁高效的同步原语。
