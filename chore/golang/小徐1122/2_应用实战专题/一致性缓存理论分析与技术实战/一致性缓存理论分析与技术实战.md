# 一致性缓存理论分析与技术实战

缓存（如 redis）和数据库（如 mysql）是两个独立的存储组件，在操作过程中无法在跨组件的基础上保证“事务”  的语义，因此不可避免地会面临缓存数据与数据库数据不一致的问题.我们把上述问题称为  “`缓存一致性`”问题，本篇将紧密围绕该问题，针对设计缓存与数据库的读、写流程进行串联梳理，总结出能够兼顾数据一致性与操作性能的执行方法论.

- 跨组件间的数据一致性问题属于`分布式事务的范畴，本身有一套解决的方案，但受限于其高昂的实现成本，因此不适用于绝大多数场景`
  我们更多将注意力集中在，`如何针对数据的读写流程进行秩序地组织串联，以此来满足 cache 和 db 间数据的最终一致性`，并尽可能追求即时一致性的语义.

---

对于缓存一致性问题，工业界没有唯一的“银弹”，而是根据业务场景对**一致性要求**、**性能**和**系统复杂度**三者进行权衡后，选择最适合的方案。

以下是目前被广泛认可和采用的工业级最佳实践，按推荐程度和复杂度排序：

### 1. 核心指导思想：删除缓存，而非更新缓存

绝大多数场景下，写操作应遵循 **“删除缓存，而非更新缓存”** 的原则。

- **原因 1 (懒加载)**：更新缓存可能写入一个从不被读取的“冷”数据，浪费资源。而删除缓存后，由下一次读请求将最新数据加载到缓存中，确保了只有热点数据才会进入缓存。
- **原因 2 (避免并发问题)**：如果多个写操作并发更新缓存，顺序无法保证，可能导致缓存中是旧版本数据。而`“删除”操作是幂等的`，多次删除结果一致。

### 2. 主流实践方案：先更新数据库，再删除缓存 (Cache-Aside Pattern)

这是**最经典、最常用**的方案，适用于绝大多数对一致性要求不是极端严苛的场景。

**流程**：

1.  **写请求**：先更新数据库。
2.  **写请求**：成功更新数据库后，再删除缓存中的对应数据。
3.  **读请求**：
    - 先读缓存，如果命中，直接返回。
    - 如果未命中，则查询数据库，获取数据后**回写到缓存**，然后返回。

**优点**：

- 逻辑简单，易于实现。
- 能保证在没有并发或失败的情况下，数据最终是一致的。

**缺点与风险**：

- **风险 1：删除缓存失败**。如果第二步删除缓存失败，数据库是新的，缓存是旧的，数据将永久不一致。
- **风险 2：读写并发冲突**（理论上存在，但概率极低）。
  1.  线程 A 读取数据，发现缓存不存在。
  2.  线程 A 去查询数据库，得到旧值 `v1`。
  3.  此时线程 B 发起写请求，更新数据库为新值 `v2`，并成功删除缓存。
  4.  线程 A 将之前查到的旧值 `v1` 回写到缓存中。
  - **结果**：数据库是新值 `v2`，缓存是旧值 `v1`，数据不一致。
  - **为什么概率低**：这要求写操作（更新 DB+删缓存）的速度比读操作（查 DB）还要快，在现代系统中很少见。

### 3. 工业级优化方案：基于消息队列的最终一致性

为了解决“先更新 DB，再删缓存”方案中的删除失败问题，工业界引入消息队列（如 RabbitMQ, Kafka）来保证删除操作的可靠性。这是**保障最终一致性的黄金方案**。

**流程**：

1.  **写请求**：更新数据库。
2.  **写请求**：将需要删除的缓存 `key` 发送到一个消息队列（MQ）中。
3.  **消费端**：有一个独立的消费者服务，订阅该 MQ。
4.  **消费端**：从 MQ 中获取到 `key` 后，执行删除缓存的操作。

**优点**：

- **高可靠性**：写请求的业务逻辑与非核心的“删除缓存”操作解耦。即使缓存服务暂时宕机，或网络抖动导致删除失败，MQ 的重试机制（ACK 机制）能确保删除操作最终会被成功执行。
- **高性能**：应用主流程无需等待删除缓存的结果，响应更快。

**缺点**：

- **系统复杂度增加**：需要引入并维护消息队列中间件。
- **一致性延迟**：从更新数据库到删除缓存之间存在时间延迟（取决于 MQ 的效率），在这个窗口期内，读请求可能会读到旧数据。

### 4. 极端一致性要求：订阅数据库变更日志 (Canal)

对于金融、交易等对数据一致性要求极高的场景，可以采用订阅数据库 `binlog` 的方式。

**流程**：

1.  **写请求**：只管更新数据库。
2.  **中间件 (如 Canal)**：模拟成一个 MySQL 的从库，订阅并解析主库的 `binlog`。
3.  **Canal**：当监听到指定表的数据发生变更时，将变更信息推送给消息队列或直接调用应用服务。
4.  **应用服务**：接收到变更通知后，精确地删除或更新缓存。

**优点**：

- **强一致性保障**：数据源头是数据库，完全消除了应用层面操作缓存可能带来的不一致问题。
- **业务代码解耦**：业务代码完全无需关心缓存的维护逻辑，只需操作数据库。

**缺点**：

- **架构最复杂**：需要部署和维护 Canal 等额外的中间件，技术门槛高。
- **运维成本高**。

### 总结：工业最佳实践是什么？

**没有唯一的最佳实践，只有最适合你业务场景的实践。**

- **90% 的场景**：采用 **“先更新数据库，再删除缓存”**，并为删除操作加上**失败重试**机制（例如，简单的 `for` 循环重试几次）。这足以应对绝大多数情况。

- **对可靠性要求高的场景**：采用 **“更新数据库 + 消息队列异步删除缓存”** 的方案。这是性能、可靠性和复杂度的最佳平衡点，也是大型互联网公司的标准做法。

- **对一致性要求极高的场景**：采用 **“订阅 `binlog` (Canal) + 异步处理缓存”** 的方案。

**不推荐的方案**：

- **延时双删** (`先删缓存 -> 更新DB -> sleep -> 再删缓存`)：`sleep` 时间难以确定，且在并发下依然存在问题，是一种“看起来很美”但实践中问题很多的方案。
- **更新 DB 后更新缓存**：有并发安全问题和懒加载问题，应尽量避免。
