https://github.com/xiaoxuxiansheng/xtimer
https://mp.weixin.qq.com/s/gfiAm4NrcY_PaRNrQ1P2vw
分布式定时器

xTimer 基于协程池实现，仅依赖于 mysql 和 redis，用户准备好 mysql、redis，配置好鉴权信息和关系性数据表后可做到开箱即用

## xTimer 对标 workflow.timer 的异同：

相同点：

• xTimer 和 workflow.timer 均采用`去中心化`架构，系统整体根据职责边界，
拆分为 `调度器 scheduler、触发器 trigger、执行器 executor` 三个模块，
各模块各司其职，相互配合串联起整个调度流程.

## 核心思路

1. 主动轮询
   一句话总结：实现定时器最简单粗暴的方式：轮询 + 触发.
   • 注册定时器：解析并将一系列定时任务平铺直叙地展开，每笔定时任务明确展示执行时间这一指标
   • 节点自轮询：每间隔一个微小的时间范围，对定时任务列表进行全量查询
   • 过滤&触发：以 执行时间小于等于当前时刻 作为过滤条件，摘出满足执行条件的定时任务进行执行.
2. 优化
   - 有序容器优化 popmin 操作：redis zset
   - 通过时间范围分片，减少查询涉及的任务数量：在 xTimer 的实现中，选用 1 分钟作为分片的时间范围
   - 通过定时任务分桶，提高并发度：集群模式，保证每个时间范围内能有对应于分桶数量的 goroutine 并发参加工作
     分桶数量自适应
3. 服务架构总览

   - 总架构
     - 定时任务调度流程
       服务架构: `3 个模块 + 2 个协程池.`
       xTimer 是一个去中心化体系的定时任务调度框架，根据职责边界，将服务拆分为调度器模块（Scheduler module）、触发器模块（Trigger module）和执行器模块（Executor module）三个模块，`各模块之间存在依赖关系`，`父模块通过协程池的方式异步启动子模块进行工作`：
     - 定时任务创建流程
       定时任务创建与 `webServer 和 migrator 2 个模块有关`
       xTimer 提供了 webServer 模块，面向用户提供 api 用于定时器的创建；用户激活定时器后，会根据定时器 cron 表达式批量创建定时任务，用于执行；
       此外，迁移器模块（migrator module）会`定期将 db 中的定时任务提前加载的 redis 中`，采用 zset 有序表进行组织，供触发器模块轮询触发.

4. 定时任务调度

- **调度器模块**
  负责二维分片`(分时+分桶)`的全局统筹分配.
  调度器的作用就是负责在分布式场景中，将一系列二维分片资源进行统筹分配，`最终保证一个分片会由一个单独的触发器角色进行负责`，既不能被遗漏，也不能被重复执行.

  xTimer 的实现中，调度器模块核心流程如下：

  • 基于 time ticker 每隔 1s 进行主动轮询，基于当前时刻推算出对应的分钟级时间范围表达式；
  • 读取配置获得最大桶数的信息，基于时间范围拼接桶号，获得当前需要关心的一系列二维分片的 key；
  • 尝试抢占对应于每一个二维分片的分布式锁，并将锁的过期时间设置为一个小于分片时间范围的值；
  • `抢锁成功，则从协程池中取出一个协程调度一个触发器进行作业`；

- **触发器模块**
  按时唤醒二维分片内的定时任务.
  • 将达到执行条件的定时任务取出，`不断从协程池中取出对应于任务数量的协程`，在协程中启用执行器模块，用于执行定时任务.
  • 当触发器协程完成任务后，会将该分片对应的分布式锁的过期时间更新为一个大于分片时间范围的值.

  At least Once:
  综上可见，在调度器模块中，只能保证到 at least once 的语义. 这是因为实际上`没有手段能实现百分之百的分布式事务，即无法保证 （1）触发器完成时间分片作业 + （2）延长分布式锁过期时间 这两个动作整体具有原子性`.
  一种常见的场景是，`触发器在分片对应时间范围内轮询时出现宕机，导致一部分任务完成，另遗留少量任务未执行`. 此时由于触发器不会更新分布式锁的过期时间，导致锁会被其他调度器协程抢占，最终启动新的触发器重复执行分片，从而导致部分任务重复.
  这个重复问题会留到后续`执行器模块进行兜底处理`,但至少在调度器和触发器模块的范围内,需要明白,`目前这样的处理方式只能做到 at least once,而非 exactly once.`

- **执行器模块**
  真正执行定时任务.
  • 执行器由触发器异步启动，一个执行器协程对应于一个定时任务
  • 执行器首先对定时任务进行`幂等去重`，具体在下文中展开
  • 根据消息中的定时器 id，查询到定时器的完整信息
  • 执行定时任务
  • 在 bloomFilter 中进行定时任务记录的打点
  • 更新 mysql 定时任务执行记录的状态为已执行

  幂等去重
  （1）在执行器模块的视角中，对于二维分片的概念是无感知的，接收到的每一笔定时任务可以通过其`定时器 id 和执行时间戳`拼接出一个全局唯一的标识 id，简称为 定时任务 id；
  （2）每个执行器协程在执行定时任务前，`以定时任务 id 为 key，通过 bloomFilter(依赖 redis 组件) 进行第一轮查重，由于 bloomFilter 机制，假如未命中，则一定能保证定时任务未重复，可以继续往下执行；假如命中，由于其存在一定的失误率，需要进入步骤（3）复核`；
  （3）基于定时任务 id 检索 mysql 中的定时任务执行记录表，准确查询出定时任务是否属于重复执行，若已重复则停止执行.

  事实上，在分布式场景中，exactly once 的语义永远无法完美触达，我们只能尝试通过各种手段进行补偿和兜底，尽可能降低出现错误的概率以及发生错误所带来的损失.

5. 定时任务创建

- **migrator**

  - 解决的问题：redis 重度依赖问题:

    - 使用 redis 作为数据库的数据可靠性问题
    - 定时任务无论执行时间远近均添加到 Redis 中，可能导致缓存迟迟得不到释放

  - 三级存储模型 + 迁移器模块
    因此，xTimer 中基于 `mysql 数据库 + redis 缓存 + 节点内存` 建立三级存储模型，并增设一个迁移器模块（migrator module）根据任务执行时机由远及近进行存储介质之间的迁移`同步`.
  - 数据一致性问题
    同一份数据可能分别位于 mysql 和节点内存中，如何保证数据一致性？
    定时器定义数据会发生变更的内容只有定时器状态（激活<->未激活）.可以通过和用户方约定，保证当调整定时器状态时，可能存在一定滞后，但承诺状态最晚会在一个二级时间步的时长内完成同步，来规避这一问题.

- **webServer**
  xTimer 中提供 webServer 模块，提供了一组 restful api 用于支持用户对定时器的 crud 操作.
