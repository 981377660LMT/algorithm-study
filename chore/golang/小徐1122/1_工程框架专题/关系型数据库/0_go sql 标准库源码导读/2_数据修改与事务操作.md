### 详细总结：在 Go 中修改数据与使用事务

#### 1. **修改数据的语句**

- **使用 `Exec()` 方法**：  
  对于不返回数据行的操作（如 `INSERT`, `UPDATE`, `DELETE`），应优先通过预编译语句调用 `Exec()` 方法。示例流程：

  ```go
  stmt, err := db.Prepare("INSERT INTO users(name) VALUES(?)")
  res, err := stmt.Exec("Dolly")
  lastId, _ := res.LastInsertId()    // 获取最后插入的 ID
  rowCnt, _ := res.RowsAffected()    // 获取受影响的行数
  ```

  通过 `sql.Result` 对象可访问操作元数据。

- **避免错误使用 `Query()`**：  
  执行写操作时，禁止使用 `db.Query()`（如 `db.Query("DELETE ...")`），因为它会返回 `sql.Rows` 并占用数据库连接，直到显式关闭。这可能导致连接泄漏和资源耗尽。

---

#### 2. **事务处理（Transactions）**

- **事务对象 `Tx`**：  
  事务通过 `db.Begin()` 创建，生成 `Tx` 对象。所有事务内操作需基于 `Tx` 的方法（如 `tx.Exec()`），而非直接调用 `db` 的方法，以确保操作在同一个连接上执行。

  ```go
  tx, err := db.Begin()
  res, err := tx.Exec("UPDATE ...")
  err := tx.Commit()  // 或 tx.Rollback()
  ```

- **关键注意事项**：
  - **禁止混用事务与 SQL 语句**：  
    不要在代码中混合使用 `Tx` 的方法（如 `Commit()`）和原生 SQL 事务语句（如 `COMMIT`），否则可能导致连接未释放、状态不一致等问题。
  - **事务内的预编译语句**：  
    事务中创建的预编译语句（`Stmt`）仅绑定到该事务，无法在事务外使用。
  - **非事务场景下的 `Tx` 使用**：  
    即使无需事务，若需在单连接上执行操作（如创建临时表、设置会话变量、修改连接参数等），仍需使用 `Tx` 来绑定连接。

---

#### 3. **资源管理与连接安全**

- **连接释放**：  
  `Tx` 对象在事务结束后需明确调用 `Commit()` 或 `Rollback()` 以释放连接。未释放的连接会导致连接池资源耗尽。
- **避免跨事务操作**：  
  在事务中，所有数据库操作必须通过 `Tx` 对象执行。直接调用 `db.Exec()` 会绕过事务，使用其他连接，破坏事务原子性。

---

#### 4. **典型应用场景**

- **必须使用事务的情况**：
  1. 需要保证多个操作的原子性（如转账操作）。
  2. 执行影响连接状态的操作（如 MySQL 的 `SET @var` 或修改字符集）。
  3. 创建会话级临时对象（如临时表）。

---

#### 5. **错误处理与最佳实践**

- **始终检查错误**：  
  对 `db.Begin()`, `tx.Exec()`, `tx.Commit()` 等操作进行错误检查，确保及时回滚。
- **使用 `defer` 清理资源**：  
  在事务开始后，使用 `defer tx.Rollback()` 确保异常时回滚。若事务提交成功，`Rollback()` 会无操作。
  ```go
  tx, err := db.Begin()
  defer tx.Rollback()
  // ... 事务操作 ...
  err = tx.Commit()
  ```

---

### 关键总结

- **写操作**：用 `Exec()`，禁止 `Query()`。
- **事务管理**：通过 `Tx` 对象操作，确保连接一致性。
- **资源释放**：显式提交或回滚事务，避免连接泄漏。
- **特殊操作**：即使无事务需求，单连接绑定需通过 `Tx` 实现。

正确使用这些机制能有效提升数据库操作的效率和安全性，避免资源泄漏与状态不一致问题。
