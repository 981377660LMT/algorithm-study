下面是一份对 **MIT 6.897: Advanced Data Structures (Spring 2012) Lecture 10** (_Hashing_) 的**详细讲解与总结**。本讲重点讨论了**哈希（Hashing）**的相关概念和若干经典数据结构，包括：

1. **各种哈希函数及其性质**：从完全随机（totally random）、不同级别的独立性（k-wise independence）、简单可并行（simple tabulation），到如何在实际中做乘法或取模等实现。
2. **几种哈希表设计**：如基本的拉链法（Chaining）、完美哈希（Perfect Hashing，FKS 法）、线性探测（Linear Probing）、以及新的布谷鸟哈希（Cuckoo Hashing）。

以下我们依次展开。

---

## 1. 哈希函数 (Hash Function)

### 1.1 目标与背景

在哈希表的世界里，我们有一个**潜在宇宙**（universe）大小为 \(u\) 的键集合。希望将其中的 \(n\) 个键高效地映射到表大小 \(m\) 的槽（slot）上，达到快速插入、查询等操作。这需要设计一个好的 **hash function** \(h\colon U \to \{0,\dots,m-1\}\)，并关注其在查询或插入时冲突的情况。

### 1.2 完全随机（Totally Random）哈希

- 定义：对每个键 \(x\)，**独立均匀地**映射到 \(\{0,\dots,m-1\}\) 之中，\(\Pr[h(x)=t] = 1/m\)。
- 问题：要在计算机上真正存储一个**完全随机**哈希函数，需要为宇宙中每个键都存储随机值，需 \(u \log m\) 位，非常大。

因此在实践中，我们常用更“可构造”的哈希函数家族，如**可逆散列**、多项式散列、乘法散列等，在**空间**和**独立性**间做折中。

### 1.3 普遍哈希（Universal Hashing）

- **Universal family**：\(\{h\}\) 若对任何两个不同键 \(x \neq y\)，\(\Pr[h(x)=h(y)] \le c/m\)，则称此家族是 (c-)universal。最常见的是 \(h_a(x)=((a \cdot x) \mod p)\mod m\)。
- 仍只需存储常数个参数（如 \(a\),\(p\)）。
- 有时也说**强普遍性**(strong universal)，二者相似。

### 1.4 k-独立 (k-wise independence)

- **定义**：哈希函数家族 \(H\) 称为 k-独立，若对任意 k 个不同键 \((x_1,\dots,x_k)\)，其哈希值 \((h(x_1),\dots,h(x_k))\) 在 \(\{0,\dots,m-1\}^k\) 中均匀分布。
- 例如，**多项式哈希**：\(h(x) = (a*0 + a_1 x + \dots + a*{k-1} x^{k-1}) \bmod p \bmod m\) 可以实现 k-独立。
- k-独立越大，碰撞概率越低，能在某些场景提供更好性能或更严格的期望/概率界。

### 1.5 简单表哈希 (Simple Tabulation)

- **思想**：将键 (word) 拆成若干字节 (c 字节)，为每个字节分配一个随机表 \(T_i\)，对字节的值进行查表，然后 XOR 合并：  
  \[
  h(x_1,\dots,x_c) = T_1[x_1] \oplus \dots \oplus T_c[x_c].
  \]
- 存储规模约 \(c \cdot u^{1/c}\)，计算时间 \(O(c)\)。
- 已知它能提供 3-wise 独立，并且在实践中往往速度极快、碰撞概率小，甚至可以达到很多 k-独立哈希才能实现的效果（参见后续文献 [11]）。

---

## 2. 基本拉链 (Chaining)

### 2.1 基本思路

把键 \(x\) 放在数组槽 \(h(x)\) 对应的一条链表里；查询时在该链表上顺序查找。若 \(\alpha=n/m\) 是装填因子，若哈希“足够好”，则链长在期望上约为 \(\alpha\)。

### 2.2 期望和方差

- **期望**：\(\mathbb{E}[|chain(h(x))|]=O(\alpha)\)。常常令 \(m=O(n)\)，故期望链长常数。
- **方差**：也可分析得知通常链长方差不大。因此**期望**时间好，但**最坏情况**却可能很大。

### 2.3 高概率分析

- 对于**完全随机**或足够 k-独立的哈希，可用 Chernoff bound 得到\(\Pr[\text{链长} > c \log n / \log \log n]\) 很小。但仍有可能出现极长链。
- 若加上**缓存** (caching) 改进，每当访问到一个长链，就把它缓存起来可减少后续访问开销，从而在摊还意义下得到较好性能。

---

## 3. 完美哈希 (Perfect Hashing)

### 3.1 静态 (FKS) 哈希

**FKS** (Fredman, Komlós, Szemerédi) 提供了**静态字典**在 \(O(1)\) **最坏情况**查找，且只用 \(O(n)\) 期望空间，构建时间 \(O(n)\)。

- 先用一个**顶层哈希**\(h\)把 \(n\) 个键分到 \(m\approx n\) 个槽，每个槽是一组冲突的键（链表）。
- 对每个槽内键再用**完美哈希**构建一个小表（大小约为冲突数平方 \(\approx C_t^2\)），保证无冲突。构建时随机尝试直到无冲突出现。
- 期望空间分析：\(\sum C_t^2 \approx n\).
- 查询：先算顶层 \(h(x)\)，再在对应的小表用二级哈希查看。

### 3.2 动态扩展 (DFK...)

可扩展成**动态**场景：若槽冲突增多时，可重构二级表；发生概率较小，最终可证明摊还 O(1) 更新、最坏 O(1) 查询。

---

## 4. 线性探测 (Linear Probing)

### 4.1 算法

若插入时槽 \(h(x)\) 已占，用 \((h(x)+1)\% m\),(h(x)+2)\% m,\dots\) 线性往后探测空位。查询也需类似探测直到碰到空槽或找到键。优点在于**相邻**槽会一起访问，利用缓存局部性。

### 4.2 效率与独立性

- 对**完全随机**哈希，可得**期望 O(1)**，若装载因子低于常数(1-\(\epsilon\))。
- 后续研究 [9][10] 表明：必须至少 5-wise 独立才能保证线性探测在期望 O(1)；4-wise 或更少独立性不够，会产生 \(\Omega(\log n)\) 情形。
- **简单表哈希 (simple tabulation)** 已被证明也能支持线性探测达期望 O(1/\(\epsilon^2\)) 性能，和完美随机哈希类似。

---

## 5. 布谷鸟哈希 (Cuckoo Hashing)

### 5.1 思路

由 Pagh 和 Rodler 提出 [16]，结合双哈希的想法，每个键有两个备选槽：\(T_1[f(x)]\) 或 \(T_2[g(x)]\)。若插入时冲突，就把原有键“踢走”(cuckoo)到它的另一个槽，可能造成连锁反应，但期望会很快结束。若碰到极端长的连锁，就选新哈希函数并重哈希。

### 5.2 性能

- **查询**：只需检查两个槽，O(1) **最坏情况**。
- **删除**：同样 O(1) 最坏情况。
- **插入**：若发生连续踢出，期望也在 O(1)，极少数情况要重哈希。
- 在负载因子 \(\alpha<0.5\) 左右可长久稳定运行。空间 \(\approx(2+\epsilon)n\) 槽。

### 5.3 哈希独立度需求

- 对**完全随机**哈希，可得 O(1) 均摊更新，O(1) worst-case 查询；rebuild 失败概率很低。
- 若只有 k-独立，小 k(≤4,5) 不足以保证 cuckoo hashing 期望 O(1) 成功构造或更新，需要更高独立度或简单表哈希能得到相似好效果但有更高失败率 [11]。

---

## 6. 小结

本讲介绍了多种**哈希函数与哈希表**组合，包括：

1. **哈希函数家族**
   - **完全随机**（理论上好，实现代价高）
   - **(c)universal**、**k-wise 独立**、**simple tabulation**等
2. **哈希表数据结构**
   - **Chaining**：期望 O(1) 查找，最坏有长链。高独立度可使链长 w.h.p. 较短。
   - **FKS 完美哈希**：静态场景 O(1) worst-case 查询，O(n) 期望空间+构造。
   - **Linear Probing**：有缓存优势，需 5-wise 独立或 simple tabulation 才达期望 O(1)；若独立性不足可有 \(\Omega(\log n)\) 均摊。
   - **Cuckoo Hashing**：2 个槽位置，查询最坏 O(1)、插入均摊 O(1)、空间 \((1+\epsilon)n\)~\(2n\)，受哈希独立性要求影响。

这些结果给了我们理论与实践间的灵活选择：若能接受极端情况 + 期望分析，则 2,3-独立加 chaining/linear-probing 常常很好；若需最坏界，多采用**完美哈希**或**布谷鸟哈希**；若要更优的实际性能，**simple tabulation**往往是业界推荐的一种折中实现。
