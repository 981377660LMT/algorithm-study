下面是一份对 **MIT 6.851: Advanced Data Structures (Spring 2012) Lecture 16** (_String Data Structures_) 的**详细讲解与总结**。本讲的主要内容是如何在有可能多次查询的场景下，针对一个文本（或多个文本）构建可支持高效字串查询的数据结构。讲座首先从“字符串前驱问题”入手，介绍了字典树（Trie）的多种实现方式，然后讨论了后缀树（Suffix Tree）及其应用，最后介绍了更紧凑的后缀数组（Suffix Array）及构建算法（DC3）。以下按照讲座脉络逐一展开。

---

## 1. 字符串前驱问题（String Predecessor Problem）

考虑有一批字串 \(T_1, T_2, \dots, T_k\)，我们想要构造一个数据结构，以支持给定一个模式串 \(P\)，**找出其在这 \(k\) 个字串中的前驱**（即在字典序下比 \(P\) 小的最大字符串）。

### 1.1 Trie 与压缩Trie

- **Trie**：一种将若干字符串集进行前缀共享的树结构。

  - 每条从根到节点的路径代表一个前缀；叶子则代表完整单词；
  - 孩子根据字符排序，前驱可通过**下落并在分支内找紧邻较小分支**的最大字串。

- **压缩Trie**：对单分支路径进行合并，使得每条边可包含多个字符（substring），从而减少节点数量。
  - 枝节点即产生分支的地方或叶子；
  - 同样支持在树中根据查询串下落来比较。

### 1.2 实现节点

对每个 Trie 节点，存储其子分支。若字符集 \(\Sigma\) 很大，则按以下方式实现：

1. **数组**：每节点用大小 \(|\Sigma|\) 的数组，快速查询 O(1)，但空间 O(|T||\Sigma|)。
2. **BST** / **平衡树**：可在 O(\log|\Sigma|) 时间比较并遍历，空间 O(|T|)。
3. **Hash**：能做精确匹配 O(1)，但前驱查找麻烦，不支持 predecessor。
4. **van Emde Boas**：可在 O(\log\log|\Sigma|) 做 predecessor。
5. **Weight Balanced BST**：把子分支按子树叶数做平衡，可保证在下落时每“走一条边”，要么前进 1 字符，要么减少 1/3 候选分支。查询 O(|P| + \log k)。[详细见讲义的分析。]

为得到 O(|P| + \log|\Sigma|) 或更好，需要**分层**（macro/micro tree）及“leaf trimming”等策略，参考 L15 方式。这样可实现 O(|T|) 空间和 O(|P| + \log|\Sigma|) 查询。

---

## 2. 后缀树（Suffix Tree）

### 2.1 定义和构造

- 给定文本 \(T\)，在末尾加终止符 `$\in\Sigma` 并生成全部后缀 \(T[i:]\)，把这些后缀放到一个**压缩Trie**。得到的结构称为**后缀树** (Suffix Tree)。
- 每个节点、每条边也可用“起止索引”表示，节省存储空间到 O(|T|)。
- 构造后缀树的经典算法有 McCreight / Ukkonen / Weiner 等，时间可达线性 O(|T|)。

### 2.2 应用

1. **字串匹配**：给定模式 \(P\)，下落后缀树走边比较即可，若匹配成功到某节点，则输出其子树下所有叶子；最坏时 O(|P|) + 匹配到所有出现位置。
2. **找前 k 次出现**：只需在每节点留指向最左叶子以及把叶子链接成链表 => 前 k 次出现可在 O(k) 找到。
3. **计数出现次数**：存每节点子树叶子数 => O(1)可算某模式出现次数。
4. **Longest Repeated Substring**：找最大letter-depth的分支节点。
5. **Longest Common Substring (多文档)**：将多个文档拼接并用不同终止符 `$1, $2, ...`，找“含至少2个不同 `$i`”的分支节点中 letter-depth 最大者。
6. **在线欧几里得距离**：更多场景类似。

---

## 3. 后缀数组（Suffix Array）

### 3.1 定义与构造

**后缀数组**是一种更紧凑的后缀树替代：

- 列出文本所有后缀并排，按字典序排序；
- 后缀数组存的是“排好序的后缀起始索引”；
- 可附加 LCP（Longest Common Prefix）数组存相邻后缀的公共前缀长度 => 这与后缀树的节点信息有直接对应。

![](https://fakeimg.pl/500x200/?text=SuffixArrayDiagram)

### 3.2 后缀数组与后缀树等价

- 从**后缀树**到**后缀数组**：对树中叶子做**中序遍历** => 得到有序的后缀列表 => Suffix Array；
- 从**后缀数组**到**后缀树**：用 LCP 数组建**Cartesian Tree**（类似L15构造），再结合后缀数组本身可恢复树结构。

### 3.3 线性构造算法 DC3

**DC3** (Difference Cover 3) 算法 ([Kärkkäinen-Sanders-Burkhardt 2003]) 能在 O(n) 构造后缀数组(附加条件: sort alphabet cost, often linear)：

1. 将文本分割成三部分 T0, T1, T2；
2. 先递归处理 T0+T1 => suffix array (规模 ~ 2n/3)；
3. 用**基于T0+T1排序**结果快速对 T2 suffix 做基数排序；
4. 再把三路merge起来，对 suffix 比较可在 O(1) 完成。  
   由此可得 T(n)=T(2n/3)+ O(n) => O(n) 总时间。

因此可以在 O(n) 内构造后缀数组 => 也就能在 O(n) 内构造后缀树(利用 LCP+后缀数组+Cartesian Tree 方法)。

---

## 4. 总结

本讲主要内容概括：

1. **字符串前驱**数据结构：以**Trie**（或压缩 Trie）来组织多个字符串，查询时下落树分支找到前驱；具体节点实现（如 Weight Balanced BST）保证 O(|P| + \log k) 或 O(|P| + \log|\Sigma|) 时间并保持 O(|T|) 空间，需进一步“leaf trimming / macro-micro”策略等。

2. **后缀树** (Suffix Tree)：在文本末加 `$`，收录全部后缀到压缩 trie 得到。它适用于各种字符串匹配、计数、公共子串等应用，在 O(|T|) 空间（最优构造方法）和高效查询。

3. **后缀数组** (Suffix Array)：相比后缀树更紧凑，同时可附带 LCP 数组。两个结构彼此可在线性时间内相互转换。通过**DC3**算法可 O(n) 构造后缀数组（从而 O(n) 构造后缀树）。

借助这些数据结构和技巧，我们能在**多次查询**场景中以预处理 \(\approx O(n)\) + 查询 \(\approx O(|P|)\) 提供快速字串匹配，远优于单次匹配算法 (KMP, BM, RK) 当需要处理很多查询时。同时后缀数组/后缀树在其他文本算法场景下也有广泛应用。

**后续阅读**：

- KMP [6], Boyer-Moore [1], Rabin-Karp [4] 解决单次匹配；
- Suffix Arrays 构造: DC3 [3]、SA-IS 等其他近线性/线性时间算法；
- Suffix Trees 构造: Ukkonen、McCreight、Weiner 等线性算法；
- Suffix Automaton、LCP, RMQ, LCA 深度等是下一阶段延伸。

(完)
