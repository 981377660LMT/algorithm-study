# Back to the Future: Retroactive Data Structures

下面是一份对 **MIT 6.851: Advanced Data Structures (Spring 2012) Lecture 2**（Retroactive Data Structures）内容的**详细讲解和梳理**。本次课程的主题是**回溯（Retroactive）数据结构**，以及它和上一讲介绍的**持久化（Persistent）数据结构**的区别与联系。以下内容按照讲义顺序，逐段展开关键概念、思路和结果。

---

## 1. 背景与概览

在第一讲中，我们讨论了**持久化数据结构（Persistent DS）**：如果在过去进行修改，通常会“分叉”出一个全新的版本（“新的宇宙”），而原版本保持不变。这样，任何对旧版本状态的查询，或在旧版本上继续的更新都不会影响目前的时间线。

本讲介绍的**回溯数据结构（Retroactive DS）**则更像科幻中“回到过去”并**改变了现在这条时间线**上的状态与结果。也就是说：

- 我们可以把一次更新“插入”到过去的某个时间点；
- 这次更新会对之后（包括当前）的数据结构状态产生影响；
- 若过去的改变会导致中间某些结果不同，则需要“顺着时间线”对后续变化进行相应调整。

相应地，这就需要一套新的框架来支持“在过去插入/删除操作，或在过去某时刻做查询”的功能。

---

## 2. 回溯（Retroactive）数据结构的定义

### 2.1 操作与表示

在传统的数据结构中，我们的操作往往是“在当前时刻”插入/删除/查询，然后时间向后走。然而在回溯数据结构中，我们允许在**过去**的时间点执行操作。为此，我们定义以下操作（其中大写 `Insert`, `Delete`, `Query` 表示“对回溯数据结构本身”的操作，小写操作表示“对原本DS”的实际更新或查询）：

1. **Insert(t, update)**

   - 在时间 \( t \)（过去或现在）插入一条“update”操作，这个 `update` 可以是“插入某元素”、“删除某元素”等。
   - 这会改变从时间 \( t \) 之后的所有DS状态。

2. **Delete(t)**

   - 删除在时间 \( t \) 处曾经插入过的一条操作。
   - 同样会影响从时间 \( t \) 之后的DS状态。

3. **Query(t, query)**
   - 在时间 \( t \) 上执行一次查询 `query`，返回当时的数据结构状态。

在实现时，为方便在任意时间点插入操作，可以使用**order-maintenance**（与第一讲类似）来维护时间顺序，而不是简单的整数时刻。当要插入一个介于 \( t \) 和 \( t+1 \) 之间的操作时，可以使用该数据结构高效地在时间线上插入新事件。

### 2.2 三种类型的回溯

1. **部分回溯（Partial Retroactivity）**

   - 我们只能在过去插入/删除操作，但**只能在现在（\( t=\infty \)）**做查询。
   - 即：过去的修改最终如何影响“现在”的数据结构？并不需要查询中间时刻。

2. **完全回溯（Full Retroactivity）**

   - 既能在过去插入/删除操作，也能在任意时刻（包括过去）进行查询。
   - 这比部分回溯更强大，也更复杂。

3. **非遗忘回溯（Nonoblivious Retroactivity）**
   - 除了可以回溯插入/删除操作和在任意时刻进行查询，还要求当我们更改过去后，能知道**将来哪些查询结果发生变化**。
   - 实际应用中，往往“后面的操作”依赖于前面某些查询结果（例如算法逻辑），如果过去被改写，就可能要连带修改后续整个逻辑流程，需要知道“第一个出错的查询”在哪里。

---

## 3. 便于回溯的特殊情况：可交换性与可逆性

在一些特殊场景下，如果数据结构的更新操作**可交换（commutative）**并且**可逆（invertible）**，那么回溯就会容易实现。

- **可交换**：如果操作 \(x\) 和 \(y\) 的执行次序无关（\( x \circ y = y \circ x \)），则在时间线上重新插入并不会影响最终结果。
- **可逆**：若对操作 \(x\) 存在反操作 \(x^{-1}\) 满足 \(x \circ x^{-1} = \emptyset\)（可视为“撤销”），那么在时间点 \(t\) 删除某操作，就等效于在现在插入它的反操作。

**部分回溯**在可交换并可逆的场景（如某些“仅累加的哈希表”、或“数组元素只做 += 操作”）可以很容易地实现。因为把插入操作挪到过去不会影响与其并行的其他操作的效果顺序，撤销也方便。

---

## 4. 完全回溯（Full Retroactivity）

在完全回溯中，我们可以对过去任意时刻做插入/删除，也能查询过去或现在的状态。这类需求更强，难度也更大。

### 4.1 可分解的搜索问题（Decomposable Search Problem）

给定一个动态搜索问题：维护一个集合 \(S\)，支持：

- 插入、删除
- 查询如 “是否包含某元素？最近邻是谁？” 等

若该搜索问题是**可分解（decomposable）**的，即对于任意拆分 \(A \cup B\)，查询结果满足：
\[
\text{query}(x, A \cup B) = f(\,\text{query}(x, A),\; \text{query}(x, B)\,),
\]
且合并函数 \(f\) 可以在 \(O(1)\) 时间内完成，那么可用**线段树**（Segment Tree）方式实现对时间的划分，从而达到在**完全回溯**下的 \(O(\log m)\) 因子开销（这里 \(m\) 是操作数）。

> 这个思路由 Bentley 和 Saxe 在 1980 年提出 [6]：
>
> - 时间轴上建一棵平衡的段树，每个节点对应一个时间区间；
> - 每个元素在其“生存的时间段”会被覆盖到若干个段树节点中，每层只出现一次；
> - 查询时，通过沿着时间对应到的叶子回溯各祖先节点来合并结果。

#### 示例

- **动态最近邻**、**动态一维 successor**、**动态点定位**等都属于可分解搜索，进而可以做完全回溯并在 \(O(\log m)\) 获得查询和更新的开销。

### 4.2 一般情况的下界：回滚法和多项式计算

对于更一般的动态问题，如果不具备上述可分解属性或更新不可交换，就难以高效地做完全回溯。讲义中给出一个**滚动（roll back）**的观点：将时间线上过去一段 \(r\) 的更新改动，需要 \(O(r)\) 级别开销。

- 从下界角度也有例子说明：若数据结构实现了一种多项式计算（形如多项式在不同 \(x\) 上的值），则在过去改一个初始条件就需要重新计算多项式，至少要 \(\Omega(n)\) 步。

### 4.3 Cell-probe 模型的下界

还提到 Frandsen 与 Miltersen 等关于**cell-probe**模型的下界 [5]，给出了 \(\Omega\bigl(q \frac{r}{\log r}\bigr)\) 的结果，或者在某些场景想达到 \(\Omega(r)\) 的下界则是尚未解决的开放问题。从中可以看到，对过去的修改往往意味着要重读内存中大量单元才能更新计算结果。

---

## 5. 回溯优先队列（Retroactive Priority Queue）

下面是更具体的一个例子：**优先队列（priority queue）**。支持的操作包括：

- `insert(key)`
- `delete-min()`
- （可选）`min()` 查询最小值

### 5.1 部分回溯优先队列

在部分回溯的需求下（只在现在查询，但可在过去插入或删除操作），Demaine、Iacono 和 Langerman 研究了该问题 [1][2]，可以在 **\(O(\log n)\)** 摊还开销内完成。

#### 可视化思路

用二维平面，横轴是时间 \(t\)，纵轴是 key 值。

- 每次 `insert(t, key)` 会从点 \((t,key)\) 向右画一条**水平射线**，直到它被某个后续时刻的 `delete-min()` 删除为止。
- `delete-min(t)` 可以想象为从 \((t, -\infty)\) 向上画一条**垂直射线**，停止在它删掉的那个“水平段”上，使之截断。

整个结构看起来就是一堆倒“L”形，表示元素何时插入、何时被删除（若它从未被删除则一直延伸到未来）。

**关键**：当我们在过去插入一个新的 `insert(t, k)` 时，这可能会“改写”后面时间里的那些 `delete-min()` 的删除对象，从而产生“连锁反应”。不过因为是**部分回溯**，我们只关心“此连锁反应后，最终在现在（\(t=\infty\)）还保留下来的元素是哪个？”。

- 最终会发现，能“活到最后”的元素只可能是：
  \[
  \max \{\,k_0 \mid k_0 \text{在时间 } \ge t \text{ 之后才被删，或者从未被删}\}.
  \]
  或者是插入的 \(k\) 本身（如果它能一直活到最后，且比之前的那些“被复活”的元素要大）。

#### “桥”概念（Bridge）简化

为了快速找到“那些可能被复活的元素”（过去插入、但在现在又“重新活”过来），引入了**桥（bridge）**的概念：

- “桥”时刻 \(t*0\) 定义为：从时间 \(t_0\) 的优先队列状态 \(Q*{t*0}\) 到最后 \(Q*{\infty}\)，其所有元素都保持在最终状态中。换句话说：\(Q*{t_0} \subseteq Q*{\infty}\)。
- 这样可以把时间轴划分成若干区间，每个区间起点是一个“桥”。当我们要在时间 \(t\) 插入一个新元素时，只需从它所在区间的桥时刻往后找出“最大可能被复活”的key即可，从而**避免遍历所有后续的连锁删除**。

通过在平衡树中维护一些额外信息（例如每个时刻的前缀和、在最终队列中的元素等），就能在 **\(O(\log n)\)** 时间内处理一次 “Insert(t, insert(k))” 或 “Delete(t, delete-min)” 等操作。细节见 [1][2]。

---

## 6. 其他数据结构的回溯结果

讲义提供了一个简表，列出了一些常见抽象数据类型在部分回溯与完全回溯时的已知时间复杂度结果：

| 数据结构 / ADT             | 部分回溯复杂度       | 完全回溯复杂度                   | 备注                                                   |
| -------------------------- | -------------------- | -------------------------------- | ------------------------------------------------------ |
| Queue（队列）              | \(O(1)\)             | \(O(\log m)\)                    |                                                        |
| Deque（双端队列）          | \(O(\log m)\)        | \(O(\log m)\)                    |                                                        |
| Union-Find（仅增量连通性） | \(O(\log m)\)        | \(O(\log m)\)                    |                                                        |
| Priority-Queue（优先队列） | \(O(\log m)\) (部分) | 有结果可到 polylog 级别          | 参考 [7] 的 Hierarchical Checkpointing 技术            |
| Successor（有序集找后继）  | \(O(\log m)\) (部分) | \(O(\log^2 m)\) 或 \(O(\log m)\) | 传统分段法是 \(O(\log^2 m)\)，[3] 优化到 \(O(\log m)\) |
| ...                        | ...                  | ...                              |                                                        |

其中提到：

- **完全回溯优先队列**：在 2015 年由 Demaine 等人 [7] 利用“分层检查点（Hierarchical Checkpointing）”给出了多对数时间（polylog）的实现（具体为 \(\tilde{O}(\log^2 n)\) 或更好）。
- **完全回溯的有序集（Successor）** 最初用 \(\log^2 m\) 的分段树实现，但后来 Giora & Kaplan [3] 用更先进的数据结构（包括**fractional cascading**、**van Emde Boas 树**等）将其降到 \(\mathbf{O}(\log m)\)。

---

## 7. 非遗忘回溯（Nonoblivious Retroactivity）

### 7.1 需求与动机

在一些算法场景中，不只是数据结构要在过去插入/删除，还需要知道“未来哪些查询结果会被影响”。尤其是在**算法的执行逻辑**中，如果一个查询结果发生了变化，后续的更新操作也会跟着不同。

Acar、Blelloch、Tangwongsan 等人提出了“非遗忘回溯（Nonoblivious Retroactivity）”的模型 [4]，让数据结构在收到回溯插入/删除后，能告诉我们：**“最早在哪个查询（按时间顺序）开始与原先结果不同”**，从而让算法有机会只从此处开始重新执行，避免整条时间线重跑。

### 7.2 在优先队列中的实现思路

对于优先队列，我们把**查询**操作也当作可以插入到时间线中的事件（例如 `min()` 查询出一个值）。当我们在过去插入/删除更新后，就可能导致某些后续 `min()` 的结果不再正确，称之为**“错误”**（error）。

- **“第一个”出错的查询**：指时间最早且在纵向最下方（可视化 2D 平面）的冲突点。因为我们假设在实际算法中，如果出现了第一个错误，立刻会修正，然后再继续往下执行新的操作，这样后续错误也许就不会发生。

在 2D 平面（时间 vs. key）中：

- “插入新的 insert” 可能引发**穿越（crossing error）**：新的水平线会与旧有的删除线、查询线等交叉；
- “删除一个 deletion” 或 “插入一个 deletion” 则可能让某些查询“悬空”（floating error）。
- 每次只要能找到**最左下的错误**，报告给算法，算法就可以立即“修补”（通过 Delete/Insert 相应操作），并在时间线继续向后。

要支持快速找出这些 crossing / floating error，可以类比“射线探测（ray shooting）”问题：

- 垂直向上/向下射线，或水平向右射线碰到哪些线段。
- 这与**完全回溯 successor**或**区间射线查询**在一些文献里是等价的，已有结果表明能在 \(O(\log m)\) 时间内进行**动态垂直/水平射线**查询 [3]。

因此，可以在 \(O(\log m)\) 时间内维护并找到第一个出错点，从而实现非遗忘回溯优先队列的相应需求。

---

## 8. 总结

1. **回溯数据结构**允许在过去插入或删除操作，从而改变后续状态；可分为**部分回溯**、**完全回溯**和**非遗忘回溯**三大类。
2. **部分回溯**只需在“现在”查询，常用数据结构（如队列、优先队列、并查集）往往能在 \(O(\log m)\) 或更优的时间内支持。
3. **完全回溯**则可在任意时刻做查询，若问题是**可分解搜索**类型，可用段树在 \(O(\log m)\) 时间内实现。但通用情况下会遇到较高下界。
4. **优先队列**的回溯是一个有代表性的示例，通过 2D 可视化（时间 vs. key）来理解“插入/删除/查询”引起的线段交错。其中部分回溯的实现可在 \(O(\log n)\) 完成，而完全回溯也有新的多对数级别方案。
5. **非遗忘回溯**更进一步，引入“查询”操作到时间线，并要求数据结构告诉我们“最早在哪条查询上出错”，从而让上层算法只需从那里往后修正。对优先队列，可利用**动态射线查询**技术在 \(O(\log m)\) 时间找到错误位置。

以上即是本讲（Lecture 2）关于回溯数据结构的主要内容与分析，涵盖了其定义、分类、可用技术、典型应用（优先队列）以及难点和下界结论，也介绍了非遗忘回溯及其在算法中的价值。可参考文献 [1]–[7] 获取更多细节。
