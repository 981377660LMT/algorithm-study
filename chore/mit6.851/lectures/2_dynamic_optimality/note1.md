以下是对 **MIT 6.851: Advanced Data Structures (Spring 2012) Lecture 5** (_Dynamic Optimality of BSTs_) 的**详细讲解与总结**。本讲围绕二叉搜索树（BST）的**动态最优性（Dynamic Optimality）**展开讨论，并引出了一些重要的 BST 性质与经典或新颖的结果。

---

## 1. 引言与背景

在此之前，我们已经熟悉了各种平衡搜索树（AVL、红黑树、Treap、Splay 等），它们都能保证**单次操作**在 \(O(\log n)\) 时间。然而，是否存在某种 BST 算法，能在一个给定的**搜索序列**上表现得比任意其他 BST 算法都好呢？或者至少能达到它们的常数因子近似？

### 1.1 动态最优性（Dynamic Optimality）

- 一棵 BST 的算法称为**动态最优（Dynamically Optimal）**，如果对于任何搜索序列 \(X = (x_1, x_2, \ldots, x_m)\)，此算法的总访问代价至多是**任意**离线最优 BST 算法的常数倍。
- “离线最优” 指的是：在看到整个搜索序列之后，可以预先设计一切旋转与访问顺序，以达到最小总访问代价的 BST。
- 问题：**是否存在**一个 BST 算法能够始终达到这个常数竞争比？这个问题仍然是一个著名的开放问题。

### 1.2 相关性质

在追求动态最优以前，我们先回顾一些典型的 BST 访问性能性质：

1. **Sequential Access Property**：当搜索序列是访问所有键的有序遍历 \((1,2,\dots,n)\) 时，算法能做到摊还 \(O(1)\) 每次访问。
2. **Dynamic Finger Property**：当两个相继访问的键 \(x*{k-1}, x_k\) 很接近时，访问 \(x_k\) 的时间应当与 \(|x_k - x*{k-1}|\) 成正比。
3. **Static Optimality / Entropy Bound**：若元素 \(k\) 出现频率为 \(p_k\)，算法的平均访问应符合 \(O(\sum p_k \log (1/p_k))\)，即信息论下界。
4. **Working Set Property**：若上次访问元素 \(x_i\) 到当前为止共访问了 \(t_i\) 个“不同的”元素，则访问 \(x_i\) 的时间是 \(O(\log t_i)\)。这能保证若某元素被频繁访问，访问代价会下降。
5. **Unified Property**：综合 Working Set 与 Dynamic Finger，以同时度量“空间接近”和“时间接近”对于访问代价的影响。

以上性质，都与 BST 的“自适应能力”或“自调整”相关。**Splay 树**就是一个经典自适应 BST，被猜想具备“动态最优”特性，但尚无完整证明。

---

## 2. BST 作为运算模型

Lecture 5 中，首先把 **BST** 本身当作一种**模型**来严格定义：

1. **数据结构限制**：树节点有 `(key, parent, left, right)`；子树键值有序（左 <= 根 <= 右）。
2. **基本操作（单位代价）**：
   - 沿着 `parent` / `left` / `right` 指针走一步
   - 对某节点做一次**旋转（rotate）**
3. **搜索操作**：`Search(x)`，必须从根出发，经若干指针走到值为 `x` 的节点并访问它。

我们只关注搜索（无插入删除），并假设每次搜索都能成功（即 `x` 在树中）。在此模型下，**访问代价**就是指我们走指针和执行旋转的总次数。

### 2.1 我们能否做得比 O(log n) 更好？

- 在**最坏情形**中，BST 深度必然是 \(\Omega(\log n)\)，所以 O(\log n) 无法被打破。
- 但若我们考虑**访问序列**，有些可能出现大量重复查询或访问相近元素，从而可以明显快于 \(\log n\) 摊还；这就需要自适应地调整树，让热点元素更快被访问。
- 最好的例子：若访问序列重复访问同一个 key \(X\)，则只要 \(X\) 在根处，每次查询都是 \(O(1)\)。静态平衡树做不到一次就将 \(X\) 调到根；但自适应算法可以快速把最近访问的元素旋转到根。

---

## 3. 动态最优性与候选算法

### 3.1 动态最优性定义

一棵 BST 算法是**动态最优**的，若对任意搜索序列 \((x*1,\dots,x_m)\)：
\[
\text{Cost}*\text{algorithm}(X) \;\le\; C \times \text{Cost}_\text{OPT}(X) + D
\]
其中 \(\text{Cost}_\text{OPT}(X)\) 是离线最优 BST 对该序列的最小代价，\(C, D\) 是与 \(n\)（或 \(m\)）无关的常数。

开放性问题：是否存在**在线**的 BST 算法能实现常数竞争比？

### 3.2 Splay 树

**Splay 树**由 Sleator 和 Tarjan 在 1985 年提出 [5]，是一种“在访问后把节点旋转到根”的自适应 BST。其主要旋转规则是 **zig-zig** 与 **zig-zag**：

- **zig-zig**：节点与其父亲同侧时，先旋转父，再旋转自己。
- **zig-zag**：节点与其父亲异侧时，两次旋转都是围绕自己。

Splay 树的已知性质：

1. **静态最优**：与静态树（固定结构不随查询变化）相比不会差。
2. **工作集（Working Set）**性能：访问刚访问过的元素会更快。
3. **动态指针（Dynamic Finger）**性能：访问相近元素可获 \(O(\log|x*i - x*{i-1}|)\) 时间。

但**Splay 是否动态最优**仍然是悬而未决的 **Splay 猜想（Splay Conjecture）**。同时我们也不知它是否具备 Unified Property。

---

## 4. 几何视角：Arborally Satisfied Sets

Demaine 等人在 [3] 中提出了一种**几何化**方法，将 BST 的访问序列转化为一个点集的问题。基本思路：

### 4.1 点集表示

- 我们有关键字 \(\{1,2,\dots,n\}\)；搜索序列为 \((x_1,\dots,x_m)\)。
- 在 2D 平面上，令横坐标为“键”，纵坐标为“访问顺序”，即第 \(i\) 次访问了键 `x_i`，将点 \((x_i, i)\) 放到平面。
- 然后，BST 的执行会对每次访问 `x_i` 遍历若干节点。我们在几何平面上也为“在时刻 \(i\)” 访问节点 `k` 放一个点 \((k, i)\)。

这样，每次搜索的**代价**可以视为访问了多少个 \((k, i)\) 点的总数（在常数因子下等价于 BST 的旋转 + 指针走动次数）。

### 4.2 Arborally Satisfied 集合

一个包含所有输入点 \((x_i, i)\) 的点集 \(S\) 若满足**对任意两个点 (x1, t1) 与 (x2, t2) 只要它们不在同一行或列，就存在第三点 (x3, t3)\) 落在该矩形的边界或内部**，则称之为 **Arborally Satisfied**。可以证明：

> **定理**：一个点集是 Arborally Satisfied 当且仅当它对应一个合法 BST 的执行过程（带有一定旋转/访问顺序）  
> 换言之，给定输入序列 \((x_1,\dots,x_m)\)，若我们能找一个 Arborally Satisfied 的点集覆盖所有输入点 \((x_i,i)\)，则这个点集规模越小意味着 BST 执行的代价越小。

这个几何观点将“最优 BST 执行”转化为“找最小 Arborally Satisfied 集”的问题。

#### 4.2.1 开放问题

- 求最小 Arborally Satisfied 点集的算法复杂度未知。
- 是否存在常数因子的近似算法也未知。若有，就等价于构造了在线动态最优 BST 算法的常数竞争性。

---

## 5. 贪心构造及意义

Lecture 5 提到了一个简单的“行扫描贪心算法”来构造 Arborally Satisfied 集：

- 从低到高依次扫描每一行 \(t\)，并将行里必要的额外点补上，以保证新加入行和前面行合并后仍然 Arborally Satisfied。
- 这可能在每行产生少量额外点。

若能证明此贪心算法构造的点集大小不超过 \(\text{OPT}+O(m)\) 或 \(\alpha \cdot \text{OPT}\)，那么就有了一个**在线**的 BST 算法在 \(O(1)\) 因子上逼近最优，也就解决了**动态最优**大问题。

目前尚未有完整证明。有一些结果表明它可能是非常有前景的候选人之一。

---

## 6. 对动态最优的期望与总结

- **开问题**：是否存在在线 BST 算法能在任意序列上取得常数竞争比（即动态最优）？Splay 是否就是？或者还有更好的结构？
- 已有**上界**：最好的在线算法能做到 \(O(\log\log n)\) 因子近似 [后续讲解]，但与常数因子还差一大截。
- **几何化**（Arborally Satisfied）视角为研究动态最优提供了新的方法和可能性。若能找出构造或近似算法，就能给出或多或少的实质突破。

**Lecture 5** 为我们铺垫了如下重点：

1. **BST 的各种自适应性能标准**（Working Set, Dynamic Finger, Unified）。
2. **Splay 树**：已知满足若干强大性质，但动态最优性依旧悬而未决。
3. **BST 动态最优性**的**几何表述**：用 Arborally Satisfied 点集来编码 BST 的访问执行。最优 BST 对应最小的满足此性质的点集。
4. 若能找到一条\(O(1)\)-近似的构造方法，即可实现在线动态最优 BST。

这些内容也引出了下一讲对于 BST 动态最优问题更深入的探讨。
