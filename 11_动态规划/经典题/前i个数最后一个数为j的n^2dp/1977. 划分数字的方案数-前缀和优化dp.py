# 你写下了若干 正整数 ，并将它们连接成了一个字符串 num 。
# 但是你忘记给这些数字之间加逗号了。你只记得这一列数字是 非递减 的且 没有 任何数字有前导 0 。
# 请你返回有多少种可能的 正整数数组 可以得到字符串 num 。
# 由于答案可能很大，将结果对 109 + 7 取余 后返回。

# 1977. 划分数字的方案数-字符串相等长时比较大小


# n<=3500
# # 这个dp是O(n^3)的


# class Solution:
#     def numberOfCombinations(self, num: str) -> int:
#         @lru_cache(None)
#         def dfs(index: int, pre: int) -> int:
#             """当前划分起始点index，前一个划分的起始点pre"""
#             if index >= n:
#                 return 1
#             if num[index] == '0':
#                 return 0

#             res = 0
#             preLen = index - pre
#             lcpCount = lcp[pre][index]

#             # 在内部循环不好，要在外部循环
#             for i in range(n - 1, index + preLen - 1, -1):

#                 curLen = i - index + 1
#                 if (
#                     (curLen > preLen)
#                     or (curLen == preLen and lcpCount >= preLen)
#                     or (curLen == preLen and num[index + lcpCount] >= num[pre + lcpCount])
#                 ):
#                     res += dfs(i + 1, index)
#                     res %= MOD

#             return res

#         n = len(num)

#         # lcp 加速比较字符串大小
#         # lcp[i][j] 表示后缀 num[i:]与num[j:]的最长公共前缀长度
#         lcp = [[0] * (n + 1) for _ in range(n + 1)]
#         for i in range(n - 1, -1, -1):
#             for j in range(n - 1, -1, -1):
#                 if num[i] == num[j]:
#                     lcp[i][j] = lcp[i + 1][j + 1] + 1

#         res = dfs(0, 0)
#         dfs.cache_clear()
#         return res % MOD


# 这个dp是O(n^2)的 里面不要循环，在外面累加循环
class Solution:
    def numberOfCombinations(self, num: str) -> int:
        if num[0] == '0':
            return 0
        n = len(num)

        # lcp 加速比较字符串大小
        # lcp[i][j] 表示后缀 num[i:]与num[j:]的最长公共前缀长度
        lcp = [[0] * (n + 1) for _ in range(n + 1)]
        for i in range(n - 1, -1, -1):
            for j in range(n - 1, -1, -1):
                if num[i] == num[j]:
                    lcp[i][j] = lcp[i + 1][j + 1] + 1

        dp = [[0] * n for _ in range(n)]  # dp[i][j] 表示对前j个数字划分，最后一个数字开头为i的方案书
        for i in range(n):
            dp[0][i] = 1

        for i in range(1, n):
            if num[i] == '0':
                continue

            preSum = 0  # 关键的优化，优化循环，表示之前的划分方案数
            for j in range(i, n):
                length = j - i + 1
                dp[i][j] = preSum % MOD
                if i - length >= 0:
                    if (
                        lcp[i - length][i] >= length
                        or num[i - length + lcp[i - length][i]] < num[i + lcp[i - length][i]]
                    ):
                        dp[i][j] += dp[i - length][i - 1]
                        dp[i][j] %= MOD
                    preSum += dp[i - length][i - 1]  # 这里加上之前的划分方案数

        res = 0
        for i in range(n):
            res += dp[i][n - 1]
            res %= MOD
        return res


print(Solution().numberOfCombinations(num="327"))
# print(
#     Solution().numberOfCombinations(
#         num="11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
#     )
# )

# 没有必要lcp
# https://leetcode.cn/problems/number-of-ways-to-separate-numbers/solution/by-iancn-90gl/
# dp[i][j]代表num[:i]中最后一个数长度为j的方案数量


class Solution:
    def numberOfCombinations(self, s: str) -> int:
        n, MOD = len(s), int(1e9 + 7)
        dp = [[0] * (i + 1) for i in range(n + 1)]
        dp[0][0] = 1
        preSum = [[0] * (i + 1) for i in range(n + 1)]
        preSum[0][0] = 1

        for i in range(1, n + 1):
            for j in range(1, i + 1):
                if s[i - j] != '0':
                    # 小的长度(这里会有重复计算)
                    # dp[i][j] = sum(dp[i - j][k] for k in range(min(j, i - j + 1)))
                    dp[i][j] = preSum[i - j][min(j - 1, i - j)]
                    # 相等的长度
                    if i - 2 * j >= 0 and s[i - j : i] >= s[i - 2 * j : i - j]:
                        dp[i][j] += dp[i - j][j]
                    dp[i][j] %= MOD
                preSum[i][j] = (preSum[i][j - 1] + dp[i][j]) % MOD

        return preSum[-1][-1]

