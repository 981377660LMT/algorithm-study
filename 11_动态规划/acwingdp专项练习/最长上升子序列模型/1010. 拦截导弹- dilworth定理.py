# 雷达给出的高度数据是不大于 30000 的正整数，导弹数不超过  1000 。

# 不断删除下降子序列，问最少删除几次(答案是 最长上升子序列的长度)
nums = list(map(int, input().split()))
n = len(nums)

# 最长上升子序列
dp = [1] * (n)
for i in range(n):
    for j in range(i):
        if nums[i] > nums[j]:
            dp[i] = max(dp[i], dp[j] + 1)
res = max(dp)

# 最长不下降子序列
nums = nums[::-1]
dp = [1] * (n)
for i in range(n):
    for j in range(i):
        if nums[i] >= nums[j]:
            dp[i] = max(dp[i], dp[j] + 1)

# 第一行包含一个整数，表示最多能拦截的导弹数。
# 第二行包含一个整数，表示要拦截所有导弹最少要配备的系统数。
print(max(dp))
print(res)


# 证明
# 1、首先我们把这些导弹分为s组（s即为所求答案）
# 可以看出每一组都是一个不升子序列
# 2、划分完后我们在组一里找一个原序列里以组一的开头点连续的不升子串的最后一个元素，可以知道在组2中`一定有一个大与它的点`
# （如果组二中没有的话，那么组二中最高的导弹高度必然小于这个点，而其他的高度都小于这个高度而且是递减或相等的，那么没有必要再开一个组二了，矛盾，所以不存在找不到比他大的点的情况）
# 3、以此类推，对于每一个k组（1<=k<n）都可以找到这样的一些点
# 所以把这些点连起来，就是一条上升子序列。
