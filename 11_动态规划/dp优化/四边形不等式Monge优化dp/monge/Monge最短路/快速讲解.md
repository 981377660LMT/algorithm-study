# 解决的问题

**在满足某种“凸性”条件下，通过给单次操作增加“代价（惩罚值）”来消除“恰好选取 $k$ 个”这一维度限制。**

---

### 1. 几个概念

- **Aliens DP**：起源于 IOI 2016 的题目 $Aliens$。它是一种**算法模型**，指代“通过二分斜率将 $dp[i][k]$ 降至 $dp[i]$”的整套方法。
- **WQS 二分（王钦石二分）**：国内对该算法的通俗称呼。它强调了**实现手段**：通过二分（Binary Search）寻找一个斜率（或惩罚金），使得最优解正好使用了 $k$ 个物品。
- **Monge 图 $d$ 边最短路**：数学上的**形式化定义**。如果一个问题的代价函数 $cost(i, j)$ 满足 Monge 性质（四边形不等式），那么该问题在图论上表现为：求从 $0$ 到 $n$ 恰好经过 $d$ 条边的最短路。
  - **核心定理**：Monge 图中，经过 $d$ 条边的最短路长度 $f(d)$ 是关于 $d$ 的**凸函数**。

---

### 2. 本质理解：拉格朗日乘数法的离散版

1.  **硬约束变软成本**：
    原本要求“必须切 $k$ 刀”。现在由于 $k$ 这一维太占空间，我们规定：“不限制切几刀，但每切一刀都要额外付 $x$ 元的税。”
2.  **利用单位代价诱导数量**：
    - 如果税 $x$ 很高，程序为了省钱会尽量少切（$k$ 变小）。
    - 如果税 $x$ 极低甚至为负，程序会为了降低原代价而多切（$k$ 变大）。
3.  **凸性保证单调性**：
    因为 $f(d)$ 是凸的，所以“切的刀数”关于“税率 $x$”具有单调性。这使得我们可以用**二分法**找到那个完美的 $x$，使得程序“自发地”恰好切了 $k$ 刀。

```go
func MongeShortestPathDEdge(n, d, maxWeight int, f func(i, j int) int) int {
    cal := func(x int) int {
        // 带了“惩罚值 x”的代价函数
        g := func(from, to int) int {
            return f(from, to) + x
        }
        // MongeShortestPath (决策单调性优化) 算出不限边数的最短路
        cost := MongeShortestPath(n, g)[n]
        // 还原真实的代价值 (减去多加的惩罚项)
        return cost - x*d
    }
    // 二分寻找最佳惩罚值
    _, res := FibonacciSearch(cal, -maxWeight, maxWeight+1, false)
    return res
}
```

- **外层（WQS 二分/FibonacciSearch）**：在寻找最优的“惩罚金” $x$。
- **内层（Decision Monotonicity / MongeShortestPath）**：在已知 $x$ 的情况下，快速算出“被税收诱导后的”最优解。由于 $f(i, j)+x$ 依然保持 Monge 性质，所以内层可以用决策单调性优化到 $O(n \log n)$。

利用**数学性质 (Monge)** 证明了**函数凸性**，从而允许使用**二分策略 (WQS)**，最终将 $O(nk)$ 的问题优化到 $O(n \log n \cdot \log V)$。
