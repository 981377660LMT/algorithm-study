这些优化技术主要旨在解决 DP 状态转移复杂度过高的问题（通常将 $O(N^2)$ 降低至 $O(N \log N)$ 或 $O(N)$）。

### DP 优化最佳实践总览

**核心心法**：

1.  **先写暴力 DP**：明确状态定义（$dp[i]$ 或 $dp[i][j]$）和转移方程。
2.  **观察转移瓶颈**：
    - 是区间求和/最值？ $\to$ **前缀和 / 线段树 / 单调队列**
    - 是 $i, j$ 乘积项 ($a[i] \times b[j]$)？ $\to$ **斜率优化 (CHT)**
    - 决策点 $opt[i]$ 单调递增？ $\to$ **分治优化 / 四边形不等式 / WQS 二分**
    - 函数是凸函数叠加？ $\to$ **Slope Trick**

---

### 一、 辅助数据结构优化 (Data Structure Optimization)

最基础且常用的优化手段，用于快速获取某个范围内的状态信息。

#### 1. 前缀和优化 (Prefix Sum)

- **适用场景**：转移方程涉及连续区间的和、积、最值。
  - $dp[i] = \sum_{k=L}^{R} dp[k]$
- **最佳实践**：
  - **分离变量**：将转移方程变形，把只与 $j$ 相关的项分离出来维护前缀和。
  - **处理边界**：在实现时，注意 $index-1 < 0$ 的情况，通常使用 `padding` 或者 `max(0, ...)` 以及 `if` 检查。
  - **二维降维**：二维 DP 中，通常将连续的那个维度放在数组的第二个维度（内存局部性更好，且切片操作更方便）。
  - **滚动数组**：注意先计算 `new_dp` 再更新 `prefix_sum`。

#### 2. 单调队列优化 (Monotonic Queue)

- **适用场景**：滑动窗口最值模型。
  - $dp[i] = \min_{j \in [i-k, i-1]} \{ dp[j] + val[j] \}$
- **最佳实践**：
  - **存下标**：队列中存储下标 `index` 而不是值，这样方便判断队头是否过期 (`index < i - k`)。
  - **维护单调性**：队尾入队时，弹出所有比当前劣的元素。

#### 3. 线段树/树状数组优化

- **适用场景**：不仅仅是区间查询，涉及“权值”维度的 DP。
  - 例如：$dp[i][v]$ 表示前 $i$ 个数，当前权值为 $v$ 的最优解。如果 $v$ 值域很大但离散，或者操作涉及区间更新，使用线段树维护 $v$ 维度。
- **最佳实践**：
  - **权值线段树**：如果权值 $\le 2 \times 10^5$，直接用线段树节点索引代替 DP 的第二维。

---

### 二、 几何与代数优化 (Geometric & Algebraic)

#### 1. 斜率优化 (Convex Hull Trick - CHT)

- **适用场景**：转移方程包含 $i$ 和 $j$ 的乘积项（交叉项）。
  - $dp[i] = \min_{j < i} \{ dp[j] + A[i] \times B[j] + C[j] \} + D[i]$
  - 形式化为直线方程 $y = kx + b$，其中 $x$ 和斜率 $k$ 只与 $j$ 或 $i$ 有关。
- **技术细节**：
  - **斜率 $k$ 单调**：可以使用 **单调队列** 维护凸包，$O(N)$。
  - **斜率 $k$ 不单调**：需要在凸包上 **二分查找** 或使用 **李超线段树 (Li Chao Tree)**，$O(N \log N)$。
- **最佳实践**：
  - **化简式子**：不要死记硬背，将式子写成 $y = kx + b$ 的形式，明确 $x, y, k, b$ 分别对应什么。
  - **避免浮点数**：比较斜率 $\frac{y_2-y_1}{x_2-x_1} \le \frac{y_3-y_2}{x_3-x_2}$ 时，使用乘法形式 `(y2-y1)*(x3-x2) <= (y3-y2)*(x2-x1)` 避免精度问题。

#### 2. Slope Trick

- **适用场景**：DP 状态函数 $f(x)$ 是凸函数，且转移过程是由多个绝对值函数 $|x-a|$ 或其他简单凸函数叠加而成。
  - $dp[i][x] = \min_y (dp[i-1][y] + |x - a_i|)$
- **最佳实践**：
  - **维护转折点**：只需用两个堆（大顶堆和小顶堆）维护凸函数的拐点，而不需要记录具体的函数值。
  - **复杂度**：将 $O(NK)$ 优化至 $O(N \log N)$。

---

### 三、 决策单调性优化 (Decision Monotonicity)

这类优化基于一个性质：对于 $i' > i$，如果 $i$ 的最优决策点是 $opt[i]$，那么 $i'$ 的最优决策点 $opt[i'] \ge opt[i]$。

#### 是否满足单调性的判据：四边形不等式 (Monge Property)

如果代价函数 $w(i, j)$ 满足交叉小于包含：
$$w(a, d) + w(b, c) \ge w(a, c) + w(b, d) \quad (a < b < c < d)$$
则该问题通常满足决策单调性。

#### 1. 分治优化 DP (Divide & Conquer Optimization)

- **适用场景**：**2D DP，按层转移**。即 $dp[k][j]$ 仅依赖于上一层 $dp[k-1][\dots]$。
  - $dp[k][j] = \min_{i < j} \{ dp[k-1][i] + w(i, j) \}$
- **最佳实践**：
  - 函数签名通常为 `solve(L, R, optL, optR)`，表示计算状态区间 $[L, R]$，其最优决策点在 $[optL, optR]$ 范围内。
  - 取中点 `mid`，暴力扫描 $[optL, \min(mid, optR)]$ 找到 `mid` 的最优决策点 `optMid`。
  - 递归 `solve(L, mid-1, optL, optMid)` 和 `solve(mid+1, R, optMid, optR)`。

#### 2. “二分栈” / 1D1D 动态规划优化

- **适用场景**：**1D DP，同层转移**。$dp[i]$ 依赖于 $dp[0 \dots i-1]$。
  - $dp[i] = \min_{j < i} \{ dp[j] + w(j, i) \}$
- **注意**：普通分治法不能直接用，因为 $dp[j]$ 需要先算出来。
- **最佳实践**：
  - **CDQ 分治 (OfflineOnline)**：利用分治思想，先递归计算左半边 $[L, mid]$ 的 DP 值，然后用左半边的值去更新右半边 $[mid+1, R]$ 的 DP 值（通常结合单调性），再递归计算右半边。
  - **二分栈**：维护一个栈，栈中保存决策点及其“生效区间”。当新决策点入栈时，二分查找它在何时优于栈顶决策，并更新栈顶区间。

#### 3. WQS 二分 (Alien's Trick / 带权二分)

- **适用场景**：题目限制“恰好选 $k$ 个物品”或“分 $k$ 段”，且随着 $k$ 变化，最优解呈现凸函数特性。
- **最佳实践**：
  - 去掉 $k$ 的限制，给每个物品/段增加一个附加成本 $\lambda$ (惩罚值)。
  - 二分 $\lambda$，做无限制的 DP，统计最优解下选了多少个物品 $count$。
  - 如果 $count = k$，则找到答案。

---

### 四、 状态定义优化 (State Definition)

- **正难则反**：如果正向计算很复杂，考虑补集或反向 DP。
- **更换状态**：
  - 如果背包容量特别大但价值很小，交换 DP 状态与值：$dp[val] = min\_weight$。
- **倍增/二进制分组 DP**：
  - 当需要进行极大多次转移时（如 $10^9$ 次），结合矩阵快速幂或倍增法。

### 总结：拿到 DP 题的优化路线图

1.  **写出朴素方程**：$dp[i] = \min(dp[j] +cost(j, i))$。
2.  **看 $cost(j, i)$ 的形式**：
    - 只有 $j$ 的项和常数项？ $\to$ **单调队列/前缀和**。
    - 有 $i \times j$ 交叉项？ $\to$ **斜率优化**。
    - 是任意函数但满足四边形不等式？ $\to$ **决策单调性 (分治/二分栈)**。
3.  **看限制条件**：
    - 恰好 $k$ 次？ $\to$ **WQS 二分**。
    - 数据结构相关限制？ $\to$ **线段树优化 DP**。

该文件夹中的 `kitamasa法` (模 $x^n-1$ 的多项式快速幂) 和 `MongeShortestPath` (SMAWK 算法的图论应用) 属于更高级的进阶技巧，通常针对特定的竞赛难题。
