# Shopee 拥有 N 位软件工程师。 Shopee 通过在一维平面上安排 N 个表来容纳它们。
# 然而，许多人担心工作环境过于嘈杂。为了缓解这个问题，Shopee 决定将工程师分成 K 个组。
# 组是相邻工程师的非重叠部分。然后，Shopee 将在组之间放置分隔符。

# 组的噪声值由以下函数定义：
# 噪声(l, r) = sum(A[l], A[l + 1], ..., A[r]) * (r - l + 1)
# 在哪里：
# noise(l, r) 表示由第 l 个工程师到第 r 个工程师组成的组的噪声值。
# A[i] 表示第 i 个工程师的噪声因子。 Shopee 希望最小化总噪声值。请帮助 Shopee 找到可能的最小总噪声值。

# 输入格式 输入的第一行包含2个整数：N, K (1 <= N <= 10,000; 1 <= K <= min(N, 100))
# 分别代表工程师的数量和组的数量。
# 下一行包含 N 个整数：A[i] (1 <= A[i] <= 10,000)
# 表示第 i 个工程师的噪声因子。

# 输出格式 在一行中输出一个整数，表示可能的最小总噪声值。
# 样本输入
# 4 2 1 3 2 4 样本输出 20
# 解释
# 1 | 3 2 4 (1 * 1) + (9 * 3) = 28 1 3 | 2 4 (4 * 2) + (6 * 2) = 20 1 3 2 | 4 (6 * 3) + (4 * 1) = 22
# 我们可以看到，从所有可能性中，20 是最小的总噪声值。


# https://zhuanlan.zhihu.com/p/363772434
# 如果 dp[i] = min(f(i)+g(j)) 那么可以用线段树/有序容器/单调队列来维护g(j)的最值
# 但是如果 `dp[i]=min(f(i)+g(j)+h1(i)*h2(j))` 即多了交叉项 那么就需要用凸壳优化或者斜率优化解决此问题

# 记dp[i][k]为前i个人分k组的最小噪声值，
# 则dp[i][k] = min(dp[j][k-1]+(preSum[i]-preSum[j])*(i-j+1))
