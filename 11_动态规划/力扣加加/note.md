递归中如果存在重复计算（我们称重叠子问题，下文会讲到），那就是使用记忆化递归（或动态规划）解题的强有力信号之一。

动态规划的基本概念

1. **最优子结构**:如果考试中的分数定义为 f，那么这个问题就可以被分解为语文，数学，英语等子问题。显然子问题最优的时候，总分这个大的问题的解也是最优的。
2. **无后效性**:背包问题中 f([1,2,3], [2,2,4], 10) 选择是否拿第三件物品，不应该影响是否拿前面的物品。比如题目规定了拿了第三件物品之后，第二件物品的价值就会变低或变高）。这种情况就不满足无后向性。

动态规划三要素

1. 状态定义:状态的定义都有特点的套路。 比如一个字符串的状态，通常是 dp[i] 表示字符串 s 以 i 结尾的 ....。 比如两个字符串的状态，通常是 dp[i][j] 表示字符串 s1 以 i 结尾，s2 以 j 结尾的 ....。说实话，只能多练习，在练习的过程中总结套路。
   例子:**最长回文子串**,**正则表达式匹配**
2. 初始条件
3. 状态转移方程:枚举状态时,如果是一维状态，那么我们使用一层循环可以搞定。如果是两维状态，那么我们使用两层循环可以搞定。但是实际操作的过程有很多细节比如:

```
一维状态我是先枚举左边的还是右边的？（从左到右遍历还是从右到左遍历）
二维状态我是先枚举左上边的还是右上的，还是左下的还是右下的？
里层循环和外层循环的位置关系（可以互换么）
```

总结了一个关键点，那就是：

- 如果你没有使用滚动数组的技巧，那么遍历顺序取决于状态转移方程

  ```Python
  for i in range(1, n + 1):
    dp[i] = dp[i - 1] + 1
  ```

  原因很简单，因为 dp[i] 依赖于 dp[i - 1]，因此计算 dp[i] 的时候， dp[i - 1] 需要已经计算好了。

- 如果你使用了滚动数组的技巧，则怎么遍历都可以，但是不同的遍历意义通常不不同的

爬楼梯的动态规划与记忆化递归的写法

```JS
// 动态规划,动态规划使用迭代枚举状态
function climbStairs(n) {
  if (n == 1) return 1;
  const dp = new Array(n);
  dp[0] = 1;
  dp[1] = 2;

  for (let i = 2; i < n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2];
  }
  return dp[dp.length - 1];
}
// 记忆化递归,递归用调用栈枚举状态
const memo = {};
function dp(n) {
  if (n === 1) return 1;
  if (n === 2) return 2;
  if (n in memo) return memo[n];
  const ans = dp(n - 1) + dp(n - 2);
  memo[n] = ans;
  return ans;
}
```

滚动数组优化:爬楼梯问题的状态转移方程中当前状态只和前两个状态有关，因此只需要存储这两个即可
记忆化递归和动态规划除了一个用递归一个用迭代，其他没差别。那两者有啥区别呢?最大的区别就是**记忆化递归无法使用滚动数组优化**。

动态规划的题型

区间 dp:将问题分解为左右两个部分，最后合并两个部分的最优值得到原问题的最优值。
状压 dp:状态不会大于 20(可以用**状态压缩 BSet**),使用自顶向下的记忆化搜索
背包 dp
...

使用记忆化递归和动态规划来解决。如果使用动态规划，则尽可能使用滚动数组优化空间。
