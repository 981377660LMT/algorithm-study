# 百练上机
# https://www.luogu.com.cn/blog/littleseven/solution-cf358d

# 给你 3 个长度均为 n(<=3000) 的数组 a b c，元素范围 [0,1e5]，具体含义见下文。

# 有 n 个物品排成一排，你可以按照任意顺序拿物品，并获得相应的分数：

# 1. 如果拿走某个物品时，相邻两个物品都没有被拿过，那么得到的分数为 a[i]
# 2. 如果相邻的两个物品恰好有一个被拿过，那么得到的分数为 b[i]
# 3. 如果相邻的两个物品都被拿走了，那么得到的分数为 c[i]

# 问拿走所有物品后，能够获得的最高分数为多少？

# 输入
# a=[1 2 3 4]
# b=[4 3 2 1]
# c=[0 1 1 0]
# 输出 13
# 解释 顺序为 4 3 2 1，得分为 a[3]+b[2]+b[1]+b[0]=4+2+3+4=13

# 如果每次都考虑当前点为中间点的话，的确很直接，很清晰，
# 但是怎么同时对前后更改，（如果前后更改还会涉及到其它点的更改），这显然是实现不了的。
# 那么我们更换思路，考虑每一次遍历到的当前点是三个点中的最后一个
