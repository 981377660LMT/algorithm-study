判断子序列:
**两种经典预处理方法，适合待匹配的字符串有很多个时**
`392. 判断子序列`
`583. 两个字符串的删除操作`

1. 哈希表存出现的 index
   二分查找(bisectRight)出现的位置 索引需要递增

```JS
Map(13) {
  'a' => [ 0, 3 ],
  'h' => [ 1, 8 ],
  'b' => [ 2 ],
  's' => [ 4 ],
  'd' => [ 5, 15 ],
  'f' => [ 6 ],
  'g' => [ 7, 14 ],
  'y' => [ 9 ],
  't' => [ 10 ],
  'r' => [ 11 ],
  'e' => [ 12 ],
  'w' => [ 13 ],
  'c' => [ 16 ]
}
```

2. 对于长 n 的字符串 使用 数组+哈希 map (单词很多时，空间开销极大)
   **倒序**记录从该位置开始往后每一个字符第一次出现的位置

```JS
[
  Map(13) {
    'a' => 0,
    'h' => 1,
    'b' => 2,
    's' => 4,
    'd' => 5,
    'f' => 6,
    'g' => 7,
    'y' => 9,
    't' => 10,
    'r' => 11,
    'e' => 12,
    'w' => 13,
    'c' => 16
  },
...
```
