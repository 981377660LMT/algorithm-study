from math import comb, factorial
import sys

sys.setrecursionlimit(int(1e9))
input = lambda: sys.stdin.readline().rstrip("\r\n")
MOD = 998244353
INF = int(4e18)
# H 行
# W 列のグリッドがあります。 上から
# i 行目、左から
# j 列目のマス目を
# (i,j) と表します。 グリッドの各マスはスタートマス、ゴールマス、空マス、壁マス、お菓子マスのいずれかです。
# (i,j) が何のマスであるかは文字
# A
# i,j
# ​
#   によって表され、
# A
# i,j
# ​
#  = S のときスタートマス、
# A
# i,j
# ​
#  = G のときゴールマス、
# A
# i,j
# ​
#  = . のとき空マス、
# A
# i,j
# ​
#  = # のとき壁マス、
# A
# i,j
# ​
#  = o のときお菓子マスです。 ここで、スタートマスとゴールマスはちょうど
# 1 つずつあり、お菓子マスは
# 18 個以下であることが保証されます。

# 高橋くんは現在スタートマスにいます。 高橋くんは、上下左右に隣接するマスであって壁マスでないマスに移動することを繰り返し行えます。 高橋くんは今から
# T 回以下の移動によってゴールマスに到達したいです。 そのようなことは可能かどうか判定してください。 可能な場合は、最終的にゴールマスにいるという条件のもとで、移動の途中に訪れるお菓子マスの数の最大値を求めてください。 ただし、
# 1 つのお菓子マスに複数回訪れた場合でも、カウントするのは
# 1 回のみです。


# 2^18状态dp
if __name__ == "__main__":
    ROW, COL, T = map(int, input().split())
    grid = [list(input()) for _ in range(ROW)]
