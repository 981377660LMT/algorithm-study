[AtCoder 版！蟻本 (初級編)](https://qiita.com/drken/items/e77685614f3c6bf86f44)
[AtCoder 版！蟻本 (中級編)](https://qiita.com/drken/items/2f56925972c1d34e05d8)
[AtCoder 版！蟻本 (上級編)](https://qiita.com/drken/items/9b311d553aa434bb26e4)
[AtCoder 版！蟻本 (発展的トピック編)](https://qiita.com/drken/items/0de3d205690d92307b7c)

1. N が大きいと全探索できない => `半分全列挙` + 二分探索
   O(n^4) を O(n^2 logn) にする系の半分全列挙
   O(2^n) を O(n 2^(n/2)) にする系の半分全列挙

   競技プログラミングにおけるすべての基本 全探索 です。全探索といっても

   for 文を二重三重にして回す
   bit 全探索
   DFS
   BFS

2. 区間スケジューリング問題
   Greedy
   区間の終端でソート

   区間の終端 (または始端) でソートするのは極めてよくみるテクニックで、今後難しい問題に挑むときにも常に念頭に置いておきたいです。

3. 値を覚えて再利用 "動的計画法"
   分割数
   時々高難易度な問題で部分的に登場する分割数です。同じように高難易度な問題で登場する話題に、`スターリング数`や`ベル数`があります。

   区間 DP
   区間に対する DP です。Monge 性は蟻本にない話題なのでどこかで学ぶ必要があります。通常の区間 DP は O(n^3) かかり、`Monge 性を満たすと O(n^2) にすることができます。`
   最適二分探索木問題に限ってはさらに O(n logn) で解ける Hu-Tucker のアルゴリズムが知られています。

   部分文字列 DP

   **きたまさ法**

4. データを工夫して記憶する "データ構造"
   「あとで補償する」という発想

5. あれもこれも実は "グラフ"
6. 「～を満たす最大 (最小) の値を求めよ」
   解 x を仮定して可能かを判定する問題に置き換えて
   解 x が可能となるような最大 (最小) の x を求める
7. 最小値の最大化 (最大値の最小化)
   **最小値の最大化を見たら条件反射で二分探索したくなります**
   判定問題に落とした後は `Greedy` であることが多いです。
8. 平均最大化
   「a[0], ..., a[n-1] の平均が K 以上」を「a[0]-K, ..., a[n-1]-K の`総和が 0 以上」にするテク`
   二分探索に限らずちょくちょく見る印象です
9. しゃくとり法:枚举区间左端点
   求めるものが「最小の区間」か「最大の区間」かはあまり影響がないです
   しゃくとり法は条件を満たすものを列挙するタイプのアルゴリズムなので数え上げもできます
10. バブルソートの交換回数 <=> 転倒数
11. 轮廓线 dp:ドミノ敷き詰め
    `dfs(r,c,state)`
    c==Col => 次の行へ
    r==Row => すべて敷き詰め終わった
    ブロックを置く必要がない
    2 通りの向きを試す
12. m 項間漸化式を行列累乗に持ち込む(求斐波那契第 1e16 項模 1e9+7 的值)
13. 水を流して解く "ネットワークフロー"
14. Grundy 数
    複数盤面を同時に処理するゲームに使える一般的なテク Grundy です！
    **NIM 和 Grundy 到底是啥**
    NIM:取石子游戏 异或非 0 先手必胜
