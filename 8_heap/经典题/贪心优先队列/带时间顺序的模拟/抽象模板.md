# 协程调度器架构详解

## 架构概述

这是一个基于事件驱动的协程调度器实现，通过模拟操作系统调度原理，来解决资源竞争问题。

```mermaid
classDiagram
    class Event~R~ {
        <<abstract>>
    }
    class Sleep~R~ {
        +int duration
    }
    class Acquire~R~ {
        +R resource
        +Any priority
    }
    class Release~R~ {
        +R resource
    }

    Event <|-- Sleep
    Event <|-- Acquire
    Event <|-- Release

    class Task~R~ {
        +Generator gen
    }

    class Scheduler~R~ {
        +int current_time
        -List _time_pq
        -Dict _waiting
        -Dict _locked
        -Counter _counter
        +start_task(Task)
        -_dispatch(Task, Event)
        +run()
    }

    Scheduler o-- Task : schedules
    Task -- Event : yields
```

## 系统工作流程

```mermaid
flowchart TD
    A[创建任务] --> B[start_task]
    B --> C[_dispatch]
    C -->|Sleep| D[添加到时间队列]
    C -->|Acquire| E[添加到资源等待队列]
    C -->|Release| F[释放资源]

    G[run方法] --> H{时间队列有到期任务?}
    H -->|Yes| I[唤醒任务]
    H -->|No| J{有可获取资源?}
    J -->|Yes| K[分配资源给最高优先级任务]
    J -->|No| L[快进到下一时间点]

    I --> C
    K --> C
    L --> G
    F --> C
```

## 核心组件解析

### 1. 事件系统

- **Event**: 标记接口，表示协程可以yield的事件类型
- **Sleep**: 请求在指定时长后唤醒
- **Acquire**: 请求获取资源，带优先级
- **Release**: 释放资源，允许其他任务获取

### 2. 任务系统

- **TaskGen**: 协程类型，可以yield出Event对象
- **Task**: 包装协程生成器的类

### 3. 调度器

- **数据结构**:
  -

\_time_pq

: 最小堆，按唤醒时间排序

-

\_waiting

: 资源等待队列，按优先级排序

-

\_locked

: 资源占用状态表

```mermaid
sequenceDiagram
    participant Client
    participant Scheduler
    participant Task

    Client->>Scheduler: start_task(task)
    Scheduler->>Task: next(gen)
    Task-->>Scheduler: yield Event

    loop run
        Scheduler->>Scheduler: 检查时间队列
        Scheduler->>Scheduler: 检查资源等待队列
        Scheduler->>Task: 唤醒任务
        Task-->>Scheduler: yield新Event
        Scheduler->>Scheduler: _dispatch(task, event)
    end
```

## 桥梁过河问题实现

```mermaid
stateDiagram-v2
    [*] --> 左岸
    左岸 --> 请求过桥: Acquire("bridge")
    请求过桥 --> 返回: remaining=0
    请求过桥 --> 过桥中: remaining>0
    过桥中 --> 右岸: Release("bridge")
    右岸 --> 卸货
    卸货 --> 请求回程: Acquire("bridge")
    请求回程 --> 回程中
    回程中 --> 左岸: Release("bridge")
    左岸 --> 装货
    装货 --> 左岸
    返回 --> [*]
```

这个调度器架构通过协程和事件机制，优雅地实现了复杂的资源竞争处理，可以扩展到更多场景。
