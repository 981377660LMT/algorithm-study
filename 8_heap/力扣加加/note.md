1. 堆的中心就一个，那就是**动态求极值**;如果没有动态两个字，很多情况下没有必要使用堆
2. 两种实现
   如果永远都维护一个有序数组的方式取极值很容易，但是插队麻烦。
   如果永远都维护一个有序链表的方式取极值也容易。 不过要想查找足够快，而不是线性扫描，就需要借助索引，这种实现对应的就是**优先级队列的跳表实现**。
   你可以形象地将跳表想象为玩游戏的存档。
   我如果想玩第 5 关的某一个地方，也可以不用从第 5 关的开头开始，而是直接选择离你想玩的地方更近的存档，这就相当于跳表的二级索引。
   如果永远都维护一个树的方式取极值也可以实现，比如根节点就是极值，这样 O(1) 也可以取到极值，但是调整过程需要 $O(logN)$。这种实现对应的就是**优先级队列的二叉堆实现**。
   使用优先队列的 BFS 实现典型的就是 dijkstra 算法
3. 三个堆的做题技巧
   1. 固定堆:固定一个大小为 k 的大顶堆可以快速求第 k 小的数，反之固定一个大小为 k 的小顶堆可以快速求第 k 大的数
   2. 多路归并:本质就是一个暴力解法
   3. 事后小诸葛:有些信息，我们在当前没有办法获取，就可用一种数据结构存起来，方便之后”东窗事发“的时候查
4. 四种应用

- topK
  带权最短路径
  因子分解
  堆排序

堆和优先队列大家可以认为是同一个东西

跳表 SkipList
二分查找算法之所以能达到 O(logn) 这样高效的一个重要原因在于它所依赖的数据结构是数组，数组支持随机访问一个元素，通过下标很容易定位到中间元素。而链表是不支持随机访问的，只能从头到尾依次访问。但是数组有数组的局限性，比如需要连续的内存空间，插入删除操作会引起数组的扩容和元素移动，链表有链表的优势，链表不需要先申请连续的空间，插入删除操作的效率非常高。在很多情况下，数据是通过链表这种数据结构存储的，**如果是有序链表，真的就没有办法使用二分查找算法了吗**？
实际上对有序链表稍加改造，我们就可以对链表进行二分查找。这就是我们要说的跳表。
带多级索引的链表，就是跳表
第 k 级索引的结点个数是第 k-1 级索引的结点个数的 1/2，那么第 k 级索引的节点个数为 n 除以 2 的 k 次方，即 n/(2^k)
跳表的空间复杂度是 O(n) 时间复杂度 O(logn)
**为什么 redis 使用跳表而不使用红黑树。**

1. 红黑树在查找区间元素的效率没有跳表高，其他操作时间复杂度一致。
2. 相比红黑树，跳表的实现还是简单的，简单就意味着不容易出错，bug 少，稳定，易读，易维护。
3. 跳表更加灵活，通过改变索引构建策略，有效平衡效率和内存消耗。
