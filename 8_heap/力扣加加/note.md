1. 堆的中心就一个，那就是**动态求极值**;如果没有动态两个字，很多情况下没有必要使用堆
2. 两种实现
   如果永远都维护一个有序数组的方式取极值很容易，但是插队麻烦。
   如果永远都维护一个有序链表的方式取极值也容易。 不过要想查找足够快，而不是线性扫描，就需要借助索引，这种实现对应的就是**优先级队列的跳表实现**。
   如果永远都维护一个树的方式取极值也可以实现，比如根节点就是极值，这样 O(1) 也可以取到极值，但是调整过程需要 $O(logN)$。这种实现对应的就是**优先级队列的二叉堆实现**。
   使用优先队列的 BFS 实现典型的就是 dijkstra 算法
3. 三个堆的做题技巧
   1. 固定堆:固定一个大小为 k 的大顶堆可以快速求第 k 小的数，反之固定一个大小为 k 的小顶堆可以快速求第 k 大的数
   2. 多路归并:本质就是一个暴力解法
   3. 事后小诸葛:有些信息，我们在当前没有办法获取，就可用一种数据结构存起来，方便之后”东窗事发“的时候查
4. 四种应用

- topK
  带权最短路径
  因子分解
  堆排序

堆和优先队列大家可以认为是同一个东西
