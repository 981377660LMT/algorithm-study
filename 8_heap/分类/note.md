1. 堆的中心就一个，那就是**动态求极值**;如果没有动态两个字，很多情况下没有必要使用堆
2. 两种实现
   如果永远都维护一个有序数组的方式取极值很容易，但是插队麻烦。
   如果永远都维护一个有序链表的方式取极值也容易。 不过要想查找足够快，而不是线性扫描，就需要借助索引，这种实现对应的就是**优先级队列的跳表实现**。
   你可以形象地将跳表想象为玩游戏的存档。
   我如果想玩第 5 关的某一个地方，也可以不用从第 5 关的开头开始，而是直接选择离你想玩的地方更近的存档，这就相当于跳表的二级索引。
   如果永远都维护一个树的方式取极值也可以实现，比如根节点就是极值，这样 O(1) 也可以取到极值，但是调整过程需要 $O(logN)$。这种实现对应的就是**优先级队列的二叉堆实现**。
   使用优先队列的 BFS 实现典型的就是 dijkstra 算法
3. 三个堆的做题技巧
   1. 固定堆:固定一个大小为 k 的大顶堆可以快速求第 k 小的数，反之固定一个大小为 k 的小顶堆可以快速求第 k 大的数
   2. 多路归并:从 m 个数组中各抽取一个数的题目
   3. 事后小诸葛:有些信息，我们在当前没有办法获取，就可用一种数据结构存起来，方便之后”东窗事发“的时候查
4. 四种应用

- topK
  求第 k 小的数比较容易想到的就是堆和二分法。二分的原因在于求第 k 小，本质就是求不大于其本身的有 k - 1 个的那个数。而这个问题很多时候满足单调性，因此就可使用二分来解决。
  带权最短路径
  因子分解
  堆排序

堆和优先队列大家可以认为是同一个东西

跳表 SkipList
二分查找算法之所以能达到 O(logn) 这样高效的一个重要原因在于它所依赖的数据结构是数组，数组支持随机访问一个元素，通过下标很容易定位到中间元素。而链表是不支持随机访问的，只能从头到尾依次访问。但是数组有数组的局限性，比如需要连续的内存空间，插入删除操作会引起数组的扩容和元素移动，链表有链表的优势，链表不需要先申请连续的空间，插入删除操作的效率非常高。在很多情况下，数据是通过链表这种数据结构存储的，**如果是有序链表，真的就没有办法使用二分查找算法了吗**？
实际上对有序链表稍加改造，我们就可以对链表进行二分查找。这就是我们要说的跳表。
带多级索引的链表，就是跳表
第 k 级索引的结点个数是第 k-1 级索引的结点个数的 1/2，那么第 k 级索引的节点个数为 n 除以 2 的 k 次方，即 n/(2^k)
跳表的空间复杂度是 O(n) 时间复杂度 O(logn)
**为什么 redis 使用跳表而不使用红黑树。**

1. 红黑树在查找区间元素的效率没有跳表高，其他操作时间复杂度一致。
2. 相比红黑树，跳表的实现还是简单的，简单就意味着不容易出错，bug 少，稳定，易读，易维护。
3. 跳表更加灵活，通过改变索引构建策略，有效平衡效率和内存消耗。

一点说明
**元组**和**模拟大顶堆**
**元组**
使用堆不仅仅可以存储单一值，
python 中使用元组的方式，默认将元组第一个值当做键来比较。如果第一个相同，继续比较第二个。
使用这个技巧有两个作用：

1. 携带一些额外的信息。比如我想求二维矩阵中第 k 小数，当然是以值作为键。但是处理过程又需要用到其行和列信息，那么使用元组就很合适，比如 (val, row, col)这样的形式。
2. 想根据两个键进行排序，一个主键一个副键。
   如果你所使用的编程语言没有堆或者堆的实现不支持元组，那么也可以通过简单的改造使其支持，主要就是自定义比较逻辑即可(compareFunction)。

**模拟大顶堆**
即将原有的数全部取相反数，比如原数字是 5，就将 -5 入堆。经过这样的处理，小顶堆就可以当成大顶堆用了。不过需要注意的是，当你 pop 出来的时候， 记得也要取反，将其还原回来哦。
