# 二进制分组(Binary Grouping)

https://zerol.me/2017/08/04/group-by-binary/
https://rsk0315.hatenablog.com/entry/2019/06/19/124528

题目要求支持修改和查询操作。但是你只有一种`不支持修改`的算法，往往是通过预处理来支持快速查询操作。

- 把需要维护的元素按照个数的二进制表示，分成不超过 log𝑛 个组，构建每个组时进行一些预处理，使得每个组内都可以快速地询问信息。如果增加一个操作，分组的变化通过暴力删除和重建进行（当然如果可以合并的话那就只需要合并了）。(如 5 = 4 + 1, 6 = 4 + 2，从 5 增加到 6 就把原来那个大小为 1 的组删了，再将原来最后一个和新增加的那一个建一个大小为 2 的组)
  保证了每个节点的更新次数只有 logn 次，最多维护 logn 个块
- 与其他分治算法相比，**优势在于可以在线**
- 在线版 cdq 分治：以一个 log 的代价，让一个需要支持动态修改的问题变成不需要支持动态修改的问题。

https://www.cnblogs.com/Dfkuaid-210/p/bit_divide.html

https://www.cnblogs.com/TianMeng-hyl/p/14989441.html

[二进制分组的本质](https://www.mina.moe/archives/12681)

[尝试用二进制分组实现某些数据结构及习题](https://zhuanlan.zhihu.com/p/35519230)

---

CF710F - String Set Queries
https://www.luogu.com.cn/problem/CF710F
维护一个字符串集合，支持三种操作：

1. 插入一个字符串
2. 删除一个字符串
3. 查询集合中的所有字符串在给出的模板串中出现的次数

- 解法 1: 哈希+自然根号
- 解法 2: trie+kmp；短的串丢进 trie 维护，长的串用 kmp 维护
- **解法 3: 二进制分组 + ac 自动机**
  - 插入操作：AC 自动机比较难支持在线的修改查询
  - 删除操作：再开一个 AC 自动机记录删除的串，两个 query 的结果相减即可（满足相减性）。

---

应用：

1. 二项堆(一种可并堆)
2. 动态 AC 自动机
3. 动态凸包

---

这段文字是关于如何使用可变长度数组 D 来管理静态数据结构 T 的元素，并且如何处理添加和搜索查询的说明。以下是对这段文字的简单解释：

1. 创建一个静态数据结构的（可变长度）数组 D，同时也创建一个数组 A，用于直接存储 T 的元素。

2. 当需要添加元素 t 时，创建一个临时的 T 数组 a，并将 t 添加到 a 中。

3. 初始化 i 为 0，如果 A[i]为空，则将 a 赋值给 A[i]，并从 A[i]的元素中构建静态数据结构，将其赋值给 D[i]，然后结束。如果 A[i]不为空，则将 A[i]的所有元素添加到 a 的末尾，然后销毁 A[i]和 D[i]，将 i 加 1，然后返回步骤 2。

4. 对于搜索查询，假设 D 的元素为 d[0], ..., d[m-1]，并且 d[i]的查询结果为 q[i]，那么最终的答案可以从 q[m-1], ..., q[0]中恢复。如果恢复的方法是可交换的，那么也可以按照升序索引来获取结果。

5. 对于计算复杂性的分析，假设 A 中元素的总数为 n，那么 A[i]的元素数可以表示为 2^i。从 0 到 2^m-1 的过程中，i 位从 0 变为 1 的次数为 2^(m-i-1)，因此 D[i]的构建次数也是 2^(m-i-1)。如果构建 d[t1, ..., tk]的时间复杂性为 O(f(k))，那么构建 D[i]的时间复杂性为 O(f(2^i))，因此构建所有 D[i]的总时间复杂性为 O(f(2^i)) \* 2^(m-i-1)。如果 f(k) = O(k)，那么总时间复杂性为 O(2^(m-1))。如果 D 的最终元素数为 n，那么 D 的元素数为 ceil(log2n)，因此总时间复杂性为 O(nlogn)。搜索查询的处理时间也是原始查询时间的 log2n 倍。

6. 如果 T 是字符串或者 f(k)会因为元素的不同而变化，那么可能需要另外的分析。

7. 如果需要处理删除查询，可以创建一个用于管理已删除元素的数据结构，然后通过计算每个数据结构中元素的出现次数并进行减法运算来处理。如果不是这种情况，可能需要更多的思考。
