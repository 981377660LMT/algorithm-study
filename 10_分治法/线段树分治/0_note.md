线段树分治

离线场景下，给你若干操作，每一个操作的作用时间范围为[l,r]，然后让你求每一个时刻下 (题目要求) 的结果。或是没有说明操作时间，我们以操作个数为时间，当某些操作完全相同，则可以合并。
如果我们要求每一个时间点的答案(即查询线段树叶节点)，可以通过一次 dfs 线段树来实现。

- `如果一个数据结构可以 O(T(n)) 进行 add 操作和 undo 操作`，
  `那么可以在离线条件下做到 O(T(n)logn) remove 操作`
  https://cp-algorithms.com/data_structures/deleting_in_log_n.html
  https://blog.csdn.net/weixin_44282912/article/details/104403335
  如第 1,2,3 个操作一样的，那么我们可以在 [1,3] 的时间上都`做相同的修改`，而不必分别在 [1,1]，[2,2]，[3,3]修改，即按时间建成线段树，然后在 [1,3] 的节点上修改即可，而不必到达每一个叶节点。
  使用 undo 的方式实现'回溯删除'：要一次 dfs 就完成所有点的查询(dfs 先查左子树再右子树)，那么当我们已经查完了当前节点的左右子树，要返回 dfs 的上一层查另一个节点时就需要撤回操作。
  比如我们查完 [1,3] 后，要查 [4,6] 的时候，已经进行了 [1,3] 的操作，该怎么办？撤回对[1,3] 的所有操作。也就是每次 dfs 搜完左右子树之后就将这个点进行的操作撤回，这样对后面查询的节点就没有影响了。而 dfs 的过程就是不断进栈的过程，我们可以用堆栈来存储当前这个点的操作，然后结束之后撤回即可。

  **要求修改操作可以撤销(undo).**

- 特殊情形：第 i 个操作的作用时间范围为[0,i)+[i+1,n)，类似`除自身以外数组的乘积`
  [分治删点](%E5%88%86%E6%B2%BB%E5%88%A0%E7%82%B9.ts)
  使用持久化的方式实现'回溯删除'：此时可以在每个非叶子节点上保存一个版本，回溯撤销只需读取这个版本即可
  **不要求修改操作可以撤销(undo).**

---

updates:

https://www.luogu.com.cn/blog/yszs/xian-duan-shu-fen-zhi

考虑这一类离线问题：
`给定一个时间轴（或者设想一个），有若干个操作(可交换,commutative)在时间 l−r 中起作用。询问某一个时间某个值是什么。`

- 如果操作可删除(remove 接口)：扫描线算法, ins 和 outs 保存修改
- 如果操作难删除，但是容易撤销(undo 接口)或者拷贝(copy 接口)的总代价不大：线段树分治
  一般来说，数据结构撤销的方法包括两种：修改时拷贝(copy)、修改时记录变更(updates)
  前一种可以参考模版`mutateWithOutOne.go`，后一种可以参考可撤销并查集。
  下面把基于记录变更的撤销方法叫做`undo`，修改时拷贝的撤销方法叫做`copy`.

  线段树分治是一种处理动态修改和询问的离线算法。通过将某一元素的出现时间段在线段树上保存，我们可以 dfs 遍历整棵线段树，运用可撤销数据结构维护来得到每个时间点的答案。

  **undo 流派 和 copy 流派 什么时候用？**
  线段树分治中，使用 undo 需要`nlog(n)`次，使用 copy 需要`O(n)`次.
  实际问题中，谁的代价小就用谁.
  例如，可撤销并查集适合 undo 流派，可持久化数据结构适合 copy 流派.
  有些数据结构难以撤销，就只能使用拷贝.

  [注意到如果单次 mutate 可以 log(n)，那么单次 undo 也可以 log(n)，总复杂度 nlog(n)log(n)](https://cp-algorithms.com/data_structures/deleting_in_log_n.html)
  https://oi-wiki.org/topic/segment-tree-offline/
  即：如果一个数据结构可以以 O(a)时间修改，那么离线条件下可以以 O(alogn)的时间复杂度删除.

  注意线段树数组的 index 表示的是时间

---

Marser 的线段树分治题单
https://www.luogu.com.cn/training/5037
