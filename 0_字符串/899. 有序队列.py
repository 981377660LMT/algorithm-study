# 我们可以进行任意次数的移动。
# 在每次移动中，我们选择前 K 个字母中的一个（从左侧开始），
# 将其从原位置移除，并放置在字符串的末尾。
# 返回我们在任意次数的移动之后可以拥有的按字典顺序排列的最小字符串。

# 当 K == 1 时， 只能循环移动每个元素，无法改变相对位置。因此只需要获取循环移动过程中字典序最小的序列。
# 当 K > 1 时， 可以生成当前字符串的任意序列。因此将原字符串排序生成字典序最小的序列。
class Solution:
    def orderlyQueue(self, S: str, K: int) -> str:
        return "".join(sorted(S)) if K > 1 else min(S[i:] + S[:i] for i in range(len(S)))


# 输入：S = "baaca", K = 3
# 输出："aaabc"
# 解释：
# 在第一步中，我们将第一个字符（“b”）移动到最后，获得字符串 “aacab”。
# 在第二步中，我们将第三个字符（“c”）移动到最后，获得最终结果 “aaabc”。
