删除文件是否需要对该文件具有写权限，为什么？

删除文件不需要该文件的写权限，**需要文件所在目录**的写权限以及执行权限。
因为删除文件修改的该文件父级即其所在目录的内容，所以需要目录的写权限。
同时，删除文件先要**进入到目录**，进入是目录的一个操作，所以需要该目录的执行操作。

```BASH
mkdir a && touch a/b  #新建a目录，a下有b文件
chmod -w a && rm a/b  #去掉a的写权限，尝试去删除a/b，报 rm: a/b: Permission denied，说明删除文件需要文件所在目录有写权限
chmod +w a && chmod -w a/b && rm a/b #恢复a写权限，去掉b写权限，尝试去删除b, 删除成功，说明删除文件不需要写权限
touch b && chmod -x a && rm a/b #去掉a的执行权限 报rm: a/b: Permission denied，说明删除文件需要目录的执行权限
```

////////////////////////////////////////////////////////////////////////////////
V8 只是负责解析和运行 JS 代码。Node.js 通过 libuv 抽象封装层不同平台使用不同方法实现异步 I/O，windows 是 IOCP，\*nix 是自定义线程池
Node 的 Buffer 模块性能相关部分有 C++实现，所以 Buffer 对象的内存分配不是在 V8 的堆内存中，而是在 Node 的 C++层面实现内存申请的（Buffer 的内存虽然由 Node 的 C/C++层面实现内存申请，但是变量的回收的还是由 V8 的 GC 管理的）
////////////////////////////////////////////////////////////////////////////////
== 转换规则

1. 如果一个是 null，一个是 undefined，则它们相等

2. 如果一个是数字，一个是字符串，先将**字符串转换成数字**，然后使用转换后的值进行比较

3. 如果其中的一个值为 true，则转换成 1 再进行比较；如果其中一个值为 false，这转换成 0 再进行比较

4. 如果一个值是对象，另一个值是数字或者字符串，则将对象转换成原始值再进行比较。**转换成字符串时，会先调用 toString()**，如果没有 toString()方法或者返回的不是一个原始值，则再调用 valueOf()，如果还是不存在或者返回不是原始值，则会抛出一个类型错误的异常。返回的原始值会被转换成字符串；**如果转换成数字时，也是类似的，不过是会先调用 valueOf()**，再调用 toString()，返回的原始值会被转换成数字

5. 其他不同类型之间的比较均不相等

所以在这里使用**a 与这些字符进行比较时会被转换成数字，此时会默认调用字符串的 valueOf()方法**，我们将这个方法进行重写，用于拦截处理 a 的值
////////////////////////////////////////////////////////////////////////////////
一个 `100 * 100 Canvas` 占用内存多大
要回答这个问题，我们其实只要知道 1 \* 1 像素占用多大内存就好了。

那么 1 \* 1 像素的 Canvas 占用多大像素呢
**结果是一个像素的 Canvas 占内存是 4Byte**
可以看出其实像素信息使用 Uint8 来存储的，数组长度为 4， Uint8 占用内存为 1 个字节， 因此一共是 4 个字节，所以答案就是一个像素的 Canvas 占内存是 4Byte。
////////////////////////////////////////////////////////////////////////////////
JavaScript 的数值 Number 用 64 位的浮点数表示，首位是符号位，然后是 11 位的指数位和 52 位的小数位。如果符号位为 1，其他各位均为 0，那么这个数值会被表示成“-0”。
////////////////////////////////////////////////////////////////////////////////
Base64 Alphabet 包含 64 个基本 ASCII 字符，用于编码数据。64 个字符足以编码任何长度的任何数据。唯一的缺点是结果的大小将增加到 33％。

Base64 字母表的字符可以分为四组：

大写字母（索引 0-25）： ABCDEFGHIJKLMNOPQRSTUVWXYZ
小写字母（索引 26-51）： abcdefghijklmnopqrstuvwxyz
数字（指数 52-61）： 0123456789
特殊符号（索引 62-63）： +/

除了这些字符之外，**等号（=）用于填充**。也就是说，等号不具有索引，并且不参与数据的编码。
可以使用以下正则表达式定义 Base64 值：

```JS
^[A-Za-z0-9+/]+={0,2}$
```

////////////////////////////////////////////////////////////////////////////////
JS 中 Number 类型的可以表示的范围是多少
最大数字 1.79e+308 Number.MAX_VALUE;
`2^1023 * (1 * 2^0 + 1 * 2^-1 + ... + 1 * 2^-52)`

整数 -2^53 到 2^53(不包括边界)
`2∧52+2∧51+…+2∧1+2∧0结果为2∧53-1`
Number.MAX_SAFE_INTEGER;
64 位的双精度
![双精度浮点数代表数值](https://wikimedia.org/api/rest_v1/media/math/render/svg/1cd35e7fd85754afe6f1a77ba5842ae1581bcf87)
单精度，也即 float，一般在计算机中存储占用 4 字节，也 32 位；**双精度（double）在计算机中存储占用 8 字节，64 位**

为什么 0.1+0.2=0.30000000000000004？

```JS

// 0.1 和 0.2 都转化成二进制后再进行运算
0.00011001100110011001100110011001100110011001100110011010 +
0.0011001100110011001100110011001100110011001100110011010 =
0.0100110011001100110011001100110011001100110011001100111

// 转成十进制正好是 0.30000000000000004

```

////////////////////////////////////////////////////////////////////////////////
页面注入 50 万个 li 怎么做提升性能？

`50 万个 li 是基本不可能同时在页面上展现的。 这个时候我们需要具体地限定一下问题范围。

我们不妨假设一个 li 的宽度为 100%， 高度为 20px; 屏幕高度为 1000px. 那么也就说理论上，一个屏幕所能 容纳的最大 li 个数为为 1000 / 20 = 50 个。

因此一个简单且直观的想法是，在必要的时候我们再去 DOM 中插入。 我们可以利用“视口检测”技术判断当前是否应该去插入 li。但是这里有个问题， 就是如果用户滚动太快怎么办？ 不在视口的 DOM 需不需要回收？ 如果需要回收，我们应该怎么回收？ 这些都需要大家去思考。大家可以查一下相关的资料。

由于插入 50 个 li，如果一个一个插入肯定会不断重排，性能会很差。 我们可以考虑使用 **createDocumentFragment** 来减少重排的次数。

我们创建 50 个 li 的过程是否会涉及到后端请求，如果涉及到了，我们一次请求多少比较合适？ 我们需不需要进行预先请求。 如果本地网络 IO 很差的话，如何尽可能提高用户体验？

其实性能是一个相当主观的东西， 比如 React 使用了 fiber 架构，它的总运行时间 甚至比以前还要长，但是给用户的感觉是“性能好”。因此性能优化其实还有很多 讨巧的点可以考虑，大家不妨发散一下脑洞。
`

- 假如创建 li 的过程非常耗时，我们应该怎么去应对
  这个时候，我们可以考虑使用 webworker，将计算量比较大的任务放到别的线程去执行， 然后利用线程通信，获取返回的结果，从而避免由于 JS 运算导致主线程阻塞
- 如果本机计算性能很差，我们怎么应对
  这个时候，我们可以考虑使用类似 RIC(requestIdleCallback) 或者 RAF(requestanimationframe) 这样的 API。 保证用户正常交互的同时，完成我们的插入任务。
  ////////////////////////////////////////////////////////////////////////////////
  **CDN 的原理**
  CDN 的基本原理是广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对集中的地区或网络中，在用户访问网站时，利用全局负载技术将用户的访问指向距离最近的工作正常的缓存服务器上，由缓存服务器直接响应用户请求。
  **最简单的 CDN 网络由一个 DNS 服务器和几台缓存服务器就可以组成**，当用户输入 URL 按下回车，经过本地 DNS 系统解析，DNS 系统会最终将域名的解析权交给 CNAME 指向的 CDN 专用 DNS 服务器，然后将得到全局负载均衡设备的 IP 地址，用户向全局负载均衡设备发送内容访问请求，全局负载均衡设备将实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上，使用户可就近取得所需内容，解决 Internet 网络拥挤的状况，提高用户访问网站的响应速度
  ////////////////////////////////////////////////////////////////////////////////
  尽量不要用 undefined, 因为 undefined 既是一个类型，同时也是一个值，因此这会在某些浏览器被修改（BUG？）。 更稳妥的做法是使用 void 0 代替 undefined。
  ////////////////////////////////////////////////////////////////////////////////
  **为何设计 this 关键字**
  对象的属性可能是一个函数，当引擎遇到对象属性是函数的情况，会将函数单独保存在堆中，然后再将函数的地址赋值给对象属性；而 Javascript 是允许在函数体内引用当前环境的其他变量，那么问题来了，函数可以在不同的运行环境执行，所以我们就需要一种机制，能够在函数内获得当前运行环境，由此诞生了 this，它的设计目的就是指向**函数运行时所在的环境**。
  总结了 this 的绑定规则总共是有下面 5 种：

1、默认绑定（严格/非严格模式）
this 在严格模式下绑定到 undefined
在非严格模式下绑定到全局对象
2、隐式绑定(**对象属性执行函数**)
3、显式绑定(通过 call apply bind 绑定)
**一句话介绍 call：使用一个指定的 this 和若干个指定的参数调用某个函数或方法。**

```JS
将函数设为对象的属性
指定函数的this，并进行传参
执行&删除函数
判定如果没有指定要绑定的this，非严格模式下默认指向全局对象
```

4、new 绑定
5、ES6 箭头函数绑定
////////////////////////////////////////////////////////////////////////////////
数组和对象的关系是什么
对象的 key 可以是 string/symbol 数组的 key 是 number
