Vue 和 React 的优点分别是什么？两者的最核心差异对比是什么？
https://developer.51cto.com/art/201907/599732.htm
React 和 Vue 在理念上的差别，且对后续设计实现产生不可逆影响的是：
Vue 进行数据拦截/代理，它对侦测数据的变化更敏感、更精确，也间接对一些后续实现(比如 hooks，function based API)提供了很大的便利。这个我们后面会提到
React 推崇函数式，它直接进行局部重新刷新(或者重新渲染)，这样更粗暴，但是更简单，让我们的开发回到了上古时代，就是刷新呗，前端开发非常简单。但是 React 并不知道什么时候“应该去刷新”，触发局部重新变化是由开发者手动调用 setState 完成。

React setState 引起局部重新刷新。为了达到更好的性能，React 暴漏给开发者 shouldComponentUpdate 这个生命周期 hook，来避免不需要的重新渲染(相比之下，Vue 由于采用依赖追踪，默认就是优化状态：你动了多少数据，就触发多少更新，不多也不少，而 React 对数据变化毫无感知，它就提供 React.createElement 调用已生成 virtual dom)。
////////////////////////////////////////////////////////////
大量数据滚动加载如何保证性能足够好

- 重用你的 DOM 元素以及删除那些远离可视范围的元素
- 延迟显示的元素使用占位符
- pull 模式，而不是 push 模式

////////////////////////////////////////////////////////////

设计一个功能，前端实时地检查有没有新版本发布

- 使用 WebSocket， 当发布的时候推送到前端，前端收到通知进行更新操作
- 前端设计一套算法， 不定时地去服务端询问有没有最新的版本，有的话则进行更新

////////////////////////////////////////////////////////////

设计一个新闻列表，用户已经看过的新闻，在标题后面增加“已阅读”文字
需要做到精确么，比如用户换了手机，清了缓存要确保功能不受影响么？
是否可以换成别的交互形式，比如看过的标题改为特别的样式？

- 后端加一个字端，前端根据数据不同展示不同的样式
- 前端持久化存储，前端根据数据不同展示不同的样式
- 前端通过 CSSvisited 伪类，给已经点击的标题增加特殊样式（但是似乎无法增加文字）

////////////////////////////////////////////////////////////
React 实现的关键点

Step I 第一步: The :createElement Function 功能
Step II 第二步: The :render Function 功能
Step III 第三步: Concurrent Mode : 并发模式
Step IV 第四步: Fibers : 纤维
Step V 第五步: Render and Commit Phases 渲染和提交阶段
Step VI 第六步: Reconciliation : 和解
Step VII 第七步: Function Components : 函数组件
Step VIII 第八步: Hooks : 钩子

Babel 将 JSX 转换为 JS。转换通常很简单: 用对 createElement 的调用替换标记内部的代码，将标记名、道具和子元素作为参数传递。

```JS
const element = React.createElement(
  "h1",
  { title: "foo" },
  "Hello"
)

const element = { type: 'h1', props: { title: 'foo', children: 'Hello' } }
```

////////////////////////////////////////////////////////////
面试的时候多会问小程序的多线程架构，以及多个 webview 是如何和 JS 线程通信的，JS 线程又是如何和 native 通信的。
中介者模式
交互通过系统层的 JSBridge 进行，当用户进行操作触发了事件，通过 JSBridge 通知逻辑层，逻辑层执行对应逻辑并把数据通过 JSBridge 传递给视图层，视图层执行相应的操作。
![架构](https://lucifer.ren/fe-interview/assets/imgs/topics/mini-program/architecture-1.webp)
多线程模型：小程序有一个 JS 线程和若干个 webview，我们称之为 view 层， view 不能够执行 JS 代码，而是负责 UI 显示，它由开发者编写的 wxml 和 wxss 转换后代码以及微信提供相关辅助模块组成。
一个 view 模块对应一个 webview 组件（也就是我们常规理解的一个页面）, 小程序支持同时多个 view 存在。view 模块通过 WeixinJSBridge 对象来跟后台通信。
微信 Native 程序会预先加载一个 WebView，当打开指定页面时，无需加载额外资源直接渲染，这样会感觉 小程序会很快。
JS 线程我们称之为 service，service 模块负责应用的后台逻辑， 它由小程序的 js 代码以及微信提供的相关辅助模块组成。 一个应用只有一个 service 进程 ，它同样也是一个页面（至少在开发者工具内如此，上线后可能运行于 WeixinJSCore 之内）， 与 view 模块不同的是，它在程序生命周期内后台运行，service 模块通过与 view 模块实现不同但接口格式一样的 WeixinJSBridge 对象跟后台通信。
////////////////////////////////////////////////////////////
如何劫持这个 https 请求
![Charles抓取HTTPS原理](https://upload-images.jianshu.io/upload_images/2438937-a453e3e411efcae5.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)
简单来说，就是 Charles 作为“中间人代理”，**拿到了 服务器证书公钥 和 HTTPS 连接的对称密钥**，前提是客户端选择信任并安装 Charles 的 CA 证书，否则客户端就会“报警”并中止连接。这样看来，HTTPS 还是很安全的。
////////////////////////////////////////////////////////////
支付宝和微信的付款没网络时也可以支付是怎么做到的
1、线下支付时，用户打开支付宝 App，出示付款码（可以离线）；
2、商家用扫码枪读取付款码，并上传至支付宝服务器；
3、支付宝服务器收到商家传来的付款码后，与令牌系统里保存的信息进行对比；
4、比对通过则创建支付订单，并返回给商户订单信息，如果余额足够便可完成支付。
**付款码可以离线生成**
**付款码是一次性且实时更新**
**付款方可以离线，但收款方得在线**
////////////////////////////////////////////////////////////
输入 ping IP 后敲回车，发包前会发生什么？
如果在相同网段直接先查询 arp 缓存，如果找到目标 ip 的 mac 地址
如果不在主机的网段里，会查询默认网关 ip，接着查询 arp 缓存，是否有网关的 mac 地址记录，如果有，填充该 mac 地址，发送出去，如果没有，发 arp 问网关的 mac 地址，得到结果，发送出去。
////////////////////////////////////////////////////////////
子网掩码的左边是网络位，用二进制数字“1”表示，1 的数目等于网络位的长度；右边是主机位，用二进制数字“0”表示，0 的数目等于主机位的长度。
**当主机与同一个广播域里的其他主机通讯时就可以直接通信通过 ARP(地址解析协议) 广播即可。，如果不在同一个广播域里，就发给默认网关**。
////////////////////////////////////////////////////////////
WebSocket 工作在七层（或者四层）中的哪一层？和 HTTP 是什么关系？ 是基于 UDP 的还是 TCP 的
**应用层；双工；TCP**
////////////////////////////////////////////////////////////

Node 进程间通信有 4 种方式：

- 通过 stdin/stdout 传递：最直接的方式，适用于能够拿到“子”进程句柄的场景
- Node 原生 IPC 支持：node 封装了 IPC 的具体实现，暴露了 exec, fork 等方法，可以用于父子进程- 通讯
- 通过 sockets：最通用的方式，可以跨机器通讯
- 借助 message queue：最强大的方式，但是使用起来考虑的问题是最多的

////////////////////////////////////////////////////////////
性能优化
https://lucifer.ren/automate-everything/#/chapter4
尽量减少 HTTP 请求数这一条，**在 HTTP2 协议下就不管用了**，因为 HTTP2 实现了 HTTP 复用，HTTP 请求变少，反而降低性能。因此一定要结合历史环境看待具体的优化原则和手段，否则会适得其反。

一个应用使用一段时间就会很卡，可能是什么原因？
一个应用首屏加载时间超级长，如果让你来优化，你会怎么做？
前端常见的优化手段有哪些？
性能优化的闭环是什么？

首次渲染
假设 DNS 查询和 TLS 握手需要花费 1.6s. 那么我们只剩下 5s - 1.6s = 3.4s
国内三大运营商的 3G 网络数据理论上是 350kb/s ， 由于地地形和周边设施等因素，实际测试平均大约在 100kb/s 左右。 这里以 100kb/s 计算。

那么我们可以传输的文件大小理论上最大 为 100kb/s \* 3.4s = 340kb. 因此我们需要将我们的网站的首屏加载的文件大小总和控制在 340kb. 通常来说，**控制在 170kb 以内比较理想**。 我们按照 170kb 计算。
前面说过的 170kb 是 gzip 之后的文件大小，通常来说 gzip 对文件大小的压缩比率为 5x - 7x.
**那么压缩前文件的大小为 850kb - 1M 左右。**
////////////////////////////////////////////////////////////

模块和组件的划分依据
**根据业务划分**
是面向系统的，还是面向用户的。
面向用户的就会有频繁的变动，就会不停匹配用户的需求
**根据技术划分**
一个好的思路是分层，将基础服务下沉，将业务服务上浮。 实现了分层，但是模块间通信又是问题，目前业界比较好的解决方案是通过 MQ 和 配置中心解耦。 模块之间 并不知道自己依赖的系统或者被谁依赖，所有需要的东西动过 MQ 注册，并通过配置中心管理，解决了模块之间的通信问题。因此模块划分的另一个原则是单一职能原则。
////////////////////////////////////////////////////////////
运营商劫持
**HTTP 劫持和 DNS 劫持**
对于 DIV 注入的，可以初始化时检查全部 html 代码。
对于 js 注入，可以在 window 监听 DOMNodeInserted 事件。
对于 iframe 的情况，要检测非常简单，只需要比较 self 和 top 是否相同。

```JS
    (function (window) {
        if (window.location !== window.top.location) {
            window.top.location = window.location;
        }
    })(this);
```

////////////////////////////////////////////////////////////

- redux 里的 reducer
  (redux 的)reducer 累计的时间上的变化，(数组的)reduce 是累计空间上的变化。

```JS
fucntion reducer(state, action) {
  const nextState = {};
  // xxx
  return nextState;
}

[].reduce((state, action) => {
  const nextState = {};
  // xxx
  return nextState;
}, initialState)

```

**如何理解 reducer 是累计时间上的变化？**
我们每次通过调用 dispatch(action)的时候，都会调用 reducer，然后将 reducer 的返回值去更新 store.state。
每次 dispatch 的过程，其实就是在空间上 push(action)的过程，类似这样：

```JS
[action1, action2, action3].reduce((state, action) => {
    const nextState = {};
    // xxx
    return nextState;
}, initialState)
```

- middlewares

////////////////////////////////////////////////////////////
**http2.0 做了哪些改进 3.0 呢**
http2.0 特性如下

二进制分帧传输
多路复用
头部压缩
服务器推送
////////////////////////////////////////////////////////////
说说 CSS 选择器以及这些选择器的优先级
!important
内联样式（1000）
ID 选择器（0100）
类选择器/属性选择器/伪类选择器（0010）
元素选择器/伪元素选择器（0001）
关系选择器/通配符选择器（0000）

Boostrap 的清除浮动（display：table 创建匿名 table-cell 间接触发 BFC
类似一个 BFC 就是一个独立的行政单位的意思
