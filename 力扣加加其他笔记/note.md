1. hooks 使用数组保存
2. 队列的实际使用
   HTTP2 解决了 HTTP1.1 中的**队头阻塞**问题
   http1.0 协议规定， 对于同一个 tcp 连接，所有的 http1.0 请求放入队列中，只有前一个请求的响应收到了，才能发送下一个请求，这个时候就发生了阻塞，并且这个阻塞主要发生在客户端
   在 HTTP/1.0 中每一次请求都需要建立一个 TCP 连接，请求结束后立即断开连接
   在 HTTP/1.1 中，每一个连接都默认是长连接 (persistent connection)。对于同一个 tcp 连接，允许一次发送多个 http1.1 请求，也就是说，不必等前一个响应收到，就可以发送下一个请求。这样就解决了 http1.0 的客户端的队头阻塞，而这也就是 HTTP/1.1 中管道 (Pipeline)的概念了。
   但是，http1.1 规定，服务器端的响应的发送要根据请求被接收的顺序排队
   可见，http1.1 的队首阻塞是发生在服务器端。
   **为了解决 HTTP/1.1 中的服务端队首阻塞**，HTTP/2 采用了**二进制分帧** 和 **多路复用** 等方法
   帧是 HTTP/2 数据通信的最小单位。在 HTTP/1.1 中数据包是文本格式，而 HTTP/2 的数据包是二进制格式的，也就是二进制帧
3. 浏览器的执行栈就是一个基本的栈结构，从数据结构上说，它就是一个栈。 这也就解释了，我们用递归的解法和用循环+栈的解法本质上是差不多的。
4. React fiber 是基于链表实现
   fiber 出现的目的其实是为了解决 react 在执行的时候是无法停下来的，需要一口气执行完的问题的
5. 那么有了线性结构，我们为什么还需要非线性结构呢？ 答案是为了高效地兼顾静态操作和动态操作，我们一般使用树去管理需要大量动态操作的数据。
6. immutable 与 字典树
   immutableJS 的底层就是 share + tree
