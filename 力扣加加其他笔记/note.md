1. hooks 使用数组保存
2. 队列的实际使用
   HTTP2 解决了 HTTP1.1 中的**队头阻塞**问题
   http1.0 协议规定， 对于同一个 tcp 连接，所有的 http1.0 请求放入队列中，只有前一个请求的响应收到了，才能发送下一个请求，这个时候就发生了阻塞，并且这个阻塞主要发生在客户端
   在 HTTP/1.0 中每一次请求都需要建立一个 TCP 连接，请求结束后立即断开连接
   在 HTTP/1.1 中，每一个连接都默认是长连接 (persistent connection)。对于同一个 tcp 连接，允许一次发送多个 http1.1 请求，也就是说，不必等前一个响应收到，就可以发送下一个请求。这样就解决了 http1.0 的客户端的队头阻塞，而这也就是 HTTP/1.1 中管道 (Pipeline)的概念了。
   但是，http1.1 规定，服务器端的响应的发送要根据请求被接收的顺序排队
   可见，http1.1 的队首阻塞是发生在服务器端。
   **为了解决 HTTP/1.1 中的服务端队首阻塞**，HTTP/2 采用了**二进制分帧** 和 **多路复用** 等方法
   帧是 HTTP/2 数据通信的最小单位。在 HTTP/1.1 中数据包是文本格式，而 HTTP/2 的数据包是二进制格式的，也就是二进制帧
3. 浏览器的执行栈就是一个基本的栈结构，从数据结构上说，它就是一个栈。 这也就解释了，我们用递归的解法和用循环+栈的解法本质上是差不多的。
4. React fiber 是基于链表实现
   fiber 出现的目的其实是为了解决 react 在执行的时候是无法停下来的，需要一口气执行完的问题的
5. 那么有了线性结构，我们为什么还需要非线性结构呢？ 答案是为了高效地兼顾静态操作和动态操作，我们一般使用树去管理需要大量动态操作的数据。
6. immutable 与 字典树
   immutableJS 的底层就是 share + tree
7. AST 厉害就厉害在它本身不涉及到任何语法，因此你只要编写相应的转义规则，就可以将任何语法转义到任何语法。
   这就是 babel， PostCSS, prettier， typescript 等的原理，
8. 算法在日常开发中的应用都有哪些

   - ”我们的系统需要支持用户撤销和重做最近十次的操作。“

   1. store 可以被计算出来。因此我们只要存储 action 即可。
      比如我们要回退到第二步，我们拿出来 store1，然后和 action 运算一次，得到 store2，
      然后将 store2 覆盖到当前的 store 即可。
   2. 我们可以用树来表示我们的 store。每次修改 store，我们不是将整个 store
      销毁然后创建一个新的，而是重用可以重用的部分。

   - 巨型 Mapper 的优化
     由于业务需要，我们需要在前端缓存一些 HTTP 请求。
     我们的 key 中的前缀是有规律的，即有很多重复的数据在。 返回值也有可能是有很多重复的。
     这是一个典型的数据压缩算法。

   - 实现自动联想功能
     很多输入框都带了自动联想的功能， 很多组件库也实现了自动填充组件。
     我们可以用前缀树，很高效的完成这个工作。
   - 相似度检测
     相似度检测，我们其实可以借助“最小编辑距离”算法。
     如果编辑距离为 0 表示是相同的字符串，
     相似度为 100%。 我们可以加入自己的计算因子，将相似度
     离散在 0 - 100%之间。

9. 从大的范围上前端领域都在做什么
   架构和平台
   规范和标准化
   生态体系
10. 性能和优雅，我全都要

假如你现在开发一款类似石墨文档的多人在线协作编辑文档系统。

- 权限系统
  不同的角色可以分配不同的文件权限。 比如查看，下载，编辑，审批等。
  我们需要递归往上搜索，看有没有相应权限，如果有，则这个角色有文件的该操作权限。
  参考了 linux 的设计。
  使用一个二进制来标示一个权限有还是没有。
  只需要 4 个 bit 就可以存储权限信息
  是否可以下载/ 是否可以编辑/是否可以查看/是否可以审批
- 状态机
  我们以现实中广泛使用的有限状态机（以下简称 FSM）为例进行讲解
  FSM 应用非常广泛， 比如正则表达式的引擎，编译器的词法和语法分析，网络协议，企业应用等很多领域都会用到。
  通过状态机去控制系统内部的状态以及状态流转，逻辑会比较清晰，尤其在逻辑比较复杂的时候，这种作用越发明显。
  状态机的实际应用场景
  **匹配三的倍数**
  数字可以非常大，以至于超过 Number 的表示范围，因此我们需要用 string 来存储。

  **状态模式**
  有这样一个业务场景，我们需要设计一款答题活动，让用户过来进行答题，
  我们预先设置 N 道题目。 规则如下：
  初始状态用户会进入欢迎页面
  答对之后可以直接进入下一个题目
  答错了可以使用复活卡重新答，也可以使用过关卡，直接进入下一题
  用户可以通过其他途径获取复活卡和过关卡
  答对全部 N 道题之后用户过关，否则失败
  不管是过关还是失败都展示结果页面，只不过展示不同的文字和图片
  我会用 **FSM 来实现**

  假设我们后端服务器是一主一备，我们将所有的数据都同时存储在两个服务器上。
  假如某一天，有一份数据丢失了，我们如何快速找到有问题的服务器。
  可以抽象成【Single Number 问题】
  因此很多时候，不是缺乏应用算法的场景，
  而是缺乏这种将现实业务进行抽象为纯算法问题的能力。
  我们会被各种细枝末节的问题遮蔽双眼，无法洞察隐藏在背后的深层次的规律。

11. 浏览器的进程模型
    Chrome 采用多进程架构，其顶层存在一个 Browser process 用以协调浏览器的其它进程。
    渲染进程几乎负责 Tab 内的所有事情，渲染进程的核心目的在于转换 HTML CSS JS 为用户可交互的 web 页面。
    渲染进程由以下四个线程组成：主线程 Main thread ， 工作线程 Worker thread，光栅线程 Raster thread 和排版线程 Compositor thread。

        Main thread
        Worker thread: Web Woker 和 Service Worker 两种。

    假如我们可以涉及一个算法，智能地根据当前系统的硬件条件和网络状态，
    自动判断应该将哪部分交给工作线程，哪部分代码交给主线程，会是怎么样的场景？
