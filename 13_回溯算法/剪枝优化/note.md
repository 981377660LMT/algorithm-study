如何剪枝

1. 优先分配大的任务/优先搜索好的情况

   ```JS
   jobs.sort((a,b)=>b-a) 4088 ms
   ```

   优先分配工作量小的工作会使得工作量大的工作更有可能最后无法被分配

   `698. 划分为k个相等的子集`
   `acwing1118. 分成互质组`:优先搜索好的情况
   [1723. 完成所有工作的最短时间](%E5%A5%BD%E9%A2%981723.%20%E5%AE%8C%E6%88%90%E6%89%80%E6%9C%89%E5%B7%A5%E4%BD%9C%E7%9A%84%E6%9C%80%E7%9F%AD%E6%97%B6%E9%97%B4.ts)

2. 最优性剪枝：超过 res 立马返回，一般配合`优先搜索好的情况`使用
   ```Python
   # 关键的剪枝1:超出res就返回
   if pathSum > res:
         return
   ```
   `好题805. 数组的均值分割`
   `1255. 得分最高的单词集合`
3. 排除等效冗余：相同的工作分配只使用第一次(工人都是对称的,要去重)
   ```JS
   if (i >= 1 && workTime[i] === workTime[i - 1]) continue 76 ms
   ```
   类似于`1_全排列允许相同元素` `1_组合总和允许元素相同` `2_子集有重复元素`
   [698. 划分为 k 个相等的子集(相同的组分配只使用第一次)](698.%20%E5%88%92%E5%88%86%E4%B8%BAk%E4%B8%AA%E7%9B%B8%E7%AD%89%E7%9A%84%E5%AD%90%E9%9B%86-dfs.py)
   [691. 贴纸拼词-搜索剪枝(排列剪枝成组合)](691.%20%E8%B4%B4%E7%BA%B8%E6%8B%BC%E8%AF%8D-%E6%90%9C%E7%B4%A2%E5%89%AA%E6%9E%9D.py)
