# 前端处理并发问题的解决方案

核心原则是：
要么避免并发发生，要么正确处理并发结果。
避免并发优先，无法避免时加锁保证一致性，具体选择取决于业务场景和用户体验

- 避免并发发生

  - **请求去重与合并**：合并相同请求，减少重复发送
  - **防抖**

- 处理并发结果

  **目的：保证数据的最终一致性。**

  1. 乐观锁
     **在用户操作后立即更新 UI，提高可用性**
     例如：用户点击“点赞”，前端先将点赞数加 1，同时发送更新请求；若服务器返回冲突（例如数据版本不一致），则回滚或提示用户。

     - 版本号/时间戳检测更新冲突
     - 取消更新

  2. 悲观锁

     **在用户操作后 UI 会有锁定状态。**
     比如按钮置灰(disable)，或者显示 loading 状态，防止其他用户同时修改数据。

     - mutex

       1. 获取锁失败，被打回
          实现方式为 `locked` 字段。
       2. 获取锁失败，阻塞等待
          实现方式为 `promise + 队列`

          ```js
          // 当用户重复点击提交按钮时，会发送多次请求
          async function handleClick() {
            await doSomething()
          }

          // 此时可以保证，第一个handleClick()完全执行完后，第二个handleClick()才会执行
          async function handleClick() {
            try {
              await mu.lock()
              await doSomething()
            } finally {
              mu.unlock()
            }
          }
          ```
