# 前端处理并发问题，有合适的解决方式吗，最佳实践是什么，如何运用分布式理论分析问题 比如表单联动场景

## 并发问题

并发问题通常指多个异步操作在时间上交错执行，导致程序状态或结果依赖于不可控的执行顺序。
当用户操作频繁或有多个请求同时进行时，前端可能出现：

- **竞态条件和数据不一致**：由于异步请求返回顺序无法保证，可能出现早发出的请求晚返回，覆盖了用户更后发出的操作结果 ​。例如用户快速切换选项卡，最后停留的 Tab 内容可能被第一个 Tab 的迟返结果覆盖，导致显示错误内容。
- **重复或冲突请求**：用户多次点击提交，可能产生重复的数据提交；或者两个并发操作尝试修改同一数据，造成冲突。

## 前端处理并发问题的通用解决方案

核心原则是：要么避免并发发生，要么正确处理并发结果。

- 避免并发发生

  - **请求去重与合并**：合并请求，减少请求次数。
  - **节流和防抖**

- 处理并发结果

  **目的：保证数据的最终一致性。**
  `加锁`保证数据的最终一致性；注意前端不存在强一致性，强一致性依赖于共识。
  Consistency Models 是 safety 属性，而最终一致性是 liveness 属性。

  1. 乐观锁
     **在用户操作后立即更新 UI，提高可用性**
     例如：用户点击“点赞”，前端先将点赞数加 1，同时发送更新请求；若服务器返回冲突（例如数据版本不一致），则回滚或提示用户。

     - 版本号/时间戳检测更新冲突
     - 取消更新

  2. 悲观锁

     **在用户操作后 UI 会有锁定状态。**
     比如按钮置灰，或者显示 loading 状态，防止其他用户同时修改数据。

     - mutex

       1. 获取锁失败，被打回
          实现方式为 `locked` 字段。
       2. 获取锁失败，阻塞等待
          实现方式为 `promise + 队列`

          ```js
          // 当用户重复点击提交按钮时，会发送多次请求
          // 此时，多个函数中的 doSomething() 没有 happens-before 关系，会导致 race condition
          async function handleClick() {
            await doSomething()
          }

          // 悲观锁的实现方式
          // 此时可以保证，第一个handleClick()完全执行完后，第二个handleClick()才会执行
          async function handleClick() {
            try {
              await mu.lock()
              await doSomething()
            } finally {
              mu.unlock()
            }
          }
          ```

## 理解

1. 有时候不需要满足最终一致性。
   想一想，`不满足最终一致性的后果是什么`？
   如果用户可以接受，则不需要。最终一致性 = 没有一致性。

   在某些场景下，仅使用防抖是可接受的：
   非关键功能，UI 不一致不会导致严重后果
   用户体验要求对延迟更敏感而对一致性要求不高
   系统资源有限，需要优先考虑性能而非完美一致性
   临时方案，计划后续完善

   eg:

   ```
   问题：用户在界面上频繁操作导致某个任务的 onTrigger、onReset 中的异步代码并发执行，可能出现不预期的竞态问题。

   解决方法：
   仅通过防抖来降低并发发生的概率，而不处理并发问题。缺点是用户操作频繁时，会出现下拉选项与组件值不匹配的问题。
   不处理并发问题的原因有两点：
   此时的数据不一致不会导致不可用。用户重新修改上游字段后，下游会被重置，且用户可以通过手动输入来创建选项；
   处理并发问题的思路有两种，一种是加锁保证任务不会并发执行，另一种是让任务可以被取消，但都具有一定的实现成本。
   ```

2. cancel、版本号等方法本质是什么，用数据同步，一致性理论解释
   从数据同步和一致性理论的角度看，版本号及其替代方案的本质都是为了**提供一种机制，在多节点（或多客户端）同时对数据进行操作时，保证数据最终能够按照预期顺序合并并保持一致。**
3. 递归函数加锁会不会死锁，如何解决
   在递归函数中如果使用普通的、不可重入的锁（non-recursive lock），会很容易导致死锁。原因在于，递归调用会在同一线程中多次尝试获取同一把锁，而普通锁在同一线程中再次请求时会被阻塞，导致程序永远等待自己释放锁，从而形成死锁。

   为了解决这个问题，可以采用以下两种方法：

   - **使用递归锁（可重入锁）：**  
      递归锁`允许同一线程在持有锁的情况下多次加锁，而不会阻塞自己`。内部通常会维护一个计数器，记录加锁次数，只有当计数器归零时才真正释放锁。例如，在 C/C++ 中，可以通过设置 `pthread_mutexattr_settype` 为 `PTHREAD_MUTEX_RECURSIVE` 来创建递归锁；在 Java 中使用 `ReentrantLock`；在 Python 中使用 `threading.RLock`。

   - **调整锁粒度：**  
      如果条件允许，也可以**考虑把锁放到递归函数的外层**，只在进入递归前加锁，递归结束后再解锁，这样就避免了在递归过程中反复加锁的需求，从而避免死锁风险。

   综上所述，关键在于避免同一线程在未释放锁的情况下再次请求普通锁。如果需要在递归过程中保护共享资源，最佳实践就是使用递归锁或重新设计代码逻辑以减少锁的使用。

4. 什么时候解决并发问题只能悲观锁，而不能版本号/时间戳

悲观锁在以下场景中更为必要，此时基于版本号/时间戳的乐观锁可能失效或不适用：

---

### **1. 高并发写冲突场景**

**问题**：当多个事务频繁修改同一数据时，乐观锁的冲突检测（版本号比对）会导致大量事务回滚和重试。  
**示例**：

- 库存扣减（秒杀场景）：100 人同时抢购 1 件商品，乐观锁可能导致 99 次重试，而悲观锁直接通过行锁/排他锁保证原子性。
- 账户余额扣款：高频金融交易场景中，乐观锁的重试成本远高于悲观锁的阻塞等待。

**关键点**：

> **写冲突率 > 30%** 时，悲观锁性能更高（避免 CAS 的"自旋"开销）。

---

### **2. 强一致性要求场景**

**问题**：乐观锁在提交时才检查冲突，无法保证操作过程中的中间状态一致性。  
**示例**：

- 转账操作：A 向 B 转账需同时修改 A 和 B 的账户，悲观锁（如`SELECT FOR UPDATE`）可锁定两条记录直至事务完成。
- 订单状态流转：订单从"待支付"→"已支付"→"已发货"，需严格串行化执行。

**关键点**：

> 悲观锁通过**提前加锁**确保操作原子性和中间状态隔离。

---

### **3. 外部系统交互场景**

**问题**：若事务依赖外部系统（如第三方 API），乐观锁无法控制外部系统的状态一致性。  
**示例**：

- 支付系统：调用支付宝扣款后修改本地订单状态，若使用乐观锁，可能因本地订单版本号冲突导致支付成功但状态更新失败。
- 分布式事务：涉及多系统协作时，悲观锁（如分布式锁）更易实现全局协调。

**关键点**：

> 外部系统无法感知版本号，需通过锁保证操作的独占性。

---

### **4. 无法容忍重试的场景**

**问题**：乐观锁冲突后需重试，但某些场景重试会带来业务副作用。  
**示例**：

- 唯一性约束：用户注册时并发插入相同用户名，乐观锁重试可能导致唯一索引冲突（数据库抛异常而非业务层处理）。
- 物理资源操作：如打印机任务队列，重复提交可能导致重复打印。

**关键点**：

> 悲观锁通过阻塞避免无效的重试成本。

---

### **5. 长事务或复杂事务场景**

**问题**：乐观锁要求事务尽量短小，长事务会增加版本号冲突概率。  
**示例**：

- 数据迁移：批量处理百万级数据时，事务耗时较长，乐观锁几乎必然冲突。
- 复杂计算：先查询数据，经过复杂运算后更新，中间过程数据易被修改。

**关键点**：

> 悲观锁通过长期占用锁，保证事务执行期间数据稳定。

---

### **6. 无版本号维护的场景**

**问题**：遗留系统或某些数据库表结构无法添加版本号字段。  
**示例**：

- 历史数据表：已存在海量数据，无法通过 ALTER TABLE 新增版本号字段。
- 只读数据库副本：从库无法写入版本号，导致乐观锁机制失效。

**关键点**：

> 悲观锁（如数据库行锁）无需额外字段，直接依赖数据库原生锁机制。

---

### **总结：锁机制选型参考**

| **维度**   | **乐观锁**     | **悲观锁**               |
| ---------- | -------------- | ------------------------ |
| 冲突频率   | 低（读多写少） | 高（写密集）             |
| 一致性要求 | 最终一致性     | 强一致性                 |
| 事务时长   | 短事务         | 长事务                   |
| 重试成本   | 可接受         | 不可接受                 |
| 系统扩展性 | 适合分布式系统 | 适合单机或强一致分布式锁 |

**最终建议**：

- 优先用乐观锁：适合互联网高吞吐、低冲突场景（如社交 APP 点赞）。
- 必须用悲观锁：金融、库存、交易等对一致性和实时性要求极高的场景。

5. 并发问题：何时不能使用取消任务方法

# 并发问题：何时不能使用取消任务方法

在前端 UI 操作中，取消上一个异步任务是解决并发问题的常用方式，但以下场景中这种方法不适用：

## 1. 不可撤销的操作

- **已提交的数据库事务**：一旦事务提交，无法简单撤销
- **已发送的外部 API 调用**：特别是无幂等性 API
- **触发的物理世界动作**：如打印、设备控制
- **已发送的消息通知**：邮件、短信、消息推送等

## 2. 原子性要求高的业务

- **金融交易**：支付、转账等操作
- **库存管理**：库存扣减不能随意取消
- **关键业务记录**：如订单创建、合同签署
- **多步骤事务流程**：需要完整执行的业务逻辑

## 3. 有副作用的操作

- **产生日志记录的操作**：审计日志、操作记录
- **触发后续业务流程**：如订单支付后触发的配送流程
- **状态机转换**：系统状态已发生不可逆转换

## 4. 技术限制场景

- **使用不支持取消的 API**：某些 API 不提供取消机制
- **分布式系统协调**：跨系统操作难以统一取消
- **无法追踪的异步操作**：无法确定哪些任务需要取消

## 5. 合规与审计要求

- **需要处理所有请求**：监管要求所有操作必须被处理
- **审计追踪要求**：需要保留所有操作记录
- **数据一致性要求**：不能有"悬空"或未完成的操作

## 6. 资源与状态管理

- **共享资源锁定**：已经锁定的资源可能影响其他操作
- **取消可能导致不一致**：部分完成的操作难以清理
- **级联效应**：一个操作取消可能影响多个相关联操作

在这些场景中，应考虑使用悲观锁、事务隔离、队列处理等其他并发控制机制，而非简单的取消任务策略。
