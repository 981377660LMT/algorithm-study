# 关键点

https://taodaling.github.io/blog/2019/06/18/%E5%9B%BE%E8%AE%BA/

1.  给定一个有向图 G=(V,E)，一个顶点 u 称为关键点，当且仅当，**对于任意顶点 v，要么存在一条从 u 到 v 的路径，要么存在一条从 v 到 u 的路径**。要求找出所有的关键点。同一个强连通分量中的点要么同时都是关键点，要么都不是，我们先将强连通分量进行缩点。现在我们可以认为图中没有环。显然存在一个用 bitset 进行优化的算法，时间复杂度为 O(EV/32)
2.  一个时间复杂度为 O(V+E)的算法
    对于无环图，它实际对应一个偏序关系。那么一个关键点，实际上就是一个特殊的点，它可以与所有顶点进行比较。
    我们将图按照拓扑序进行分层。
    一个顶点如果没有出度，那么它处于第一层，否则它处在第 d+1 层，其中 d 为它能直接到达的顶点所在层的最大值。
    对于处在相同层的顶点，由于它们之间一定不存在路径，因此它们一定不能被比较。
    如果这个层中至少有两个顶点，那么这个层中的所有顶点都不是关键点。
    现在我们得出了关键点的必要条件，必须**独占一个层**，这时候可以同时推出之后的所有层次中的顶点都必定能抵达这个顶点。但是光这个还不够，**从它出发必须能抵达所有之前层的顶点**。
    我们可以遍历所有层，并且维护一个集合 S，表示目前不可达的顶点。初始的时候为空。之后按照编号从小到大遍历每一层，考虑层中的所有顶点，删除 S 中的可以被这一层的顶点抵达的那些顶点，之后把整层中的所有顶点全部加入到 S 中。如果某一层扫描完成，且 S 中只有一个元素，那么这一层中的唯一顶点就是关键点。
3.  题目 1：给定一个有向图，其中如果存在边(u,v)，那么一定满足 u>v。现在要求对于 1≤i≤n，判断从 i 是否能抵达所有编号小于它的顶点（存在一条路径）。

    按照编号扫描所有顶点，维护一个集合 S，其中存储扫描过的不可达的顶点。考虑当前扫描的顶点为 u，那么我们需要删除 S 中所有 u 可达的顶点，之后将 u 加入到 S 中。如果此时 S 中只包含 u，那么 u 满足条件。
    可以发现我们可以 O(V+E)实现上面这个算法。
