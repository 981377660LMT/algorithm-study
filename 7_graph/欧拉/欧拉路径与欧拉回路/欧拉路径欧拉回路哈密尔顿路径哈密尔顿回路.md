# 欧拉路径欧拉回路哈密尔顿路径哈密尔顿回路

### 1. 核心概念对比

| 概念                  | 定义                                    | 核心关注点      | 复杂度            |
| :-------------------- | :-------------------------------------- | :-------------- | :---------------- |
| **欧拉路径/回路**     | 经过图中**每条边**恰好一次的路径/回路   | **边 (Edge)**   | 多项式时间 (易解) |
| **哈密尔顿路径/回路** | 经过图中**每个顶点**恰好一次的路径/回路 | **点 (Vertex)** | NP-完全 (难解)    |

---

### 2. 欧拉路径与欧拉回路 (Euler Path & Circuit)

**判定条件 (充要条件)**

| 图类型     | 欧拉回路存在的条件 (起点=终点)                                   | 欧拉路径存在的条件 (起点 ≠ 终点)                                                                                             |
| :--------- | :--------------------------------------------------------------- | :--------------------------------------------------------------------------------------------------------------------------- |
| **无向图** | 1. 图是连通的 (忽略孤立点)<br>2. 所有顶点的度数都是偶数          | 1. 图是连通的<br>2. 恰好有 2 个顶点的度数为奇数 (其余均为偶数)<br>_(起点和终点必须是那两个奇度点)_                           |
| **有向图** | 1. 基图是连通的<br>2. 每个顶点的入度等于出度 ($in[v] == out[v]$) | 1. 基图是连通的<br>2. 恰好有一个顶点出度=入度+1 (起点)<br>3. 恰好有一个顶点入度=出度+1 (终点)<br>4. 其余所有顶点入度等于出度 |

**常用算法：Hierholzer 算法**

- **思路**：DFS 遍历，回溯时将节点加入路径（逆序输出即为路径）。
- **时间复杂度**：$O(V+E)$。

```cpp
// C++ 示例：Hierholzer 算法框架 (有向图)
#include <iostream>
#include <vector>
#include <stack>
#include <algorithm>

using namespace std;

// 邻接表
vector<vector<int>> adj;

// DFS 寻找欧拉回路
void dfs(int u, vector<int>& circuit) {
    // 这里使用引用来直接修改邻接表，避免重复访问边
    // 注意：实际实现中对于无向图需要标记边，对于有向图可以直接pop
    while (!adj[u].empty()) {
        int v = adj[u].back();
        adj[u].pop_back();
        dfs(v, circuit);
    }
    circuit.push_back(u);
}

int main() {
    // 假设已经构图...
    vector<int> circuit;
    dfs(0, circuit); // 从起点开始
    reverse(circuit.begin(), circuit.end());
    // 输出 circuit...
    return 0;
}
```

---

### 3. 哈密尔顿路径与哈密尔顿回路 (Hamilton Path & Cycle)

哈密尔顿问题没有像欧拉问题那样简单的度数判定公式，主要依靠搜索。

**判定与求解**

- **一般情况**：这是一个 **NP-Complete** 问题。
- **求解方法**：
  1.  **回溯法 (Backtracking)**：暴力 DFS 搜索，尝试所有可能的排列。时间复杂度约为 $O(N!)$。
  2.  **状态压缩 DP (State Compression DP)**：适用于节点数较小 ($N \le 20$) 的情况。

**状态压缩 DP 详解**

- **状态定义**：$dp[mask][i]$ 表示经过了 $mask$ 集合中的点（二进制位为 1 表示经过），且当前停留在节点 $i$ 的合法性（或最短路径长度）。
- **转移方程**：
  $$dp[mask | (1 \ll j)][j] = \text{true/min\_cost} \quad \text{if } dp[mask][i] \text{ is valid AND } (i, j) \in E$$
- **时间复杂度**：$O(2^N \cdot N^2)$。

```cpp
// C++ 示例：状态压缩 DP 求解哈密尔顿路径是否存在
#include <vector>
#include <iostream>

using namespace std;

bool hamiltonPath(int n, vector<vector<int>>& graph) {
    // dp[mask][i]
    vector<vector<bool>> dp(1 << n, vector<bool>(n, false));

    // 初始化：只经过起点本身是合法的
    for (int i = 0; i < n; i++) {
        dp[1 << i][i] = true;
    }

    for (int mask = 1; mask < (1 << n); mask++) {
        for (int i = 0; i < n; i++) {
            if (mask & (1 << i)) { // 如果 i 在 mask 中
                int prev_mask = mask ^ (1 << i);
                if (prev_mask == 0) continue;

                for (int j = 0; j < n; j++) {
                    if ((prev_mask & (1 << j)) && graph[j][i]) { // j 在 prev_mask 中且 j->i 有边
                        if (dp[prev_mask][j]) {
                            dp[mask][i] = true;
                            break;
                        }
                    }
                }
            }
        }
    }

    // 检查是否有全集掩码且以任意点结束的路径
    int full_mask = (1 << n) - 1;
    for (int i = 0; i < n; i++) {
        if (dp[full_mask][i]) return true;
    }
    return false;
}
```

### 总结对比

| 特性         | 欧拉问题                                                   | 哈密尔顿问题                                 |
| :----------- | :--------------------------------------------------------- | :------------------------------------------- |
| **复杂度**   | 线性 $O(E)$                                                | 指数级 $O(2^N)$ 或阶乘级                     |
| **应用场景** | 可以在不重复画线的情况下画出图形、DNA 片段重组、送信员问题 | 旅行商问题 (TSP, 带权哈密尔顿回路)、灰码生成 |
| **算法策略** | DFS / Hierholzer                                           | 状态压缩 DP / 回溯 / 启发式搜索              |
