这类题一般是 dijkstra 模板+ **带权重的 visited** `根据限制条件控制是否再入堆`
考虑遍历最小费用，如果同一个城市出现更多费用，但是可以获得更多时间的时候，
这类题一般是 dijkstra 模板 + visited 控制再入堆的条件：如果还没看过这个点，或者当前的限制条件比之前更优，则加入堆

```Python
pq: List[Tuple[Cost, ID, Time]] = [(passingFees[0], 0, 0)]
```

模板题：
`1928. 规定时间内到达终点的最小花费.py`
**多一个时间限制**
使用 visited`记录每个结点的time来控制入队`

`787. K 站中转内最便宜的航班.py`
**多一个辗转次数限制**
使用 k 来控制入队

`LCP 35. 电动车游城市.py `
**多一个加油限制**
两个维度的 visited 数组
使用两个维度来控制是将状态否继续入队
