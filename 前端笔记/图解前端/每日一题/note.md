删除文件是否需要对该文件具有写权限，为什么？

删除文件不需要该文件的写权限，**需要文件所在目录**的写权限以及执行权限。
因为删除文件修改的该文件父级即其所在目录的内容，所以需要目录的写权限。
同时，删除文件先要**进入到目录**，进入是目录的一个操作，所以需要该目录的执行操作。

```BASH
mkdir a && touch a/b  #新建a目录，a下有b文件
chmod -w a && rm a/b  #去掉a的写权限，尝试去删除a/b，报 rm: a/b: Permission denied，说明删除文件需要文件所在目录有写权限
chmod +w a && chmod -w a/b && rm a/b #恢复a写权限，去掉b写权限，尝试去删除b, 删除成功，说明删除文件不需要写权限
touch b && chmod -x a && rm a/b #去掉a的执行权限 报rm: a/b: Permission denied，说明删除文件需要目录的执行权限
```

////////////////////////////////////////////////////////////////////////////////
V8 只是负责解析和运行 JS 代码。Node.js 通过 libuv 抽象封装层不同平台使用不同方法实现异步 I/O，windows 是 IOCP，\*nix 是自定义线程池
Node 的 Buffer 模块性能相关部分有 C++实现，所以 Buffer 对象的内存分配不是在 V8 的堆内存中，而是在 Node 的 C++层面实现内存申请的（Buffer 的内存虽然由 Node 的 C/C++层面实现内存申请，但是变量的回收的还是由 V8 的 GC 管理的）
////////////////////////////////////////////////////////////////////////////////
== 转换规则

1. 如果一个是 null，一个是 undefined，则它们相等

2. 如果一个是数字，一个是字符串，先将**字符串转换成数字**，然后使用转换后的值进行比较

3. 如果其中的一个值为 true，则转换成 1 再进行比较；如果其中一个值为 false，这转换成 0 再进行比较

4. 如果一个值是对象，另一个值是数字或者字符串，则将对象转换成原始值再进行比较。**转换成字符串时，会先调用 toString()**，如果没有 toString()方法或者返回的不是一个原始值，则再调用 valueOf()，如果还是不存在或者返回不是原始值，则会抛出一个类型错误的异常。返回的原始值会被转换成字符串；**如果转换成数字时，也是类似的，不过是会先调用 valueOf()**，再调用 toString()，返回的原始值会被转换成数字

5. 其他不同类型之间的比较均不相等

所以在这里使用**a 与这些字符进行比较时会被转换成数字，此时会默认调用字符串的 valueOf()方法**，我们将这个方法进行重写，用于拦截处理 a 的值
////////////////////////////////////////////////////////////////////////////////
一个 `100 * 100 Canvas` 占用内存多大
要回答这个问题，我们其实只要知道 1 \* 1 像素占用多大内存就好了。

那么 1 \* 1 像素的 Canvas 占用多大像素呢
**结果是一个像素的 Canvas 占内存是 4Byte**
可以看出其实像素信息使用 Uint8 来存储的，数组长度为 4， Uint8 占用内存为 1 个字节， 因此一共是 4 个字节，所以答案就是一个像素的 Canvas 占内存是 4Byte。
////////////////////////////////////////////////////////////////////////////////
JavaScript 的数值 Number 用 64 位的浮点数表示，首位是符号位，然后是 11 位的指数位和 52 位的小数位。如果符号位为 1，其他各位均为 0，那么这个数值会被表示成“-0”。
////////////////////////////////////////////////////////////////////////////////
Base64 Alphabet 包含 64 个基本 ASCII 字符，用于编码数据。64 个字符足以编码任何长度的任何数据。唯一的缺点是结果的大小将增加到 33％。

Base64 字母表的字符可以分为四组：

大写字母（索引 0-25）： ABCDEFGHIJKLMNOPQRSTUVWXYZ
小写字母（索引 26-51）： abcdefghijklmnopqrstuvwxyz
数字（指数 52-61）： 0123456789
特殊符号（索引 62-63）： +/

除了这些字符之外，**等号（=）用于填充**。也就是说，等号不具有索引，并且不参与数据的编码。
可以使用以下正则表达式定义 Base64 值：

```JS
^[A-Za-z0-9+/]+={0,2}$
```

////////////////////////////////////////////////////////////////////////////////
JS 中 Number 类型的可以表示的范围是多少
最大数字 1.79e+308 Number.MAX_VALUE;
`2^1023 * (1 * 2^0 + 1 * 2^-1 + ... + 1 * 2^-52)`

整数 -2^53 到 2^53-1(包括边界)
`2∧52+2∧51+…+2∧1+2∧0结果为2∧53-1`
Number.MAX_SAFE_INTEGER;
64 位的双精度
![双精度浮点数代表数值](https://wikimedia.org/api/rest_v1/media/math/render/svg/1cd35e7fd85754afe6f1a77ba5842ae1581bcf87)
单精度，也即 float，一般在计算机中存储占用 4 字节，也 32 位；**双精度（double）在计算机中存储占用 8 字节，64 位**

为什么 0.1+0.2=0.30000000000000004？

```JS

// 0.1 和 0.2 都转化成二进制后再进行运算
0.00011001100110011001100110011001100110011001100110011010 +
0.0011001100110011001100110011001100110011001100110011010 =
0.0100110011001100110011001100110011001100110011001100111

// 转成十进制正好是 0.30000000000000004

```

////////////////////////////////////////////////////////////////////////////////
页面注入 50 万个 li 怎么做提升性能？

`50 万个 li 是基本不可能同时在页面上展现的。 这个时候我们需要具体地限定一下问题范围。

我们不妨假设一个 li 的宽度为 100%， 高度为 20px; 屏幕高度为 1000px. 那么也就说理论上，一个屏幕所能 容纳的最大 li 个数为为 1000 / 20 = 50 个。

因此一个简单且直观的想法是，在必要的时候我们再去 DOM 中插入。 我们可以利用“视口检测”技术判断当前是否应该去插入 li。但是这里有个问题， 就是如果用户滚动太快怎么办？ 不在视口的 DOM 需不需要回收？ 如果需要回收，我们应该怎么回收？ 这些都需要大家去思考。大家可以查一下相关的资料。

由于插入 50 个 li，如果一个一个插入肯定会不断重排，性能会很差。 我们可以考虑使用 **createDocumentFragment** 来减少重排的次数。

我们创建 50 个 li 的过程是否会涉及到后端请求，如果涉及到了，我们一次请求多少比较合适？ 我们需不需要进行预先请求。 如果本地网络 IO 很差的话，如何尽可能提高用户体验？

其实性能是一个相当主观的东西， 比如 React 使用了 fiber 架构，它的总运行时间 甚至比以前还要长，但是给用户的感觉是“性能好”。因此性能优化其实还有很多 讨巧的点可以考虑，大家不妨发散一下脑洞。
`

- 假如创建 li 的过程非常耗时，我们应该怎么去应对
  这个时候，我们可以考虑使用 webworker，将计算量比较大的任务放到别的线程去执行， 然后利用线程通信，获取返回的结果，从而避免由于 JS 运算导致主线程阻塞
- 如果本机计算性能很差，我们怎么应对
  这个时候，我们可以考虑使用类似 RIC(requestIdleCallback) 或者 RAF(requestanimationframe) 这样的 API。 保证用户正常交互的同时，完成我们的插入任务。
  ////////////////////////////////////////////////////////////////////////////////
  **CDN 的原理**
  CDN 的基本原理是广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对集中的地区或网络中，在用户访问网站时，利用全局负载技术将用户的访问指向距离最近的工作正常的缓存服务器上，由缓存服务器直接响应用户请求。
  **最简单的 CDN 网络由一个 DNS 服务器和几台缓存服务器就可以组成**，当用户输入 URL 按下回车，经过本地 DNS 系统解析，DNS 系统会最终将域名的解析权交给 CNAME 指向的 CDN 专用 DNS 服务器，然后将得到全局负载均衡设备的 IP 地址，用户向全局负载均衡设备发送内容访问请求，全局负载均衡设备将实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上，使用户可就近取得所需内容，解决 Internet 网络拥挤的状况，提高用户访问网站的响应速度
  ////////////////////////////////////////////////////////////////////////////////
  尽量不要用 undefined, 因为 undefined 既是一个类型，同时也是一个值，因此这会在某些浏览器被修改（BUG？）。 更稳妥的做法是使用 void 0 代替 undefined。
  ////////////////////////////////////////////////////////////////////////////////
  **为何设计 this 关键字**
  对象的属性可能是一个函数，当引擎遇到对象属性是函数的情况，会将函数单独保存在堆中，然后再将函数的地址赋值给对象属性；而 Javascript 是允许在函数体内引用当前环境的其他变量，那么问题来了，函数可以在不同的运行环境执行，所以我们就需要一种机制，能够在函数内获得当前运行环境，由此诞生了 this，它的设计目的就是指向**函数运行时所在的环境**。
  总结了 this 的绑定规则总共是有下面 5 种：

1、默认绑定（严格/非严格模式）
this 在严格模式下绑定到 undefined
在非严格模式下绑定到全局对象
2、隐式绑定(**对象属性执行函数**)
3、显式绑定(通过 call apply bind 绑定)
**一句话介绍 call：使用一个指定的 this 和若干个指定的参数调用某个函数或方法。**

```JS
将函数设为对象的属性
指定函数的this，并进行传参
执行&删除函数
判定如果没有指定要绑定的this，非严格模式下默认指向全局对象
```

4、new 绑定
5、ES6 箭头函数绑定
////////////////////////////////////////////////////////////////////////////////
数组和对象的关系是什么
对象的 key 可以是 string/symbol 数组的 key 是 number
////////////////////////////////////////////////////////////////////////////////
[cookie 讲解](https://github.com/mqyqingfeng/Blog/issues/157)
跨域:域名/端口/协议必须相同
跨站:
Cookie 中的「同站」判断就比较宽松：只要两个 URL 的 eTLD+1 相同即可
**eTLD 表示有效顶级域名**
举几个例子，www.taobao.com 和 www.baidu.com 是跨站，www.a.taobao.com 和 www.b.taobao.com 是同站，a.github.io 和 b.github.io 是跨站(注意是跨站)。

SameSite 属性可以让 Cookie 在`跨站`请求时不会被发送，从而可以阻止跨站请求伪造攻击（CSRF）。
之前默认是 None 的，Chrome80 后默认是 Lax。

SameSite 可以有下面三种值：
Strict 仅允许一方请求携带 Cookie，即浏览器将只发送相同站点请求的 Cookie，即当前网页 URL 与请求目标 URL 完全一致。
Lax 允许部分第三方请求携带 Cookie
None 无论是否跨站都会发送 Cookie

解决方案就是设置 SameSite 为 none。但是必须 https
HTTP 接口不支持 SameSite=none
////////////////////////////////////////////////////////////////////////////////
css 怎么开启硬件加速(GPU 加速)
浏览器在处理下面的 css 的时候，会使用 GPU 渲染

transform（当 3D 变换的样式出现时会使用 GPU 加速）
opacity
filter
will-change
////////////////////////////////////////////////////////////////////////////////
flex:1 是哪些属性组成的
flex 实际上是 flex-grow、flex-shrink 和 flex-basis 三个属性 1 1 0 的缩写。

flex-grow：定义项目的的放大比例
默认为 0，即 即使存在剩余空间，也不会放大；
所有项目的 flex-grow 为 1：等分剩余空间（自动放大占位）；
flex-grow 为 n 的项目，占据的空间（放大的比例）是 flex-grow 为 1 的 n 倍。

flex-basis： 定义在分配多余空间之前，项目占据的主轴空间（main size），浏览器根据此属性计算主轴是否有多余空间
`默认值为 auto，即 项目原本大小；`
设置后项目将占据固定空间。

////////////////////////////////////////////////////////////////////////////////
协商缓存命中返回 304 (from disk)
请求头 If-Modified-Since 的日期与响应头的 last-modified 一致
请求头 if-none-match 的 hash 与响应头的 If-Match 里的 etag 一致
这两种情况会返回 Status Code: 304
强缓存命中返回 200 200（from cache）

```JS
- 浏览器地址栏中写入URL，回车浏览器发现缓存中有这个文件了，不用继续请求了，直接去缓存拿（最快）
- F5就是告诉浏览器，别偷懒，好歹去服务器看看这个文件是否有过期了。于是浏览器就胆胆襟襟的发送一个请求带上If-Modify-since
- Ctrl+F5告诉浏览器，你先把你缓存中的这个文件给我删了，然后再去服务器请求个完整的资源文件下来。于是客户端就完成了强行更新的操作

作者：子弈
链接：https://juejin.cn/post/6844903928442667015
来源：掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

////////////////////////////////////////////////////////////////////////////////
HTML5 新接口，可以改变网址(存在跨域限制)而不刷新页面，这个强大的特性后来用到了单页面应用如：vue-router，react-router-dom 中。
用 history.pushState()或者 history.replaceState()不会触发 popstate 事件
popstate 事件会在点击后退、前进按钮(或调用 history.back()、history.forward()、history.go()方法)时触发
////////////////////////////////////////////////////////////////////////////////

```JS
Function.prototype === Function.__proto__; //true
```

////////////////////////////////////////////////////////////////////////////////
![require 基本原理](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f1dbabee4d849d3a3e018c91f04c619~tplv-k3u1fbpfcp-watermark.awebp)

```JS

{
  "a.js": "hello world",
  "b.js": function add(){},
  "c.js": 2,
  "d.js": { num: 2 }
}

```

////////////////////////////////////////////////////////////////////////////////
![浏览器渲染过程](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/8/30/16ce245b8f160035~tplv-t2oaga2asx-watermark.awebp)
解析 HTML，生成 DOM 树
解析 CSS，生成 CSSOM 树
将 DOM 树和 CSSOM 树结合，生成渲染树(Render Tree)
Layout(回流)：根据生成的渲染树，进行回流(Layout)，得到节点的几何信息（位置，大小）
Painting(重绘)：根据渲染树以及回流得到的几何信息，得到节点的绝对像素
Display：将像素发送给 GPU，展示在页面上。（这一步其实还有很多内容，比如会在 GPU 将多个合成层合并为同一个层，并展示在页面中。而 css3 硬件加速的原理则是新建合成层，这里我们不展开，之后有机会会写一篇博客）

链接：https://juejin.cn/post/6844903928442667015

////////////////////////////////////////////////////////////////////////////////
伪类和伪元素的区别
比如说，当用户悬停在指定的元素时，我们可以通过:hover 来描述这个元素的状态
伪元素用于创建一些不在文档树中的元素，并为其添加样式。比如说，我们可以通过:before 来在一个元素前增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在文档树中。
伪类与伪元素的区别在于：**有没有创建一个文档树之外的元素。**
CSS3 规范中的要求使用**双冒号(::)表示伪元素**，以此来区分伪元素和伪类，比如::before 和::after 等伪元素使用双冒号(::)，**:hover 和:active 等伪类使用单冒号(:)**
////////////////////////////////////////////////////////////////////////////////
Vue 一定要研究源码
https://juejin.cn/post/6961222829979697165
////////////////////////////////////////////////////////////////////////////////
Vue 的数据为什么频繁变化但只会更新一次
**Vue 源码的实现过程要详细说出**
只要有一个问题答的非常出彩，仍然可以弥补那些没答上来的问题
////////////////////////////////////////////////////////////////////////////////
206 Partial Content
HTTP 206 Partial Content 成功状态响应代码表示请求已成功
