1. JavaScript 中不同类型以及不同环境下变量的内存都是何时释放?
   引用类型:是在没有引用之后, 通过 v8 的 GC 自动回收
   值类型:如果是处于闭包的情况下, 要等闭包没有引用才会被 GC 回收, 非闭包的情况下等待 v8 的新生代 (new space) 切换的时候回收
2. a.js 和 b.js 两个文件互相 require 是否会死循环? 双方是否能导出变量? 如何从设计上避免这种问题?
   CommonJS 的做法是，一旦出现某个模块被"循环加载"，**就只输出已经执行的部分，还未执行的部分不会输出。**
   ES6 模块的运行机制与 CommonJS 不一样，它遇到模块加载命令 import 时，不会去执行模块，而是只生成一个引用。等到真的需要用到时，再到模块里面去取值。
   **ES6 根本不会关心是否发生了"循环加载"，只是生成一个指向被加载模块的引用**，需要开发者自己保证，真正取值的时候能够取到值。
   不会, 先执行的导出其 未完成的副本, 通过导出工厂函数让对方从函数去拿比较好避免
3. 如果 a.js require 了 b.js, 那么在 b 中定义全局变量 t = 111 能否在 a 中直接打印出来
   每个 .js 能独立一个环境只是因为 node 帮你在外层**包了一圈自执行**, 所以你使用 t = 111 定义全局变量在其他地方当然能拿到.

   ```JS
      // b.js
    (function (exports, require, module, __filename, __dirname) {
      t = 111;
    })();

    // a.js
    (function (exports, require, module, __filename, __dirname) {
      // ...
      console.log(t); // 111
    })();
   ```

4. 如何在不重启 node 进程的情况下热更新一个 js/json 文件? 这个问题本身是否有问题?
   可以清除掉 require.cache 的缓存重新 require(xxx), 视具体情况还可以用 VM 模块重新执行.
   主要是 require 会有一个 cache, 有这个 cache 在, 即使你更新了 .js 文件, 在代码中再次 require 还是会拿到之前的编译好缓存在 v8 内存 (code space) 中的的旧代码
5. module.exports 和 exports 的区别
   exports 只是 module.exports 的一个引用.
6. Eventemitter 的 emit 是同步还是异步?
   Node.js 中 Eventemitter 的 emit 是同步的
7. 如何判断接口是否异步? 是否只要有回调函数就是异步?
   开放性问题, 每个写 node 的人都有一套自己的判断方式.

   看文档
   console.log 打印看看
   看是否有 IO 操作
   单纯使用回调函数并不会异步, IO 操作才可能会异步, 除此之外还有使用 setTimeout 等方式实现异步.

8. nodejs 与浏览器事件循环差异
   node 中事件循环的实现是**依靠的 libuv 引擎**
   浏览器和 Node 环境下，microtask 任务队列的执行时机不同
   Node 端，**微任务** 在事件循环的**各个阶段之间**执行
   浏览器端，**微任务** 在事件循环的 **宏任务** 执行完之后执行
   nodejs 事件循环六部

   **轮**询阶段(poll)：检索新的 I/O 事件;执行与 I/O 相关的回调（几乎所有情况下，除了关闭的回调函数，那些由计时器和 setImmediate() 调度的之外），其余情况 node 将在适当的时候在此阻塞。
   **检**查阶段(check)：**setImmediate**() 回调函数在这里执行
   **关**闭事件回调阶段(close callback)：一些关闭的回调函数，如：socket.on(‘close’, …)。
   **定**时器检测阶段(timers)：本阶段执行 **timer** 的回调，即 setTimeout、setInterval 里面的回调函数。
   I/O 事件**回**调阶段(I/O callbacks)：执行延迟到下一个循环迭代的 I/O 回调，即上一轮循环中未被执行的一些 I/O 回调。
   **闲**置阶段(idle, prepare)：仅系统内部使用。
   轮 检 关 定 回 闲

   node 的事件循环的阶段顺序为：
   输入数据阶段(incoming data)->轮询阶段(poll)->检查阶段(check)->关闭事件回调阶段(close callback)->定时器检测阶段(timers)->I/O 事件回调阶段(I/O callbacks)->闲置阶段(idle, prepare)->轮询阶段…
   日常开发中的绝大部分异步任务都是在 poll、check、timers 这 3 个阶段处理的

9. nextTick, setTimeout 以及 setImmediate 三者有什么区别?
   **nextTick 就是执行完当前代码后立即执行**
   **setImmediate 就是在下一个 tick 中执行**
   它俩的名字和作用正好相反

   macro-task: script (整体代码)，setTimeout, setInterval, setImmediate, I/O, UI rendering.
   micro-task: process.nextTick, Promise(原生)，Object.observe，MutationObserver
   除了 script 整体代码，micro-task 的任务优先级高于 macro-task 的任务优先级。
   其中，script(整体代码) ，可以理解为待执行的所有代码。
   理解：**nextTick 是加到队列头，setImmediate 是加到队列尾。**

10. 进程的当前工作目录是什么? 有什么作用?
    一些获取配置的第三方模块就是通过你的当前目录来找配置文件的. 所以如果你错误的目录启动脚本, 可能没法得到正确的结果. 在程序中可以通过 process.chdir() 来改变当前的工作目录.
11. child_process.fork 与 POSIX 的 fork 有什么区别?
    Node.js 的 child_process.fork() 在 Unix 上的实现最终调用了 **POSIX fork(2)**, 而 POSIX 的 fork 需要手动管理子进程的资源释放 (waitpid),child_process.fork 则不用关心这个问题, Node.js 会自动释放, 并且可以在 option 中选择父进程死后是否允许子进程存活.
12. **child.kill 与 child.send 的区别**
    一个是基于信号系统, 一个是基于 IPC.(Inter-Process Communication 进程间通信)
13. 父进程或子进程的死亡是否会影响对方? 什么是孤儿进程?
    子进程死亡不会影响父进程
    父进程死亡, 一般情况下子进程也会随之死亡, 但如果此时子进程处于可运行态、僵死状态等等的话, 子进程将被**进程 1（init 进程）收养**，从而成为孤儿进程
    另外, 子进程死亡的时候（处于“终止状态”），父进程没有及时调用 wait() 或 waitpid() 来返回死亡进程的相关信息，此时子进程还有一个 **PCB（Process Control Block 进程管理块） 残留在进程表中，被称作僵尸进程.**
14. cluster 是如何保证负载均衡的
    Cluster 是常见的 Node.js 利用多核的办法. 它是基于 child_process.fork() 实现的
    **所以 cluster 产生的进程之间是通过 IPC 来通信的,**
    cluster 模块提供了两种分发连接的方式.

    第一种方式 (默认方式, 不适用于 windows), 通过**时间片轮转法**（round-robin）分发连接. 主进程监听端口, 接收到新连接之后, 通过时间片轮转法来决定将接收到的客户端的 socket 句柄传递给指定的 worker 处理. 至于每个连接由哪个 worker 来处理, 完全由内置的循环算法决定.

    第二种方式是**由主进程创建 socket 监听端口**后, **将 socket 句柄直接分发给相应的 worker**, 然后当连接进来时, 就直接由相应的 worker 来接收连接并处理.

    使用第二种方式时理论上性能应该较高, 然后时间上存在负载不均衡的问题, 比如通常 70% 的连接仅被 8 个进程中的 2 个处理, 而其他进程比较清闲.

15. 进程间通信?
    Node.js 中的 IPC 通信是由 libuv 通过管道技术实现的
    IPC (Inter-process communication) ，即进程间通信技术，由于每个进程创建之后都有自己的独立地址空间，实现 IPC 的目的就是**进程之间资源共享访问**
    实现 IPC 的方式有多种：管道、消息队列、信号量、Domain Socket，Node.js 通过 pipe 来实现。
16. 在 IPC 通道建立之前, 父进程与子进程是怎么通信的? 如果没有通信, 那 IPC 是怎么建立的?
    使用环境变量传递 fd;传递 fd 其实是直接传递了一个整型数字
17. 什么是守护进程? 如何实现守护进程
    普通的进程, 在用户退出终端之后就会直接关闭.
    通过 & 启动到后台的进程, 之后会由于会话（session 组）被回收而终止进程.
    **守护进程是不依赖终端（tty）的进程, 不会因为用户退出终端而停止运行的进程.**
    创建步骤

    1. 创建子进程
    2. 在子进程中创建新会话（调用系统函数 setsid）
    3. 改变子进程工作目录（如：“/” 或 “/usr/ 等）
    4. 父进程终止

18. Node.js 是单线程还是多线程？进一步会提问为什么是单线程？
    Javascript 是单线程的，但是做为其在服务端运行环境的 Node.js 并非是单线程的。
19. 如何让一个 js 文件在 Linux 下成为一个可执行命令程序?
    1. 新建 hello.js 文件，头部须加上 #!/usr/bin/env node，表示当前脚本使用 Node.js 进行解析
    2. 赋予文件可执行权限 chmod +x chmod +x /${dir}/hello.js，目录自定义
    3. 在 /usr/local/bin 目录下创建一个软链文件 sudo ln-s/${dir}/hello.js/usr/local/bin/hello，文件名就是我们在终端使用的名字
    4. 终端执行 hello 相当于输入 node hello.js
20. Buffer 一般用于处理什么数据? 其长度能否动态变化?
    Buffer 是 Node.js 中用于**处理二进制数据**的类, 其中与 IO 相关的操作 (网络/文件等) 均基于 Buffer. Buffer 类的实例非常类似整数数组, 但其**大小是固定不变的**, 并且其**内存在 V8 堆栈外分配原始内存空间**. Buffer 类的实例创建之后, 其所占用的内存大小就不能再进行调整.
21. Buffer.from() 根据已有数据生成一个 Buffer 对象
    Buffer.alloc() 创建一个初始化后的 Buffer 对象
    Buffer.allocUnsafe() 创建一个未初始化的 Buffer 对象
22. Buffer 的实现
    Node.js 的 Buffer 在 ES6 增加了 TypedArray 类型之后, 修改了原来的 Buffer 的实现, **选择基于 TypedArray 中 Uint8Array 来实现**, 从而提升了一波性能.
23. Stream 的 highWaterMark 与 drain 事件是什么? 二者之间的关系是?
    Readable 和 Writable 流都会将数据储存在内部的缓冲区.构造 stream 时候的 highWaterMark 标志指定可容纳的 byte 大小
    可读流:当缓冲区中的数据到达 highWaterMark 指定的阈值, 可读流将停止从底层汲取数据, 直到当前缓冲的报备成功消耗为止 s
    可写流:如果当前缓冲区的缓冲的数据量低于 highWaterMark 设定的值, 调用 writable.write() 方法会返回 true (表示数据已经写入缓冲区), 否则当缓冲的数据量达到了阈值, 数据无法写入缓冲区 write 方法会返回 false, **直到 drain 事件触发之后才能继续调用 write 写入.**
24. Stream 的 pipe 的作用是? 在 pipe 的过程中数据是引用传递还是拷贝传递?
    stream 的 .pipe(), **将一个可写流附到可读流上** pipe 方法最主要的目的就是将数据的流动缓冲到一个可接受的水平, 不让不同速度的数据源之间的差异导致内存被占满
    在创建流对象的时候, 可以通过提供 objectMode 参数来生成对象模式的流. 在 pipe 传递数据的过程中, objectMode 是传递引用, 非 objectMode 则是拷贝一份数据传递下去.
25. 什么是文件描述符? 输入流/输出流/错误流是什么?
    “一切皆是文件”是 Unix/Linux 的基本哲学之一, 不仅普通的文件、目录、字符设备、块设备、套接字等在 Unix/Linux 中都是以文件被对待, 也就是说这些资源的操作对象均为 fd **(文件描述符)**
    Linux/unix 的 fd 都被设计为整型数字, 从 0 开始

    ```JS
    console.log(process.stdin.fd); // 0
    console.log(process.stdout.fd); // 1
    console.log(process.stderr.fd); // 2
    ```

    stdio (standard input output) 标准的输入输出流, 即输入流 (stdin), 输出流 (stdout), 错误流 (stderr) 三者. 在 Node.js 中分别对应 process.stdin (Readable), process.stdout (Writable) 以及 process.stderr (Writable) 三个 stream.
    以 C 语言的伪代码来看的话, 这类输出函数的实现思路如下:

    ```C++
         int printf(FILE *stream, 要打印的内容)
      {
      // ...

      // 1. 申请一个临时内存空间
      char *s = malloc(4096);

      // 2. 处理好要打印的的内容, 其值存储在 s 中
      //      ...

      // 3. 将 s 上的内容写入到 stream 中
      fwrite(s, stream);

      // 4. 释放临时空间
      free(s);

      // ...
      }

    ```

26. console.log 是同步还是异步? 如何实现一个 console.log?
    console.log 同步还是异步取决于与谁相连
    ```JS
    let print = (str) => process.stdout.write(str + '\n');
    print('hello world');
    ```
27. 如何同步的获取用户的输入?
    获取用户的输入其实就是读取 Node.js 进程中的输入流 (即 process.stdin 这个 stream) 的数据.而要同步读取, 则是不用异步的 read 接口, 而是用同步的 readSync 接口去读取 stdin 的数据即可实现.
28. Readline 是如何实现的? (有思路即可)
    readline 模块提供了一个用于从 Readble 的 stream (例如 process.stdin) 中一次读取一行的接口
    realine 在读取 TTY 的数据时, 是通过 **input.on('keypress', onkeypress)** 时发现用户按下了回车键来判断是新的 line 的, 而读取一般的 stream 时, 则是通过缓存数据然后用**正则** .test 来判断是否为 new line 的.
29. REPL:Read-Eval-Print-Loop (REPL)
30. cookie 与 session 的区别? 服务端如何清除 cookie?
    主要区别在于, session 存在服务端, cookie 存在客户端. session 比 cookie 更安全. 而且 cookie 不一定一直能用 (可能被浏览器关掉). 服务端可以通过设置 cookie 的值为空并后端设置 expires 或者 maxAge 来清除 cookie.
31. HTTP 协议中的 POST 和 PUT 有什么区别?
    POST 是新建 (create) 资源, 非幂等, 同一个请求如果重复 POST 会新建多个资源. PUT 是 Update/Replace, 幂等, 同一个 PUT 请求重复操作会得到同样的结果.
32. 什么是跨域请求? 如何允许跨域?
    ```nginx
    location ~* ^/(?:v1|_) {
        if ($request_method = OPTIONS) { return 200 ''; }
        header_filter_by_lua '
            ngx.header["Access-Control-Allow-Origin"] = ngx.var.http_origin; # 这样相当于允许所有来源了
            ngx.header["Access-Control-Allow-Methods"] = "GET, POST, PUT, DELETE, PATCH, OPTIONS";
            ngx.header["Access-Control-Allow-Credentials"] = "true";
            ngx.header["Access-Control-Allow-Headers"] = "Content-Type";
        ';
        proxy_pass http://localhost:3001;
        }
    ```
33. TCP 粘包是怎么回事，如何处理? UDP 有粘包吗?
    默认情况下, TCP 连接会启用**延迟传送算法 (Nagle 算法)**,
    在数据发送之前缓存他们. **如果短时间有多个数据发送, 会缓冲到一起作一次发送** (缓冲大小见 socket.bufferSize), 这样可以减少 IO 消耗提高性能.(**React 批量更新是吧**)
    如果是传输文件的话, 那么根本不用处理粘包的问题, 来一个包拼一个包就好了. 但是如果是多条消息, 或者是别的用途的数据那么就需要处理粘包.
    我客户端调用了两次 send，怎么服务器端一个 recv 就都读出来了？！怎么回事我辛辛苦苦打包的数据都连在一起了？！啊一定是万恶的 TCP 偷偷的把我的数据都地粘在一起了（想象中电脑里 TCP 小人坏笑着拿胶水把数据粘在一起）现象是这样个现象，但 TCP 本来就**是基于字节流而不是消息包的协议**，它自己说的清清楚楚：我会把你的数据变成字节流发到对面去，而且保证顺序不会乱，但是你要自己搞定字节流解析。
    **UDP 基于消息报而非字节流，没有粘包**
    对于处理粘包的问题, 常见的解决方案有:

    - 多次发送之前间隔一个等待时间(只需要等上一段时间再进行下一次 send 就好, 适用于交互频率特别低的场景.对于比较频繁的场景而言传输效率实在太低)
    - 关闭 Nagle 算法(在 Node.js 中你可以通过 **socket.setNoDelay()** 方法来关闭 Nagle 算法, 让每一次 send 都不缓冲直接发送)
    - 进行封包/拆包(封包/拆包是目前业内常见的解决方案了. 即给每个数据包在发送之前, **于其前/后放一些有特征的数据**, 然后收到数据的时候根据特征数据分割出来各个数据包.)

34. TIME_WAIT 是什么情况? 出现过多的 TIME_WAIT 可能是什么原因?
    **假设是客户端主动发送断开连接的请求，那么 TIME_WAIT 指的是第四次挥手时服务端等待客户端的 ACK 的状态**. 如果在等待时间中, 再次收到第三次挥手 (FIN) 表示对方没收到最后一次挥手, 这时要再 ACK 一次. 这个等待的作用是避免出现连接混用的情况 (prevent potential overlap with new connections see TCP Connection Termination for more).

    出现大量的 TIME_WAIT 比较常见的情况是, **并发量大, 服务器在短时间断开了大量连接**. 对应 HTTP server 的情况可能是没开启 keepAlive. 如果有开 keepAlive, 一般是等待客户端自己主动断开, 那么 TIME_WAIT 就只存在客户端, 而服务端则是 CLOSE_WAIT 的状态, 如果服务端出现大量 CLOSE_WAIT, 意味着当前服务端建立的连接大面积的被断开, 可能是目标服务集群重启之类.

35. 什么是 RESTFUL？
    RESTful 是把每个 URI 当做资源 (Resources), 通过 method 作为动词来对资源做不同的动作, 然后服务器返回 status 来得知资源状态的变化 (State Transfer);
36. Script error. 是什么错误? 如何拿到更详细的信息?
    由于同源性策略 (CORS), 如果你引用的 js 脚本所在的域与当前域不同, 那么浏览器会把 onError 中的 msg 替换为 Script error.
    要拿到详细错误的方法, 处理配好 Access-Control-Allow-Origin 还有在引用脚本的时候指定 crossorigin 例如:

    ```JS
    <script src="http://another-domain.com/app.js" crossorigin="anonymous"></script>
    ```

    script 标签的 crossorigin 属性
    crossorigin 的属性值可以是 anonymous(默认)、use-credentials
    crossorigin 的作用：

    让浏览器启用 CORS 访问检查，检查 http 相应头的 Access-Control-Allow-Origin
    对于传统 script 需要跨域获取的 js 资源，控制暴露出其报错的详细信息

37. ECONNRESET 是什么错误? 如何复现这个错误?
    ECONNRESET 是因为 TCP 连接的对端(通常是 server)突然断开了连接.server 一般都设置了 keepalive，对于不活动的连接会超时断开
    简单的解决方法就是捕获这个异常，如果无法定位出具体出这个异常的地方，可以在进程级捕获进行分析。
    ```JS
    process.on('uncaughtException', function(err) {
        console.log(err.stack);
        console.log('NOT exit...');
    });
    ```
    例如 git push
38. socket hang up 是什么意思? 可能在什么情况下出现?
39. hosts 文件是什么? 什么叫 DNS 本地解析?
40. 列举几个提高网络传输速度的办法?
41. 什么是 TTY? 如何判断是否处于 TTY 环境?
42. 不同操作系统的换行符 (EOL) 有什么区别?
43. 服务器负载是什么概念? 如何查看负载?
44. ulimit 是用来干什么的?
45. 怎么处理未预料的出错? 用 try/catch ，domains 还是其它什么?
46. 什么是 uncaughtException 事件? 一般在什么情况下使用该事件?
47. domain 的原理是? 为什么要弃用 domain?
48. 什么是防御性编程? 与其相对的 let it crash 又是什么?
49. 为什么要在 cb 的第一参数传 error? 为什么有的 cb 第一个参数不是 error, 例如 http.createServer?
50. 为什么有些异常没法根据报错信息定位到代码调用? 如何准确的定位一个异常?
51. 内存泄漏通常由哪些原因导致? 如何分析以及定位内存泄漏?
52. 为什么要写测试? 写测试是否会拖累开发进度?
53. 单元测试的单元是指什么? 什么是覆盖率?
54. 测试是如何保证业务逻辑中不会出现死循环的?
55. mock 是什么? 一般在什么情况下 mock?
56. HTTP 如何通过 GET 方法 (URL) 传递 let arr = [1,2,3,4] 给服务器?
57. Node.js 中继承 (util.inherits) 的实现?
58. 如何递归获取某个文件夹下所有的文件名?
59. 备份数据库与 M/S, M/M 等部署方式的区别?
60. 索引有什么用，大致原理是什么? 设计索引有什么注意点?
61. Monogdb 连接问题(超时/断开等)有可能是什么问题导致的?
62. 什么情况下数据会出现脏数据? 如何避免?
63. redis 与 memcached 的区别?
64. 加密是如何保证用户密码的安全性?
65. TLS 与 SSL 有什么区别?
66. HTTPS 能否被劫持?
67. XSS 攻击是什么? 有什么危害?
68. 过滤 Html 标签能否防止 XSS? 请列举不能的情况?
69. CSRF 是什么? 如何防范?
70. 如何避免中间人攻击?

```

```
