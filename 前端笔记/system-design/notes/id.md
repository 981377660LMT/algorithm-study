对于整数类型的多列索引，我们可以合为一列。比如说我们要支持两类查找，一种是查找最新的数据，一种是查找某条指定的数据。那么我们可以把主键格式设计为时间戳+递增序列号的形式，这样我们能同时支持两类查找，且只需要建立一个索引，优化了写性能。

这是一种巧妙的索引设计思想，核心在于**利用 B-Tree 索引的有序性，将两个查询需求合并到一个索引中**。

我们来分解一下这个设计：

### 1. 要解决的问题

假设我们有一个表，需要支持两种核心查询：

1.  **按时间倒序查找**：快速获取最新发布的 N 条数据（例如，最新的帖子、最新的订单）。这对应 SQL `ORDER BY creation_time DESC`。
2.  **按唯一 ID 精确查找**：快速获取某一条指定的数据（例如，打开某个帖子的详情页）。这对应 SQL `WHERE id = ?`。

### 2. 传统的解决方案

通常，我们会创建两个索引来分别优化这两个查询：

- 在 `id` 列上创建一个**主键索引**（通常是自增整数）。
- 在 `creation_time` 列上创建一个**普通索引**。

**缺点**：

- **需要两个索引**：维护两个 B-Tree 结构。
- **写性能开销**：每次插入一条新数据，数据库不仅要更新主键索引，还要更新 `creation_time` 索引，这增加了写的负担。

### 3. “时间戳 + 序列号”的解决方案

这种方案将主键 `id` 的生成方式改变了。不再使用数据库的自增整数，而是在应用层生成一个**趋势递增且全局唯一**的 ID。

这个 ID 的结构通常是一个 64 位的整数（`BIGINT`），其二进制位被划分为几个部分：

`[ 41位的时间戳 | 10位的机器ID | 13位的序列号 ]`
_(这是 Twitter Snowflake 算法的经典结构，可以根据业务调整位数)_

- **时间戳**：占据最高位。这保证了 ID 的值会随着时间的推移而**大致递增**。
- **序列号**：占据最低位。它用于解决**同一毫秒内**在同一台机器上生成多个 ID 的情况。每生成一个 ID，序列号就加一。

#### 如何理解它能同时满足两种查找？

数据库的主键索引（在 InnoDB 等引擎中是聚簇索引）本身就是一个 B-Tree，数据是**按照主键的值物理排序**的。

1.  **满足“查找最新的数据”**：

    - 因为 ID 的最高位是时间戳，所以整个 ID 的值是**趋势递增**的。新生成的数据，其 ID 值一定比旧数据大。
    - 因此，主键索引的排列顺序**天然就是按时间排序的**。
    - 当你执行 `ORDER BY id DESC` 时，数据库只需要去 B-Tree 索引的末尾读取数据即可，速度极快。这等价于按时间倒序查找。

2.  **满足“查找某条指定的数据”**：
    - 这本身就是主键索引最基本、最高效的功能。
    - 执行 `WHERE id = ?` 就是一个典型的 B-Tree 点查，效率是 O(log N)。

### 总结

通过将主键设计为 `时间戳 + 序列号` 的形式，我们得到了一个**天然按时间排序的唯一 ID**。

- **优点**：
  1.  **一个索引，两种用途**：只用一个主键索引就同时优化了“按 ID 查找”和“按时间排序”两种常见场景。
  2.  **优化写性能**：相比创建两个独立索引，现在每次插入只需要维护一个主键索引，减少了写的开销。
  3.  **分布式友好**：这种 ID 生成方式不依赖于中心化的数据库自增，可以在分布式环境下由应用服务器各自生成，具有很好的扩展性。

所以，这句话的本质是：**通过改造主键的构成，使其值的排序特性与业务的查询需求（按时间排序）保持一致，从而用一个索引干两件事，达到优化的目的。**
