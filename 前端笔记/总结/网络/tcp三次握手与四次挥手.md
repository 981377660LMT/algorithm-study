https://github.com/huanzhiyazi/articles/issues/26

传输控制协议：将应用层的数据流分割成报文段发送给目标节点的 TCP 层

1. 为什么需要三次握手呢？关键的原因是 **为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。**
   客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。**但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。**如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。
   ![3](https://raw.githubusercontent.com/huanzhiyazi/articles/master/%E6%8A%80%E6%9C%AF/%E7%BD%91%E7%BB%9C/%E7%90%86%E8%A7%A3TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/images/tcp_connect.png)

   1. 客户端先向服务器发送 SYN(SyncNumber) 报文，如果服务器收到之后，便能确认客户端发送信息能力正常，但此时还不确定客户端接收信息能力是否正常。
   2. 然后，服务器返回给客户端 SYN+ACK 报文，SYN 使得客户端确认服务器发送信息能力正常，ACK 使得客户端确认服务器接收信息能力正常，因为这个 ACK 是服务器对上一步客户端发送 SYN 的一个确认。到这里，客户端已经完全确认了服务器收发信息都是正常的。
   3. 客户端最后再回复一个 ACK 报文给服务器，作为上一步服务器发送给客户端的 SYN 的一个确认。服务器收到该 ACK 之后便终于确认客户端接收信息的能力也是正常的。到这里，服务器已经完全确认了客户端收发信息都是正常的。
      即:

   - 客户 SYN M /Clinet SYN_SEND
   - 服务 ACK M+1,SYN N /Server SYN_RECV
   - 客户 ACK N+1 /双方 ESTABLISHED
     之后建立全双工通信

     **首次握手的隐患**:SYN 超时，Server 第三次没有收到 Client 的 ACK 会导致 Server 不断重试 1s 2s 4s 8s 16s 32s 至超时(RTO 的值是指数增⻓)
     Linux 默认 63s 才断开连接

     服务器会有 **SYN Flood** 风险 **有人恶意发 SYN 报文就溜了**
     应对：SYN 队列满了以后，通过 tcp_syncookies 回发 Sync Cookie **若为正常连接则 Client 会回发 SYN Cookie** 依然可以建立连接

     **保活机制**：建立连接后，Client 出现故障怎么办？每隔⼀个时间间
     隔向对方发送保活探测报文，retry 后收不到则断开

2. 需要四次挥手断开连接的关键原因是，**通信双方为了相互确认对方不再发送数据给自己了,都需要 ACK 与 FIN 报文**
   ![4](https://raw.githubusercontent.com/huanzhiyazi/articles/master/%E6%8A%80%E6%9C%AF/%E7%BD%91%E7%BB%9C/%E7%90%86%E8%A7%A3TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/images/tcp_disconnect.png)

   1. **客户端首先执行系统调用 close() 关闭连接**，向服务器发送 FIN 报文。这时客户端不再发送数据，只读取未读完的缓存数据。服务器收到 FIN 报文，便确认客户端已经不再发送数据过来了。客户端接下来需要确认服务器不再发送数据了，等待服务器发送 FIN 报文过来，进入 <FIN_WAIT1> 状态。
   2. 服务器向客户端发送 ACK 报文，告诉客户端我已经知道你不再发送数据过来了，但服务器可能还有数据没有发送完，所以这一步只向客户端发送 ACK 确认报文，而不捎带 FIN。客户端知道服务器已经知道自己不再发送数据了，但是服务器仍然需要时间处理完未发完的数据，所以仍然需要等待服务器发送 FIN 过来，进入 <FIN_WAIT2> 状态，即等待服务器 FIN 报文过来的第二个阶段。服务器半关闭，进入<CLOSE_WAWIT>>
   3. 服务器发送完所有数据后，执行系统调用 close()，并向客户端发送 FIN 报文，告诉客户端，我也不再发送数据了。但是服务器仍然需要确认客户端已经知道自己不再发送数据，所以进入 <LAST_ACK> 状态，即等待最后确认状态。
   4. 客户端收到来自服务器的 FIN 报文，知道服务器也不再发送数据了，于是进入 <TIME_WAIT> 状态，在这个状态下，需要等待 2MSL 时间（**2 个最大报文生存(Max Segment Lifetime)时间,4 分钟**）后最终进入 <CLOSED> 状态。同时向服务器发送最后一个 ACK 确认报文。

   - 客户 FIN M /Client FIN_WAIT1
   - 服务 ACK M+1 /Server CLOSE_WAWIT （服务器可能还有数据没有发送完，所以这一步只向客户端发送 ACK 确认报文，而不捎带 FIN）
   - 服务 FIN N /Serve LAST_ACK
   - 客户 ACK N+1 /ClIENT **TIME_WAIT** Server CLOSED
     为什么客户端最后需要在 <TIME_WAIT> 状态等待 2MSL 的时间呢？因为网络是不可靠的，**最后一个 ACK 报文可能丢失到不了服务器**。服务器在发送完最后一个 FIN 之后，如果在超时时间内没有收到客户端的 ACK，`会重发一次 FIN 给客户端`，客户端会再重发一个 ACK 报文并重新计时。如果客户端不等待 2MSL 直接进入关闭状态，**那么服务器可能永远收不到最后的 ACK 报文了，也就无法进入关闭状态了**。

   服务器大量 CLOSE_WAIT 的原因
   对方关闭 socket 连接 我方忙于读或写 **没有及时关闭连接**

3. TCP 的滑动窗口(核心)
   解决的问题：可靠性+传输速率
   RTT 和 RTO
   RTT:Round Trip Time 发一个数据包到对应的 ACK 所花费的时间
   RTO:Retransmission TimeOut :重传时间间隔，根据 RTT 计算出的

   > 老师说一段话, 学生来记.
   > 老师说"从前有个人"学生写"从前有个人". 学生说"嗯, 再来 5 个"老师说"她叫马冬梅"学生写"她叫马..梅". 学生说"啥?重来, 来 2 个"老师说"她叫"学生写"她叫". 学生说"嗯,再来 3 个"老师说"马冬梅". 学生写"马冬梅". 学生说"嗯, 给我来 10 个"老师说"她喜欢他,而他却喜欢她"学生写...

   此模式起到了流控的作用, 接收方认为状态好的时候, 让发送方每次多发一点. 接收方认为状态不好的时候(阻塞), 让发送方每次少发送一点.
   数据片丢失，需要重新发送整个 TCP 报文段，
   无法确认报文段中数据片丢失部分，因此整段重发

   窗口指**允许对方发送的数据量**
   窗口里:已接收(ACK)+正在发+未发送

4. TCP 可靠传输
   停止等待协议 超时重传
5. TCP 流量控制
   流量控制是为了控制发送方发送速率，保证接收方来得及接收。
   **接收方发送的确认报文中的窗口字段**可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据

6. TCP 拥塞控制(4 个 TCP 拥塞避免算法)
   慢开始拥塞避免 快重传快恢复
7. TCP 黏包问题：基于字节流的 TCP 不存在消息/数据包的概念，因此**在应用层字节流被错误拆分导致 TCP 粘包**
   应用层协议需要自行设计消息边界，正确分离消息,避免消息粘连
   现象：Content-Length:138 报文数据大小不等于实际大小
   解决：基于长度的标识/基于特殊分隔符
   粘包源于 Nagel 算法：缓冲合并字节流数据减少数据包+批量发送提升 TCP 传输能力，缓冲区超过最大数据段(MSS) 或者上一个数据段被确认(ACK)后发送

8. 头部比较
   UDP 协议头部:16 位源端口，16 位目的端口，16 位 UDP 长度，16 位 UDP 校验和 (固定的 8 字节)

   TCP 协议头部:16 位源端口，16 位目的端口,以及
   **Sequence Number** 是包的序号，每个字节都有唯一的序号，用来解决网络包乱序（reordering）问题。
   **Acknowledgement Number**是包的确认号 就是 ACK——用于确认收到，用来解决不丢包的问题。
   **Window** 又叫 Advertised-Window，也就是著名的滑动窗口（Sliding Window），用于解决流控的。
   窗口 2 字节，指明允许对方发送的数据量，数据缓冲空间有限
   **TCP Flag** ，控制位，也就是包的类型，主要是用于操控 TCP 的状态机的。

9. VPN (网络层)
   虚拟专用网技术
   公司内网/校园网/工业专用网
   专用 IP 地址：内网地址 ABC 三类 10 172 192.168

10. 如何在 linux 中查看 TCP 状态?
    netstat -napt

11. tcp 怎么保证可靠传输
    1. 校验和
    2. ACK/SYN
    3. 超时重传 「超时重传时间 RTO 的值」是⼀个动态变化的值
    4. 流量控制
    5. 拥塞控制
