1. 为什么需要 TCP 协议? TCP 工作在哪一层?
   IP 层是「不可靠」的，它不保证网络包的交付、不保证网络包的按序交付、也不保证网络包中的数据的完整性。
   如果需要保障网络数据包的可靠性，那么就需要由上层（传输层)的 TCP 协议来负责。
   因为 TCP 是一个工作在传输层的可靠数据传输的服务，它能确保接收端接收的网络包是无损坏、无间隔、非冗余和按序的。
2. TCP 是 面向连接的 可靠的 基于字节流 的 传输层通信协议
   - 面向连接:一定是「一对一」才能连接，不能像 UDP 协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的;
   - 可靠的:无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端;
   - 字节流:消息是「没有边界」的，所以无论我们消息有多大都可以进行传输。并且消息是「有序的」，当「前一个」消息没有收到的时候，即使它先收到了后面的字节，那么也不能扔给应用层去处理，同时对「重复」的报文会自动丢弃。
3. 什么是 TCP 连接
   简单来说就是，用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括 **Socket、序列号和窗口大小**称为连接。
   所以我们可以知道，建立一个 TCP 连接是需要客户端与服务器端达成上述三个信息的共识。
   - Socket:由 IP 地址和端口号组成
   - 序列号:用来解决乱序问题等·
   - 窗口大小:用来做流量控制
4. 如何唯一确定一个 TCP 连接呢?
   四元组
5. 有一个 IP 的服务器监听了一个端口，它的 TCP 的最大连接数是多少?
   等于`客户端的IP数*客户端端口数`
   `2**32*2**16`
6. 如果已经建立了连接，但是客户端突然出现故障了怎么办?
   TCP 的保活机制
   定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP 保活机制会开始作用，每隔一个时间间隔，发送一个探测报文，该探测报文包含的数据非常少，如果连续几个探测报文都没有得到响应，则认为当前的 TCP 连接已经死亡，系统内核将错误信息通知给上层应用程序。
7. 针对 TCP 如何进行 socket 编程
   服务端和客户端初始化 socket，得到文件描述符;
   服务端调用 bind ，将绑定在 IP 地址和端口;
   服务端调用 listen ,进行监听;
   服务端调用 accept ，等待客户端连接;
   客户端调用 connect ，向服务器端的地址和端口发起连接请求;
   服务端 accept 返回用于传输的 socket 的文件描述符;
   客户端调用 write 写入数据;服务端调用 read 读取数据;
   客户端断开连接时，会调用 close ，那么服务端 read 读取数据的时候，就会读取到了 EOF ，待处理完数据后，服务端调用 close ，表示连接关闭。

   这里需要注意的是，服务端调用 accept 时，**连接成功了会返回一个已完成连接的 socket，后续用来传输数据。**
   所以，监听的 socket 和真正用来传送数据的 socket，是「两个」socket，一个叫作监听 socket，一个叫作已完成连接 socket。
   成功连接建立之后，双方开始通过 read 和 write 函数来读写数据，就像往一个文件流里面写东西一样。

8. accept 发生在三次握手哪一步？
   客户端 connect 成功返回是在第二次握手，**服务端 accept 成功返回是在三次握手成功之后。**
9. TCP 重传、滑动窗口、流量控制、拥塞控制

   1. TCP 针对数据包丢失的情况，会⽤重传机制解决。
      常⻅的重传机制：

      - 超时重传:
        当超过指定的时间后，没有收到对⽅的 ACK 确
        认应答报⽂，就会重发该数据，也就是我们常说的超时重传。
        **超时重传时间 RTO 的值应该略⼤于报⽂往返 RTT 的值。**

        > RTO （Retransmission Timeout 超时重传时间）
        > RTT （Round-Trip Time 往返时延）

        「超时重传时间 RTO 的值」应该是⼀个动态变化的值。
        Linux 是如何计算 RTO 的呢？
        每当遇到⼀次超时重传的时候，都会将下⼀次超时时间间隔设为先前值的两倍。两次超时，就说明⽹络环境差，不宜频繁反复发送。
        超时触发重传存在的问题是，超时周期可能相对较⻓。那是不是可以有更快的⽅式呢？
        **于是就可以⽤「快速重传」机制来解决超时重发的时间等待。**

      - 快速重传
        快速重传的⼯作⽅式是当接收⽅收到乱序数据包时，会发送重复的 ACK，以便告知发送⽅要重发该数据包，**当发送⽅收到 3 个重复 ACK 时，就会触发快速重传，⽴刻重发丢失数据包。**
        快速重传机制只解决了⼀个问题，就是超时时间的问题，但是它依然⾯临着另外⼀个问题。**就是重传的时候，是重传之前的⼀个，还是重传所有的问题。**
      - SACK:Selective Acknowledgment 选择性确认:发送⽅就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以只重传丢失的数据。
      - D-SACK:使⽤了 SACK 来告诉「发送⽅」有哪些数据被重复接收了。

   2. 滑动窗口
      引⼊窗⼝概念的原因:你一句我一句的请求-响应模式太慢
      有了窗⼝，就可以指定窗⼝⼤⼩，**窗⼝⼤⼩就是指⽆需等待确认应答，⽽可以继续发送数据的最⼤值。**
      窗⼝的实现实际上是操作系统开辟的⼀个缓存空间，发送⽅主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。
      **窗⼝⼤⼩由哪⼀⽅决定？**
      TCP 头⾥有⼀个字段叫 Window ，也就是窗⼝⼤⼩。
      通常窗⼝的⼤⼩是由**接收⽅的窗⼝⼤⼩来决定的**。
      发送⽅的滑动窗⼝：四个部分
      接收⽅的滑动窗⼝：三个部分
      接收窗⼝的⼤⼩是约等于发送窗⼝的⼤⼩的。

   3. 流量控制
      发送⽅不能⽆脑的发数据给接收⽅，要考虑接收⽅处理能⼒。
      如果⼀直⽆脑的发数据给对⽅，但对⽅处理不过来，那么就会**导致触发重发机制**，从⽽导致⽹络流量的⽆端的浪费。
      TCP 为了防⽌发送⽅⽆脑的发送数据，导致接收⽅缓冲区被填满，所以就有了滑动窗⼝的机制，它可**利⽤接收⽅的接收窗⼝来控制发送⽅要发送的数据量，也就是流量控制。**
      发送窗**会被操作系统调整。**⼝和接收窗⼝中所存放的字节数，都是放在操作系统内存缓冲区中的，⽽操作系统的缓冲区，

      `零窗⼝通知与窗⼝探测`：如果窗⼝⼤⼩为 0 时，就会阻⽌发送⽅给接收⽅传递数据，直到窗⼝变为⾮ 0 为⽌，这就是窗⼝关闭。
      TCP 为每个连接设有⼀个持续定时器，**只要 TCP 连接⼀⽅收到对⽅的零窗⼝通知，就启动持续计时器**。如果持续计时器超时，就会发送**窗⼝探测 ( Window probe ) 报⽂**，⽽对⽅在确认这个探测报⽂时，给出⾃⼰现在的接收窗⼝⼤⼩。

   4. 拥塞控制
      流量控制是避免「发送⽅」的数据**填满「接收⽅」的缓存**
      拥塞控制的⽬的就是避免「发送⽅」的数据**填满整个⽹络。**
      为了在「发送⽅」调节所要发送数据的量，定义了⼀个叫做「拥塞窗⼝」的概念。
      **拥塞窗⼝ cwnd** 是发送⽅维护的⼀个的状态变量，它会根据⽹络的拥塞程度动态变化的。

      拥塞控制有哪些控制算法？

      - 慢开始：⼀点⼀点的提⾼发送数据包的数量；**当发送⽅每收到⼀个 ACK，拥塞窗⼝ cwnd 的⼤⼩就会加 1。**可以看出慢启动算法，发包的个数是指数性的增⻓。
        有⼀个叫**慢启动⻔限** ssthresh （slow start threshold）状态变量。当 cwnd < ssthresh 时，使⽤慢启动算法。当 cwnd >= ssthresh 时，就会使⽤「拥塞避免算法」。

      - 拥塞避免：**每当收到⼀个 ACK 时，cwnd 增加 1**拥塞避免算法就是将原本慢启动算法的**指数增⻓变成了线性增⻓**，还是增⻓阶段，但是增⻓速度缓慢了⼀些。

        当⽹络出现拥塞，也就是会发⽣数据包重传，

      - 快重传：当接收⽅发现丢了⼀个中间包的时候，**发送三次前⼀个包的 ACK**，于是发送端就会快速地重传，不必等待超时再重传。**cwnd = cwnd/2** ，也就是设置为原来的⼀半;**ssthresh = cwnd** ;

      - 快恢复：cwnd = ssthresh + 3 （ 3 的意思是确认有 3 个数据包被收到了）；如果再收到重复的 ACK，那么 cwnd 增加 1；恢复过程已经结束，可以回到恢复之前的状态了，也即再次进⼊ 拥塞避免状态；

10. 发送⽅在⼀个窗⼝发出 n 个包，是不是需要 n 个 ACK 确认报⽂？
    No，因为 TCP 有累计确认机制，所以当收到多个数据包时，只需要应答最后⼀个数据包的 ACK 报⽂就可以了。
11. TCP 延迟确认与 Nagle 算法
    常⻅的两种策略，来减少⼩报⽂的传输

    - Nagle 算法:Nagle 算法做了⼀些策略来避免过多的⼩数据报⽂发送，这可提⾼传输效率。

      1. 没有已发送未确认报⽂时，⽴刻发送数据。
      2. 存在未确认报⽂时，直到「没有已发送未确认报⽂」或「数据⻓度达到 MSS (最大报文段长度 Maximum Segment Size)⼤⼩」时，再发送数据。
         可以看出，Nagle 算法⼀定会有⼀个⼩报⽂，也就是在最开始的时候。
         Nagle 算法默认是打开的，如果对于⼀些需要⼩数据包交互的场景的程序，⽐如，telnet 或 ssh 这样的交互 性⽐较强的程序，则需要关闭 Nagle 算法。

    - 延迟确认
      当没有响应数据要发送时，ACK 将会延迟⼀段时间，以等待是否有响应数据可以⼀起发送

12. 如何解决粘包？
    我们不能认为一个用户消息对应一个 TCP 报文，正因为这样，所以 TCP 是面向字节流的协议。
    **当两个消息的某个部分内容被分到同一个 TCP 报文时，就是我们常说的 TCP 粘包问题**，这时接收方不知道消息的边界的话，是无法读出有效的消息。
    要解决这个问题，要交给应用程序。
    粘包的问题出现是因为不知道一个用户消息的边界在哪，如果知道了边界在哪，接收方就可以通过边界来划分出有效的用户消息。
    一般有三种方式分包的方式：

    固定长度的消息； 但是这种方式灵活性不高，实际中很少用。

    特殊字符作为边界；

    自定义消息结构。 由包头和数据组成，其中包头包是固定大小的，而且包头里有一个字段来说明紧随其后的数据有多大。当接收方接收到包头的大小（比如 4 个字节）后，就解析包头的内容，于是就可以知道数据的长度，然后接下来就继续读取数据，

13. CDN 工作原理
    CDN 将内容资源分发到位于多个地理位置机房中的服务器上，这样我们在访问内容资源的时候，不用访问源服务器。而是直接访问离我们最近的 CDN 节点 ，这样一来就省去了长途跋涉的时间成本，从而实现了网络加速。
    **CDN 能加速什么类型的内容？**
    CDN 加速的是内容资源是静态资源。
    不过，动态资源如果也想被缓存加速，就要使用动态 CDN，其中一种方式就是将数据的逻辑计算放在 CDN 节点来做，这种方式就被称为**边缘计算**
    **CDN 是怎么从源服务器获取资源的呢？**
    CDN 加速策略有两种方式，分别是「推模式」和「拉模式」。
    大部分 CDN 加速策略采用的是「拉模式」，当用户就近访问的 CDN 节点没有缓存请求的数据时，CDN 会主动从源服务器下载数据，并更新到这个 CDN 节点的缓存中。
    如果想要把资源在还没有用户访问前缓存到 CDN 节点，则可以采用「推模式」，这种方式也叫 **CDN 预热**。
    **如何找到离用户最近的 CDN 节点 ？**
    是由 CDN 的全局负载均衡器（GSLB，Global Sever Load Balance，GSLB）负责的。
    看用户的 IP 地址，查表得知地理位置，找相对最近的 CDN 节点；
    看用户所在的运营商网络，找相同网络的 CDN 节点；
    看用户请求 URL，判断哪一台服务器上有用户所请求的资源；
    查询 CDN 节点的负载情况，找负载较轻的节点；
14. TCP 的 Keepalive 和 HTTP 的 Keep-Alive 是一个东西吗？
    HTTP 的 Keep-Alive，是由应用层（用户态） 实现的，称为 HTTP 长连接；
    TCP 的 Keepalive，是由 TCP 层（内核态） 实现的，称为 TCP 保活机制；

    HTTP 的 Keep-Alive 也叫 HTTP 长连接，该功能是由「应用程序」实现的，可以使得用同一个 TCP 连接来发送和接收多个 HTTP 请求/应答，减少了 HTTP 短连接带来的多次 TCP 连接建立和释放的开销。

    TCP 的 Keepalive 也叫 TCP 保活机制，该功能是由「内核」实现的，当客户端和服务端长达一定时间没有进行数据交互时，内核为了确保该连接是否还有效，就会发送探测报文，来检测对方是否还在线，然后来决定是否要关闭该连接。

15. HTTPS 是先进行 TCP 三次握手，再进行 TLSv1.2 四次握手
