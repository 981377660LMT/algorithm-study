1. 简单讲解一下 http2 的多路复用
   之前(http/1.0)是同一个连接只能用一次， 如果开启了 keep-alive(http/1.1)，虽然可以用多次，但是同一时刻只能有一个 HTTP 请求
   **简单来说， http2 的多路复用就是在同一个 TCP 连接，同一时刻可以传输多个 HTTP 请求。**
2. 谈谈你对 TCP 三次握手和四次挥手的理解
   ![img](https://user-images.githubusercontent.com/34148615/53062591-3d846300-34fc-11e9-8d0f-4063d9ff3398.png)
3. A、B 机器正常连接后，B 机器突然重启，问 A 此时处于 TCP 什么状态
4. HTTPS 握手过程中，客户端如何验证证书的合法性
   1. 服务器 用 RSA （非对称加密：加密和解密使用不同密钥的加密）生成公钥和私钥
   2. 把公钥放在证书里发送给客户端，私钥自己保存
   3. 客户端首先向一个权威的服务器检查证书的合法性，如果证书合法，客户端产生一段随机数，这个随机数就作为通信的密钥，我们称之为对称密钥，用公钥加密这段随机数，然后发送到服务器
   4. 服务器用密钥解密获取对称密钥，然后，双方就已对称密钥进行加密解密通信了
      PS:非对称的 RSA 加密性能是非常低的，原因在于寻找大素数、大数计算、数据分割需要耗费很多的 CPU 周期，所以一般的 HTTPS 连接只在第一次握手时使用非对称加密，通过握手交换对称加密密钥，在之后的通信走对称加密。
5. 介绍 HTTPS 握手过程
   1. 客户端使用 https 的 url 访问 web 服务器,要求与服务器建立 ssl 连接
   2. web 服务器收到客户端请求后, 会将网站的证书(包含公钥)传送一份给客户端
   3. 客户端收到网站证书后会检查证书的颁发机构以及过期时间, 如果没有问题就随机产生一个秘钥
   4. 客户端利用公钥将会话秘钥加密, 并传送给服务端, 服务端利用自己的私钥解密出会话秘钥
   5. 之后服务器与客户端使用秘钥加密传输
6. 介绍下 HTTPS 中间人攻击
   中间人攻击过程如下：

   1. 服务器向客户端发送公钥。
   2. 攻击者截获公钥，保留在自己手上。
   3. 然后攻击者自己生成一个【伪造的】公钥，发给客户端。
   4. 客户端收到伪造的公钥后，生成加密 hash 值发给服务器。
   5. 攻击者获得加密 hash 值，用自己的私钥解密获得真秘钥。
   6. 同时生成假的加密 hash 值，发给服务器。
   7. 服务器用私钥解密获得假秘钥。
   8. 服务器用加秘钥加密传输信息

CA 得保证不泄漏自己的私钥，否则中间人又可以连 CA 做的的签名都伪造了
charles 想拦截 https 先要信任他的证书，印象中 charles 确实是用中间人的方式实现的拦截

7. 介绍下 http1.0、1.1、2.0 协议的区别
   https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/232#issuecomment-516677308
   http/1 :
   默认不支持长连接，需要设置 keep-alive 参数指定
   强缓存 expired、协商缓存 last-modified\if-modified-since 有一定的缺陷

   http 1.1 :
   **默认长连接**(keep-alive)，http 请求可以复用 Tcp 连接，但是同一时间只能对应一个 http 请求(http 请求在一个 Tcp 中是串行的)
   增加了强缓存 cache-control、协商缓存 etag\if-none-match 是对 http/1 缓存的优化

   http/2 :
   **多路复用**，一个 Tcp 中多个 http 请求是并行的 (雪碧图、多域名散列等优化手段 http/2 中将变得多余)
   **二进制分帧**:将所有传输的信息分割为更小的消息和帧,并对它们采用二进制格式的编码
   **header 压缩**
   **服务端推送**:服务器可以额外的向客户端推送资源，而无需客户端明确的请求

   http1.0 到 http1.1 的主要区别，就是从无连接到长连接
   http2.0 对比 1.X 版本主要区别就是多路复用
   http1.0 不支持持久连接
   http1.1 支持持久连接，但是串行发送请求，并行请求只能同时建立多个 tcp 连接，引入了管道化，但是存在队头阻塞的问题

   http2.0
   二进制分帧(HTTP/2 采用二进制格式传输数据，相比于 HTTP/1.1 的文本格式)、
   多路复用(解决了 HTTP 层面的队头阻塞，即多个请求都通过一个 TCP 连接并发地完成，实现多路复用)、
   头部压缩(使用 HPACK 算法进行头部压缩,废除了起始行的概念)、
   服务端推送(服务器不再是完全被动地接收请求，响应请求，它也能新建 stream 来给客户端发送消息)

   为什么 HTTP1.1 不能实现多路复用:HTTP/1.1 不是二进制传输，而是通过文本进行传输。由于没有流的概念，在使用并行传输（多路复用）传递数据时，**接收端在接收到响应后，并不能区分多个响应分别对应的请求，所以无法将多个响应的结果重新进行组装**，也就实现不了多路复用。
   **具体说一下 HTTP/2 中的多路复用**
   类似于多个数组先 map 附加元信息，再按顺序随机 shift 最后还是可以得到原来的数组
   HTTP/2 引入了一个**二进制分帧层**，客户端和服务端进行传输时，数据会先经过二进制分帧层处理，转化为一个个**带有请求 ID 的帧**，这些帧在传输完成后根据 ID 组合成对应的数据。
   所以原本一个个完整的 HTTP 请求报文变成了现在的**一堆乱序的二进制帧**，这些二进制帧因为**不存在先后顺序所以也就不会排队等待，也就没有了 HTTP 队头阻塞的问题**。
   通信双方都可以给对方发送二进制帧，这种二进制帧的双向传输的序列，就叫做流。HTTP/2 **在一个 TCP 连接上来进行多个数据帧的通信，这就是多路复用的概念**。
   (所谓的乱序，指的是不同 ID 的 Stream 是乱序的，但同一个 Stream ID 的帧一定是按顺序传输的。)

8. 永久性重定向（301）和临时性重定向（302）对 SEO 有什么影响
   1）301 redirect——301 代表永久性转移(Permanently Moved)，301 重定向是网页更改地址后对搜索引擎友好的最好方法，只要不是暂时搬移的情况,都建议使用 301 来做转址。
   如果我们把一个地址采用 301 跳转方式跳转的话，搜索引擎会把老地址的 PageRank 等信息带到新地址，同时在搜索**引擎索引库中彻底废弃掉原先的老地址。旧网址的排名等完全清零**

（2）302 redirect——302 代表暂时性转移(Temporarily Moved )，在前些年，不少 Black Hat SEO 曾广泛应用这项技术**作弊**，目前，各大主要搜索引擎均加强了打击力度，象 Google 前些年对 Business.com 以及近来对 BMW 德国网站的惩罚。即使网站客观上不是 spam，也很容易被搜寻引擎容易误判为 spam 而遭到惩罚。
301（永久重定向）是旧地址的资源已经被永久地删除了，搜索引擎在抓取新内容的同时也将旧的网站替换为重定向后的地址
302（临时重定向）旧地址的资源还在，这个重定向的只是临时从旧地址跳转到新地址，搜索引擎会抓取新的内容而保存旧的地址

9. 接口如何防刷
   referer 校验
   UA 校验
   频率限制（1s 内接口调用次数限制）

   **刷是禁止不了的，只能提高刷的成本**
   前端：
   限制按钮，表单提交次数，防抖
   增加图片验证码，类似 12306

   后端：
   ip，user_agent，referer
   用户唯一标示
   简单验证码
   手机号验证码
   api key，rsa 加密认证，ca 认证（后端与后端之间调用）
   ip 黑名单（一般是刷的频率太大，达到 ddos 水平了或者确认为恶意调用）

10. 分别介绍下 http 和 tcp 协议，它们之间的区别与联系
    HTTP 属于应用层协议，TCP 属于传输层协议；
    HTTP 基于 TCP 建立连接、传输数据；
    HTTP 是无状态的短连接，TCP 是有状态的长连接
11. TCP 和 UDP 的区别
    TCP 是一个面向连接的、可靠的、基于字节流的传输层协议。
    UDP 是一个面向无连接的传输层协议。
    TCP 为什么可靠，是因为它有三次握手来保证双方都有接受和发送数据的能力。
12. http header 怎么判断协议是不是 websocket
    http 通过判断 header 中是否包含 **Connection: Upgrade** 与 **Upgrade: websocket** 来判断当前协议是否要升级到 websocket

13. HTTP/2 对比 HTTP/1.1，特性是什么？是如何解决队头阻塞与压缩头部的
14. dns 查询过程，dns 用什么协议发起 dns 查询的
15. 在项目中如何把 http 的请求换成 https
    所以每次请求的域名也是写在配置文件中，有一个 baseURL 字段专门用于存储它，所以只要改这个字段就可以达到替换所有请求 http 为 https 了。
    **利用 meta 标签把 http 请求换为 https:**

```HTML
<meta http-equiv ="Content-Security-Policy" content="upgrade-insecure-requests">
```

16. 跨域
    nginx/jsonp/websocket(没有使用 HTTP 的响应头，因此也没有跨域的限制)
17. XSS？CSRF？
    XSS
    **存储型**：即攻击被存储在服务端，常见的是在评论区插入攻击脚本，如果脚本被储存到服务端，那么所有看见对应评论的用户都会受到攻击。
    **反射型**：攻击者将脚本混在 URL 里，服务端接收到 URL 将恶意代码当做参数取出并拼接在 HTML 里返回，浏览器解析此 HTML 后即执行恶意代码
    **DOM 型**：将攻击脚本写在 URL 中，诱导用户点击该 URL，如果 URL 被解析，那么攻击脚本就会被运行。和前两者的差别主要在于 DOM 型攻击不经过服务端

    如何防御 XSS 攻击
    输入检查：对输入内容中的 script 和<iframe>等标签进行转义或者过滤
    设置 httpOnly：很多 XSS 攻击目标都是窃取用户 cookie 伪造身份认证，设置此属性可防止 JS 获取 cookie
    开启 CSP，即开启白名单，可阻止白名单以外的资源加载和运行

18. 为什么 TCP 要三次握手而不是两次
    为了保证**双方都有发送和接收的能力**，如果只有两次握手的话就只能保证发送方，一般就是我们的客户端有发送的能力，但是并不能保证**它有接收的能力**，所以必须是三次。
19. 为什么 TCP 要四次挥手而不是两次
    通俗的来说，两次握手就可以释放一端到另一端的 TCP 连接，完全释放连接一共需要四次握手。
    A 和 B 打电话，通话即将结束后，A 说 “我没啥要说的了”，B 回答 “我知道了”，于是 A 向 B 的连接释放了。但是 B 可能还会有要说的话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，于是 B 向 A 的连接释放了，这样整个通话就结束了。
20. script 放在 body 头部就一定会阻塞吗
    async 与 defer 不会

21. 进程是资源分配的最小单位，线程是 CPU 调度的最小单位
    进程是运行中的程序，线程是进程的内部的一个执行序列
    进程是资源分配的单元，线程是执行行单元
    进程间切换代价大，线程间切换代价小
    进程拥有资源多，线程拥有资源少
    多个线程共享进程的资源
22. 为什么说 HTTPS 比 HTTP 安全呢
    通过混合加密保证传输的数据不被窃听
    通过数字签名的方式保证数据不会被篡改
    通过数字证书保证服务器身份的真实性
23. 在一次传输中它是如何保证每个数据包之间的顺序的？
    TCP 的报文中有序号和确认号来保证每个数据包之间的顺序。
24. GET 和 POST 的区别
    从缓存的角度上说，GET 会被浏览器主动缓存下来，留下历史记录，但是 POST 不会。
    从编码的角度上说，GET 只能进行 URL 编码，它只能接收 ASCII 字符，但是 POST 没有限制。
    从参数的角度上说，GET 一般放在 URL 上传递参数，POST 放在请求体里，更适合传递敏感信息。
    从幂等的角度上说，GET 是幂等的，而 POST 不是。
    GET 请求会把请求报文一次性发出去，但是 POST 会分为两个 TCP 数据包。首先发送的是 header 部分，若是服务器响应 100(continue)，则会发送 body 部分，当然火狐浏览器除外，它的 POST 请求只发一个 TCP 包。
    **既然 POST 要分为两个 TCP 数据包发送，那 GET 是不是会比 POST 更有效啊**
    GET 和 POST 都有它们自己的语义的，最好不要混用
    在网络条件好的情况下，发一次包和发两次包的相差的时间基本可以被无视了。并且在网络条件差的情况下，两次包的 TCP 在验证数据包的完整性上还有更大的优点。
    再者，也并不是所有的浏览器的 POST 请求都会发送两次 TCP 数据包的，比如火狐就不会。
25. 为什么说 GET 会留下历史记录？
    浏览器规定的
26. GET 可以上传图片吗
    get 可以通过 URL 传参上传图片，可以将图片转为 base64 格式再进行传输，不过由于 get 请求的参数是有大小限制的，最多不超过 4kb。

27. CIA 三元组
    机密性（Confidentiality）
    完整性（Integrity）
    可用性（Availability）
28. 知道 XSS 有哪几种类型吗
    反射型 XSS (也叫非持久型) **恶意脚本存在 URL 里(url 参数)**
    基于 DOM 的 XSS **取出和执行恶意代码由浏览器端完成，例如 img 标签里的 script**
    存储型 XSS (也叫持久型 XSS) **恶意代码存在数据库里(例如提交表单)**
29. 分别说一下它们的实现原理
    反射型：顾名思义，恶意 JavaScript 脚本属于用户发送给网站请求中的一部分，随后网站又将这部分返回给用户，恶意脚本在页面中被执行。一般发生在前后端一体的应用中，服务端逻辑会改变最终的网页代码。
    基于 DOM 型：目前更流行前后端分离的项目，反射型 XSS 无用武之地。
    但这种攻击不需要经过服务器，我们知道，网页本身的 JavaScript 也是可以改变 HTML 的，黑客正是利用这一点来实现插入恶意脚本。
    存储型：又叫持久型 XSS，顾名思义，黑客将恶意 JavaScript 脚本长期保存在服务端数据库中，用户一旦访问相关页面数据，恶意脚本就会被执行。常见于搜索、微博、社区贴吧评论等。

30. XSS 攻击如何进行防护
    一切用户输入皆不可信，在输出时进行验证将 HTML 元素内容、属性以及 URL 请求参数、CSS 值进行编码当编码影响业务时，使用白名单规则进行检测和过滤使用 W3C 提出的 CSP (Content Security Policy，内容安全策略)，定义域名白名单设置 Cookie 的 HttpOnly 属性
31. 什么是 CSRF 攻击
    **CSRF 攻击就是黑客引诱用户打开黑客的网站，利用用户的登陆状态发起跨站请求。**
    CSRF 攻击一般怎么实现
    通过引诱链接诱惑用户点击触发请求，利用 a 标签的 href。
    构造隐藏表单来自动发起 Post 请求
32. CSRF 攻击和 XSS 攻击有什么区别？
    CSRF 攻击不需要将恶意代码注入用户的页面，仅仅是利用服务器的漏洞和用户的登录状态来实施攻击。
    CSRF 攻击成本也比 XSS 低，用户每天都要访问大量网页，无法确认每一个网页的合法性， 从用户角度来说，无法彻底防止 CSRF 攻击。
33. 如何防范 CSRF 攻击
    针对实际情况，设置关键 Cookie 的 SameSite 属性为 Strict 或 Lax 服务端验证请求来源站点(Referer、Origin)使用 **CSRF Token**，服务端随机生成返回给浏览器的 Token，每一次请求都会携带不同的 CSRF Token 加入二次验证(独立的支付密码)
34. 关于 Web 密码学你了解哪些呢
    对称加密算法就是加密和解密使用同一个密钥，简单粗暴 AES(AES-128)
    非对称加密就是加密和解密使用不同的密钥。发送方使用公钥对信息进行加密，接收方收到密文后，使用私钥进行解密。 RSA
    散列算法 不可逆性、鲁棒性、唯一性 使用时记得加盐 MD5、SHA(SHA-256)
35. HTTPS 在 TCP 和 HTTP 中间加入了 SSL/TLS 安全层。
    对发起 HTTP 请求的数据进行加密操作
    对接收到 HTTP 的内容进行解密操作。
    采用对称加密的方式加密传输数据和非对称加密的方式来传输密钥，既可以解决传输效率问题也能保证两端数据的安全传输。除此之外，为了能够证明服务器是可靠的，引入了数字证书，让浏览器验证证书的可靠性。
36. 在浏览器中输入 url 地址 ->> 显示主页的过程
    1. DNS 解析
    2. TCP 连接
    3. 发送 HTTP 请求
    4. 服务器处理请求并返回 HTTP 报文
    5. 浏览器解析渲染页面
    6. 5.连接结束
37. 什么是 TCP/IP 协议？
    把与互联网相关联的协议集合起来总称为 TCP/IP。
38. TCP/IP 协议族层次分为几层？为什么要分层？
    分为以下四层：应用层、传输层、网络层、数据链路层(其实也就是我们经常看到的五层模型的前四层)
    大致说一下这四层的作用
    **应用层**：向用户提供应用服务时通信的活动
    http 协议,ftp 文件传输协议,smtp 协议,dns 域名解析协议
    **传输层**:提供处于网络连接中的两台计算机之间的数据传输
    UDP 用户数据报协议(User Datagram Protocol)：提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性）。
    TCP 传输控制协议(Transimission Control Protocol)：面向连接的，数据传输单位是报文段，能提供可靠的交付。
    **网络层**：处理网络上流动的数据包，规定了双方之间进行数据传输时的路线
    IP 协议：在网络中通常使用 IP 地址+端口号来定位一个程序在计算机中的位置，这种方式就是一种 IP 协议。
    **数据链路层**
    用来处理连接网络的硬件部分，例如控制操作系统、硬件的设备驱动、网卡、光纤等。
39. TCP/IP 通信传输流
    发送端从应用层往下走，接收端往应用层往上走。
    发送端经过每一层时都会打上该层所属的头部信息；接收端则相反，经过每一层把对应的首部消去。
    经过各个层时做的事：
    应用层：生成针对目标 Web 服务器的 HTTP 请求报文
    传输层：将接收到的数据(HTTP 请求报文)进行分割，并在每个报文上打上标记序号以及端口号
    网络层：增加通信目的地的 MAC 地址
    ![TCP/IP 通信传输流](https://github.com/LinDaiDai/niubility-coding-js/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/resource/1.png)
40. URI 和 URL 的区别
    URI 用字符串表示网络中的某个资源
    URL 表示资源的具体地址
41. 什么是 HTTPS?
    通信接口部分用 SSL 或者 TLS 协议替代(在 HTTP 和 TCP 之间建立中间层)。换句话说 HTTPS 其实就是身披 SSL 协议这层外壳的 HTTP。 HTTPS = HTTP + SSL/TLS
    采用 SSL 后 HTTP 就有了 HTTPS 的加密、证书和完整性保护这些功能。
42. 什么是第三方认证？
    产生原因：保证客户端拿到的公钥是真实有效的
43. 一句话概述 HTTP
    HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范。
    HTTP 通常跑在 TCP/IP 协议栈之上，依靠 **IP 协议实现寻址和路由**、**TCP 协议实现可靠数据传输**、DNS 协议实现域名查找、SSL/TLS 协议实现安全通信。当然，WebSocket、HTTPDNS 依赖于 HTTP
44. HTTP 经典的几个版本
    第一版 HTTP/0.9 于 1990 年问世，并没有作为正式的标准被建立。
    作为正式的标准被建立是 HTTP/1.0，于 1996 年 5 月发布
    目前主流的版本是 HTTP/1.1，于 1997 年 1 月发布。
    2015 年 5 月 正式发布 HTTP/2。(不叫 HTTP/2.0，是因为标准委员会不打算发布子版本，下一个版本直接是 HTTP/3)
45. HTTP 特点及缺点
    HTTP 特点
    **请求/响应模式**的协议。
    灵活可扩展:只规定了基本格式，其它的各部分没有严格的限制;传输的类型由 Content-Type 加以标记。
    **可靠传输**，HTTP 基于 TCP/IP
    **无状态**
    http1.1 **持久连接**:建立一次 TCP 连接即可进行多次请求或响应的交互;只要有一方没有明确的提出断开连接，则保持 TCP 连接状态。在 HTTP/1.1 中所有的连接默认都是持久连接的(也就是首部字段 Connection: keep-alive，若是想要关闭则将值设置为 close)，但是 HTTP/1.0 并未标准化

    HTTP 的缺点
    明文:协议里的报文不使用二进制数据，而是文本形式,内容可能被窃听
    无状态
    队头阻塞的问题:根本原因在于 HTTP 是基于 请求-响应 的模型;在同一个 TCP 长连接中，前一个请求没有得到响应，后面的请求就会被阻塞。
    无法验证报文的完整性，内容可能被篡改

46. http 队头阻塞与 tcp 队头阻塞的区别
    和 TCP 队头阻塞的区别：TCP 传输的单位是数据包，它的队头阻塞表示的是前一个报文没有收到便不会将下一个报文上传给 HTTP。而 HTTP 队头阻塞是在 请求-响应 层面，前一个请求还没有处理完，后面的请求就被阻塞。
47. http 请求方法种类
    GET：获取资源，幂等操作

    HEAD：**获取报文首部**，和 GET 很像但是不返回报文主体，幂等操作

    POST: 创建或更新资源，**非幂等操作**

    PUT: 创建或更新资源本身，幂等操作

    PATCH：对资源进行局部更新，**非幂等操作**

    DELETE：删除资源，和 PUT 功能相反，幂等操作

    OPTIONS：**查询服务器端支持的 HTTP 方法种类(幂等操作)：**

48. HTTP 中的幂等是什么意思
    它本质上意味着成功执行请求的结果与其执行次数无关。
49. 服务端收到不支持的方法会如何处理
    当服务端收到不支持的方法时，会返回 405 Method Not Allowed，并且会把所有支持的方法写入响应报文首部字段 Allow 中返回。
50. 状态码
    200 OK ：请求成功，通常返回的数据中带有响应体。
    204 No Content：意思和 200 一样，不过返回的数据中不带有响应体。 (删除成功)
    206 Partial Content：客户端进行了范围请求且服务端正常处理，响应报文的首部应该还有 Content-Range 字段指定实体的范围。使用场景为 HTTP 分块下载和断点续传。

    301 Moved Permanently：永久重定向，最新的 URI 为响应报文首部的 Location 字段。场景是：例如你的网站换了地址了，之前的地址不用了，若用户还是从之前的地址进的话则会返回 301 且在 Location 中带上最新的 URI。且浏览器默认会做缓存优化，减少服务器压力，在第二次访问的时候自动访问重定向的那个地址。
    302 Found：临时重定向，和 301 不同，它表示请求的资源临时被移动到了别的 URI 上，因为是暂时的，所以不会被缓存。
    304 Not Modefied：客户端带条件请求时虽未满足条件但是也允许返回该资源，它虽然被划分在 3xx 中，但其实和重定向没有关系。场景例如：协商缓存成功就会返回 304 Not Modefied，表示请求的资源在服务器上并未发送改变，告诉请求者可以使用缓存。(可以看我的这篇文章哦《霖呆呆你来说说浏览器缓存吧》)
    307 Temprary Redirect：临时重定向，但是比 302 更加明确，重定向的请求方法和实体都不允许变动。场景例如：HSTS 协议，强制客户端使用 https 建立连接，比如你的网站从 HTTP 升级到了 HTTPS，而你还是通过 http://xxx 访问的话，就会返回 307 Internal Redirect。(可以试一下http://juejin.im)

    400 Bad Request：请求报文中存在语法错误，但是没有具体指出是哪里。
    401 Unauthorized：需要有通过 HTTP 认证的认证信息或者表示用户认证失败。
    403 Forbidden：请求资源被拒绝，原因是：比如法律禁止、信息敏感。
    404 Not Found：请求资源未找到，表示没在服务器上找到相应的资源。

    500 Internal Server Error：服务器内部错误，但是没有具体指出是哪里，和 400 有点像。
    501 Not Implemented：表示客户端请求的功能还不支持
    502 Bad GateWay：服务器自身是正常的，但是**代理服务器无法获取到合法响应**(nginx 坏了)(点外卖时外卖小哥没送)
    503 Service Unavailable：服务器内部处于超负载状态或进行停机维护(就像是本店今天不开张)

51. HTTP 报文组成(参考 client api)
    HTTP/1.1 200 OK
    Connection: Keep-Alive
    Content-Encoding: gzip
    Content-Type: text/html; charset=utf-8
    Date: Thu, 11 Aug 2016 15:23:13 GMT
    Keep-Alive: timeout=5, max=1000
    Last-Modified: Mon, 25 Jul 2016 04:32:39 GMT
    Server: Apache

    (body)

    报文首部(起始行+首部字段一大堆) + 空行(CR(回车符`C`ar) 或 LF(换行`L`ine 符)区分头部和实体) + 报文实体(body)
    ![大家记住这张图就可以了](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/25/1724c6bf5d8cc428~tplv-t2oaga2asx-watermark.awebp)

    起始行
    请求报文中叫：「请求行」
    由：方法 + URI + 版本号 组成
    例：`GET index.html HTTP/1.1`
    真实例子可以看上面 👆HTTP 整体报文那张图。
    响应报文中叫：「状态行」
    由：版本号 + 状态码 + 原因短语
    例：`HTTP/1.1 200 OK`

    **HTTP 首部字段**
    字段结构:KV;多个字段值用`,`号连接;若是字段值有可选参数且是多个则用`;`号连接
    Keep-Alive: timeout=15, max=100
    Accept: text/html, q=1; application/xml, q=0.8
    通用首部字段(General Header Fields)：请求和响应报文都会用的字段
    请求首部字段(Request Header Fields)：请求报文时用的字段
    响应首部字段(Response Header Fields)：响应报文时用的字段
    实体首部字段(Entity Header Fields)：请求和响应报文的实体部分用的字段
    **通用首部字段**
    这边有一个需要注意的点：
    Connection 首部字段有一个值是 keep-alive，表示开启持久连接
    一个首部字段也叫 Keep-Alive:timeout 一个空闲连接需要保持打开状态的最小时长,max 在连接关闭之前，在此连接可以发送的请求的最大值(关闭时间与容量)

    HTTP/1.1 200 OK
    **Connection: Keep-Alive**
    Content-Encoding: gzip
    Content-Type: text/html; charset=utf-8
    Date: Thu, 11 Aug 2016 15:23:13 GMT
    **Keep-Alive: timeout=5, max=1000**
    Last-Modified: Mon, 25 Jul 2016 04:32:39 GMT
    Server: Apache

    (body)

    需要将 The Connection 首部的值设置为 "keep-alive" 这个首部才有意义。同时需要注意的是，在 HTTP/2 协议中， Connection 和 Keep-Alive 是被忽略的；在其中采用其他机制来进行连接管理。
