1. 简单讲解一下 http2 的多路复用
   之前(http/1.0)是同一个连接只能用一次， 如果开启了 keep-alive(http/1.1)，虽然可以用多次，但是同一时刻只能有一个 HTTP 请求
   **简单来说， http2 的多路复用就是在同一个 TCP 连接，同一时刻可以传输多个 HTTP 请求。**
2. 谈谈你对 TCP 三次握手和四次挥手的理解
   ![img](https://user-images.githubusercontent.com/34148615/53062591-3d846300-34fc-11e9-8d0f-4063d9ff3398.png)
3. A、B 机器正常连接后，B 机器突然重启，问 A 此时处于 TCP 什么状态
4. HTTPS 握手过程中，客户端如何验证证书的合法性
   1. 服务器 用 RSA （非对称加密：加密和解密使用不同密钥的加密）生成公钥和私钥
   2. 把公钥放在证书里发送给客户端，私钥自己保存
   3. 客户端首先向一个权威的服务器检查证书的合法性，如果证书合法，客户端产生一段随机数，这个随机数就作为通信的密钥，我们称之为对称密钥，用公钥加密这段随机数，然后发送到服务器
   4. 服务器用密钥解密获取对称密钥，然后，双方就已对称密钥进行加密解密通信了
      PS:非对称的 RSA 加密性能是非常低的，原因在于寻找大素数、大数计算、数据分割需要耗费很多的 CPU 周期，所以一般的 HTTPS 连接只在第一次握手时使用非对称加密，通过握手交换对称加密密钥，在之后的通信走对称加密。
5. 介绍 HTTPS 握手过程
   1. 客户端使用 https 的 url 访问 web 服务器,要求与服务器建立 ssl 连接
   2. web 服务器收到客户端请求后, 会将网站的证书(包含公钥)传送一份给客户端
   3. 客户端收到网站证书后会检查证书的颁发机构以及过期时间, 如果没有问题就随机产生一个秘钥
   4. 客户端利用公钥将会话秘钥加密, 并传送给服务端, 服务端利用自己的私钥解密出会话秘钥
   5. 之后服务器与客户端使用秘钥加密传输
6. 介绍下 HTTPS 中间人攻击
   中间人攻击过程如下：

   1. 服务器向客户端发送公钥。
   2. 攻击者截获公钥，保留在自己手上。
   3. 然后攻击者自己生成一个【伪造的】公钥，发给客户端。
   4. 客户端收到伪造的公钥后，生成加密 hash 值发给服务器。
   5. 攻击者获得加密 hash 值，用自己的私钥解密获得真秘钥。
   6. 同时生成假的加密 hash 值，发给服务器。
   7. 服务器用私钥解密获得假秘钥。
   8. 服务器用加秘钥加密传输信息

CA 得保证不泄漏自己的私钥，否则中间人又可以连 CA 做的的签名都伪造了
charles 想拦截 https 先要信任他的证书，印象中 charles 确实是用中间人的方式实现的拦截

7. 介绍下 http1.0、1.1、2.0 协议的区别
   https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/232#issuecomment-516677308
   http/1 :
   默认不支持长连接，需要设置 keep-alive 参数指定
   强缓存 expired、协商缓存 last-modified\if-modified-since 有一定的缺陷

   http 1.1 :
   **默认长连接**(keep-alive)，http 请求可以复用 Tcp 连接，但是同一时间只能对应一个 http 请求(http 请求在一个 Tcp 中是串行的)
   增加了强缓存 cache-control、协商缓存 etag\if-none-match 是对 http/1 缓存的优化

   http/2 :
   **多路复用**，一个 Tcp 中多个 http 请求是并行的 (雪碧图、多域名散列等优化手段 http/2 中将变得多余)
   **二进制分帧**:将所有传输的信息分割为更小的消息和帧,并对它们采用二进制格式的编码
   **header 压缩**
   **服务端推送**:服务器可以额外的向客户端推送资源，而无需客户端明确的请求

   http1.0 到 http1.1 的主要区别，就是从无连接到长连接
   http2.0 对比 1.X 版本主要区别就是多路复用
   http1.0 不支持持久连接
   http1.1 支持持久连接，但是串行发送请求，并行请求只能同时建立多个 tcp 连接，引入了管道化，但是存在队头阻塞的问题

   http2.0
   二进制分帧(HTTP/2 采用二进制格式传输数据，相比于 HTTP/1.1 的文本格式)、
   多路复用(解决了 HTTP 层面的队头阻塞，即多个请求都通过一个 TCP 连接并发地完成，实现多路复用)、
   头部压缩(使用 HPACK 算法进行头部压缩,废除了起始行的概念)、
   服务端推送(服务器不再是完全被动地接收请求，响应请求，它也能新建 stream 来给客户端发送消息)

   为什么 HTTP1.1 不能实现多路复用:HTTP/1.1 不是二进制传输，而是通过文本进行传输。由于没有流的概念，在使用并行传输（多路复用）传递数据时，**接收端在接收到响应后，并不能区分多个响应分别对应的请求，所以无法将多个响应的结果重新进行组装**，也就实现不了多路复用。
   **具体说一下 HTTP/2 中的多路复用**
   类似于多个数组先 map 附加元信息，再按顺序随机 shift 最后还是可以得到原来的数组
   HTTP/2 引入了一个**二进制分帧层**，客户端和服务端进行传输时，数据会先经过二进制分帧层处理，转化为一个个**带有请求 ID 的帧**，这些帧在传输完成后根据 ID 组合成对应的数据。
   所以原本一个个完整的 HTTP 请求报文变成了现在的**一堆乱序的二进制帧**，这些二进制帧因为**不存在先后顺序所以也就不会排队等待，也就没有了 HTTP 队头阻塞的问题**。
   通信双方都可以给对方发送二进制帧，这种二进制帧的双向传输的序列，就叫做流。HTTP/2 **在一个 TCP 连接上来进行多个数据帧的通信，这就是多路复用的概念**。
   (所谓的乱序，指的是不同 ID 的 Stream 是乱序的，但同一个 Stream ID 的帧一定是按顺序传输的。)

8. 永久性重定向（301）和临时性重定向（302）对 SEO 有什么影响
   1）301 redirect——301 代表永久性转移(Permanently Moved)，301 重定向是网页更改地址后对搜索引擎友好的最好方法，只要不是暂时搬移的情况,都建议使用 301 来做转址。
   如果我们把一个地址采用 301 跳转方式跳转的话，搜索引擎会把老地址的 PageRank 等信息带到新地址，同时在搜索**引擎索引库中彻底废弃掉原先的老地址。旧网址的排名等完全清零**

（2）302 redirect——302 代表暂时性转移(Temporarily Moved )，在前些年，不少 Black Hat SEO 曾广泛应用这项技术**作弊**，目前，各大主要搜索引擎均加强了打击力度，象 Google 前些年对 Business.com 以及近来对 BMW 德国网站的惩罚。即使网站客观上不是 spam，也很容易被搜寻引擎容易误判为 spam 而遭到惩罚。
301（永久重定向）是旧地址的资源已经被永久地删除了，搜索引擎在抓取新内容的同时也将旧的网站替换为重定向后的地址
302（临时重定向）旧地址的资源还在，这个重定向的只是临时从旧地址跳转到新地址，搜索引擎会抓取新的内容而保存旧的地址

9. 接口如何防刷
   referer 校验
   UA 校验
   频率限制（1s 内接口调用次数限制）

   **刷是禁止不了的，只能提高刷的成本**
   前端：
   限制按钮，表单提交次数，防抖
   增加图片验证码，类似 12306

   后端：
   ip，user_agent，referer
   用户唯一标示
   简单验证码
   手机号验证码
   api key，rsa 加密认证，ca 认证（后端与后端之间调用）
   ip 黑名单（一般是刷的频率太大，达到 ddos 水平了或者确认为恶意调用）

10. 分别介绍下 http 和 tcp 协议，它们之间的区别与联系
    HTTP 属于应用层协议，TCP 属于传输层协议；
    HTTP 基于 TCP 建立连接、传输数据；
    HTTP 是无状态的短连接，TCP 是有状态的长连接
11. TCP 和 UDP 的区别
    TCP 是一个面向连接的、可靠的、基于字节流的传输层协议。
    UDP 是一个面向无连接的传输层协议。
    TCP 为什么可靠，是因为它有三次握手来保证双方都有接受和发送数据的能力。
12. http header 怎么判断协议是不是 websocket
    http 通过判断 header 中是否包含 **Connection: Upgrade** 与 **Upgrade: websocket** 来判断当前协议是否要升级到 websocket

13. HTTP/2 对比 HTTP/1.1，特性是什么？是如何解决队头阻塞与压缩头部的
14. dns 查询过程，dns 用什么协议发起 dns 查询的
15. 在项目中如何把 http 的请求换成 https
    所以每次请求的域名也是写在配置文件中，有一个 baseURL 字段专门用于存储它，所以只要改这个字段就可以达到替换所有请求 http 为 https 了。
    **利用 meta 标签把 http 请求换为 https:**

```HTML
<meta http-equiv ="Content-Security-Policy" content="upgrade-insecure-requests">
```

16. 跨域
    nginx/jsonp/websocket(没有使用 HTTP 的响应头，因此也没有跨域的限制)
17. XSS？CSRF？
    XSS
    **存储型**：即攻击被存储在服务端，常见的是在评论区插入攻击脚本，如果脚本被储存到服务端，那么所有看见对应评论的用户都会受到攻击。
    **反射型**：攻击者将脚本混在 URL 里，服务端接收到 URL 将恶意代码当做参数取出并拼接在 HTML 里返回，浏览器解析此 HTML 后即执行恶意代码
    **DOM 型**：将攻击脚本写在 URL 中，诱导用户点击该 URL，如果 URL 被解析，那么攻击脚本就会被运行。和前两者的差别主要在于 DOM 型攻击不经过服务端

    如何防御 XSS 攻击
    输入检查：对输入内容中的 script 和<iframe>等标签进行转义或者过滤
    设置 httpOnly：很多 XSS 攻击目标都是窃取用户 cookie 伪造身份认证，设置此属性可防止 JS 获取 cookie
    开启 CSP，即开启白名单，可阻止白名单以外的资源加载和运行

18. 为什么 TCP 要三次握手而不是两次
    为了保证**双方都有发送和接收的能力**，如果只有两次握手的话就只能保证发送方，一般就是我们的客户端有发送的能力，但是并不能保证**它有接收的能力**，所以必须是三次。
19. script 放在 body 头部就一定会阻塞吗
    async 与 defer 不会

20. 进程是资源分配的最小单位，线程是 CPU 调度的最小单位
    进程是运行中的程序，线程是进程的内部的一个执行序列
    进程是资源分配的单元，线程是执行行单元
    进程间切换代价大，线程间切换代价小
    进程拥有资源多，线程拥有资源少
    多个线程共享进程的资源
21. 为什么说 HTTPS 比 HTTP 安全呢
    通过混合加密保证传输的数据不被窃听
    通过数字签名的方式保证数据不会被篡改
    通过数字证书保证服务器身份的真实性
22. 在一次传输中它是如何保证每个数据包之间的顺序的？
    TCP 的报文中有序号和确认号来保证每个数据包之间的顺序。
23. GET 和 POST 的区别
    从缓存的角度上说，GET 会被浏览器主动缓存下来，留下历史记录，但是 POST 不会。
    从编码的角度上说，GET 只能进行 URL 编码，它只能接收 ASCII 字符，但是 POST 没有限制。
    从参数的角度上说，GET 一般放在 URL 上传递参数，POST 放在请求体里，更适合传递敏感信息。
    从幂等的角度上说，GET 是幂等的，而 POST 不是。
24. 为什么说 GET 会留下历史记录？
    浏览器规定的
25. GET 可以上传图片吗
    get 可以通过 URL 传参上传图片，可以将图片转为 base64 格式再进行传输，不过由于 get 请求的参数是有大小限制的，最多不超过 4kb。

26. CIA 三元组
    机密性（Confidentiality）
    完整性（Integrity）
    可用性（Availability）
27. 知道 XSS 有哪几种类型吗
    反射型 XSS (也叫非持久型) **恶意脚本存在 URL 里(url 参数)**
    基于 DOM 的 XSS **取出和执行恶意代码由浏览器端完成，例如 img 标签里的 script**
    存储型 XSS (也叫持久型 XSS) **恶意代码存在数据库里(例如提交表单)**
28. 分别说一下它们的实现原理
    反射型：顾名思义，恶意 JavaScript 脚本属于用户发送给网站请求中的一部分，随后网站又将这部分返回给用户，恶意脚本在页面中被执行。一般发生在前后端一体的应用中，服务端逻辑会改变最终的网页代码。
    基于 DOM 型：目前更流行前后端分离的项目，反射型 XSS 无用武之地。
    但这种攻击不需要经过服务器，我们知道，网页本身的 JavaScript 也是可以改变 HTML 的，黑客正是利用这一点来实现插入恶意脚本。
    存储型：又叫持久型 XSS，顾名思义，黑客将恶意 JavaScript 脚本长期保存在服务端数据库中，用户一旦访问相关页面数据，恶意脚本就会被执行。常见于搜索、微博、社区贴吧评论等。

29. XSS 攻击如何进行防护
    一切用户输入皆不可信，在输出时进行验证将 HTML 元素内容、属性以及 URL 请求参数、CSS 值进行编码当编码影响业务时，使用白名单规则进行检测和过滤使用 W3C 提出的 CSP (Content Security Policy，内容安全策略)，定义域名白名单设置 Cookie 的 HttpOnly 属性
30. 什么是 CSRF 攻击
    **CSRF 攻击就是黑客引诱用户打开黑客的网站，利用用户的登陆状态发起跨站请求。**
    CSRF 攻击一般怎么实现
    通过引诱链接诱惑用户点击触发请求，利用 a 标签的 href。
    构造隐藏表单来自动发起 Post 请求
31. CSRF 攻击和 XSS 攻击有什么区别？
    CSRF 攻击不需要将恶意代码注入用户的页面，仅仅是利用服务器的漏洞和用户的登录状态来实施攻击。
    CSRF 攻击成本也比 XSS 低，用户每天都要访问大量网页，无法确认每一个网页的合法性， 从用户角度来说，无法彻底防止 CSRF 攻击。
32. 如何防范 CSRF 攻击
    针对实际情况，设置关键 Cookie 的 SameSite 属性为 Strict 或 Lax 服务端验证请求来源站点(Referer、Origin)使用 **CSRF Token**，服务端随机生成返回给浏览器的 Token，每一次请求都会携带不同的 CSRF Token 加入二次验证(独立的支付密码)
33. 关于 Web 密码学你了解哪些呢
    对称加密算法就是加密和解密使用同一个密钥，简单粗暴 AES(AES-128)
    非对称加密就是加密和解密使用不同的密钥。发送方使用公钥对信息进行加密，接收方收到密文后，使用私钥进行解密。 RSA
    散列算法 不可逆性、鲁棒性、唯一性 使用时记得加盐 MD5、SHA(SHA-256)
34. HTTPS 在 TCP 和 HTTP 中间加入了 SSL/TLS 安全层。
    对发起 HTTP 请求的数据进行加密操作
    对接收到 HTTP 的内容进行解密操作。
    采用对称加密的方式加密传输数据和非对称加密的方式来传输密钥，既可以解决传输效率问题也能保证两端数据的安全传输。除此之外，为了能够证明服务器是可靠的，引入了数字证书，让浏览器验证证书的可靠性。
