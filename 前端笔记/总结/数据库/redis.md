1.  Redis 是 Remote Dictionary Server(远程字典服务器)的缩写
2.  作用：缓存/队列(列表)/发布订阅(聊天室)
3.  特点：读写高性能；持久化；单线程；数据自动过期；发布订阅；分布式
4.  应用场景
    - 缓存系统(键过期)
    - 排行榜(zset 有序集合 ZADD ZRANGE ZRANK)/微博热搜(存帖子 id 和回复量就可以了)
    - 计数器(incr 命令，内存操作)
    - 分布式会话(session 服务)
    - 分布式锁(setnx 返回 1 获取锁成功，否则失败)
    - 社交网络(哈希；集合)
    - 最新列表(LPUSH 命令)
    - 消息系统()
5.  秒杀与 redis 的结合
    秒杀出现的问题:
    1. 并发太高导致程序阻塞
    2. 库存无法有效控制，出现超买
       对应解决方案
    3. 数据尽量缓存，阻断直接访问数据库
    4. 锁来控制超卖现象
       那么 redis 应该如何操作呢？
       1. 提前预热数据放入 redis
       2. 商品列表放入 redis list
       3. 详细数据放入 redis hash 设置过期时间
       4. 库存数据用 redis SortedSet 保存
       5. 用户地址用 redis set 保存
       6. 订单扣库存通过 redis 制造分布式锁，库存同步扣除
       7. 订单产生后发货的数据产生 redis list,通过消息队列处理
       8. 秒杀结束后同步 redis 与数据库
6.  redis-server 与 redis-cli
    ping pong
7.  redis 的多数据库 (默认 16 个，名称为编号命名;类似于命名空间而非独立的数据库)
    自动选择 0 号数据库
    不同的应用应该使用不同的 redis 实例(再开一个)
8.  数据结构
    string hash set list(双向链表) ZSet(跳表实现) bitmap
    redis 种没有数字类型 都用字符串存 但是有 INCR
9.  redis 中的事务
    银行转账
    事务的 ACID 特性
10. | RDB 持久化与 AOF 持久化 |                              |
    | :---------------------- | ---------------------------- | -------- |
    | 持久化方式              | 优点                         | 缺点     |
    | RDB                     | 文件小；异步备份；恢复速度快 | 安全性低 |
    | AOF                     | 安全；利于开发分析异步       | 同步慢   |

    RDB:异步备份，将数据库的快照（`snapshot`）以二进制的方式保存到磁盘中
    AOF：将 redis **每一句命令 append 到文件**；同步；最安全，以协议文本的方式，将所有对数据库进行过写入的命令（及其参数）记录到 AOF 文件(`即记录 action`)

应用场景

11. 只允许三个人登录的场景
    Redis list 的实现为一个**双向链表**
    redis 队列
    lpush、rpush、lpop、rpop
    twitter 的关注列表、粉丝列表等都可以用 Redis 的 list 结构来实现
12. Hash
    Redis Hash 对应 Value 内部实际就是一个 HashMap，实际这里会有 2 种不同实现，这个 Hash 的成员比较少时 Redis 为了节省内存会采用类似一维数组的方式来紧凑存储，而不会采用真正的 HashMap 结构

13. 三种缓存模式:缓存常用的 3 种读写策略
    这 3 种缓存读写策略各有优劣，不存在最佳，需要我们根据具体的业务场景选择更适合的。

    1. Cache Aside Pattern（旁路缓存模式）(平时使用比较多的一个缓存读写模式，比较适合读请求比较多的场景。)
       写：先更新 DB，然后`直接删除 cache`
       读: 读 cache，读不到就从 DB 中读取数据返回,`再把数据放到 cache `中。

       **“在写数据的过程中，可以先删除 cache ，后更新 DB 么？”**
       可能会造成数据库（DB）和缓存（Cache）数据不一致的问题
       请求 1 先把 cache 中的 A 数据删除 -> 请求 2 从 DB 中读取数据->请求 1 再把 DB 中的 A 数据更新。
       **“在写数据的过程中，先更新 DB，后删除 cache 就没有问题了么？”**
       理论上来说还是可能会出现数据不一致性的问题，不过概率非常小，`因为缓存的写入速度是比数据库的写入速度快很多！`

       Cache Aside Pattern 的缺陷。
       缺陷 1：`首次请求数据一定不在 cache 的问题`
       解决办法：可以将**热点数据可以提前放入 cache 中。**

       缺陷 2：写操作比较频繁的话导致 **cache 中的数据会被频繁被删除，这样会影响缓存命中率 。**
       解决办法：

       - 数据库和缓存数据`强一致`场景 ：更新 DB 的时候同样更新 cache，不过我们需要加一个锁/分布式锁来保证更新 cache 的时候不存在线程安全问题。
       - 可以短暂地允许数据库和缓存数据`不一致`的场景 ：更新 DB 的时候同样更新 cache，但是给`缓存加一个比较短的过期时间`，这样的话就可以保证即使数据不一致的话影响也比较小。

    2. Read/Write Through Pattern（读写穿透）(开发过程中非常少见)
       把 cache 视为主要数据存储，从中读取数据并将数据写入其中
    3. Write Behind Pattern（异步缓存写入）(非常非常少见)

## redis 为什么快

Redis 为什么快，为什么单线程
首先，采用了多路复用阻塞 io 机制;
然后，数据结构简单，操作节省时间;
最后，运行在内存中，自然速度快
单线程：Redis 的瓶颈不是 cpu 的运行速度，而往往是网络带宽和机器的内存大小。单线程切换开销小，容易实现。
