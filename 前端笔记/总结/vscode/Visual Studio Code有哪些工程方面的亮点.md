1. 它到底是代码编辑器(Editor)还是集成开发环境(IDE)？
   Erich 阐述了 VS Code 的定位：编辑器+代码理解+调试
2. 较小的团队也使得团队成员做到了行为层面的整齐划一
   超出产品定位范畴的请求和反馈基本都被婉拒或者转交到第三方插件项目，可以说是很专注了。
3. 进程隔离的插件模型
   你用 Node 我用 Go，你搞前端我弄后台，VS Code 如何满这些五花八门的需求呢？机智的你已经抢答了——海量插件。
   来看看其他 IDE 是怎么做的，Visual Studio 自己搞定所有功能，并且做到优秀，让别人无事可做，这也成就了其“宇宙第一 IDE”的美名；IntelliJ 与之相仿，开箱即用，插件可有可无。这么看起来，自己搞定所有的事情是个好办法，但大家是否知道，Visual Studio 背后有庞大的工程团队，显然，这不是 VS Code 这几号人能搞定的。他们选择了让大家来做插件，那怎么解决 Eclipse 所遇到的问题呢？
   Eclipse 核心部分的开发者就是早期的 VS Code 团队。嗯，所以他们没有两次踏入同一条河流。与 Eclipse 不同，VS Code 选择了把插件关进盒子里。
   这样做首先解决的问题就是稳定性，这个问题对于 VS Code 来说尤为重要。都知道 VS Code 基于 Electron，实质上是个 node.js 环境，单线程，任何代码崩了都是灾难性后果。所以 VS Code 干脆不信任任何人，`把插件们放到单独的进程里`，任你折腾，主程序妥妥的。
   而遗憾的是，Eclipse 的插件运行在主进程中，任何插件性能不佳或者不稳定，都直接影响到 Eclipse，最终结果是大家抱怨 Eclipse 臃肿、慢、不稳定。
4. UI 渲染与业务逻辑隔离，一致的用户体验
   VS Code 的做法是根本不给插件们“发明”新界面的机会。
   插件们被关在 Extension Host 进程里，而 UI 则在主进程里，所以插件们天然没法直接在用户界面上做手脚。
   界面和业务逻辑的彻底隔离，使得所有插件有了一致的行为，用户就得到了整齐划一的体验。不仅如此，这种接口和行为层面的一致性，最终转化成了另一个“伟大”的功能——Remote Development，
5. LSP——基于文本的协议(Language Server Protocol。)
   前文提到了 VS Code 定位中的两个特色：代码理解和调试，绝大部分都由第三方插件来实现，中间的桥梁就是两大协议——Language Server Protocol(LSP)和 Debug Adapter Protocol(DAP)。
   先划重点：1、节制的设计 2、合理的抽象 2、周全的细节。
   先来说说设计(Design)，大而全是很常见的问题。如果让我来设计这么一个用来支持所有编程语言的东西，`第一反应很可能是搞个涵盖所有语言特性的超集。`
   相较之下，LSP 显然把小巧作为设计目标之一，它选择做最小子集，贯彻了团队一贯节制的作风。它关心的是用户在编辑代码时最经常处理的物理实体（比如文件、目录）和状态（光标位置）。它根本没有试图去理解语言的特性，编译也不是它所关心的问题，所以自然不会涉及语法树一类的复杂概念。它也不是一步到位的，而是随着 VS Code 功能的迭代而逐步发展的。所以它自诞生至今依然保持着小巧的身材，易懂，实现门槛也很低，迅速在社区得到了广泛的支持，各种语言的 Language Server(LS)遍地开花。
   小归小，功能可不能少，所以抽象就非常关键了。
   LSP 最重要的概念是动作和位置，LSP 的大部分请求都是在表达”`在指定位置执行规定动作`“。
   举个栗子，用户把鼠标悬停在某个类名上方，查看相关的定义和文档。这时 VS Code 会发送一个'textDocument/hover'请求给 LS，这个请求里最关键的信息就是当前的文档和光标的位置。LS 收到请求之后，经过一系列内部计算（识别出光标位置所对应的符号，并找出相关文档），找出相关的信息，然后发回给 VS Code 显示给用户看。这样一来一回的交互，在 LSP 里被抽象成请求(Request)和回复(Response)，LSP 同时也规定了它们的规格(Schema)。在开发者看来，概念非常少，交互形式也很简单，实现起来非常轻松。
   首先这是一个基于文本的协议，文本降低了理解和调试的难度。
   参考 HTTP 和 REST 的成功，很难想象如果这是一个二进制协议会是什么局面，
   其次这是一个基于 JSON 的协议,比 XML 简单太多。
   再次，这是一个基于 JSONRPC 的协议，由于 JSON 的流行，各大语言都对它有极好的支持，所以开发者根本不需要处理序列化、反序列化一类的问题，这是实现层面的“简单”。
   从这些细节可以看出，VS Code 团队对当今技术趋势的把握是相当精准的，他们决策充分考虑到了“简单”，牢牢抓住了社区开发者的心。所以重要的事情说三遍：

   在做设计的时候一定要倾向于简单。

   在做设计的时候一定要倾向于简单。

   在做设计的时候一定要倾向于简单。

6. 集大成的 Remote Development
   VSCRD 从本质上改善了远程开发的体验，与常用的远程桌面共享相比，具体改进如下：

   1. 响应迅速：VSCRD 所有的交互都在本地 UI 内完成，响应迅速；远程桌面由于传输的是截屏画面，数据往返延迟很大，卡顿是常态
   2. 沿用本地设置：VSCRD 的 UI 运行在本地，遵从所有本地设置，所以你依然可以使用自己所习惯的快捷键、布局、字体，避免了工作效率层面的开销
   3. 数据传输开销小：远程桌面传输的是视频数据，而 VS Code 传输是操作请求和响应，开销与命令行相仿，卡顿的情况进一步改善
   4. 第三方插件可用：在远程工作区里，不仅 VS Code 的原生功能可用，所有第三方插件的功能依然可用；远程桌面的话，你得自己一个个装好
   5. 远程文件系统可用：远程文件系统被完整映射到本地，这个两者差不多
      那么 VSCRD 做了什么神奇的操作能够实现以上效果呢？来看看它的架构图：
      1. 进程级别隔离的插件模型
         Extension Host（也就是图中的 VS Code Server）与主程序做到了物理级别的分离，`那么把 Extension Host 在远程或者本地跑没有本质的区别`
      2. UI 渲染与插件逻辑隔离，整齐划一的插件行为
         所有的插件的 UI 都由 VS Code 统一渲染，所以插件里面只有纯业务逻辑，行为高度统一，跑在哪里都没区别
      3. 高效的协议 LSP
         VS Code 的两大协议 LSP、DAP 都非常精简，天然适合网络延迟高的情况，用在远程开发上再适合不过

   VS Code 团队在架构上的决策无疑是非常有前瞻性的，与此同时，他们对细节的把握也是无可挑剔。正因为有了如此扎实的工程基础，VSCRD 这样的功能才得以诞生，所以我认为这是集大成的作品。

大家留意一下《Design Patterns》这本书的作者名单。对，就是他，不谢。
