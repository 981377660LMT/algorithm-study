1. 解析 HTML，生成 DOM 树（DOM）
2. 解析 CSS，生成 CSSOM 树（CSSOM）
3. 将 DOM 和 CSSOM 合并，生成渲染树（Render-Tree）
4. Layout(布局)：根据生成的渲染树，进行回流(Layout)，得到节点的**几何**信息（位置，大小）
5. Painting(绘制)：根据渲染树以及回流得到的几何信息，得到节点的**绝对像素**
6. 渲染层合并（Composite）合成图层、合成线程调用光栅化线程池，生成位图后浏览器进程间通信过程，显卡缓存与显示器的关系
7. 调用操作系统 NativeGUI API 进行绘制

几个关键概念

7. CSS 阻塞渲染(不阻塞解析)：由于 CSSOM 负责存储渲染信息，浏览器就必须保证在合成渲染树之前，CSSOM 是完备的，这种完备是指所有的 CSS（内联、内部和外部）都已经下载完，并解析完，只有 CSSOM 和 DOM 的解析完全结束，浏览器才会进入下一步的渲染。CSS 阻塞渲染意味着，在 CSSOM 完备前，页面将一直处理白屏状态，**这就是为什么样式放在 head 中**，仅仅是为了更快的解析 CSS，保证更快的首次渲染。
8. JS 阻塞页面(阻塞解析)：JS 可以操作 DOM 来修改 DOM 结构，可以操作 CSSOM 来修改节点样式，这就导致了浏览器在解析 HTML 时，一旦碰到 script，就会立即停止 HTML 的解析，也阻塞了其后的 CSS 解析，整个解析进程必须等待 JS 的执行完成才能够继续。从性能角度上讲，**将 script 放在页面底部，也就合情合理了**
9. 重排（Reflow）：DOM 结构中的各个元素都有自己的盒子（模型），这些都需要浏览器根据各种样式来计算并根据计算结果将元素放到它该出现的位置，这个过程称之为 reflow
   触发重排（reflow）：

1、当增加、删除、修改 DOM 节点时
2、元素的位置、尺寸发生变化
3、内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代
4、当 Resize 窗口的时候，或是滚动的时候
5、页面一开始渲染的时候

10. 重绘（Repaint）：当当页面中元素样式的改变并不影响它在文档流中的位置时（例如：color、background-color、visibility 等），浏览器会将**新样式赋予给元素并重新绘制**它，这个过程称为重绘。
    触发重绘（Repaint）：

    0、回流一定会触发重绘
    1、DOM 改动
    2、CSS 改动

    批量处理回流重绘：有时即使仅仅回流一个单一的元素，它的父元素以及任何跟随它的元素也会产生回流。**现代浏览器会对频繁的回流或重绘操作进行优化，浏览器会维护一个队列**，把所有引起回流和重绘的操作放入队列中，如果队列中的任务数量或者时间间隔达到一个阈值的，浏览器就会将队列清空，进行一次批处理，这样可以把多次回流和重绘变成一次。你访问以下属性或方法时，浏览器会立刻清空队列：

    - clientWidth
    - offsetWidth
    - scrollWidth
    - width
    - getComputedStyle()
    - getBoundingClientRect()

      以上属性和方法都需要返回**最新的布局信息**，因此浏览器不得不清空队列，触发回流重绘来返回正确的值。因此，我们在修改样式的时候，**最好避免使用上面列出的属性，他们都会刷新渲染队列。**如果要使用它们，最好将值缓存起来。

11. 最小化重绘和重排

    1. 一次性修改样式：减少内联样式使用 样式合并写法
    2. 批量修改 DOM：使用文档片段创建一个子树，然后再拷贝到文档中（document.fragment）
    3. 缓存布局信息

    ```JS
    //每次需要查询div.offsetLeft 浪费性能
    div.style.left = 1 + div.offsetLeft + 'px';
    div.style.top = 1 + div.offsetTop + 'px';

    //将这个值保存下来，避免重复取值 性能优化
    current = div.offsetLeft;
    div.style.left = 1 + ++current + 'px';
    div.style.top = 1 + ++current + 'px';

    ```

12. 由于浏览器使用流式布局( Flow Based Layout)，对 Render Tree 的计算通常只需要遍历一次就可以完成，但 table 及其内部元素除外，通常需要多次计算且要花费 3 倍于同等元素的时间，这也是为什么要避免使用 table 布局的原因之一

13. 如何避免触发回流和重绘
    **CSS**：

    避免使用 table 布局。
    尽可能在 DOM 树的最末端改变 class。
    避免设置多层内联样式。
    将动画效果应用到 position 属性为 absolute 或 fixed 的元素上
    避免使用 CSS 表达式（例如：calc()）
    CSS3 硬件加速（GPU 加速）

    **JavaScript**：

    避免频繁操作样式，最好一次性重写 style 属性，或者将样式列表定义为 class 并一次性更改 class 属性
    避免频繁操作 DOM，创建一个 `documentFragment`，在它上面应用所有 DOM 操作，最后再把它添加到文档中
    也可以先为元素设置 display: none，操作结束后再把它显示出来。因为在 display 属性为 none 的元素上进行的 DOM 操作不会引发回流和重绘
    避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用`一个变量缓存`起来
    `对具有复杂动画的元素使用绝对定位，使它脱离文档流`，否则会引起父元素及后续元素频繁回流
