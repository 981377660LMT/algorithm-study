1. 解析 HTML，生成 DOM 树（DOM）
2. 解析 CSS，生成 CSSOM 树（CSSOM）
3. 将 DOM 和 CSSOM 合并，生成渲染树（Render-Tree）
4. 计算渲染树的布局（Layout）回流(重排)
5. 将布局渲染到屏幕上（Paint） 重绘

几个关键概念

1. CSS 阻塞渲染(不阻塞解析)：由于 CSSOM 负责存储渲染信息，浏览器就必须保证在合成渲染树之前，CSSOM 是完备的，这种完备是指所有的 CSS（内联、内部和外部）都已经下载完，并解析完，只有 CSSOM 和 DOM 的解析完全结束，浏览器才会进入下一步的渲染。CSS 阻塞渲染意味着，在 CSSOM 完备前，页面将一直处理白屏状态，**这就是为什么样式放在 head 中**，仅仅是为了更快的解析 CSS，保证更快的首次渲染。
2. JS 阻塞页面(阻塞解析)：JS 可以操作 DOM 来修改 DOM 结构，可以操作 CSSOM 来修改节点样式，这就导致了浏览器在解析 HTML 时，一旦碰到 script，就会立即停止 HTML 的解析，也阻塞了其后的 CSS 解析，整个解析进程必须等待 JS 的执行完成才能够继续。从性能角度上讲，**将 script 放在页面底部，也就合情合理了**
3. 重排（Reflow）：DOM 结构中的各个元素都有自己的盒子（模型），这些都需要浏览器根据各种样式来计算并根据计算结果将元素放到它该出现的位置，这个过程称之为 reflow
   触发重排（reflow）：

   1、当增加、删除、修改 DOM 节点时，会导致 reflow 或 repaint
   2、当移动 DOM 的位置，或是插入动画的时候
   3、当修改 CSS 样式的时候
   4、当 Resize 窗口的时候，或是滚动的时候
   5、当修改网页的默认字体时

4. 重绘（Repaint）：当各种盒子的位置、大小以及其他属性，例如颜色、字体大小等都确定下来后，浏览器便把这些元素都按照各自的特性绘制了一遍，于是页面的内容出现了，这个过程称之为 repaint。
   触发重绘（Repaint）：

   1、DOM 改动
   2、CSS 改动

5. 最小化重绘和重排

   1. 一次性修改样式：减少内联样式使用 样式合并写法
   2. 批量修改 DOM：使用文档片段创建一个子树，然后再拷贝到文档中（document.fragment）
   3. 缓存布局信息

   ```JS
   //每次需要查询div.offsetLeft 浪费性能
   div.style.left = 1 + div.offsetLeft + 'px';
   div.style.top = 1 + div.offsetTop + 'px';

   //将这个值保存下来，避免重复取值 性能优化
   current = div.offsetLeft;
   div.style.left = 1 + ++current + 'px';
   div.style.top = 1 + ++current + 'px';

   ```
