1. cookie 和 token 都存放在 header 中，为什么不会劫持 token
   1、首先 token 不是防止 XSS 的，而是为了防止 CSRF 的；
   2、CSRF 攻击的原因是浏览器会自动带上 cookie，而浏览器不会自动带上 token

---

2.  请求时浏览器缓存 from memory cache 和 from disk cache 的依据是什么，哪些数据什么时候存放在 Memory Cache 和 Disk Cache 中
    从缓存位置上来说分为四种，并且各自有优先级，当依次查找缓存且都没有命中的时候，才会去请求网络。

    - Service Worker
      Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker 的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。Service Worker 的缓存与浏览器其他内建的缓存机制不同，**它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。**

    - Memory Cache
      是内存中的缓存. 一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。
    - Disk Cache
      存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache 胜在容量和存储时效性上。
    - Push Cache
      Push Cache（推送缓存）是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂，

      我们根据是否需要向服务器重新发起 HTTP 请求将缓存过程分为两个部分，分别是强缓存和协商缓存

      **强缓存**：不会向服务器发送请求，直接从缓存中读取资源，在 chrome 控制台的 Network 选项中可以看到该**请求返回 200 的状态码**，并且 Size 显示 **from disk cache 或 from memory cache**。强缓存可以通过设置两种 HTTP Header 实现：**Expires(HTTP/1) 和 Cache-Control(HTTP/1.1)**。

      Expires 是 HTTP/1 的产物，受限于本地时间，如果修改了本地时间，可能会造成缓存失效;资源到期的时间，是服务器端的具体的时间点.Expires 其实是过时的产物，现阶段它的存在只是一种兼容性的写法。

      Cache-Control

      - public：所有内容都将被缓存（客户端和代理服务器都可缓存）
      - private：所有内容只有客户端可以缓存
      - no-cache：客户端缓存内容，是否使用缓存则需要经过协商缓存来验证决定
      - no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存
      - max-age：max-age=xxx (xxx is numeric)表示缓存内容将在 xxx 秒后失效

强缓存判断是否缓存的依据来自于是否超出某个时间或者某个时间段，而不关心服务器端文件是否已经更新，这可能会导致加载文件不是服务器端最新的内容，那我们如何获知服务器端内容是否已经发生了更新呢？此时我们需要用到协商缓存策略。
协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况
**协商缓存生效，返回 304 和 Not Modified**
**协商缓存失效，返回 200 和请求结果**
协商缓存可以通过设置两种 HTTP Header 实现：Last-Modified 和 ETag 。

| 名称 | client            | server        | 评价                                                                                |
| ---- | ----------------- | ------------- | ----------------------------------------------------------------------------------- |
| A    | If-Modified-Since | Last-Modified | 只能以秒计时 ;如果是负载均衡的服务器，各个服务器生成的 Last-Modified 也有可能不一致 |
| B    | If-None-Match     | ETag          | 唯一标识 ;精度高；性能消耗高；优先                                                  |

**缓存机制**
强制缓存优先于协商缓存进行，若强制缓存(Expires 和 Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since 和 Etag / If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，返回 200，重新返回资源和缓存标识，再存入浏览器缓存中；生效则返回 304，继续使用缓存。
**实际场景应用缓存策略**
频繁变动的资源 `Cache-Control: no-cache`
不常变化的资源 `Cache-Control: max-age=31536000(一年)` 在线提供的类库 (如 jquery-3.3.1.min.js, lodash.min.js 等) 均采用这个模式。
**用户行为对浏览器缓存的影响**
打开网页，地址栏输入地址： **查找 disk cache 中是否有匹配**。如有则使用；如没有则发送网络请求。
普通刷新 (F5)：因为 TAB 并没有关闭，因此 **memory cache 是可用的**，会被优先使用(如果匹配的话)。**其次才是 disk cache**。
强制刷新 (Ctrl + F5)：浏览器不使用缓存，因此发送的请求头部均带有 Cache-control: **no-cache**(为了兼容，还带了 Pragma: no-cache),服务器直接返回 200 和最新内容。

3. 为什么通常在发送数据埋点请求的时候使用的是 1x1 像素的透明 gif 图片
   英文术语叫：image beacon

- 没有**跨域**问题，一般这种上报数据，代码要写通用的；（排除 ajax）
- 不会阻塞页面加载，影响用户的体验，不需要额外注入 DOM,只要 new Image 对象就好了；（排除 JS/CSS 文件资源方式上报）
- 在所有图片中，体积最小；（最小的 BMP 文件需要 74 个字节，PNG 需要 67 个字节，而合法的 GIF，只需要 **43** 个字节）

```JS
<script type="text/javascript">
 var thisPage = location.href;
 var referringPage = (document.referrer) ? document.referrer : "none";
 var beacon = new Image();
 beacon.src = "http://www.example.com/logger/beacon.gif?page=" + encodeURI(thisPage)
 + "&ref=" + encodeURI(referringPage);
</script>
```

主要应用于只需要向服务器发送数据(日志数据)的场合，且无需服务器有消息体回应。比如收集访问者的统计信息。
用 header 来响应比较合适，目前比较合适的做法**是服务器发送"204 No Content"**，即“服务器成功处理了请求，但不需要返回任何实体内容”。

为什么不能直接用 GET/POST/HEAD 请求接口进行上报
打点域名都不是当前域名，所以所有的接口请求都会构成跨域

为什么不能用请求其他的文件资源（js/css/ttf）的方式进行上报
这和浏览器的特性有关。通常，创建资源节点后只有将对象注入到浏览器 DOM 树后，浏览器才会实际发送资源请求。反复操作 DOM 不仅会引发性能问题，而且载入 js/css 资源还会阻塞页面渲染，影响用户体验。
但是图片请求例外。构造图片打点不仅不用插入 DOM，**只要在 js 中 new 出 Image 对象就能发起请求**，而且还没有阻塞问题，在没有 js 的浏览器环境中也能通过 img 标签正常打点，这是其他类型的资源请求所做不到的。

4. 浏览器缓存 ETag 里的值是怎么生成的
   Nginx 的 ETag 生成方式

5. 从页面 A 打开一个新页面 B，B 页面关闭（包括意外崩溃），如何通知 A 页面
   本题是 html 页面通信题，可以拆分成：

   1. A 页面打开 B 页面，A、B 页面通信方式？

   - A 页面通过 url 传递参数与 B 页面通信，同样通过监听 hashchange 事件，在页面 B 关闭时与 A 通信
   - postMessage 是 h5 引入的 API，postMessage() 方法允许来自不同源的脚本采用异步方式进行有效的通信，可以实现跨文本文档、多窗口、跨域消息传递，可在多用于窗口间数据通信
   - localStorage 仅允许你访问一个 Document 源（origin）的对象 Storage；存储的数据将保存在浏览器会话中。如果 A 打开的 B 页面和 A 是不同源，则无法访问同一 Storage
   - Service Worker 是一个可以长期运行在后台的 Worker，能够实现与页面的双向通信。多页面共享间的 Service Worker 可以共享，将 Service Worker 作为消息的处理中心（中央站）即可实现广播效果。

   2. B 页面正常关闭，如何通知 A 页面？
      页面正常关闭时，会先执行 window.**onbeforeunload** ，然后执行 window.**onunload** ，我们可以在这两个方法里向 A 页面通信

   3. B 页面意外崩溃，又该如何通知 A 页面？
      **我们可以利用 window 对象的 load 和 beforeunload 事件，通过心跳监控来获取 B 页面的崩溃**

6. docoment,window,html,body 的层级关系
   window > document > html > body

7. 浏览器为什么要跨域？如果是因为安全的话那小程序或者其他的为什么没有跨域？
   跨域的产生来源于现代浏览器所通用的同源策略，在地址栏输入要访问的地址或者点击某个链接就可以了，正是这种开放的形态，所以我们需要对它有所限制。
   同源策略主要是为了保证用户信息的安全，可分为两种：Ajax 同源策略和 DOM 同源策略。
   Ajax 同源策略主要是使得不同源的页面**不能获取 cookie 且不能发起 Ajax 请求，这样在一定层度上防止了 CSRF 攻击**。
   DOM 同源策略也一样，它限制了**不同源页面不能获取 DOM**，这样可以防止一些恶意网站在自己的网站中利用 iframe 嵌入正 gui 的网站并迷惑用户，以此来达到窃取用户信息。

   ```HTML
   // HTML
   <iframe name="yinhang" src="www.yinhang.com"></iframe>
   // JS
   // 由于没有同源策略的限制，钓鱼网站可以直接拿到别的网站的Dom
   const iframe = window.frames['yinhang']
   const node = iframe.document.getElementById('你输入账号密码的Input')
   console.log(`拿到了这个${node}，我还拿不到你刚刚输入的账号密码吗`)

   ```

8. 跨域资源共享(CORS)
   它允许浏览器向跨源服务器，发出 XMLHttpRequest 或 Fetch 请求。并且整个 CORS 通信过程都是浏览器自动完成的，不需要用户参与。
   实现 CORS 的关键是服务器需要服务器。通常是有以下几个配置：

   Access-Control-Allow-Origin
   Access-Control-Allow-Methods
   Access-Control-Allow-Headers 服务器允许的首部字段
   Access-Control-Allow-Credentials
   Access-Control-Max-Age 该响应的有效时间(s),在有效时间内浏览器无需再为同一个请求发送预检请求;减少 CORS 预请求的次数
   例如我们想要在跨域请求中带上 cookie，需要满足 3 个条件：

   web（浏览器）请求设置 withCredentials 为 true
   服务器设置首部字段 Access-Control-Allow-Credentials 为 true
   服务器的 Access-Control-Allow-Origin 不能为\*

   当我们发起跨域请求时，**如果是非简单请求**，浏览器会帮我们自动触发预检请求，也就是 OPTIONS 请求，用于确认目标资源是否支持跨域。如果是简单请求，则不会触发预检，直接发出正常请求。
   浏览器会根据**服务端响应的 header 自动处理剩余的请求**，如果响应支持跨域，则继续发出正常请求，如果不支持，则在控制台显示错误。

过程总结：

1. 浏览器先根据同源策略对前端页面和后台交互地址做匹配，若同源，则直接发送数据请求；若不同源，则发送跨域请求。

2. 服务器收到浏览器跨域请求后，根据自身配置返回对应文件头。若未配置过任何允许跨域，则文件头里不包含 Access-Control-Allow-origin 字段，若配置过域名，则返回 Access-Control-Allow-origin + 对应配置规则里的域名的方式。

3. 浏览器根据接受到的 响应头里的 Access-Control-Allow-origin 字段做匹配，若无该字段，说明不允许跨域，从而抛出一个错误；若有该字段，则对字段内容和当前域名做比对，如果同源，则说明可以跨域，浏览器接受该响应；若不同源，则说明该域名不可跨域，浏览器不接受该响应，并抛出一个错误。

另外在 CORS 中有简单请求和非简单请求，简单请求是不会触发 CORS 的预检请求的，而非简单请求会。

         CORS 的哪些是简单请求？

         1.  只能使用 GET、HEAD、POST 方法。使用 POST 方法向服务器发送数据时，Content-Type 只能使用 application/x-www-form-urlencoded、multipart/form-data 或 text/plain 编码格式。
         2.  请求时不能使用自定义的 HTTP Headers

9.  V8 的垃圾回收是发生在什么时候？
    V8 引擎帮助我们实现了自动的垃圾回收管理，利用**浏览器渲染页面的空闲时间进行垃圾回收。**
10. 说一下垃圾回收机制
    栈内存的回收：
    栈内存调用栈上下文切换后就被回收，比较简单。(闭包里的变量在堆内存)
    堆内存的回收：
    V8 的堆内存分为新生代内存和老生代内存，新生代内存是临时分配的内存，存在时间短，老生代内存存在时间长。

    新生代内存回收机制：
    新生代内存容量小，64 位系统下仅有 32M。
    Scavenge 算法**新生代内存分为 From、To 两部分**，进行垃圾回收时，**先扫描 From，将非存活对象回收，将存活对象顺序复制到 To 中，之后调换 From/To，等待下一次回收**

    老生代内存回收机制
    **晋升**：如果新生代的变量经过多次回收依然存在，那么就会被放入老生代内存中
    **标记清除**：老生代内存会先遍历所有对象并打上标记，然后对正在使用或被强引用的对象取消标记，回收被标记的对象
    **整理内存碎片**：把对象挪到内存的一端

11. V8 如何执行一段 JS 代码
    1. 预解析：检查语法错误但不生成 AST
    2. 生成 AST：经过词法/语法分析，生成抽象语法树
    3. 生成字节码：基线编译器(Ignition)将 AST 转换成字节码
    4. 生成机器码：优化编译器(Turbofan)将字节码转换成优化过的机器码，此外在逐行执行字节码的过程中，如果一段代码经常被执行，那么 V8 会将这段代码直接转换成机器码保存起来，下一次执行就不必经过字节码，优化了执行速度
12. setTimeout 的执行原理
    执行该语句时，是立即把当前定时器代码推入事件队列，当定时器在事件列表中满足设置的时间值时将传入的函数加入任务队列，之后的执行就交给任务队列负责。但是如果此时任务队列不为空，则需等待，所以执行定时器内代码的时间可能会大于设置的时间
13. requestAnimationFrame 有了解过吗？
    让**回到顶部**更加平滑

14. **eventLoop**
    一开始整个脚本作为一个宏任务执行
    执行过程中同步代码直接执行，宏任务进入宏任务队列，微任务进入微任务队列
    当前宏任务执行完出队，检查微任务列表，有则依次执行，直到全部执行完
    执行浏览器 UI 线程的渲染工作
    检查是否有 Web Worker 任务，有则执行
    执行完本轮的宏任务，回到 2，依此循环，直到宏任务和微任务队列都为空
    **requestAnimationFrame 它不属于宏任务也不属于微任务，因为它是独立于主线程之外的任务，不归主线程管。**
15. 如何在前端实现一个图片压缩
    canvas
    核心 API 就是使用 canvas 的 drawImage()方法。
    Canvas 本质上就是一张位图，而 drawImage()方法可以把一张大大的图片绘制在小小的 Canvas 画布上，不久等同于图片尺寸压缩了

```JS
var canvas = document.createElement('canvas');
var context = canvas.getContext('2d');
canvas.width = 400;
canvas.height = 300;
// 核心JS就这个
context.drawImage(img,0,0,400,300);
```

**如果想要上传或下载**
以使用 canvas.toDataURL()或者 canvas.toBlob()方法先进行转换

```JS
canvas.toDataURL(mimeType, qualityArgument)
```

```JS
canvas.toBlob(callback, mimeType, qualityArgument)
// canvas转为blob并上传
canvas.toBlob(function (blob) {
  // 图片ajax上传
  var xhr = new XMLHttpRequest();
  // 开始上传
  xhr.open("POST", 'upload.php', true);
  xhr.send(blob);
});
```

16. addEventListener 函数的第三个参数
    第三个参数涉及到冒泡和捕获，是 true 时为捕获，是 false 则为冒泡。
    或者是一个对象{passive: true}，针对的是 Safari 浏览器，禁止/开启使用滚动的时候要用到。
17. target="\_blank"有哪些问题？

    1. 安全隐患：新打开的窗口可以通过 window.opener 获取到来源页面的 window 对象即使跨域也可以。某些属性的访问被拦截，是因为跨域安全策略的限制。 但是，比如修改 window.opener.location 的值，指向另外一个地址，这样新窗口有可能会把原来的网页地址改了并进行页面伪装来欺骗用户。
    2. 新打开的窗口与原页面窗口共用一个进程，若是新页面有性能不好的代码也会影响原页面

    尽量不用 target="\_blank"
    如果一定要用，需要加上 **rel="noopener"或者 rel="noreferrer"**。这样新窗口的 window.openner 就是 null 了，而且会让新窗口运行在独立的进程里，不会拖累原来页面的进程。(不过，有些浏览器对性能做了优化，即使不加这个属性，新窗口也会在独立进程打开。不过为了安全考虑，还是加上吧。)

18. children 以及 childNodes 的区别
    children 和只获取该节点下的所有 element 节点
    childNodes 不仅仅获取 element 节点还会获取元素标签中的空白节点
    firstElementChild 只获取该节点下的第一个 element 节点
    firstChild 会获取空白节点
19. 知道 insertAdjacentHTML 方法吗？

```JS
Element.insertAdjacentHTML(position, text);
```

用法
一个空的容器(你可以理解为一个 div)，开始需要一个 loading 的效果，在数据加载完毕之后，需要**把 loading 取掉且清空容器内的元素并以其它方式重新渲染出容器的内容**。

20. form 表单中的 label 标签的作用？
    当你使用了一个 label 标签和一个 input 绑定起来之后，点击 label 标签上的文字就会自动聚焦到 input 上。
    绑定的方式：

        label 标签上设置 for 属性
        input 标签上设置和 for 属性一样的 id

    这里有两点需要注意的：
    这两个标签不一定非要在 form 标签内才会生效
    for 是和 id 对应的，并不是和 name

21. 文档对象模型 DOM（Document Object Model）定义访问和处理 HTML 文档的标准方法。
    DOM 将 HTML 文档呈现为带有元素、属性和文本的树结构（节点树）。
    每一个节点都有三个特点:
    1.nodeName 节点名称(只读)
    2.nodeValue 节点值(设置或返回节点的值)
    3.nodeType 节点类型
    元素 element 1
    属性 attr 2
    文本 text 3
22. documentElement 属性以一个元素对象返回一个文档的文档元素。HTML 文档返回对象为 HTML 元素。

```HTML
<body>
    <script type="text/javascript">
        alert(document.documentElement.nodeName);    // html
        alert(document.documentElement.nodeValue);    // null
        alert(document.documentElement.nodeType);    // 1
    </script>
</body>

```

23. **cookie**
    通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态，解决 HTTP 无状态的问题，本质就是存储在浏览器上一个很小的文本文件(也可能存在本地文件里)

    **关于 Cookie 的首部字段**

    Set-Cookie
    Cookie

    **交互流程**
    客户端请求服务端
    服务端生成 Cookie 信息使用 Set-Cookie 添加到响应报文头部上
    客户端在拿到之后保存 Cookie
    在下次请求的时候通过把信息写入请求报文头部 Cookie 字段中传给服务端

    **生命周期**
    **默认情况下 Cookie 是暂时存在的**，也就是它们的存储只在浏览器会话期间存在，当用户在关闭浏览器时失效
    **可以使用 expires 和 max-age 来设置 Cookie 的过期时间**

    - expires=DATE
      Set-Cookie: token=112233; expires=Wed Aug 12 2020 21:55:03 GMT
    - max-age=TIME
      Set-Cookie: token=112233; max-age=36000
      **0：立即删除这个 Cookie**
      **正数：浏览器将其持久化写入 Cookie 中**
      **负数：会话性 Cookie**

    **作用域**
    关于 Cookie 作用域的首部字段有哪些呢？

    - domain=域名 Set-Cookie: domain=.example.com
      指定 Cookie 可以送达的主机名。
    - path=PATH Set-Cookie: name=xxx; path=/docs
      只有/docs 下的资源才会带有 Cookie，而另一个名为/test 的目录下就没有。

    **安全性**
    **Secure** Set-Cookie: name=xxx; secure
    表示 Cookie 只在 HTTPS 下传输。
    **HttpOnly** Set-Cookie: name=xxx; HttpOnly
    不能通过 JS 脚本文件访问 **预防 XSS 攻击**的重要手段吧
    **SameSite** Set-Cookie: name=xxx; SameSite=Lax
    限制第三方(跨站) Cookie，一般用来防止 CSRF 攻击
    SameSite 有哪些属性值

    - Strict 完全禁止第三方 Cookie 跨站点使用
    - Lax 允许部分第三方请求携带 Cookie。 只能允许 链接、预加载、GET 表单 发送 Cookie
    - None 无论是否跨站都会发送 Cookie。

    SameSite 在使用时需要注意什么
    对于默认值，Chrome80 之前一直是 None，在 Chrome80 之后为 Lax
    HTTP 接口不支持 SameSite=None，必须配合 Secure 属性，表示只有在 HTTPS 协议下才发送 Cookie

    **Cookie 实际的用处**
    会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）
    个性化设置（如用户自定义设置、主题等）
    浏览器行为跟踪（如跟踪分析用户行为等）

    **缺点**
    容量缺陷 Cookie 的体积上限只有 4KB
    性能缺陷 不管域名下面的某一个地址需不需要这个 Cookie ，请求都会携带上完整的 Cookie，使得请求会携带不必要的参数。但是可以通过 Domain 和 Path 指定作用域来解决
    安全缺陷 由于 Cookie 以纯文本的形式在浏览器和服务器中传递，很容易被非法用户截获。在 HttpOnly 为 false 的情况下可以通过 JS 脚本获取到。

24. preload 与 prefetch
    preload 加载资源一般是**当前页面需要的**，prefetch 一般是**其它页面有可能用到的资源**。
    < link rel = " preload" > 告诉浏览器尽快下载并缓存一个资源(比如脚本或样式表)。当您在加载页面后几秒钟内需要该资源并希望加速时，这种方法很有帮助;不会阻塞文档的 onload 事件。
    < link rel = " prefetch" > 要求浏览器在后台下载并缓存一个资源(比如，一个脚本或者一个样式表)。下载的优先级较低，因此不会干扰更重要的资源。如果您知道在随后的页面中将需要该资源，并且希望提前缓存它，那么这将非常有帮助。
25. 为什么 css 放上面 js 放下面
    1. CSS 不阻塞 DOM tree 解析
    2. javascript 加载后会立即执行，同时会阻塞后面的资源加载
26. DOMContentLoaded 和 load
    从页面空白到展示出页面内容的过程就会触发 DOMContentLoaded 事件，而这段事件就是 HTML 文档被加载和解析完成。
    页面上所有的资源（图片，音频，视频等）被加载以后才会触发 load 事件，页面的 load 事件会在 DOMContentLoaded 被触发之后才触发。
    jquery 中的 ready 函数其实监听的 DOMContentLoaded 事件，
27. href 和 src 的区别
    一般加载 CSS 用 href,并放在头部；加载 script 用 src，放在 body 内的下方。
    href:超文本引用;常用的有 link，a。不会停止对当前文档的加载。
    src:是 source 的缩写.常用的有 img, script, iframe。
    当 script 使用 src 引用，浏览器解析到该元素时会停止对文档的渲染，直到该资源加载完成。这也是将 script 放底部而不是头部的原因。
