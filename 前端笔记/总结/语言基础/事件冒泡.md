这个问题通常是因为第三方抽屉组件使用了 React Portal 将 DOM 挂载到了 `body` 上，但 React 的事件冒泡机制仍然会沿着组件树向上传递，导致画布容器捕获到了点击事件。

由于抽屉的 DOM 实际上并不在画布容器的 DOM 内部，我们可以通过检查 `e.target` 是否包含在 `e.currentTarget`（画布容器）中来过滤掉这些冒泡上来的事件。

请在 useCanvasEvents.tsx 中修改 `onPointerDown` 方法：

```typescript
// ...existing code...
      onPointerDown: (e: React.PointerEvent) => {
        if ((e as any).dead) {
          return;
        } else {
          (e as any).dead = true;
        }

        // 阻止 React Portal 冒泡的事件（如抽屉、弹窗）触发画布交互
        // 如果事件目标不在当前容器内，说明它是通过 Portal 冒泡过来的
        if (e.currentTarget && !e.currentTarget.contains(e.target as Node)) {
          return;
        }

        if (!inputs.pointerIsValid(e)) {
          return;
        }

        // setPointerCapture 会使onClick事件无法冒泡，导致 textinput输入框的清除icon点击失效，或下拉框的下拉选择失效等。
// ...existing code...
```

**原理说明：**

- `e.currentTarget` 是绑定了事件监听器的元素（即画布容器）。
- `e.target` 是实际被点击的元素（即抽屉内的元素）。
- 如果是 React Portal 渲染的抽屉，`e.target` 在 DOM 结构上位于 `body` 下，不在 `e.currentTarget` 内部。
- `!e.currentTarget.contains(e.target)` 为 `true`，从而直接返回，不再执行后续的选中/取消选中逻辑。
