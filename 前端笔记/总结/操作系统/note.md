1.  服务器为什么用 Linux
    首先就是开源，其次就是安全无漏洞不容易被攻击
2.  select epoll 等异步
3.  串行=>批处理=>进程=>线程
4.  同步异步 阻塞非阻塞
    进程五个状态(参考 Java)
    同步异步:消息通信机制
    阻塞非阻塞：程序等待调用结果时的状态
5.  用户态和内核态理解
    执行等级
6.  进程何时进入内核态
    系统调用/异常中断/外围设备中断
7.  IO 密集型： 复制粘贴，下载工具
8.  CPU 密集型：游戏画面渲染(gpu)，图片卷积，视频解码，AI 模型训练
9.  协程
10. 什么是虚拟内存
    内存管理关键技术
11. 操作系统的内存管理：
    页式：**进程逻辑空间分成若干固定大小的页面**。分页映射，页大小固定，逻辑连续，物理分散 页面 4k 大小
    **页表**记录进程逻辑空间与物理空间的映射
    段式：**进程逻辑空间分成若干大小的段**，分段映射，段大小不固定，取决于连续逻辑的长度，例如主函数，子函数等
    段页式:逻辑空间先分段，段内空间再分页
    操作系统中的缺页中断:
    访问的页面不在内存，则产生缺页中断.
12. 页面置换算法:在地址映射过程中，若在页面中发现**所要访问的页面不在内存中**，则产生**缺页中断**。当发生缺页中断时，如果操作系统内存中没有空闲页面，则操作系统必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。而用来选择淘汰哪一页的规则叫做页面置换算法(理解为安卓的后台页面)。
    FIFO
    LFU
    LRU
    OPT
    CLOCK
13. linux 文件系统(Ext 文件系统)
    软连接与硬链接的区别：硬链接直接指向 Inode/软连接有自己的 Inode 和 Block ,指向源文件
    软连接：windows 快捷方式
    linux 文件=Inode+Block
    INode:保存文件的元信息
    Block:存放文件内容
14. RAID 磁盘冗余阵列
    利用虚拟化技术组合多个硬盘成一个，提升性能减少冗余

15. 死锁
    概念：进程/线程竞争发生阻塞(例如 go channel 阻塞,生产者消费者阻塞，哲学家就餐)
    原因：竞争临界资源(只允许一个线程访问的资源)/调度顺序不当
    四个必要条件:`互斥`、`请求和保持`、`不可剥夺`、`环路`
    如何避免线程死锁:破坏` 请求和保持``环路 `
16. 🔒 的种类
    乐观锁/悲观锁
    乐观锁：适合读操作多；结束确定版本号
    悲观锁：适合写操作多

    无锁=>偏向锁=>轻量级锁=>重量级锁
    无锁：不锁资源，多个线程一个改，其余线程重试
    偏向锁：同一个线程自动获取资源
    轻量级锁：没有获得资源的线程**自旋等待锁释放**
    重量级锁：没有获得资源的线程阻塞等待唤醒

    公平锁：获取资源的线程必须排队
    非公平锁：获取资源的线程可以插队;吞吐率高，CPU 不必唤醒所有线程；**可能有饥饿的线程**

    可重入锁：这个线程再次获得锁时不阻塞（可以锁两次）
    非可重入锁：这个线程再次获得锁时阻塞

    共享锁：可被多个线程持有锁，但是只能读数据不能改
    排他锁：mutex

17. 互斥锁与自旋锁
18. 线程**同步/通信**方式(使用锁)
    **线程间的通信目的主要是用于线程同步**，所以线程没有像进程通信中的用于数据交换的通信机制
    互斥锁/量（mutex）、读写锁（reader-writer lock）、自旋锁（spin lock）、条件变量（condition）
    **互斥锁/量**（mutex）：提供了以排他方式防止数据结构被并发修改的方法，串行访问。
    **自旋锁**（spin lock）与互斥锁类似，都是为了保护共享资源。互斥锁是当资源被占用，申请者进入睡眠状态(**让出 CPU**)；而**自旋锁则循环检测**保持者是否已经释放锁(**不会让出 CPU**，忙等待，避免进程线程切换上下文开销，不适合单核 CPU 使用,操作系统内部很多地方自旋锁)。
    **读写锁**（reader-writer lock）：**特殊的自旋锁**，允许多个线程同时读共享数据，而对写操作是互斥的。
    **条件变量**（condition）：可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。
    例子：**生产者-消费者通过缓存区存在同步关系**(go channel)
    https://interview.huihut.com/#/?id=%e8%bf%9b%e7%a8%8b%e4%b8%8e%e7%ba%bf%e7%a8%8b
19. 进程间同步/通信
    **管道（PIPE）**:`linux 的 | `
    `有名管道`：一种半双工的通信方式，它允许无亲缘关系进程间的通信
    优点：可以实现任意关系的进程间的通信
    缺点：
    长期存于系统中，使用不当容易出错
    缓冲区有限
    `无名管道`：一种半双工的通信方式，只能在具有亲缘关系的进程间使用（父子进程）
    优点：简单方便
    缺点：
    局限于单向通信
    只能创建在它的进程以及其有亲缘关系的进程之间
    缓冲区有限
    **消息队列**（Message Queue）：是消息的链表，存放在内核中并由消息队列标识符标识 `跨级进程通信Kafka,RabbitMQ`
    优点：可以实现任意进程间的通信，并通过系统调用函数来实现消息发送和接收之间的同步，无需考虑同步问题，方便
    缺点：信息的复制需要额外消耗 CPU 的时间，不适宜于信息量大或操作频繁的场合
    **共享内存**（Shared Memory）：`映射一段能被其他进程所访问的内存`，这段共享物理内存由一个进程创建，但多个进程都可以访问
    优点：无须复制，**快捷**，信息量大
    缺点：
    通信是通过将共享空间缓冲区直接附加到进程的虚拟地址空间中来实现的，因此进程间的读写操作的同步问题,`共享内存未提供同步机制`
    利用内存缓冲区直接交换信息，内存的实体存在于计算机中，只能同一个计算机系统中的诸多进程共享，不方便网络通信
    **信号**（Signal）：一种比较复杂的通信方式，用于通知接收进程某个事件已经发生
    `NodeJS` SIGHUP(1,ctrlZ) SIGINT(2,ctrlC) SIGKILL(9) 等
    **信号量**（Semaphore）：一个计数器，可以用来控制多个线程对共享资源的访问
    优点：可以同步进程
    缺点：信号量有限
    **套接字**（Socket）：可用于不同计算机间的进程通信
    `NodeJS`master 传递 socket 给 slaver
    优点：
    传输数据为字节级，传输数据可自定义，数据量小效率高
    传输数据时间短，性能高
    适合于客户端和服务器端之间信息实时交互
    可以加密,数据安全性强
    缺点：需对传输的数据进行解析，转化成应用级的数据。
20. 无锁数据结构的原理 (CAS 原理与无锁技术) Compare & Swap
    并行系统访问临界资源必须考虑加锁
    原子性：一系列操作**不可被中断**,要么全执行要么不执行
    CAS 本质是一个原子性指令,做了两件事:比较旧值，交换新值
21. 分布式锁的实现
    场景：**秒杀系统**
    redis 临界资源 需要分布式锁保护临界资源
    - 基于 redis (setnx key value 加锁) (del key 释放锁)
    - 基于 Zookeeper 数据节点:znode
    - 基于 mysql
22. 为什么分层：复杂系统实现要有清晰明确的分层设计
23. 对 java/python 字节码的理解
24. 编译和解释的区别
    ts 编译成 js jsx 编译成 h 函数 cpp/go 编译成可执行文件 java 编译成.class 字节码
    js/python 都是解释型语言
25. JIT 技术
26. 源码到二进制文件的转化步骤
    二进制程序本质是一条条 CPU 指令，而不同 CPU 体系结构的指令集不同，C/C++程序跨平台需要重新编译
    C++代码
    test.cpp=>main(二进制文件)
    **预编译**(代码文本替换，#define 等)=>**编译**(g++编译)=>**汇编**(转机器码)=>**链接**(调库的依赖，链接到目标文件)=>**装载**(可执行文件加载到内存，确定进程入口地址，完整进程空间)=>**运行**
    java 代码：
    java=>（**编译**）JVM 字节码=>（**解释**）机器码  
    针对解释执行效率不如本地二进制执行效率的问题=>**JIT 技术**
    JIT:**在运行过程动态将中间字节码编译成本地代码**
27. 静态和动态链接的区别

28. socket 工作原理
    文件&管道
    IO 多路复用:单个线程处理多个 socket
29. BIO:阻塞线程；原理是利用 CPU 中断
    NIO:不阻塞线程；
    AIO：异步，终极目标是异步转同步(async await)

30. 小端字节序与大端字节序
    字节的排列方式有两个通用规则:

    **大端序**（Big-Endian）将`数据的低位字节存放在内存的高位地址`，高位字节存放在低位地址。这种排列方式与数据用字节表示时的书写顺序一致，`符合人类的阅读习惯`。
    **小端序**（Little-Endian），将一个多位数的低位放在较小的地址处，高位放在较大的地址处，则称小端序。`小端序与人类的阅读习惯相反，但更符合计算机读取内存的方式`，因为 CPU 读取内存中的数据时，是从低地址向高地址方向进行读取的。

    举例来说，数值 0x2211 使用两个字节储存：高位字节是 0x22，低位字节是 0x11
    大端字节序：高位字节在前，低位字节在后，这是人类读写数值的方法。
    小端字节序：低位字节在前，高位字节在后，即以 0x1122 形式储存。

    ```JS
    const buffer = new ArrayBuffer(24);
    const dv = new DataView(buffer);
    // 小端字节序
    const v1 = dv.getUint16(1, true);
    // 大端字节序
    const v2 = dv.getUint16(3, false);
    // 大端字节序
    const v3 = dv.getUint16(3);  // 默认大端
    ```

31. linux 信号
    快捷键|名称|数字
    -----|-----|-----
    ctrl-z|SIGHUP|1
    ctrl-c|SIGINT|2
    x|SIGKILL|9
    x|SIGTERM|15|优雅退出（该信号可以被阻塞和处理）

    如何让 nodejs 服务器优雅地退出
    如果我们直接杀死进程，那么存量的请求就会无法正常被处理
    我们首先`监听 SIGINT` 信号，当我们使用 SIGINT 信号杀死进程时，首先调用 server.close，等到所有的连接断开，触发 close 时候时，再退出进程

    ```JS
    const net = require('net');
    const server = net.createServer().listen(80);
    server.on('close', () => {
        process.exit();
    });
    // 防止进程提前挂掉
    process.on('uncaughtException', () => {

    });
    process.on('SIGINT', function() {
        server.close();
    })
    ```
