1.  冯诺依曼模型
    中央处理器（CPU）、内存、输⼊设备、输出设备、总线
    总线是⽤于 CPU 和内存以及其他设备之间的通信

    注：CPU 主要包括两个部分：控制器+运算器。**根本任务就是执行指令**，对计算机来说最终都是一串由“0”和“1”组成的序列。

2.  64 位相⽐ 32 位 CPU 的优势在哪吗？64 位 CPU 的计算性能⼀定⽐ 32 位 CPU ⾼很多吗？
    两个优势:
    - 64 位 CPU 可以⼀次计算超过 32 位的数字，⽽ 32 位 CPU 如果要计算超过 32 位的数字，要分多步骤进⾏计算。只有运算⼤数字的时候，64 位 CPU 的优势才能体现出来
    - 64 位 CPU 可以寻址更⼤的内存空间 2^64 ，32 位 CPU 最⼤的寻址地址是 4G ,2^32
3.  你知道软件的 32 位和 64 位之间的区别吗？再来 32 位的操作系统可以运⾏在 64 位的电脑上吗？64 位的操作系统可以运⾏在 32 位的电脑上吗？如果不⾏，原因是什么？
    64 位和 32 位软件，实际上代表指令是 64 位还是 32 位的：
    如果 32 位指令在 64 位机器上执⾏，需要⼀套兼容机制，就可以做到兼容运⾏了。但是如果 64 位指令在 32 位机器上执⾏，就⽐较困难了，**因为 32 位的寄存器存不下 64 位的指令**；
    操作系统其实也是⼀种程序，我们也会看到操作系统会分成 32 位操作系统、64 位操作系统，其代表意义就是**操作系统中程序的指令是多少位**，⽐如 64 位操作系统，指令也就是 64 位，因此不能装在 32 位机器上。
    总之，硬件的 64 位和 32 位指的是 CPU 的**位宽**(CPU 一次处理多少 bit)，软件的 64 位和 32 位指的是指令的位宽。

4.  存储器层次结构

    - 寄存器
    - CPU 三级缓存 L1,L2,L3
    - 内存
    - SSD/HDD 硬盘

           CPU 比喻成我们的大脑
           大脑**正在思考的东西**，就好比 CPU 中的**寄存器**
           大脑中的**记忆**，就好比 **CPU Cache** L1：短期记忆 L2L3:长期记忆
           我们大脑记忆中没有资料的时候,**桌子上的书，就好比内存**
           **图书馆书架上的书，就好比硬盘**

      我们从图书馆书架取书，把书放到桌子上，再阅读书，我们大脑就会记忆知识点，然后再经过大脑思考，这一系列过程相当于，数据从硬盘加载到内存，再从内存加载到 CPU 的寄存器和 Cache 中，然后再通过 CPU 进行处理和计算。

      当 CPU 需要访问内存中某个数据的时候，如果寄存器有这个数据，CPU 就直接从寄存器取数据即可，如果寄存器没有这个数据，CPU 就会查询 L1 高速缓存，如果 L1 没有，则查询 L2 高速缓存，L2 还是没有的话就查询 L3 高速缓存，L3 依然没有的话，才去内存中取数据。
      存储层次结构也形成了**缓存**的体系。

5.  如何写出让 CPU 跑得更快的代码？
    缓存命中率越高的话，代码的性能就会越好，CPU 也就跑的越快。
    L1 Cache 通常分为「数据缓存」和「指令缓存」，这是因为 CPU 会别处理数据和指令，比如 1+1=2 这个运算，+ 就是指令，会被放在「指令缓存」中，而输入数字 1 则会被放在「数据缓存」里。

    **如何提升数据缓存的命中率？**
    形式一 array[i][j] 执行时间比形式二 array[j][i] 快好几倍。
    CPU 访问 array[0][0] 时，由于该数据不在 Cache 中，于是会「顺序」把跟随其后的 3 个元素从内存中加载到 CPU Cache，这样当 CPU 访问后面的 3 个数组元素时，就能在 CPU Cache 中成功地找到数据，这意味着缓存命中率很高，缓存命中的数据不需要访问内存，这便大大提高了代码的性能。
    遇到这种遍历数组的情况时，**按照内存布局顺序访问**，将可以有效的利用 CPU Cache 带来的好处，这样我们代码的性能就会得到很大的提升，

    **如何提升指令缓存的命中率？**
    先遍历再排序速度快，还是先排序再遍历速度快呢
    **先排序再遍历速度会更快**
    对于指令缓存，有规律的条件分支语句能够让 CPU 的分支预测器发挥作用，进一步提高执行的效率；

    计算机操作系统中的**局部性原理**
    如果 cpu 要读取数据块 1，cpu 先在**高速缓存中查找**数据块 1，如果找到就直接返回，这就叫“缓存命中”，因为缓存的速度比主存的速度要快很多，缓存命中大大提高了效率。
    如果 cpu 要读取数据块 5，数据块 5 不在缓存中，那么叫做“缓存不命中”。那么 cpu 就要去主存中取到数据块 5，然后把数据块 5 放到高速缓存中，如果缓存中的数据存满了，就要覆盖现存的一个数据块。
    一个优秀的程序通常具有良好的局部性，它们通常会重复使用已用过的数据，或者使用已用过数据的邻近数据，也就是说，程序常常会使用集中在一起的局部数据。
    局部性分为：时间局部性和空间局部性。**如果一个内存位置被重复的引用，那就是有了时间局部性，如果一个内存位置被引用了，很快这个位置的附近位置也被引用了，这就有了空间局部性。**
    由于缓存中的数据是一个个数据块，每个数据块包含几十到几千字节不等，如果某个程序要访问数组 a，第一次缓存没命中，cpu 会从主存中取出包含数组 a 的一个数据块(一般是 3 个)，复制到缓存中来，下次访问 a[1],a[2],a[3]的数据时每次都缓存命中，极大的提高了效率，实现了空间的局部性。(prefetch,`读取内存块的时候将该内存块附近的内存块也读进缓存中`。称为预取)

6.  多核 CPU 缓存一致性
    MESI 协议其实是 4 个状态单词的开头字⺟缩写
    Modified，已修改
    Exclusive，独占
    Shared，共享
    Invalidated，已失效
    这四个状态来标记 Cache Line 四个不同的状态

    总结：CPU 在读写数据的时候，都是在 CPU Cache 读写数据的，原因是 Cache 离 CPU 很近，读写性能相⽐内存⾼出很多。对于 Cache ⾥没有缓存 CPU 所需要读取的数据的这种情况， **CPU 则会从内存读取数据，并将数据缓存到 Cache ⾥⾯**，最后 CPU 再从 Cache 读取数 据。

    ⽽对于数据的写⼊，**CPU 都会先写⼊到 Cache ⾥⾯，然后再在找个合适的时机写⼊到内存**， 那就有「**写直达**」和「**写回**」这两种策略来保证 Cache 与内存的数据⼀致性：
    类似于 computed 计算属性
    `写直达`，只要有数据写⼊，都会直接把数据写⼊到内存⾥⾯，这种⽅式简单直观，但是性能就会受限于内存的访问速度；
    `写回`，对于已经缓存在 Cache 的数据的写⼊，只需要更新其数据就可以，不⽤写⼊到内存，只有在需要把缓存⾥⾯的脏数据交换出去的时候，才把数据同步到内存⾥，这种⽅式在缓存命中率⾼的情况，性能会更好；
    当今 CPU 都是多核的，每个核⼼都有各⾃独⽴的 L1/L2 Cache，只有 L3 Cache 是多个核⼼之间共享的。所以，我们要确保多核缓存是⼀致性的，否则会出现错误的结果。
    **要想实现缓存⼀致性，关键是要满⾜ 2 点：**
    第⼀点是写传播，也就是当某个 CPU 核⼼发⽣写⼊操作时，需要把该`事件⼴播通知给其他核⼼`；
    第⼆点是事物的串⾏化，这个很重要，只有保证了这个，才能保障我们的数据是真正⼀致的，我们的程序在各个不同的核⼼上运⾏的结果也是⼀致的；
    `基于总线嗅探机制的 MESI 协议`，就满⾜上⾯了这两点，因此它是保障缓存⼀致性的协议。
    MESI 协议，是已修改、独占、共享、已实现这四个状态的英⽂缩写的组合。整个 MSI 状态的变更，则是根据来⾃本地 CPU 核⼼的请求，或者来⾃其他 CPU 核⼼通过总线传输过来的请求，从⽽构成⼀个`流动的状态机`。另外，对于在「已修改」或者「独占」状态的 Cache Line，`修改更新其数据不需要发送⼴播给其他 CPU 核⼼`。

7.  为什么 0.1 + 0.2 不等于 0.3 ?

    - 为什么负数要用补码表示？
      所谓的补码就是把正数的二进制全部取反再加 1
      用了补码的表示方式，**对于负数的加减法操作，实际上是和正数加减法操作一样的**,主要是为了统一和正数的加减法操作一样
      >
    - 十进制小数怎么转成二进制？
      div mod 循环
      0.1 的二进制表示是无限循环的。
      >
    - 计算机是怎么存小数的？
      计算机存储小数的采用的是浮点数
      现在绝大多数计算机使用的浮点数，一般采用的是 IEEE 制定的国际标准，这种标准形式如下图：
      **符号位**：表示数字是正数还是负数，为 0 表示正数，为 1 表示负数；
      **指数位**：指定了小数点在数据中的位置，指数可以是负数，也可以是正数，**指数位的长度越长则数值的表达范围就越大**；
      **尾数位**：小数点右侧的数字，也就是小数部分，比如二进制 1.0011 x 2^(-2)，尾数部分就是 0011，而且尾数的长度决定了这个数的精度，因此如果要表示精度更高的小数，则就要提高尾数位的长度；
      用 32 位来表示的浮点数，则称为单精度浮点数，也就是我们编程语言中的 float 变量，而用 64 位来表示的浮点数，称为双精度浮点数，也就是 double 变量，
      >
    - 0.1 + 0.2 == 0.3 吗？
      不是的，0.1 和 0.2 这两个数字用二进制表达会是一个一直循环的二进制数，比如 0.1 的二进制表示为 0.0 0011 0011 0011… （0011 无限循环)，对于计算机而言，**0.1 无法精确表达，这是浮点数计算造成精度损失的根源。**
      这主要是因为有的**小数无法可以用「完整」的二进制来表示**，所以计算机里只能采用近似数的方式来保存，那两个近似数相加，得到的必然也是一个近似数。
      JavaScript 对于数字都是使用 IEEE 754 标准下的双精度浮点类型来存储的。
