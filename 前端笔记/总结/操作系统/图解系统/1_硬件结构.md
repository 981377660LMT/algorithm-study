1.  冯诺依曼模型
    中央处理器（CPU）、内存、输⼊设备、输出设备、总线
    总线是⽤于 CPU 和内存以及其他设备之间的通信

2.  64 位相⽐ 32 位 CPU 的优势在哪吗？64 位 CPU 的计算性能⼀定⽐ 32 位 CPU ⾼很多吗？
    两个优势:
    - 64 位 CPU 可以⼀次计算超过 32 位的数字，⽽ 32 位 CPU 如果要计算超过 32 位的数字，要分多步骤进⾏计算。只有运算⼤数字的时候，64 位 CPU 的优势才能体现出来
    - 64 位 CPU 可以寻址更⼤的内存空间 2^64 ，32 位 CPU 最⼤的寻址地址是 4G ,2^32
3.  你知道软件的 32 位和 64 位之间的区别吗？再来 32 位的操作系统可以运⾏在 64 位的电脑上吗？64 位的操作系统可以运⾏在 32 位的电脑上吗？如果不⾏，原因是什么？
    64 位和 32 位软件，实际上代表指令是 64 位还是 32 位的：
    如果 32 位指令在 64 位机器上执⾏，需要⼀套兼容机制，就可以做到兼容运⾏了。但是如果 64 位指令在 32 位机器上执⾏，就⽐较困难了，**因为 32 位的寄存器存不下 64 位的指令**；
    操作系统其实也是⼀种程序，我们也会看到操作系统会分成 32 位操作系统、64 位操作系统，其代表意义就是**操作系统中程序的指令是多少位**，⽐如 64 位操作系统，指令也就是 64 位，因此不能装在 32 位机器上。
    总之，硬件的 64 位和 32 位指的是 CPU 的**位宽**(CPU 一次处理多少 bit)，软件的 64 位和 32 位指的是指令的位宽。

4.  存储器层次结构

    - 寄存器
    - CPU 三级缓存 L1,L2,L3
    - 内存
    - SSD/HDD 硬盘

           CPU 比喻成我们的大脑
           大脑**正在思考的东西**，就好比 CPU 中的**寄存器**
           大脑中的**记忆**，就好比 **CPU Cache** L1：短期记忆 L2L3:长期记忆
           我们大脑记忆中没有资料的时候,**桌子上的书，就好比内存**
           **图书馆书架上的书，就好比硬盘**

      我们从图书馆书架取书，把书放到桌子上，再阅读书，我们大脑就会记忆知识点，然后再经过大脑思考，这一系列过程相当于，数据从硬盘加载到内存，再从内存加载到 CPU 的寄存器和 Cache 中，然后再通过 CPU 进行处理和计算。

      当 CPU 需要访问内存中某个数据的时候，如果寄存器有这个数据，CPU 就直接从寄存器取数据即可，如果寄存器没有这个数据，CPU 就会查询 L1 高速缓存，如果 L1 没有，则查询 L2 高速缓存，L2 还是没有的话就查询 L3 高速缓存，L3 依然没有的话，才去内存中取数据。
      存储层次结构也形成了**缓存**的体系。

5.  如何写出让 CPU 跑得更快的代码？
    缓存命中率越高的话，代码的性能就会越好，CPU 也就跑的越快。
    L1 Cache 通常分为「数据缓存」和「指令缓存」，这是因为 CPU 会别处理数据和指令，比如 1+1=2 这个运算，+ 就是指令，会被放在「指令缓存」中，而输入数字 1 则会被放在「数据缓存」里。

    **如何提升数据缓存的命中率？**
    形式一 array[i][j] 执行时间比形式二 array[j][i] 快好几倍。
    CPU 访问 array[0][0] 时，由于该数据不在 Cache 中，于是会「顺序」把跟随其后的 3 个元素从内存中加载到 CPU Cache，这样当 CPU 访问后面的 3 个数组元素时，就能在 CPU Cache 中成功地找到数据，这意味着缓存命中率很高，缓存命中的数据不需要访问内存，这便大大提高了代码的性能。
    遇到这种遍历数组的情况时，**按照内存布局顺序访问**，将可以有效的利用 CPU Cache 带来的好处，这样我们代码的性能就会得到很大的提升，

    **如何提升指令缓存的命中率？**
    先遍历再排序速度快，还是先排序再遍历速度快呢
    **先排序再遍历速度会更快**
    对于指令缓存，有规律的条件分支语句能够让 CPU 的分支预测器发挥作用，进一步提高执行的效率；

6.  为什么 0.1 + 0.2 不等于 0.3 ?

    - 为什么负数要用补码表示？
      所谓的补码就是把正数的二进制全部取反再加 1
      用了补码的表示方式，**对于负数的加减法操作，实际上是和正数加减法操作一样的**,主要是为了统一和正数的加减法操作一样
      >
    - 十进制小数怎么转成二进制？
      div mod 循环
      0.1 的二进制表示是无限循环的。
      >
    - 计算机是怎么存小数的？
      计算机存储小数的采用的是浮点数
      现在绝大多数计算机使用的浮点数，一般采用的是 IEEE 制定的国际标准，这种标准形式如下图：
      **符号位**：表示数字是正数还是负数，为 0 表示正数，为 1 表示负数；
      **指数位**：指定了小数点在数据中的位置，指数可以是负数，也可以是正数，**指数位的长度越长则数值的表达范围就越大**；
      **尾数位**：小数点右侧的数字，也就是小数部分，比如二进制 1.0011 x 2^(-2)，尾数部分就是 0011，而且尾数的长度决定了这个数的精度，因此如果要表示精度更高的小数，则就要提高尾数位的长度；
      用 32 位来表示的浮点数，则称为单精度浮点数，也就是我们编程语言中的 float 变量，而用 64 位来表示的浮点数，称为双精度浮点数，也就是 double 变量，
      >
    - 0.1 + 0.2 == 0.3 吗？
      不是的，0.1 和 0.2 这两个数字用二进制表达会是一个一直循环的二进制数，比如 0.1 的二进制表示为 0.0 0011 0011 0011… （0011 无限循环)，对于计算机而言，**0.1 无法精确表达，这是浮点数计算造成精度损失的根源。**
      这主要是因为有的**小数无法可以用「完整」的二进制来表示**，所以计算机里只能采用近似数的方式来保存，那两个近似数相加，得到的必然也是一个近似数。
      JavaScript 对于数字都是使用 IEEE 754 标准下的双精度浮点类型来存储的。
