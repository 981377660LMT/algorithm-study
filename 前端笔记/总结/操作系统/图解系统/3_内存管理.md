虚拟内存 内存分段 内存分页 段页式内存管理 linux 内存管理

1. 虚拟内存
   单片机的 CPU 是直接操作内存的「物理地址」。要想在内存中同时运行两个程序是不可能的。

   **操作系统是如何解决这个问题呢？**
   这里关键的问题是这两个程序都引用了绝对物理地址，而这正是我们最需要避免的。
   我们可以把**进程所使用的地址「隔离」开来**，即让操作系统**为每个进程分配独立的一套「虚拟地址」**，人人都有，大家自己玩自己的地址就行，互不干涉。但是有个**前提每个进程都不能访问物理地址**，至于虚拟地址最终怎么落到物理内存里，对进程来说是透明的，操作系统已经把这些都安排的明明白白了。
   操作系统会提供一种机制，**将不同进程的虚拟地址和不同内存的物理地址映射起来。**

   **操作系统是如何管理虚拟地址与物理地址之间的关系？**
   主要有两种方式，分别是**内存分段和内存分页**，分段是比较早提出的，我们先来看看内存分段。

2. 内存分段
   它也有一些不足之处：

   第一个就是`内存碎片`的问题。
   第二个就是`内存交换的效率低`的问题。
   解决外部`内存碎片的问题就是内存交换。`这个内存交换空间，在 Linux 系统里，也就是我们常看到的 Swap 空间，这块空间是从硬盘划分出来的，用于`内存与硬盘的空间交换`。
   如果内存交换的时候，`交换的是一个占内存空间很大的程序`，这样整个机器都会显得卡顿。
   为了解决内存分段的内存碎片和内存交换效率低的问题，就出现了内存分页。

3. 内存分页
   分页是把整个虚拟和物理内存空间**切成一段段固定尺寸的大小**
   在 Linux 下，每一页的大小为 4KB。
   采用了分页，那么`释放的内存都是以页为单位释放的，也就不会产生无法给进程使用的小内存。`
   虚拟地址与物理地址之间通过**页表**来映射
   页表实际上存储在 CPU 的**内存管理单元 （MMU）** 中，于是 CPU 就可以直接通过 MMU，找出要实际要访问的物理内存地址。
   当进程访问的**虚拟地址在页表中查不到**时，系统会产生一个**缺页异常**，进入系统内核空间**分配物理内存、更新进程页表**，最后再返回用户空间，恢复进程的运行。
   分页的方式使得我们在加载程序的时候，不再需要一次性都把程序加载到物理内存中。我们完全可以在进行虚拟内存和物理内存的页之间的映射之后，并不真的把页加载到物理内存里，而`是只有在程序运行中，需要用到对应虚拟内存页里面的指令和数据时，再加载到物理内存里面去。`

   简单的分页有什么缺陷吗？
   100 个进程的话，就需要 400MB 的内存来存储页表，这是非常大的内存了，更别说 64 位的环境了。

4. 多级页表：懒加载
   为了解决简单`分页产生的页表过大`的问题，就有了多级页表
   思路是拆分哈希表:
   我们把这个 100 多万个「页表项」的单级页表再分页，`将页表（一级页表）分为 1024 个页表（二级页表），每个表（二级页表）中包含 1024 个「页表项」，形成二级分页。`
   你可能会问，分了二级表，映射 4GB 地址空间就需要 4KB（一级页表）+ 4MB（二级页表）的内存，这样占用空间不是更大了吗？
   当然如果 4GB 的虚拟地址全部都映射到了物理内上的，二级分页占用空间确实是更大了，但是，我们往往`不会为一个进程分配那么多内存`。
   引入多级页表的主要目的是为了`避免把全部页表一直放在内存中占用过多空间`，`特别是那些根本就不需要的页表就不需要保留在内存中`。如果某个一级页表的页表项没有被用到，也就不需要创建这个页表项对应的二级页表了，即可以在需要时才创建二级页表。
   做个简单的计算，假设只有 20% 的一级页表项被用到了，那么页表占用的内存空间就只有 4KB（一级页表） + 20% \* 4MB（二级页表）= 0.804MB，这对比单级页表的 4MB 是一个巨大的节约
5. TLB(快表)：查询缓存
   在 CPU 芯片里面，封装了内存管理单元（Memory Management Unit）芯片，它用来完成地址转换和 TLB 的访问与交互。
   把最常访问的几个页表项存储到访问速度更快的硬件
   使用快表之后的地址转换流程是这样的：

   1. 根据虚拟地址中的页号查快表；
   2. 如果该页在快表中，直接从快表中读取相应的物理地址；
   3. 如果该页不在快表中，就访问内存中的页表，再从页表中得到物理地址，同时将页表中的该映射表项添加到快表中；
   4. 当快表填满后，又要登记新页时，就按照一定的淘汰策略(LRU)淘汰掉快表中的一个页。

   不论是快表还是多级页表实际上都利用到了程序的局部性原理

6. 段页式内存管理
   先将程序划分为多个有逻辑意义的段，也就是前面提到的分段机制；

   接着再把每个段划分为多个页，也就是对分段划分出来的连续空间，再划分固定大小的页；
   这样，地址结构就由**段号**、**段内页号**和**页内位移**三部分组成。

7. Linux 内存管理
   Linux 内存主要采用的是**页式内存管理**，但同时也不可避免地涉及了段机制。

8. 总总结结
   为了在多进程环境下，使得进程之间的内存地址不受影响，相互隔离，于是操作系统就**为每个进程独立分配一套的虚拟地址空间**，每个程序只关心自己的虚拟地址就可以，实际上大家的虚拟地址都是一样的，但分布到物理地址内存是不一样的。作为程序，也不用关心物理地址的事情。

   每个进程都有自己的虚拟空间，而物理内存只有一个，所以当启用了大量的进程，物理内存必然会很紧张，于是操作系统会通过**内存交换技术**，**把不常使用的内存暂时存放到硬盘**（换出），在需要的时候再装载回物理内存（换入）。

   那既然有了虚拟地址空间，那必然要把虚拟地址「映射」到物理地址，这个事情通常由操作系统来维护。

   那么对于虚拟地址与物理地址的映射关系，可以有**分段和分页**的方式，同时两者结合都是可以的。

   内存分段是根据程序的逻辑角度，分成了栈段、堆段、数据段、代码段等，这样可以分离出不同属性的段，同时是一块连续的空间。但是**每个段的大小都不是统一**的，这就会导致内存碎片和内存交换效率低的问题。

   于是，就出现了内存分页，把虚拟空间和物理空间分成大小固定的页，如**在 Linux 系统中，每一页的大小为 4KB**。由于分了页后，就不会产生细小的内存碎片。同时在内存交换的时候，写入硬盘也就一个页或几个页，这就大大提高了内存交换的效率。

   再来，为了解决简单分页产生的页表过大的问题，就有了多级页表，它解决了空间上的问题，但这就会导致 CPU 在寻址的过程中，需要有很多层表参与，加大了时间上的开销。于是根据程序的局部性原理，在 CPU 芯片中加入了 TLB，负责缓存最近常被访问的页表项，大大提高了地址的转换速度。

   **Linux 系统主要采用了分页管理，但是由于 Intel 处理器的发展史，Linux 系统无法避免分段管理。**于是 Linux 就把所有段的基地址设为 **0**，也就意味着所有程序的地址空间都是线性地址空间（虚拟地址），相当于屏蔽了 CPU 逻辑地址的概念，所以段只被用于访问控制和内存保护。

   另外，Linxu 系统中**虚拟空间分布**可分为**用户态**和**内核态**两部分，其中用户态的分布：代码段、全局变量、BSS、函数栈、堆内存、映射区。
