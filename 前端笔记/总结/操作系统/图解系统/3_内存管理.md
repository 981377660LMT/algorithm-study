虚拟内存 内存分段 内存分页 段页式内存管理 linux 内存管理

1. 虚拟内存
   单片机的 CPU 是直接操作内存的「物理地址」。要想在内存中同时运行两个程序是不可能的。

   **操作系统是如何解决这个问题呢？**
   这里关键的问题是这两个程序都引用了绝对物理地址，而这正是我们最需要避免的。
   我们可以把**进程所使用的地址「隔离」开来**，即让操作系统**为每个进程分配独立的一套「虚拟地址」**，人人都有，大家自己玩自己的地址就行，互不干涉。但是有个**前提每个进程都不能访问物理地址**，至于虚拟地址最终怎么落到物理内存里，对进程来说是透明的，操作系统已经把这些都安排的明明白白了。
   操作系统会提供一种机制，**将不同进程的虚拟地址和不同内存的物理地址映射起来。**

   **操作系统是如何管理虚拟地址与物理地址之间的关系？**
   主要有两种方式，分别是**内存分段和内存分页**，分段是比较早提出的，我们先来看看内存分段。

2. 内存分段
   它也有一些不足之处：

   第一个就是内存碎片的问题。
   第二个就是内存交换的效率低的问题。
   为了解决内存分段的内存碎片和内存交换效率低的问题，就出现了内存分页。

3. 内存分页
   分页是把整个虚拟和物理内存空间**切成一段段固定尺寸的大小**
   在 Linux 下，每一页的大小为 4KB。
   虚拟地址与物理地址之间通过**页表**来映射
   页表实际上存储在 CPU 的**内存管理单元 （MMU）** 中，于是 CPU 就可以直接通过 MMU，找出要实际要访问的物理内存地址。
   当进程访问的**虚拟地址在页表中查不到**时，系统会产生一个**缺页异常**，进入系统内核空间**分配物理内存、更新进程页表**，最后再返回用户空间，恢复进程的运行。

   简单的分页有什么缺陷吗？
   100 个进程的话，就需要 400MB 的内存来存储页表，这是非常大的内存了，更别说 64 位的环境了。

4. 段页式内存管理
   先将程序划分为多个有逻辑意义的段，也就是前面提到的分段机制；

   接着再把每个段划分为多个页，也就是对分段划分出来的连续空间，再划分固定大小的页；
   这样，地址结构就由**段号**、**段内页号**和**页内位移**三部分组成。

5. Linux 内存管理
   Linux 内存主要采用的是**页式内存管理**，但同时也不可避免地涉及了段机制。

6. 总总结结
   为了在多进程环境下，使得进程之间的内存地址不受影响，相互隔离，于是操作系统就**为每个进程独立分配一套的虚拟地址空间**，每个程序只关心自己的虚拟地址就可以，实际上大家的虚拟地址都是一样的，但分布到物理地址内存是不一样的。作为程序，也不用关心物理地址的事情。

   每个进程都有自己的虚拟空间，而物理内存只有一个，所以当启用了大量的进程，物理内存必然会很紧张，于是操作系统会通过**内存交换技术**，**把不常使用的内存暂时存放到硬盘**（换出），在需要的时候再装载回物理内存（换入）。

   那既然有了虚拟地址空间，那必然要把虚拟地址「映射」到物理地址，这个事情通常由操作系统来维护。

   那么对于虚拟地址与物理地址的映射关系，可以有**分段和分页**的方式，同时两者结合都是可以的。

   内存分段是根据程序的逻辑角度，分成了栈段、堆段、数据段、代码段等，这样可以分离出不同属性的段，同时是一块连续的空间。但是**每个段的大小都不是统一**的，这就会导致内存碎片和内存交换效率低的问题。

   于是，就出现了内存分页，把虚拟空间和物理空间分成大小固定的页，如**在 Linux 系统中，每一页的大小为 4KB**。由于分了页后，就不会产生细小的内存碎片。同时在内存交换的时候，写入硬盘也就一个页或几个页，这就大大提高了内存交换的效率。

   再来，为了解决简单分页产生的页表过大的问题，就有了多级页表，它解决了空间上的问题，但这就会导致 CPU 在寻址的过程中，需要有很多层表参与，加大了时间上的开销。于是根据程序的局部性原理，在 CPU 芯片中加入了 TLB，负责缓存最近常被访问的页表项，大大提高了地址的转换速度。

   **Linux 系统主要采用了分页管理，但是由于 Intel 处理器的发展史，Linux 系统无法避免分段管理。**于是 Linux 就把所有段的基地址设为 **0**，也就意味着所有程序的地址空间都是线性地址空间（虚拟地址），相当于屏蔽了 CPU 逻辑地址的概念，所以段只被用于访问控制和内存保护。

   另外，Linxu 系统中**虚拟空间分布**可分为**用户态**和**内核态**两部分，其中用户态的分布：代码段、全局变量、BSS、函数栈、堆内存、映射区。
