0. CPU 会执行程序中的每一条指令，那么这个运行中的程序，就被称为「进程」。

1. 当进程要从硬盘读取数据时，CPU 不需要阻塞等待数据的返回，而是去执行另外的进程。当硬盘数据返回时，CPU 会收到个**中断**，于是 CPU 再继续运行这个进程。
2. 在操作系统中，是用进程控制块（process control block，PCB）数据结构来描述进程的。
   **PCB 是进程存在的唯一标识**，这意味着一个进程的存在，必然会有一个 PCB，如果进程消失了，那么 PCB 也会随之消失。
   PCB 包含进程四个属性
   id name state priority
   进程当前状态，如 new、ready、running、exit 或 blocked 等；

   **每个 PCB 是如何组织的呢？**
   通常是通过**链表**的方式进行组织，把具有相同状态的进程链在一起，组成各种队列。
   将所有处于就绪状态的进程链在一起，称为就绪队列；
   把所有因等待某事件而处于等待状态的进程链在一起就组成各种阻塞队列；

3. 线程是进程当中的一条执行流程。
   线程与进程的比较如下：

   进程是资源（包括内存、打开的文件等）分配的单位，线程是 CPU 调度的单位；

   进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如**寄存器和栈；**

   线程同样具有就绪、阻塞、执行三种基本状态，同样具有状态之间的转换关系；

   线程能减少并发执行的时间和空间开销；

4. 线程上下文切换的是什么？
   当两个线程是属于同一个进程，因为虚拟内存是共享的，所以在切换时，**虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据；**

5. 进程调度算法

   1. 先来先服务调度算法:每次从就绪队列选择最先进入队列的进程，然后一直运行，直到进程退出或被阻塞，才会继续从队列中选择第一个进程接着运行。
   2. 最短作业优先调度算法
   3. 时间片轮转调度算法 Round Robin:每个进程被分配一个时间段，称为时间片（Quantum），即允许该进程在该时间段中运行。
      通常时间片设为 20ms~50ms 通常是一个比较合理的折中值。
   4. 最高优先级调度算法

6. 一个进程最多可以创建多少个线程？
   这个问题跟两个东西有关系：
   **进程的虚拟内存空间上限**，因为创建一个线程，操作系统需要为其分配一个**栈空间**，如果线程数量越多，所需的栈空间就要越大，那么虚拟内存就会占用的越多。
   **系统参数限制**，虽然 Linux 并没有内核参数来控制单个进程创建的最大线程个数，但是有系统级别的参数来控制整个系统的最大线程个数。
   在 32 位 Linux 系统里，一个进程的虚拟空间是 4G，内核分走了 1G，留给用户用的只有 3G。
   那么假设创建一个线程需要占用 10M 虚拟内存，总共有 3G 虚拟内存可以使用。于是我们可以算出，最多可以创建差不多 300 个（3G/10M）左右的线程。

   32 位系统，用户态的虚拟空间只有 3G，如果创建线程时分配的栈空间是 10M，那么一个进程最多只能创建 300 个左右的线程。

   64 位系统，用户态的虚拟空间大到有 128T，理论上不会受虚拟内存大小的限制，而会受系统的参数或性能限制。

7. 进程间通信
   由于每个进程的用户空间都是独立的，不能相互访问，这时就需要**借助内核空间**来实现进程间通信，原因很简单，**每个进程都是共享一个内核空间**。

   Linux 内核提供了不少进程间通信的方式，其中最简单的方式就是管道，管道分为「匿名管道」和「命名管道」。

   **匿名管道**顾名思义，它没有名字标识，匿名管道是特殊文件只存在于内存，没有存在于文件系统中，shell 命令中的「|」竖线就是匿名管道，通信的数据是**无格式的流并且大小受限**，通信的方式是**单向的**，数据只能在一个方向上流动，如果要双向通信，需要创建两个管道，再来**匿名管道是只能用于存在父子关系的进程间通信**，匿名管道的生命周期随着进程创建而建立，随着进程终止而消失。

   命名管道突破了匿名管道只能在亲缘关系进程间的通信限制，因为使用命名管道的前提，需要在文件系统创建一个类型为 p 的设备文件，那么毫无关系的进程就可以通过这个设备文件进行通信。另外，不管是匿名管道还是命名管道，进程写入的数据都是缓存在内核中，另一个进程读取数据时候自然也是从内核中获取，同时通信数据都遵循先进先出原则，不支持 lseek 之类的文件定位操作。

   **消息队列**克服了管道通信的数据是无格式的字节流的问题，消息队列实际上是保存在内核的「消息链表」，消息队列的消息体是可以用户自定义的数据类型，发送数据时，会被分成一个一个独立的消息体，当然接收数据时，也要与发送方发送的消息体的数据类型保持一致，这样才能保证读取的数据是正确的。消息队列通信的速度不是最及时的，**毕竟每次数据的写入和读取都需要经过用户态与内核态之间的拷贝过程。**

   **共享内存**可以解决消息队列通信中用户态与内核态之间数据拷贝过程带来的开销，它直接分配一个共享空间，每个进程都可以直接访问，就像访问进程自己的空间一样快捷方便，不需要陷入内核态或者系统调用，大大提高了通信的速度，享有**最快**的进程间通信方式之名。但是便捷高效的共享内存通信，带来新的问题，**多进程竞争同个共享资源会造成数据的错乱。**

   那么，就需要**信号量**来保护共享资源，以确保任何时刻只能有一个进程访问共享资源，这种方式就是互斥访问。**信号量不仅可以实现访问的互斥性，还可以实现进程间的同步**，信号量其实是一个计数器，表示的是资源个数，其值可以通过两个原子操作来控制，分别是 P 操作和 V 操作。

   与信号量名字很相似的叫**信号**，它俩名字虽然相似，但功能一点儿都不一样。信号是进程间通信机制中**唯一的异步通信机制**，信号可以在应用进程和内核之间直接交互，内核也可以利用信号来通知用户空间的进程发生了哪些系统事件，信号事件的来源主要有硬件来源（如键盘 Cltr+C ）和软件来源（如 kill 命令），一旦有信号发生，进程有三种方式响应信号 1. 执行默认操作、2. 捕捉信号、3. 忽略信号。有两个信号是应用进程无法捕捉和忽略的，即 SIGKILL 和 SEGSTOP，这是为了方便我们能在任何时候结束或停止某个进程。

   前面说到的通信机制，都是工作于同一台主机，如果要与**不同主机的进程间通信，那么就需要 Socket 通信了**。Socket 实际上不仅用于不同的主机进程间通信，还可以用于本地主机进程间通信，可根据创建 Socket 的类型不同，分为三种常见的通信方式，一个是基于 TCP 协议的通信方式，一个是基于 UDP 协议的通信方式，一个是本地进程间通信方式。

8. i++不是原子指令
   只是单纯给 i 加上数字 1，在 CPU 运行的时候，实际上要执行 3 条指令。
   CAS 乐观锁可以解决这个问题

9. 死锁
   简单来说，死锁问题的产生是由两个或者以上线程并行执行的时候，争夺资源而互相等待造成的。

   死锁只有同时满足互斥、持有并等待、不可剥夺、环路等待这四个条件的时候才会发生。

   所以要避免死锁问题，就是要破坏其中一个条件即可，最常用的方法就是**使用资源有序分配法来破坏环路等待条件。**

10. 互斥锁、自旋锁、读写锁、悲观锁、乐观锁的应用场景
    当加锁失败时，互斥锁用「线程切换」来应对，自旋锁则用「忙等待」来应对。
    实现多人同时编辑，实际上是用了乐观锁，它允许多个用户打开同一个文档进行编辑，编辑完提交之后才验证修改的内容是否有冲突。
    我们常见的 SVN 和 Git 也是用了乐观锁的思想，先让用户编辑代码，然后提交的时候，通过版本号来判断是否产生了冲突，发生了冲突的地方，需要我们自己修改后，再重新提交。
    **只有在冲突概率非常低，且加锁成本非常高的场景时，才考虑使用乐观锁。**

11.线程间到底共享了哪些进程资源？

12. 如果我们想暂停协程的运行就必须保存整个栈帧的数据，**那么我们该将整个栈帧中的数据保存在哪里呢？**
    堆区啊，heap，我们可以将栈帧保存在堆区中，那么我们该怎么在堆区中保存数据呢？希望你还没有晕，**在堆区中开辟空间就是我们常用的 C 语言中的 malloc 或者 C++中的 new。**
    我们需要做的就是在堆区中申请一段空间，让后把协程的整个栈区保存下，当需要恢复协程的运行时再从堆区中 copy 出来恢复函数运行时状态。
    实际上，我们需要做的是**直接把协程的运行需要的栈帧空间直接开辟在堆区中**，这样都不用来回 copy 数据了。
