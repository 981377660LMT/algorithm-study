1. 重量平衡树(不受到旋转机制弊端的影响)

   - 无旋 treap
   - skip-list
   - scapegoat tree

   一般的平衡树依赖于一个旋转操作，如果维护的信息可以快速合并，那么是没有问题的。
   如果维护的信息不是很容易合并，就会遇到复杂度的问题，例如每个结点用一颗平衡树保存子树内所有的数。
   传统的平衡树一次旋转操作的代价 O(n).
   **而重量平衡树不同，每次操作影响的最大子树大小均摊是 O(logn) 的。**
   应用：动态区间 k 大查询/序列顺序维护问题

2. **后缀平衡树是一种"动态维护后缀排序"的数据结构。**
   它支持在串 S 的开头添加/删除一个字符，复杂度不依赖于字符集的大小.
   即字符串 S 的后缀平衡树是 S 所有后缀的有序集合。后缀平衡树上的一个节点相当于原字符串的一个后缀。
   后缀平衡树的中序遍历即为后缀数组。

   构建：

   - 对长度为 n 的字符串 T 建立其后缀平衡树，考虑`逆序将其后缀加入`后缀平衡树。
     记后缀平衡树维护的集合为 X，当前添加的后缀为 S，则添加下一个后缀就是向 X 中加入 cS（亦可理解为后缀平衡树维护的字符串为 S，下一步往 S 前加入一个字符 c）。
     这一操作其实就是向平衡树中插入节点。
   - 寻找结点待插入位置需要进行 key 的比较。
     每次比较时，首先比较两串的首字符。
     若首字符不等，则两串的大小关系就已经确定了；
     若首字符相等，那么就只需要判断去除首字符后两字符串的大小关系。
     而两串去除首字符后都已经属于 X 了，这时候可以借助平衡树 O(logn) 求排名的操作来完成后续的比较。
     **如果能够 O(1) 判断平衡树中两个节点之间的大小关系，那么就可以在 `O(nlogn)` 的时间内完成后缀平衡树的构造**。
     这个问题其实就是`Order Maintenance`问题。
     实现时，每个结点多维护一个类型为 float64 的标记 tag，根据 tag 的大小 O(1)判断两个结点的字典序大小。

3. 优点
   - 后缀平衡树的复杂度不依赖于字符集的大小
   - 后缀平衡树支持在字符串开头添加/删除一个字符
   - 如果使用支持可持久化的平衡树，那么后缀平衡树也能可持久化
