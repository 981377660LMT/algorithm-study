判断子序列:
**两种经典预处理方法，适合待匹配的字符串有很多个时**
`792. 匹配子序列的单词数.py`
`727. 最小窗口子序列`
`392. 判断子序列`
`583. 两个字符串的删除操作`

1. 哈希表存出现的 index(推荐)
   二分查找(bisectRight)出现的位置 索引需要递增

```JS
Map(13) {
  'a' => [ 0, 3 ],
  'h' => [ 1, 8 ],
  'b' => [ 2 ],
  's' => [ 4 ],
  'd' => [ 5, 15 ],
  'f' => [ 6 ],
  'g' => [ 7, 14 ],
  'y' => [ 9 ],
  't' => [ 10 ],
  'r' => [ 11 ],
  'e' => [ 12 ],
  'w' => [ 13 ],
  'c' => [ 16 ]
}
```

2. 指向下一个字母的指针
   `792. 匹配子序列的单词数.py`
   因为 S 很长，所以寻找一种只需遍历一次 S 的方法，避免暴力解法的多次遍历。
   将所有单词根据首字母不同放入不同的桶中
   每个桶中的单词就是该单词正在等待匹配的下一个字母
   例如，有字符串 S = 'dcaog'：
   words = ['dog', 'cat', 'cop']

   初始化 heads = 'c' : ('cat', 'cop'), 'd' : ('dog',)；
   遍历 S[0] = 'd' 后，heads = 'c' : ('cat', 'cop'), 'o' : ('og',)；
   遍历 S[1] = 'c' 后，heads = 'a' : ('at',), 'o' : ('og', 'op')；
   遍历 S[2] = 'a' 后，heads = 'o' : ('og', 'op'), 't': ('t',) ;
   遍历 S[3] = 'o' 后，heads = 'g' : ('g',), 'p': ('p',), 't': ('t',)；
   遍历 S[0] = 'g' 后，heads = 'p': ('p',), 't': ('t',)。

3. 对于长 n 的字符串 使用 数组+哈希 map (单词很多时，空间开销极大；适用于 char 种类很少的情况)

**倒序**记录从该位置开始往后`每一个字符第一次出现的位置`
`2055. 蜡烛之间的盘子.py`的 Next Candle

```JS
[
  Map(13) {
    'a' => 0,
    'h' => 1,
    'b' => 2,
    's' => 4,
    'd' => 5,
    'f' => 6,
    'g' => 7,
    'y' => 9,
    't' => 10,
    'r' => 11,
    'e' => 12,
    'w' => 13,
    'c' => 16
  },
...
```
