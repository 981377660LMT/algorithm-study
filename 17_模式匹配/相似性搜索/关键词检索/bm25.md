在 Python 中实现 BM25，最常用的方式是使用成熟的库 `rank_bm25`，或者为了深入理解算法逻辑手动实现。

### 1. 使用 `rank_bm25` 库（推荐工业使用）

这是目前最简单且高效的实现方式。

```python
# 安装: pip install rank_bm25
from rank_bm25 import BM25Okapi

# 1. 准备语料库并分词
corpus = [
    "Hello there good man",
    "It is quite windy in London",
    "How is the weather today"
]
tokenized_corpus = [doc.split(" ") for doc in corpus]

# 2. 初始化 BM25 对象
bm25 = BM25Okapi(tokenized_corpus)

# 3. 准备查询语句并分词
query = "windy London"
tokenized_query = query.split(" ")

# 4. 获取文档得分
doc_scores = bm25.get_scores(tokenized_query)

# 5. 获取最相关的文档
top_n = bm25.get_top_n(tokenized_query, corpus, n=1)

print(f"得分: {doc_scores}")
print(f"最匹配文档: {top_n}")
```

---

### 2. 手动实现 BM25（深入理解原理）

如果你想了解底层逻辑，可以参考以下简化版的实现：

```python
import math
from collections import Counter

class BM25:
    def __init__(self, corpus, k1=1.5, b=0.75):
        self.k1 = k1
        self.b = b
        self.corpus_size = len(corpus)
        self.avgdl = sum(len(doc) for doc in corpus) / self.corpus_size
        self.doc_freqs = []
        self.idf = {}
        self.doc_len = []
        self._initialize(corpus)

    def _initialize(self, corpus):
        nd = {}  # 存储包含词 t 的文档数量
        for doc in corpus:
            self.doc_len.append(len(doc))
            frequencies = Counter(doc)
            self.doc_freqs.append(frequencies)
            for word in frequencies:
                nd[word] = nd.get(word, 0) + 1

        # 计算 IDF
        for word, n_q in nd.items():
            self.idf[word] = math.log((self.corpus_size - n_q + 0.5) / (n_q + 0.5) + 1)

    def get_score(self, query, index):
        score = 0.0
        doc_freq = self.doc_freqs[index]
        d_len = self.doc_len[index]

        for word in query:
            if word not in doc_freq:
                continue

            idf = self.idf.get(word, 0)
            # BM25 核心公式
            tf = doc_freq[word]
            numerator = idf * tf * (self.k1 + 1)
            denominator = tf + self.k1 * (1 - self.b + self.b * d_len / self.avgdl)
            score += numerator / denominator

        return score

# 测试手动实现
corpus = [["hello", "world"], ["hello", "bm25", "is", "cool"], ["world", "is", "windy"]]
query = ["hello", "cool"]

bm25_manual = BM25(corpus)
scores = [bm25_manual.get_score(query, i) for i in range(len(corpus))]
print(f"手动计算得分: {scores}")
```

### 核心参数说明：

- **$k_1$**：控制词频饱和度。值越大，词频对得分的影响越持久；通常取 1.2 到 2.0。
- **$b$**：控制长度归一化。$b=1$ 表示完全归一化，$b=0$ 表示不考虑文档长度；通常取 0.75。
- **IDF**：逆文档频率，惩罚在所有文档中都出现的常见词。
