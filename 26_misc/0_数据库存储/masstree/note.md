https://zhuanlan.zhihu.com/p/339023488
https://zhuanlan.zhihu.com/p/52624601
https://zhuanlan.zhihu.com/p/271740123

# **Masstree** / **Redwood** (多层 B+树混合 Trie)

- **要点**：针对数据库/键值存储中**字符串 key** 做混合结构：上层是 Trie 分裂(短前缀区分)，下层是 B+Tree 段，能够在有序/字典序场景里提供极高的吞吐与可扩展性。
- **Masstree**：MIT 论文 & 实现，Memcached/KeyDB 之类的高性能场景可见其思路；
- **Redwood**：FoundationDB 的存储引擎之一，也融合了 B+Tree + Delta 机制。
- **原理**：
  - 用 Trie 快速分割前缀，再在每个节点存一棵 B+ 树 (也可能是 ART、FPTree 等)；
  - 使得短前缀能被快速区分，且节点内部仍有 B+ 树的页缓存友好特征。

在现代高并发、低延迟的数据库系统或存储引擎中，**树形索引**（如 B+ 树、LSM 树）常被用来管理有序键值对。随着硬件环境（多核 CPU、大容量内存、SSD 或 NVMe 等）和负载模式（大量并发读写、长短键混合、多线程共享访问）不断演进，研究者和工程师也在现有数据结构上进行新的探索和优化。

本回答将介绍两种面向高并发与可扩展性的树型索引结构：

1. **Masstree** —— 来自 MIT 的多层前缀树（trie）与 B+ 树结合，并在高并发场景下进行许多优化。
2. **Redwood** —— FoundationDB（苹果开源分布式数据库）所使用的存储引擎中的 B+ 树变体，实现多版本并发与增量写盘。

---

# 一、Masstree

## 1.1 背景

- Masstree 出自 MIT 相关论文 “The Design and Implementation of Masstree: a Fast, Balanced Key-Value Store” ([论文链接](http://db.lcs.mit.edu/memkey/memkey-2012-09-24.pdf))，主要作者包括 Eddie Kohler、Nickolai Zeldovich 等。
- 目标是在内存中（可部分溢出至磁盘）维护一棵可并发访问的、针对**字符串键**的高性能树结构，同时能够适配高吞吐、多线程访问场景。

## 1.2 基本思想：Trie + B+Tree

传统的 B+ 树适用于数值区间，有序的整数键。但如果键是长字符串（如域名、URL、文件路径、自定义文本 Key 等），查询与比较会变得昂贵。此外，如果要支持前缀匹配或相似搜索，单纯的 B+ 树也不够高效。

**Masstree** 通过将**前缀**分段，把字符串键按若干固定长度（如 8 字节）分割，然后在每层用一个**B+ 树**存储该“段”的所有可能取值范围。把它类比成一个多层的 **Trie**，只是 Trie 的每个节点不是二叉或多叉指针，而是一个**B+ 树节点**。

> - 第 0 层：存储键的前 8 字节（或更短，如果键长不足），在一个 B+ 树中管理。
> - 第 1 层：针对同一前缀下的下一个 8 字节，在另一个 B+ 树中管理。
> - 依次类推，直至完整键或插入/查询结束。

### 1.2.1 如何分层？

1. **拆分字符串键**

   - 给定一个字符串 key，如 `"apple123.org"`；将其按 8 个字节为一段（或者可根据实现自定义段大小 4 字节、16 字节等）；
   - 如果字符串过长，则需要多层；如果不足一段，就在该层就可存储并结束。

2. **层与层之间的链接**
   - B+ 树节点的叶子部分，可能包含指向下一层的指针（如果 key 未分段完毕）或者直接存放值（如果这是最后一段）。
   - 这样就构成了一个**多层**的结构，但每层实际上是一个小型的 B+ 树，这也是 “Mass” + “Tree” 命名的由来（大规模 / 大量的层？实际名称由作者给出）。

### 1.2.2 并发控制与结构优化

- **锁分割（Lock Coupling）**
  - Masstree 用精细化锁，常见做法是在 B+ 树节点上使用**读写锁**或类似机制，只在需要修改节点时才加写锁，其他只读访问可加读锁。
  - 在多层结构中，也需要“自顶向下”或“乐观并发控制”方式锁住相关节点。
- **缓存优化（Cache awareness）**
  - 由于大键值对或多层结构容易导致缓存 miss，Masstree 会尽量减少关键路径上的内存访问，并对节点大小、内部布局做缓存行对齐。
- **前缀合并**
  - 如果很多 key 拥有相同的前缀，可在一层中存储共享前缀，以缩短树高、减少比较次数。
- **版本号 + 乐观并发**
  - 在插入、删除、更新节点时，Masstree 维护一个**版本号**（或世代号），读操作可以先记下版本号，在读取过程结束时验证版本号是否变化，用于检测并发冲突。

### 1.2.3 性能特征

- **按段进行字符串比较**：每层只需要比较最多 8 字节，然后若仍需深入下一层再比较下一段，从而减少一次性长字符串比较的代价。
- **高并发**：在多核场景下，通过细粒度锁或乐观并发减少冲突。
- **适用场景**：
  - 大量字符串键、高并发读写的内存型数据库、KV 存储；
  - 需要快速前缀搜索（只要前缀 align 在分层上时可以很好地裁剪搜索空间）；
  - 像某些网络路由表、域名查找、文件系统元数据管理等都可以用 Masstree 思想。

---

# 二、Redwood

## 2.1 背景

- **Redwood** 是 [FoundationDB](https://github.com/apple/foundationdb) 使用的存储引擎之一，由苹果（Apple）在收购 Wavefront 并开源 FoundationDB 后继续维护、发展。
- FoundationDB 的核心是一个**分布式、有序 Key-Value Store**，默认存储引擎曾经使用 SQLite B-tree、LevelDB 等。**Redwood** 是后期官方在 6.0+ 版本中实现的本地存储引擎，用于替代旧的基于 sqlite/page cache 的方法。

## 2.2 Redwood B+Tree 的特点

### 2.2.1 Multi-Version B-Tree

FoundationDB 是一个**多版本**数据库：

- 在同一时刻，可能存在多个**读版本**（read version），以支持 MVCC（多版本并发控制）。
- Redwood 需要在一个 B+ 树结构里同时提供对多个版本快照的访问。

Redwood 如何实现多版本？

1. **基于 Delta 或 CoW（Copy on Write）**
   - 在更新时，不直接修改原节点，而是写新的节点或增量日志，这样可以保留旧版本供并发读使用。
2. **Suffix Delta / Page Reuse**
   - Redwood 采用**页面（page）+ 重写**的形式，结合“suffix tree”概念，每次更新写新的 page，把旧的 page 保留在磁盘上，直到没有读者需要它。
   - 也可以在 B+ 树节点上记录**delta chain**，让新老版本共存一段时间。

### 2.2.2 SSD / Page 优化

- Redwood 以**页（page size，例如 4KB）**为单位进行磁盘 IO。
- 采用**Copy-on-Write**：更新时先写新页面，然后在树结构上更新指针，最后释放旧页面或者保留以支持旧版本访问。
- 通过**Prefix compression**、**Key suffix** 等手段在 B+ 节点上减少重复存储（对于有序的 Key 列表，相邻 Key 共享大量前缀/后缀）。
- 使用**延迟合并 / Page splitting**策略，尽量避免频繁的小写放大（Write Amplification）。

### 2.2.3 Concurrent & Commit/Read

- **事务模型**：FoundationDB 在高层对事务进行 MVCC 控制，Redwood 在底层负责存储多个版本的数据和区段。
- **Commit**：在事务提交时，只需将**变更**以 B+Tree 的 CoW 方式写到新的页面，并更新“root page”指针即可；旧页面对应旧版本号。
- **Read**：读操作指定一个 read version，即可在 Redwood B+ 树中沿着版本链查找相应的页面或 Delta，获取一致的快照数据。

### 2.2.4 优势与适用场景

- Redwood 的多版本 B+ 树对于**OLTP 系统中的快照读**和**可重复读事务**非常友好；
- 相比于日志结构合并树(LSM Tree)，Redwood 依旧保持 B+ 树的顺序访问、高效范围扫描性能；
- 对 FoundationDB 这种分布式 KV 数据库非常适配：
  - Key 有序，支持范围查询；
  - 需要 MVCC，保证读事务不被写事务阻塞；
  - 分布式环境下，大量并发、写放大的问题需要精细化管理。

---

# 三、Masstree vs. Redwood：异同与总结

虽然它们同为“树形索引”，但侧重点不同：

1. **键类型与应用场景**

   - Masstree：
     - 主要面向**内存中**高速访问、大量并发、且键多为**字符串**或可分段的二进制序列；
     - 通过 Trie + B+Tree 混合结构加速前缀处理，并对多核并发做了丰富优化；
     - 常用于 KV 存储引擎（如 Redis-like、Memcached-like、或某些新型内存数据库）。
   - Redwood：
     - 面向**分布式数据库**（FoundationDB）的存储引擎层，支持**持久化**到磁盘/SSD；
     - 实现了**多版本** B+ 树，配合 Copy-on-Write 技术，对 MVCC 读事务非常友好；
     - 适合**范围查询**、**OLTP** 模式，需要存储历史版本数据的场景。

2. **并发与版本管理**

   - Masstree：专注多核并发下的**内存 B+ Trie**，版本管理主要是**乐观并发控制**+ 节点锁；
   - Redwood：在多线程并发下，还需支持**多版本**（MVCC），采用 CoW Page、Delta Chain 等机制在磁盘上保留各历史版本。

3. **实现复杂度与特性**

   - Masstree：
     - 需要管理多层 B+ 树节点 + 哈希前缀映射；
     - 聚焦**内存**存取速度、CPU Cache 友好；
     - 部分实现也支持持久化，但核心理念是**fast in-memory**。
   - Redwood：
     - 全功能 B+ 树存储引擎，包含**页管理**、**写路径**、**日志**或**CoW**、**索引前缀压缩**、**多版本**维护等。
     - 集成到 FoundationDB 事务系统之中。

4. **性能考量**
   - Masstree 在**小值 + 大并发 + 读写混合**下，性能非常突出；其论文中的性能测试显示，它能优于传统哈希表或 B+ 树结构。
   - Redwood 牺牲了部分纯内存速度，换来对**磁盘存储**和**多版本**支持的完善，在分布式 OLTP 环境下提供极具竞争力的吞吐和延迟。

---

# 四、结语

- **Masstree** 和 **Redwood** 都是针对于“高并发、有序 KV 访问”的先进数据结构或存储引擎。
- **Masstree**：把字符串按固定长度分段，用多层 B+ 树来构造前缀 Trie，并在并发方面做了深入优化；适合内存中、大量并发、前缀搜索需求的场景。
- **Redwood**：FoundationDB 使用的多版本 B+ 树引擎，能在磁盘上高效存储并管理多版本数据，支持快速范围查询、事务一致性和高并发。

在实际系统中，选用何种结构往往取决于：

- **数据规模与类型**（字符串 vs 整数 vs 混合）
- **持久化需求**（内存型 vs 磁盘型）
- **多版本/事务模型**（是否需要 MVCC）
- **写放大与并发冲突**（是大部分随机写，还是顺序写？并发度多高？）

对于分布式数据库与存储引擎开发者来说，这两种结构都是值得深入研究的案例；它们体现了**现代硬件环境下针对 B+ 树或 Trie 优化**的前沿思路，包括**cache-friendly 布局**、**并行并发控制**、**多版本事务支持**等关键技术。
