https://curiouscoding.nl/posts/static-search-tree/
https://algorithmica.org/en/eytzinger

# **Eytzinger Layout / Cache-Friendly Layout** 对搜索树的优化

- **要点**：把完全二叉搜索树按堆的顺序（Eytzinger 顺序）存储在数组里，能更好地利用 CPU cache，对搜索性能有实测收益。
- **使用场景**：在极其注重**CPU 缓存命中率**的场景（如游戏引擎中做碰撞检测或大规模搜索）可能用到。
- **优点**：相对于指针式树，连续存储能减少 cache miss，并在小规模内提高常数因子。
- **延伸**：也可将 B+Tree 的节点或 segment tree/block tree 进行“压缩存储”布置。

## 一、Eytzinger Layout 是什么？

### 1. 定义

- **Eytzinger Layout**（有时也称“Eytzinger 顺序”或“Heap 顺序”）是一种将**完全二叉树**的节点按**广度优先（BFS）顺序**存储在数组中的方法。
- 最常见的例子是**堆（heap）**的存储：对于一个索引从 1 开始的数组，根节点在下标 1，它的左孩子在下标 `2*i`，右孩子在下标 `2*i + 1`，等等（或从 0 开始也可，规则相应微调）。
- 在实际应用中，这种**顺序化布局**可以让节点在内存中连续存储，从而使得基于二叉树的访问在 CPU cache 中具有更好的缓存局部性。

### 2. 使用背景

- 在传统的指针式二叉搜索树（BST）中，每个节点包含左右子指针，节点在内存中可能是离散分配的。一旦树规模较大，随机指针会导致频繁的缓存缺失（cache miss）。
- **Eytzinger Layout** 则把树映射到**数组**里，尽可能将父子节点放得相邻或接近，减少了跳转地址的不确定性和大规模指针间隙，提升了访问同一 cache line 的概率。

### 3. 常见场景

- **堆**：在算法和数据结构课中，我们常见的堆就是 Eytzinger Layout 的典型例子，用于优先队列等。
- **BST 的静态搜索**：如果树结构是静态的，或者在构建后不再频繁更新，那么可以通过 Eytzinger 排列将 BST 存放到数组里做快速搜索。
- **Segment Tree / Fenwick Tree**：很多区间树、树状数组也采用类似的数组结构存储，本质上是利用 Eytzinger 或类似 BFS 顺序。
- **有序数组 + Binary Search**：其实 Eytzinger Layout 里的搜索，就类似在数组中做“仿真”二叉树搜索；某些情况下，这能比传统 BST + 指针跳转更快。

---

## 二、为什么需要 Eytzinger Layout（Cache-Friendly Layout）？

### 1. 背景：CPU Cache 与内存访问

- **现代 CPU** 具有多级缓存（L1, L2, L3），访问缓存比访问主存（DRAM）快得多。要想提高程序性能，需要提升**缓存命中率**。
- 在随机指针式数据结构（如链表、指针式树）中，节点分散在内存各处，访问时往往需要跳到远处地址，导致 cache miss 频繁，延迟大。

### 2. Eytzinger Layout 的优势

1. **连续内存**
   - 树的节点依序存放在数组里，父子节点在索引上“相邻”或有可预期的偏移，不需要指针跳转；
   - 顺序读取时，CPU 可以预取（prefetch）更多后续数据到 cache line，提高命中率。
2. **更好的预测**
   - 现代 CPU 具备硬件预取（hardware prefetcher），对于线性访问或有规律的访问，可以自动将下一段地址预读到缓存。如果节点的布局是 BFS 顺序，就容易形成较好的预取模式。
3. **简化结构**
   - 节点无需存放左右指针、父指针等，仅通过数组下标计算：左子 `2*i + 1`、右子 `2*i + 2`（如果从 0 开始计）；
   - 减少了额外的指针存储空间，也减少了节点内存碎片。

### 3. 适用范围与限制

- **静态或近似静态**数据：
  - 如果树频繁插入/删除节点，Eytzinger 数组结构维护会相对复杂，需要整段重排或部分重排。
  - 若数据集是构建一次、查询多次或更新不频繁，则非常适合。
- **完全二叉树**：
  - Eytzinger layout 最初是对“完全二叉树”定义的，但对于“平衡二叉树”也常在构建时以此顺序进行数组化（需要遍历结果来映射到数组下标）。
  - 如果树不平衡或节点分布不规则，需要先进行“平衡化”再按 BFS 进行序列化。

---

## 三、怎么办（如何实现 Eytzinger Layout 并进行搜索）？

### 1. 构建（Building the Eytzinger Layout）

**(1) 给定一个有序数组**

- 若我们已经有一组有序数据，需要在 BST 中存储。为了“静态搜索”而且保证平衡，可以先建立“完全平衡 BST” 的层次遍历序，然后把节点值依 BFS 顺序填入数组即可。
- 常见方法：对有序数组做**中序遍历** -> 构建**平衡 BST** -> 再层序遍历映射到 Eytzinger 数组。
- 或者直接用递归构造：
  1. 选取中间元素为根（保证平衡），
  2. 递归左、右子数组，
  3. 最终对树的层序遍历得到 Eytzinger 顺序。

**(2) 给定一棵平衡 BST**

- 若已有平衡 BST（AVL、红黑树）并要转成 Eytzinger 格式，可以做一次 BFS 顺序访问，把节点按访问顺序依次放入数组。

### 2. 搜索（Search Algorithm）

在 Eytzinger 数组 `A[]` 中，我们模拟 BST 的搜索流程，但不通过指针，而是通过数组索引：

1. **初始 idx = 0**（根节点在 `A[0]`）。
2. 比较 `target` 与 `A[idx]`：
   - 若相等，则找到目标，返回 idx；
   - 若 `target < A[idx]`，则转到左子，`idx = 2*idx + 1`；
   - 否则转到右子，`idx = 2*idx + 2`。
3. 如果下一个子节点索引超出数组范围或空缺，就表示查找失败。

整个过程与普通二叉搜索树相同，只是用索引运算替代了指针寻址。由于节点连续存储，这样的搜索会受益于缓存局部性。

### 3. 性能对比

- **传统指针 BST**: 每步跳一次指针，若树大且分散，cache miss 频繁；
- **Eytzinger Layout**: 父子节点通常在相邻或临近的数组位置，CPU 预取能较好发挥，访问延迟更低；
- 在现代 CPU 上，对一些百万级元素的搜索测试中，Eytzinger BST 通常可以比指针 BST 快数倍，因 cache 命中率显著提高。

---

## 四、Cache-Friendly Layout 的其他思路与扩展

1. **Van Emde Boas (vEB) Layout**

   - 与 Eytzinger 类似，vEB Layout 通过递归地在数组中分块存储子树节点，实现**递归划分**以减小树高度在缓存层次中的影响。
   - vEB Layout 在 CPU cache 分层（L1, L2, L3）中同样追求局部性，尤其在多级缓存结构中表现良好。

2. **B-Trees / B+ Trees**

   - 在数据库、文件系统中，为了减少磁盘 I/O，也会将更多节点存储在一块空间中（一个磁盘页 / Cache line）。
   - 这些多阶树在磁盘/SSD 上可以视作“Cache-Friendly”结构的另一种形式。

3. **Blocked Layout** / **Cache Oblivious Structures**
   - 通过对数据分块或分段使访问局部化，无需显式知道 cache line 大小而仍能获得好性能。
   - 在高阶或分块结构中也会见到类似 BFS 排列思路。

---

## 五、常见应用与示例

1. **Binary Heap**

   - 堆排序或优先队列几乎是 Eytzinger Layout 最典型的应用。
   - 堆的插入、删除、访问顶元素都受益于数组存储和 cache-friendly 访问。

2. **Static BST for Searching**

   - 当数据是只读或少量更新场景，把有序数据直接构建成 Eytzinger layout BST，做大量搜索操作。

3. **Segment Tree / Fenwick Tree**

   - 它们本质都是在数组中存储树结构，利用下标运算来访问父子节点；虽然不完全是 Eytzinger BFS，但思想相通：数组中的位置对应树节点。

4. **In-Memory Databases**
   - 一些内存数据库中的索引结构为了减少随机指针，也会采用类似 Eytzinger 排列或者平坦化存储方法，提升内存访问效率。

---

## 六、总结

1. **是什么**

   - **Eytzinger Layout**（又称 Cache-Friendly Layout）是将**完全二叉树**按**层序（BFS）**顺序存入数组，以减少指针跳转、提高内存访问的局部性与 CPU 缓存命中率。

2. **为什么**

   - 在现代多级缓存体系下，指针式树常导致较高 cache miss；
   - Eytzinger Layout 的连续存储让硬件预取更有效，访问延迟显著降低，适合静态或近似静态的树结构。

3. **怎么办**
   - **构建**：对有序数据或平衡 BST 做层序遍历，依次存入数组；
   - **搜索**：以数组为基础，用 `idx=0` 做根，通过 `2*idx+1`, `2*idx+2` 访问左右子节点；
   - **扩展**：vEB Layout、B-Tree 或其它 cache-friendly 结构也同理在内存/磁盘层面利用局部性。
