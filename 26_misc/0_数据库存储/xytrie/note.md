在经典的数据结构中，针对**整数集合**（如维护一组不重复的整型键）经常需要支持以下操作：

- **插入**(Insert)
- **删除**(Delete)
- **前驱查询**(Predecessor)：给定一个整数 \(x\)，找到集合中不大于 \(x\) 的最大元素
- **后继查询**(Successor)：给定一个整数 \(x\)，找到集合中不小于 \(x\) 的最小元素
- **成员查询**(Membership)\*\*：判断 \(x\) 是否在集合中

当整数的取值范围（Universe）是 \([0, U)\) 时（例如 32 位无符号整数则 \(U = 2^{32}\)），传统红黑树、AVL 树等平衡树方案能在 \(O(\log n)\) 时间内完成插入、删除、查询，其中 \(n\) 是当前集合的大小。不过，如果 \(U\) 非常大但 \(n\) 相比之下并不算极大，或者要实现类似 **van Emde Boas** 树那样的 \(O(\log \log U)\) 查询，出现了**X-fast Trie** 和 **Y-fast Trie** 两种数据结构，可以在**字长 \(\log U\)** 或者 \(\log \log U\) 量级内完成各种操作。

下面依次介绍：

- **X-fast Trie**
- **Y-fast Trie**
- 它们各自的设计思路、操作流程、时间复杂度对比，以及在实际中如何选用。

---

## 一、X-fast Trie

### 1.1 背景与思路

- **Trie（前缀树）**：对于二进制表示的整数，可以将每个整数想象成一条从根到叶的路径，左子分支表示“比特 0”，右子分支表示“比特 1”。
- 传统的二进制 Trie 若将所有整数都插入，会形成一棵深度为 \(\log U\) 的树，且节点数在最坏情况下可能接近 \(n \cdot \log U\)。
- **X-fast Trie** 是在二进制 Trie 思想上做了**哈希化+层级索引**的改进，通过在每一层维护“前缀 \(\to\) 节点”的快速映射，使得前驱/后继查询能在 \(\mathrm{O}(\log U)\) 内完成，并且插入、删除同样维持 \(\mathrm{O}(\log U)\) 复杂度。

### 1.2 数据结构核心

1. **层级散列表（prefix hash）**

   - 对于深度为 \(\log U\) 的二叉 Trie，从根到任意一条路径可以分成 \(\log U\) 层（第 0 层到第 \(\log U - 1\) 层）；
   - 每层可以用一个哈希表（或 map）存储：**“前缀 -> 节点指针”**。这里的“前缀”指该层对应位数在某条路径上的 0/1 序列。
   - 这样一来，如果我们想找到某个前缀对应的 Trie 节点，就可以在 \(O(1)\) 时间（平均情况下）通过哈希查找得到。

2. **叶节点双向链表（或前驱后继链接）**

   - X-fast Trie 中，将所有**叶节点**（代表具体插入的整数）以**升序**链接成一个双向链表；
   - 这样，给定一个叶节点，就能在 \(\mathrm{O}(1)\) 时间内找到其前驱或后继的叶节点；
   - 查询时，如果找到了“最接近”的叶节点，就可以通过链接得到真正的前驱或后继。

3. **Trie 的按位结构**
   - 整数的二进制长度为 \(\log U\)；
   - 从根到叶，共 \(\log U\) 层，每层选择 0 或 1 以到达下一层；
   - 只有**插入过**的分支才会存在 Trie 节点，不会存储无用分支；
   - 结合**散列表**加速节点访问（而不需要一级一级沿着指针下去）。

### 1.3 主要操作及复杂度

#### **1）前驱 / 后继 查询（Predecessor / Successor）**

1. **二分层级**
   - 想要在集合中找“最接近 \(\le x\)”或“最接近 \(\ge x\)”的元素，可以对 Trie 的深度做**二分搜索**：
   - 先看二进制前缀长度的一半（\(\log U / 2\)），查询“是否存在与 \(x\) 前 \(\ell\) 位相同的路径分支”？
   - 依据查询结果决定往上或往下修正前缀长度，直到确定能与 \(x\) 最长共用的前缀。
2. **找最接近的叶节点**
   - 确定完前缀后，可以通过该节点在叶子双向链表中找到真正的前驱或后继；
3. **时间复杂度**
   - 二分层级的次数是 \(\mathrm{O}(\log \log U)\) 次，每次通过哈希表 \(\mathrm{O}(1)\) 查找，**合计约 \(\mathrm{O}(\log \log U)\)**。
   - 也有文献习惯称为 \(\mathrm{O}(\log U)\) 取决于实现细节和常量因子。常见的教科书中，会强调 X-fast Trie 达到了 \(\mathrm{O}(\log \log U)\) 的前驱后继查找，但要注意具体实现的差异。

> **注：** 一些资料中提到 X-fast Trie 查询在 \(\mathrm{O}(\log \log U)\) 完成，主要是因为做**二分**查找“最深公共前缀深度”即在 \([0, \log U]\) 上做二分，所以大约需要 \(\log(\log U)\) 步；每步用哈希表查找为 \(\mathrm{O}(1)\)，因此合计 \(\mathrm{O}(\log \log U)\)。

#### **2）插入（Insert）/ 删除（Delete）**

- 插入一个新整数 \(\alpha\)：

  1. 找到与 \(\alpha\) 最长公共前缀的现有节点（类似查询时的二分层级过程）；
  2. 创建或更新相关 Trie 节点；插入新的叶节点到双向链表中；
  3. 更新各层哈希表中的 “前缀->节点” 映射；
  4. 这些操作都需要 \(\mathrm{O}(\log U)\) 或 \(\mathrm{O}(\log \log U)\) 次（视具体实现而定），因为插入时可能需要更新多层节点或拆分指针；

- 删除时的过程大致相似：找到对应叶节点、从双向链表中移除，并清理不再使用的 Trie 节点以及其在各层哈希表的记录。

#### **3）空间复杂度**

- 在最坏情况下，每个插入元素都有独特的比特前缀，Trie 节点数可达 \(\mathrm{O}(n)\)（通常小于 \(n \log U\)，因为只为出现的前缀分配节点），再乘上每层都需要哈希表存储“前缀 \(\to\) 节点”的映射。
- 总体来说，X-fast Trie 相对 van Emde Boas 树在**空间常数因子**上会大一些，如果 \(n\) 或 \(\log U\) 较大时，内存消耗不容忽视。

---

## 二、Y-fast Trie

### 2.1 背景与动机

- X-fast Trie 可以在 \(\mathrm{O}(\log \log U)\) 时间内完成前驱/后继查询，但它维护了**完整的前缀节点**以及**哈希表**，导致内存占用可能很大。
- **Y-fast Trie** 通过将**元素分桶**（或称小集合）并用 **AVL / BST** 等平衡树存储，结合一个“骨架结构”的 X-fast Trie 做索引，能实现同样的查询复杂度但显著减少内存使用。

### 2.2 核心思想

1. **抽取代表（representative）并存于 X-fast Trie**
   - 将集合中的元素分成若干个不相交的小集合（每个小集合用一棵平衡搜索树存放）。
   - 每个小集合选择一个“代表元素”\( r \)；把这个\( r \) 插入到 X-fast Trie 中。
   - 当要进行前驱/后继查询时，先在 **X-fast Trie** 中找到“最接近 \(x\)”的代表\( r \)。
2. **在对应的小集合内做精准查找**
   - 找到代表\( r \) 后，根据它所在的小集合（用一棵平衡树，比如红黑树、AVL 树等），在其中做标准的 BST 前驱/后继查找，这一步是 \(\mathrm{O}(\log n_i)\)，\(n_i\) 是该小集合的大小。
   - 为了保证时间复杂度，**约束每个小集合大小**在 \([\frac{n}{2^k}, 2 \frac{n}{2^k}]\) 或某种平衡区间，进而保持整体操作在 \(\mathrm{O}(\log \log U)\) 或 \(\mathrm{O}(\log \log n)\) 时间内。
3. **插入/删除时**
   - 如果某个小集合过大或过小，进行**分裂**或**合并**，并选择/更新新的代表存入/移除 X-fast Trie。
   - 整体让所有小集合的大小保持在一个平衡范围，以控制 **BST** 操作 + **X-fast Trie** 操作总时长。

### 2.3 时间复杂度

- 查询：

  1. 在 X-fast Trie 中查到代表 \(r\) （\(\mathrm{O}(\log \log U)\)）；
  2. 在对应平衡树里做 \(\mathrm{O}(\log m)\) 查找，其中 \(m\) 为小集合大小；
  3. 设计得当时，小集合大小可保证在 \(\mathrm{O}(\log n)\) 或 \(\mathrm{O}(\log \log U)\) 范围内，使总体仍保持在 \(\mathrm{O}(\log \log U)\)。

- 插入/删除：
  - 可能触发对小集合的分裂或合并操作，不过这些操作不频繁；
  - 小集合内插入/删除是 \(\mathrm{O}(\log m)\)，更新 X-fast Trie 代表是 \(\mathrm{O}(\log \log U)\)；
  - 摊销后依旧能维持 \(\mathrm{O}(\log \log U)\) 的级别。

### 2.4 空间与实现

- 相较于 X-fast Trie，Y-fast Trie 并不会为每个元素单独维护完整的前缀节点；它只在 X-fast Trie 中存了“代表元素”。
- 大部分元素存在每个小集合的平衡树中；
- 因此在处理**大规模**的整数集合时，Y-fast Trie 往往比 X-fast Trie 更节省空间，但结构实现更复杂。

---

## 三、对比与总结

| **数据结构**    | **典型操作时间复杂度**                                                                                                         | **空间复杂度**                                    | **实现难度**                         | **备注**                                        |
| --------------- | ------------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------- | ------------------------------------ | ----------------------------------------------- |
| **X-fast Trie** | 前驱/后继：\(\mathrm{O}(\log \log U)\)<br>插入/删除：\(\mathrm{O}(\log U)\) or \(\mathrm{O}(\log \log U)\)（不同文献略有差异） | 通常较大，需要维护多层节点和哈希表                | 相对复杂，需要散列表+双向链表+Trie   | 适合宇宙大小 \(U\) 不过于庞大；当内存足够时可用 |
| **Y-fast Trie** | 前驱/后继：\(\mathrm{O}(\log \log U)\)<br>插入/删除：\(\mathrm{O}(\log \log U)\) 摊销                                          | 较 X-fast Trie 更节省<br>因为多数元素放在平衡树内 | 更复杂，需要 X-fast骨架 + 小集合 BST | 兼顾 \(\mathrm{O}(\log \log U)\) 操作和较低空间 |

- **X-fast Trie**

  1. 原理相对直观：用 Trie + 哈希表加速搜索 + 叶节点链表；
  2. 查询可以二分深度，\(\mathrm{O}(\log \log U)\) 步找到最近前缀，再用叶节点链表定位真正的前驱/后继；
  3. 缺点是会为**每层**前缀都建哈希表，元素越多、\(\log U\) 越大时，空间增幅明显。

- **Y-fast Trie**
  1. 在 X-fast Trie 基础上进一步优化，**只存代表**到 Trie 中；
  2. 其他元素放在若干平衡树（小集合）里；
  3. 保证操作仍是 \(\mathrm{O}(\log \log U)\)，但空间利用率更好，适合更大规模的整数集合。

### 适用场景

- 当需要在 **动态整数集** 上做**前驱/后继**等有序操作，并且希望比平衡 BST （如红黑树）更快（\(\mathrm{O}(\log \log U)\) vs \(\mathrm{O}(\log n)\)），可考虑 **X-fast** 或 **Y-fast**。
- 如果对空间要求较严苛或者 \(U\) 非常大，倾向使用 **Y-fast Trie**；
- 如果实现难度需要尽量低，可以实现 **X-fast Trie**；或者直接使用 **van Emde Boas** 树也能达到相似的时间复杂度，但在常数因子、实现细节和内存使用上都各有取舍。

---

## 四、小结

- **X-fast Trie** 与 **Y-fast Trie** 都是针对 **整数集合** 提供 \(\mathrm{O}(\log \log U)\) 前驱/后继查询的一种高级数据结构。
- **X-fast Trie**：
  - 利用二进制 Trie + **哈希表** + **叶节点链表**，通过**二分深度**找目标前缀；
  - 实现思路直观，但空间开销较大。
- **Y-fast Trie**：
  - 通过将元素分割为**若干小集合**并在**X-fast Trie** 中仅存“代表”来提高空间效率；
  - 操作同样能在 \(\mathrm{O}(\log \log U)\) 完成，但实现更为复杂。

两者都可视作 **van Emde Boas** 树的变种或实现方式，在需要快速有序操作（前驱/后继）的场合、且 Universe 大小 \(U\) 在可控范围内，能比传统 \(\mathrm{O}(\log n)\) 的平衡树更高效（当 \(n\) 接近 \(U\) 时，\(\log n\) 也接近 \(\log U\)，差别就更明显）。当然，若 \(U\) 过大或内存非常有限，这些结构也会遇到瓶颈；实际工程中往往还需结合**分块**、**压缩**、**外存结构**等技巧来权衡。
