https://notes.sshwy.name/Randomized/Count-min-Sketch/
「随机算法专题」Count-min Sketch 入门
这是一种，估计出现次数的数据结构，适用于数据流（强在线），不同的元素数不多的情况。

基本思想是一个哈希表可以估计某个值的出现的次数，但是会估多，因此多个哈希取最小值即可。这里的哈希要取均匀哈希才能保证理论复杂度的正确性。

---

**Count-Min Sketch（CMS）** 是一种常用的数据结构，用于**以较低的内存开销估计数据流（或海量数据）中各元素的频率（或出现次数）**。
Count-Min Sketch 的核心思想是：`使用多组独立的哈希函数，将一个元素映射到若干个不同的“桶”（bucket）中，并在对应桶内累加一个计数；当需要查询某个元素的频率时，就去各组哈希对应的桶中取最小值作为该元素的估计频率。`

Count-Min Sketch 经常被用于需要实时（或接近实时）地处理数据流，并且无法在内存中完整保存全部元素和其出现次数的场景，例如网络流量统计、日志分析、推荐系统、关键词计数等。

下面我们从原理、数据结构、误差分析、算法流程以及与其他数据结构的对比等方面对 Count-Min Sketch 进行详细讲解。

---

## 1. 结构与原理

### 1.1 数据结构

Count-Min Sketch 的核心是一张「二维表」，假设我们需要 \( d \) 个哈希函数，并且为每个哈希函数配备一个大小为 \( w \) 的数组。通常把它称为一个 \( d \times w \) 的数组或矩阵。结构示意如下：

```
          +---------+---------+---------+---------+-----+
哈希1 --> | count11 | count12 | count13 | count14 | ... |
          +---------+---------+---------+---------+-----+
哈希2 --> | count21 | count22 | count23 | count24 | ... |
          +---------+---------+---------+---------+-----+
   ...
          +---------+---------+---------+---------+-----+
哈希d --> | countd1 | countd2 | countd3 | countd4 | ... |
          +---------+---------+---------+---------+-----+
```

- 我们有 \( d \) 个互相独立的哈希函数 \( h_1, h_2, \ldots, h_d \)，每个哈希函数的取值范围都是 \([0, w - 1]\)。
- 对于一个元素 \( x \)，通过哈希函数 \( h_i(x) \) 得到它在第 \( i \) 行（对应哈希函数 \( h_i \)）所对应的桶位置，然后将该位置的计数器加 1。
- 用于存储的内存大小为 \( O(d \times w) \)。

### 1.2 频率估计原理

当查询一个元素 \( x \) 的频率时，Count-Min Sketch 会在每行对应的哈希桶中取出计数值，然后取所有这些值的最小值：  
\[
\hat{f}(x) = \min\_{i=1}^d \text{(count at } [i, h_i(x)] )
\]  
这是因为在多次哈希下，Count-Min Sketch可能会因不同元素产生的哈希碰撞而导致计数被多加，但是由于“最小值”策略，能够一定程度上减少碰撞带来的高估。

---

## 2. 误差分析

Count-Min Sketch 在时间和空间上都具有优势，但它的查询结果是一个**上界估计**，即查询出来的频率要么是准确的，要么偏大。不会出现比真实频率更小的情况。这种上界估计的误差来源于哈希碰撞（collisions）。

### 2.1 概率保证

一般地，Count-Min Sketch 在给定概率保证 \( \delta \) 和误差上限 \( \epsilon \) 的条件下，可以得到如下的空间和时间复杂度要求：

- 令 \( w = \lceil e / \epsilon \rceil \)，\( d = \lceil \ln(1/\delta) \rceil \)。
- 则 Count-Min Sketch 的空间复杂度为 \( O(\frac{1}{\epsilon} \ln \frac{1}{\delta}) \)，并且查询任意元素的结果 \( \hat{f}(x) \) 至多比真实值 \( f(x) \) 大 \( \epsilon N \)，其中 \( N \) 是元素总个数（数据流中所有元素出现次数之和）。
- 查询任意元素的时间复杂度为 \( O(d) \)，更新时也需要 \( O(d) \) 时间（因为要对每个哈希函数的结果更新一次）。

### 2.2 简要推导

- 当一个元素 \( x \) 映射到哈希桶时，由于哈希碰撞，它的计数可能和其他元素的出现次数相加。
- 多个哈希函数的独立性可以将出错的概率（碰撞导致的高估量超过一定阈值）降低到一个可控范围。
- 通过设置适当的 \( d \) 和 \( w \) 来满足误差与概率的需求。

---

## 3. 算法流程

Count-Min Sketch 主要涉及以下两个操作：**更新（update）** 和 **查询（query）**。我们以数据流的形式来说明。

### 3.1 更新（Update）算法

当数据流中到达一个元素 \( x \) （出现一次），需要在 CMS 中进行如下更新操作：

1. 对 \( i = 1, 2, \ldots, d \)：
   - 计算桶索引 \( j = h_i(x) \)，其中 \( j \in [0, w - 1] \)；
   - 将 \( \text{count}[i][j] \) 加 1。

> 如果元素的出现次数大于 1，也可以一次性加对应的频率值，但通常数据流是单个元素依次到来，因此最常见的是“加一”。

### 3.2 查询（Query）算法

当需要查询某个元素 \( x \) 出现的频率时：

1. 对 \( i = 1, 2, \ldots, d \)：
   - 计算桶索引 \( j = h_i(x) \)；
   - 取出 \( \text{count}[i][j] \) 值。
2. 将所有取出的 \( \text{count}[i][j] \) 值做最小操作，得到：  
   \[
   \hat{f}(x) = \min\_{i=1}^d \text{count}[i][h_i(x)]
   \]

### 3.3 复杂度

- **更新**：需要计算 \( d \) 次哈希并更新 \( d \) 个计数器，时间复杂度 \( O(d) \)。
- **查询**：需要计算 \( d \) 次哈希并访问 \( d \) 个计数器，时间复杂度 \( O(d) \)。
- 空间开销：\( O(d \times w) \)，在误差要求下为 \( O(\frac{1}{\epsilon} \ln \frac{1}{\delta}) \)。

---

## 4. 参数选择

从误差分析中可知，通常会根据所需的**可容忍误差** \( \epsilon \) 和**错误概率** \( \delta \) 来选取矩阵维度 \( d \) 和宽度 \( w \)。经验公式是：  
\[
w = \left\lceil \frac{e}{\epsilon} \right\rceil, \quad d = \left\lceil \ln \frac{1}{\delta} \right\rceil.
\]

- **\( w \)** 越大，则桶冲突概率越低，对应的误差上限越小；但同时需要更多的内存。
- **\( d \)** 越大，则多次独立哈希会降低出现大误差（由于多行都碰撞）的概率，但也会增加内存和计算的开销。

在实际应用中，可以根据数据量和对误差的需求，结合硬件资源来做选取和折中。

---

## 5. 与其他 Sketch 的比较

在数据流计算中，除了 Count-Min Sketch 还有其他类似的频率估计算法，例如：

1. **Count Sketch**

   - 与 Count-Min Sketch 的主要区别在于，Count Sketch 不是简单地把计数+1，而是在哈希后还多加了一层“符号函数”。这样可以得到正负抵消的效果，估计结果更精确，且可以同时估计正向和负向偏差。但是实现复杂度相对较高，并且在误差保证方面与 Count-Min Sketch 的方式不同。

2. **Cuckoo Counter / Cuckoo Filter**

   - 主要用于快速判断一个元素是否存在、并以较小的内存来估计元素出现次数或替代布隆过滤器。在频率估计能力上，相比 Count-Min Sketch 可能更为复杂，适用场景与布隆过滤器类似但并不完全相同。

3. **Top-K / Heavy Hitters 的特化算法（Misra-Gries、Space-Saving 等）**
   - 这些算法在想要挖掘出现次数最多的那几个元素（heavy hitters）时非常有效。但是它们并不像 Count-Min Sketch 那样同时对所有元素都有一个近似的频率估计，而是专注于找到出现次数最多的那部分元素。

Count-Min Sketch 的优点是实现相对简单、内存和时间性能都有良好表现，尤其在面向所有元素的频率估计时具有较好的适用性。

---

## 6. 示例与小结

假设有一个数据流（或一批数据）包含元素 \(\{a, b, c, d, ...\}\)，每个元素在流中出现若干次。我们构造一个 Count-Min Sketch，设定 \( d = 3 \) 行，每行 \( w = 10 \) 个桶。选取 3 个不同的哈希函数 \( h_1, h_2, h_3 \)。当元素到来时：

1. 计算 \( j_1 = h_1(x) \)，更新 \(\text{count}[1][j_1]\)；
2. 计算 \( j_2 = h_2(x) \)，更新 \(\text{count}[2][j_2]\)；
3. 计算 \( j_3 = h_3(x) \)，更新 \(\text{count}[3][j_3]\)。

查询时，也是分别计算哈希索引并取出对应的计数值，最后取最小值，即可得到该元素的频率估计。

**在使用 Count-Min Sketch 时，需要注意：**

- 哈希函数的质量对最终效果影响很大，要尽量减少冲突；
- 只提供上界估计，查询结果可能比真实值略大；
- 对于需要统计高频元素（heavy hitters）的场景，也可以结合 Count-Min Sketch 进一步优化。

---

### 总结

Count-Min Sketch 利用了多次独立哈希和最小值策略，以 \( O(\frac{1}{\epsilon} \ln \frac{1}{\delta}) \) 的空间和 \( O(\ln \frac{1}{\delta}) \) 的查询、更新时间，保证了“以可控概率不超过 \(\epsilon\) 范围的频率高估”这一性质，能够在海量数据场景下非常高效地进行频率估计。在网络数据流统计、日志实时分析等诸多应用中，Count-Min Sketch 常常是首选的基线解决方案之一。
