在分布式系统、实时流计算和大规模数据分析场景中，我们常常需要快速地估计数据分布的**分位数（quantiles）**，例如中位数（50% 分位）、P90、P95、P99 等各种指标，用于监控、风控、性能分析等。这类问题的核心挑战是：**数据规模巨大**、**数据流持续不断**，不可能把所有数据都完整地存到内存里再做精确计算。

为此，业界广泛采用了**近似分位数（approximate quantile）**算法，这些算法在保留一定误差范围的前提下，大幅减少内存使用量和计算开销。它们也可以方便地在分布式场景下进行合并（merge），让多个节点上各自维护的局部结构最终能合并为一个全局近似分位数结构。

下面介绍两个常见的分位数近似算法/数据结构：

1. **GKArray**（源自 Greenwald-Khanna 算法）
2. **DDSketch**（由 Datadog 提出）

---

## 1. GKArray（Greenwald-Khanna 算法）

### 1.1 什么是 Greenwald-Khanna 算法？

**Greenwald-Khanna（GK）算法** 是一个针对 **数据流（stream）** 的 **近似分位数** 计算方法。它的主要贡献在于：

- 在单机（或分区）环境中，能在 \(O(\frac{1}{\epsilon})\) 的空间复杂度下，保证分位数估计的误差不超过给定阈值 \(\epsilon\)；
- 适合**在线（online）**场景：数据一条条到来时，算法可以不断更新内部结构，并能够随时查询近似分位数。

在实现中，常把 GK 算法结构化成一个数组（因此有人称其为 **GKArray**）来维护“有代表性”的数据点及其“累计排名区间（rank range）”。

### 1.2 核心原理

1. **插入元素**

   - 维持一个有序的摘要结构（summary），其中每个记录包含一个值（\(v\))，以及一些误差边界信息（通常是 \(g\) 和 \(\Delta\)，描述了该值在排序中的“rank 范围”）。
   - 当新元素到来时，在这个摘要结构里找它应插入的位置，再根据合并策略来更新相邻记录的 \(g, \Delta\) 等参数；如果摘要结构长度超过了目标大小，就执行一次压缩（merge）操作，合并相近的记录。

2. **查询分位数**

   - 给定一个分位数 \(\phi\)（如 0.95），GK 算法会在摘要结构中找出一个值，使得它在数据流排序中的 rank 位置接近 \(\phi \times N\)（\(N\) 为当前已处理的数据量）。
   - 算法利用摘要结构中每个记录的 rank 上、下界（由 \(g\) 和 \(\Delta\) 决定），找到满足“插值”范围的那个记录值。

3. **误差保证**
   - GK 算法可以确保最终查询到的分位数值，其真实 rank 误差不超过 \(\pm \epsilon N\)。

### 1.3 为什么适合分布式？

- **可合并（Mergeable）**：  
  不同节点上可以各自维护一个 GK 摘要（GKArray），待到需要时将这些摘要合并成一个新的摘要，从而得到全局近似分位数。合并过程本质上就是把两个有序摘要合并，再进行压缩，保持同样的误差界限。
- **在线/流式**：  
  适合大规模流数据的实时统计，不用等待所有数据到齐后再离线计算。

### 1.4 何时使用 GKArray？

- 当我们需要对分位数的**误差（rank error）**有一个严格、可控的保证；
- 数据分布未知且动态变化，需要在线更新并随时可查询；
- 可以接受 \(O(\frac{1}{\epsilon})\) 级别的空间复杂度，并且实现稍显复杂一些。

---

## 2. DDSketch

### 2.1 什么是 DDSketch？

**DDSketch** 是由 [Datadog](https://www.datadoghq.com/) 提出的另一个适用于分布式场景的近似分位数算法/数据结构，最初在论文 [“DDSketch: a fast and fully-mergeable quantile sketch with relative-error guarantees”](https://arxiv.org/abs/1908.10693) 中提出。

与 GK 算法关注**绝对误差（absolute rank error）**不同，DDSketch 更关注**相对误差（relative error）**，尤其适用于某些分布具有重尾（heavy-tailed）或跨多个数量级的情况，比如响应时间、请求延迟、订单金额等有可能从 1 到 10^6 不等的场景。

### 2.2 核心思路

1. **对数映射 Buckets**
   - DDSketch 将数值通过对数尺度（logarithmic mapping）映射到不同的桶（bucket）中。
   - 当数值范围特别宽时，这种对数映射能更好地保持相对误差的一致性。
2. **分桶计数**
   - 每个桶里维护一个计数，表示有多少个数据点落在该桶范围内；
   - 对非常小的值（如负数或零值）会采用另一个分支或特殊处理。
3. **合并（Merge）**
   - 因为采用相同的对数映射规则，不同节点只需将桶计数相加就能完成合并。
   - 十分容易分布式扩展：每个节点独立维护 DDSketch，最后在中心节点把各桶计数做加和即可。
4. **查询分位数**
   - 给定分位数 \(\phi\)，去桶里累计计数直到到达 \(\phi \times N\)，再根据桶的上下界做一个估计插值。
   - 在对数映射下，误差主要体现在相对误差的控制上。

### 2.3 为什么用 DDSketch？

- **相对误差保证**：  
  当我们关注的数据呈现**大范围跨越**（如 1 微秒 ~ 1 秒的延迟），想确保在对数尺度上有准确性，而不是在绝对值上死板地保证 +/- k 的误差。
- **高并发、可合并**：  
  分布式场景中非常容易做合并（把同一 bucket index 的计数累加即可）。
- **实现简单**：  
  相比 GK，需要维护一个更简单的桶计数数组，插入和合并都很快。

### 2.4 典型应用

- **分布式系统的延迟监控**（P99、P999 等）：响应延迟常常跨多个数量级，DDSketch 很适合做这种近似统计。
- **带有极端值或长尾分布的数值分析**：如金融交易金额、用户停留时长等。

---

## 3. GKArray vs DDSketch：如何选择？

1. **误差模型不同**

   - GK 算法默认关注**rank 误差**（绝对误差），在分位数 rank 维度做精确约束；
   - DDSketch 则关注**值域上的相对误差**（尤其适合重尾或对数分布场景）。

2. **数据分布**

   - 如果数据分布在相对狭窄的范围内，或我们特别关心的是 rank-based 误差，GKArray 更合适；
   - 如果数据跨度很大（从小到大跨越多个数量级），对相对误差更敏感，DDSketch 更能保持稳定的误差。

3. **实现与合并**

   - 两者都可以分布式合并，但 DDSketch 更加直接（直接累加桶计数）；
   - GKArray 合并时需合并两份有序摘要，虽然也不算困难，但实现细节更多。

4. **复杂度与性能**
   - GKArray 在插入时需要在摘要中定位并插入/合并节点，可能相对 DDSketch 的“直接根据 log-bucket 下标加 1”要复杂；
   - DDSketch 在插入和合并阶段都非常高效，查询分位数也很快，但在值分布极端均匀时可能没那么精确；
   - GKArray 在极度平滑/均匀分布下，可以获得更精确的 rank 保障。

---

## 4. 分布式使用中的“怎么办”

无论是 **GKArray** 还是 **DDSketch**，在分布式场景下的典型做法一般是：

1. **各节点本地维护一个 Sketch**
   - 不管是 GK 还是 DDSketch，都在每个节点本地接收数据流并做插入更新。
2. **周期性或按需合并**
   - 若要查看全局分位数，就把各节点 Sketch 拉取到中央，执行一次 `merge`，得到全局 Sketch。
   - 或者节点之间可以两两合并，最终归约到一个中心。
3. **查询**
   - 对合并出的 Sketch 调用 `Query(quantile)` 方法拿到近似分位数即可。
4. **参数调优**
   - GKArray 要设置 \(\epsilon\) 控制 rank 误差和空间；
   - DDSketch 要设置相对误差参数（如 `alpha`），决定桶数量和精度。

---

## 5. 小结

- **GKArray (Greenwald-Khanna)**：

  - 关注**绝对 rank 误差**；
  - 在插入和合并上需要维护有序摘要结构（可能稍微复杂）；
  - 对所有分位数都能有较好且可控的错误上限。

- **DDSketch**：
  - 关注**相对误差**，尤其适合“数值跨越多个数量级”的重尾分布；
  - 采用对数映射、按桶计数，插入和合并非常高效；
  - 对极大或极小值也需特别处理边界情况，但整体实现比较直观。

在分布式数据处理中，**近似分位数**的需求非常普遍（如监控 metrics、海量日志分析、实时风控等）。你可以根据**数据分布特性**、**误差需求类型（绝对 vs. 相对）**、**实现难度**等因素，选择 GKArray 或 DDSketch，或其它类似的 quantile sketch（例如 T-Digest、Q-Digest、Histogram-based 方法等）来满足你的业务需求。
