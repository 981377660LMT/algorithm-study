# prometheus 中，Quantile Sketches 是如何实现的

在 **Prometheus** 中，分位数（Quantile）的计算并非直接通过传统的 Quantile Sketches 算法（如 GK、T-Digest 等）实现，而是通过 **直方图（Histogram）类型指标** 结合内置函数 `histogram_quantile()` 实现的。以下是其核心实现逻辑和特点：

---

### 一、实现原理：基于直方图的近似计算

Prometheus 的直方图指标通过 **预定义桶（Bucket）** 对数据进行分桶统计，再通过线性插值估算分位数值。具体流程如下：

#### 1. **数据分桶存储**

- **桶（Bucket）定义**：在代码中预定义一组值域区间（例如 `[0.1, 0.5, 1, 5, 10]` 秒），每个桶记录 **小于等于该阈值** 的样本数量。
- **指标格式**：每个直方图指标包含多个时间序列：
  - `<metric>_bucket{le="<上界>"}`：记录落入该桶的样本计数。
  - `<metric>_sum`：所有样本值的总和。
  - `<metric>_count`：样本总数。

例如，一个 HTTP 请求耗时的直方图指标可能包含：

```
http_request_duration_seconds_bucket{le="0.1"} 20
http_request_duration_seconds_bucket{le="0.5"} 45
http_request_duration_seconds_sum 123.4
http_request_duration_seconds_count 100
```

#### 2. **分位数计算（`histogram_quantile` 函数）**

通过以下公式估算分位数：

```promql
histogram_quantile(
    φ,  # 目标分位数（如 0.95）
    sum(rate(http_request_duration_seconds_bucket[5m])) by (le)
)
```

**计算步骤**：

1. **统计各桶的样本增长率**：使用 `rate()` 计算每个桶在时间窗口内的增量。
2. **确定目标桶**：找到第一个累积样本数超过 `φ * total_count` 的桶。
3. **线性插值**：假设目标桶内数据均匀分布，通过插值估算分位数值。

例如，若 95% 分位数落在 `le=1s` 的桶（包含 90%~95% 的样本），则分位数值为：
\[
\text{分位值} = le*{\text{lower}} + \frac{\phi \cdot N - count*{\text{lower}}}{count*{\text{upper}} - count*{\text{lower}}} \cdot (le*{\text{upper}} - le*{\text{lower}})
\]

---

### 二、与 Quantile Sketches 的对比

| **特性**     | **Prometheus 直方图**    | **Quantile Sketches（如 T-Digest）** |
| ------------ | ------------------------ | ------------------------------------ |
| **数据存储** | 预定义静态桶，存储桶计数 | 动态聚类或分层，存储数据特征         |
| **精度控制** | 依赖桶的分布密度         | 通过参数 ε 控制全局误差              |
| **内存占用** | 固定（桶数量决定）       | 动态调整，通常更高效                 |
| **合并能力** | 天然支持多实例数据聚合   | 需特定算法支持（如 KLL 可合并）      |
| **适用场景** | 监控指标、固定范围数据   | 大数据流、动态分布数据               |

---

### 三、Prometheus 实现的特点

#### **优势**

1. **高效查询**：预聚合的桶数据直接支持快速分位数计算。
2. **可扩展性**：天然支持多维度（标签）数据的分组统计。
3. **兼容性**：与 PromQL 深度集成，无需额外算法库。

#### **局限性**

1. **静态桶配置**：
   - 桶的预定义直接影响精度，配置不当会导致显著误差（如长尾分布数据）。
   - 需根据业务场景调整桶的边界（例如对延迟敏感的服务需细化 0~1s 的桶）。
2. **插值误差**：
   - 假设桶内数据均匀分布，实际可能与真实分布偏差较大（反直觉结果常见[citation:5][citation:17]）。
3. **存储成本**：
   - 每个桶作为一个时间序列存储，高基数标签可能导致存储膨胀。

---

### 四、最佳实践

1. **合理配置桶的边界**

   - 根据数据分布动态调整，例如对 Web 服务延迟监控，可细化 0.1s、0.5s 等关键阈值。
   - 示例配置（OpenTelemetry 推荐）：
     ```go
     view.Register(
         view.NewView("http_request_duration",
             instrument.Histogram{
                 Boundaries: []float64{0.1, 0.5, 1, 2, 5, 10},
             },
         ),
     )
     ```

2. **结合 `rate()` 使用**

   - 直方图桶计数为累加值，需通过 `rate()` 转换为速率后再计算分位数：
     ```promql
     histogram_quantile(0.95, sum(rate(http_request_duration_bucket[5m])) by (le))
     ```

3. **处理长尾分布**

   - 添加一个极大值的桶（如 `le="+Inf"`）捕获所有超出预设范围的数据。

4. **验证精度**
   - 对比 Summary 类型（直接存储分位数，但无法聚合）与直方图的结果差异。

---

### 五、与 Summary 类型的对比

Prometheus 提供了另一种分位数指标类型 **Summary**，但其分位数在客户端计算且无法聚合，主要差异如下：
| **特性** | **Histogram** | **Summary** |
|------------------|-----------------------------------|----------------------------------|
| **分位数计算位置** | 服务端（通过 PromQL） | 客户端（应用内） |
| **可聚合性** | 支持多实例数据聚合 | 不支持 |
| **配置灵活性** | 需预定义桶 | 分位数值在客户端预定义（如 P99） |
| **适用场景** | 需要跨实例、跨维度聚合的场景 | 单实例精准分位数需求 |

---

### 六、总结

Prometheus 通过 **直方图指标 + 线性插值** 实现了分位数的近似计算，虽非传统 Quantile Sketches 算法，但在监控场景中平衡了存储成本与查询效率。其核心优势在于可扩展性和兼容性，但在高精度需求或动态数据分布场景中需谨慎配置桶的边界。对于需要高精度分位数且无需聚合的场景，可结合使用 Summary 类型。
