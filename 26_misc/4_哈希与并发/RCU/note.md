## 一、RCU 是什么？

### 1. 定义与基本概念

- **RCU（Read-Copy Update）** 是 Linux 内核中广泛使用的一种高效同步机制，核心思想是：

  1. **Read**：读者可以在极少的开销下并发地读取共享数据；
  2. **Copy**：当需要修改数据结构时，先复制一份（或构造新的版本）并进行更改；
  3. **Update**：更新指针使读者能够看到新版本；旧版本会在没有任何读者持有后再安全地释放。

- 与传统的互斥锁（mutex）或读写锁（rwlock）相比，RCU 在“读多写少”的场景下能显著降低读操作的开销，几乎可以做到读操作无锁（lock-free）或极低锁竞争。

### 2. 适用场景：读多写少

- RCU 主要应用于**读操作非常频繁、写操作相对较少**的共享数据结构中。例如 Linux 内核的各种列表、哈希表等元数据结构（进程调度、网络子系统等）。
- 在这种场景下，如果对所有读操作都加读锁，会带来巨大的同步成本；而 RCU 允许并发读者“无锁地读取”老版本数据，只有在更新时才进行必要的同步和内存回收。

### 3. RCU 与其它同步机制的比较

- **互斥锁（mutex）**：写者和读者都需要获得锁，读者之间也会彼此排斥；当读比例巨大时，锁争用非常严重。
- **读写锁（rwlock）**：写者需要独占，读者可以共享锁，但写者和读者依然互斥；在读者很多、写者偶尔出现时，写者会阻塞所有读者。
- **RCU**：读者无须加锁，只需进入一个“RCU 读保护区域”即可并行阅读数据的**旧版本**；写者通过复制+替换指针+回收旧版本的方式来更新数据。相比读写锁，RCU 大幅减少了读者间与读写者间的竞争。

---

## 二、为什么需要 RCU？

### 1. 背景需求：大规模并发读

在现代操作系统或高并发环境（尤其 Linux 内核）中，许多共享数据结构的典型访问模式是**“大量读、少量写”**：

- 例如进程调度器要频繁读取就绪队列，但真正插入/删除一个进程并不算很频繁；
- 网络协议栈中，大量的数据包处理只是读访问协议控制块，而更新 TCP 连接状态则较少；
- 文件系统中的 VFS（虚拟文件系统）结构、内存管理中的页表等，也有非常多的查询操作。

如果对所有这些读操作都用传统锁保护，就会在读频繁时造成大量锁争用；而 RCU 通过让读者读旧版本数据并在适当时机才回收旧版本，极大减少了读取方的同步开销。

### 2. RCU 的优势

1. **读操作快**
   - 读者不必加锁，只需标记自己处于 RCU 读保护区（典型地通过 `rcu_read_lock()` / `rcu_read_unlock()` 宏），这是一个非常轻量级的操作。
2. **可无锁并发读**
   - 读者之间互不阻塞，也不会被写者阻塞（仅写操作需要做更新和等待）。
3. **安全内存回收**
   - 当写者完成更新（替换指针指向新版本）后，旧版本的内存并不会立即释放，而是等待所有可能正在读旧版本的读者都退出其读保护区（所谓“RCU 宽限期”结束）后，再安全释放。
4. **规模与性能可扩展**
   - 尤其在多核场景下，大量并发读者不必排队获取锁，显著提高吞吐量。

### 3. RCU 存在的限制

- **写复杂度**：写操作需要“复制并更新”数据结构，并需要额外的内存管理逻辑（跟踪、延迟回收旧版本）。
- **数据一致性模型**：读者可能看到旧数据版本（很短暂），所以 RCU 更适合“不影响一致性的”或对时延不敏感的更新场景。若需要强一致性，需要额外的同步机制或RCU不可满足的场景。
- **只适用于读多写少**：若写操作频繁，RCU 的优点会被耗尽，更简单的锁可能反而更好。

---

## 三、怎么办（如何使用 RCU）？

在实际使用 RCU 时，一般要关注三方面：**读保护区、更新机制、回收旧版本**。下面按 Linux 内核中的常见操作流程为例做介绍。

### 1. 读保护区

- 当读者进入 RCU 读保护区时，应调用 `rcu_read_lock()`；读完后调用 `rcu_read_unlock()`。
- 处于保护区内时，读者**不允许阻塞**（内核中一般要求不做内核调度、不可睡眠），否则会破坏 RCU 的语义。
- 在保护区内，读者可以安全地读取共享数据的指针或内容，不用担心指针突然失效，因为更新者会在释放旧版本前等待所有读保护区结束。

### 2. 更新流程

当有一个写操作（更新）需要进行，典型流程是：

1. **复制或新建数据结构**
   - 写者获取传统锁或原子操作保护其“复制构造”的过程；
   - 或者使用某些“分离式更新”技巧，不需要拷贝整份数据，仅更新关键字段等。
2. **替换指针**
   - 用 `rcu_assign_pointer()` 将全局可见指针从旧版本切换到新版本；
   - 之后新进入 RCU 读保护区的读者将看到新版本的数据。
3. **回收旧版本**
   - 写者将旧版本指针交给 RCU 的回调机制，如 `call_rcu()` 或 `synchronize_rcu()`，
   - RCU 会等待所有在此替换之前已经进入读保护区的读者都结束（宽限期已过），然后才执行回调函数，释放旧版本内存。
   - 这样确保任何仍在读旧版本数据的读者不被破坏。

### 3. 回收旧版本

- **call_rcu()**：异步调用，提供一个回调函数，让 RCU 在所有读保护区安全结束后自动执行回调（释放内存等）。
- **synchronize_rcu()**：同步等待，直到当前所有读者都离开 RCU 读保护区后才返回，使用起来更简单但会阻塞写者。

### 4. 注意事项

1. **内存模型和屏障**
   - Linux 内核的 RCU 宏如 `rcu_dereference()`, `rcu_assign_pointer()` 除了可读性，也会在特定架构插入内存屏障保证可见性。
2. **适用范围**
   - 只适合短时读取或可容忍读到旧版本数据的场景，不适用于需要马上读取最新数据且严格同步的场景。
3. **搭配其它锁**
   - 实际写操作可能依旧需要传统锁或原子操作保护数据结构的一致性；RCU 并不直接提供写时并发的冲突保护，而是侧重读写之间的并发。

---

## 四、常见应用与案例

1. **Linux 内核中的链表 / 哈希表**
   - 典型场景：`list_for_each_entry_rcu()` 遍历 RCU 保护的链表时，无需加锁。写者使用 `rcu_assign_pointer()` 插入节点，移除节点时则使用 `list_del_rcu()` 并在适当时机回收。
2. **网络子系统**
   - 协议控制块、路由表等往往需要频繁查询（大并发读），而更新相对少；RCU 大幅减少了读阻塞，提高网络转发性能。
3. **虚拟文件系统（VFS）**
   - 遍历 dentry、inode 等元数据，RCU 带来更快的查找和更少的锁争用。
4. **进程调度器、CPU 调度域**
   - 调度器需要频繁查询当前 CPU 负载、就绪队列等信息；RCU 减少了读者之间的冲突并简化了调度器的设计。

---

## 五、总结

1. **是什么**

   - **RCU**（Read-Copy Update）是一种**无锁或极低锁竞争**的读者-写者同步机制，通过为读者提供“读保护区”与“更新者复制+延迟回收旧版本”，让大量并发读几乎不互斥，极大提升读操作效率。

2. **为什么**

   - 在读多写少的场景，传统锁会带来严重的读者争用；RCU 允许读者并行访问旧版本数据而无需锁竞争，使系统能在多核环境下拥有良好可扩展性并显著提高吞吐量。

3. **怎么办**
   - **读保护区**：`rcu_read_lock()` / `rcu_read_unlock()`；读取数据时使用 `rcu_dereference()`。
   - **更新**：写者复制新版本，用 `rcu_assign_pointer()` 替换，全局可见后，通过 `call_rcu()` / `synchronize_rcu()` 延迟回收旧版本。
   - **应用**：遍历链表、哈希表、网络路由表、VFS 元数据等，适合“读占绝大多数”的数据结构。
