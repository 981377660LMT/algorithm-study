# 序列比对

https://zhuanlan.zhihu.com/p/61750658
https://www.zhihu.com/column/c_1027940319119167488

下面这份内容尝试将列出的 27 个主题串联起来，分为两大板块：**序列比对（部分 1～8，加上 18）** 与 **隐马尔可夫模型（HMM）及其应用（部分 9～17）**，以及若干与“字符串处理”相关的问题（部分 19～27）。每个主题都做了简要的原理、核心思想及应用说明，力求在有限篇幅里呈现“原理—示例—应用”的思路。若需要更深度的数学推导或代码，可参考各经典教科书和论文。

---

# 第一部分：序列比对及相关问题

## 1. 全局比对 Needleman-Wunsch 算法

- **应用场景**  
  当我们有两条生物序列（DNA/RNA/蛋白质），希望在全长度上进行比对（global alignment），找到它们的“最佳匹配方式”，常用于相似物种或同源蛋白之间的序列比对。

- **算法原理**

  1. 定义一个评分体系：通常包含“匹配得分（match）”、“错配罚分（mismatch）”、“空格罚分（gap penalty）”。
  2. 建立一个二维动态规划（DP）矩阵 \(D\)，大小为 \((m+1)\times(n+1)\)，其中 \(m, n\) 分别是两条序列的长度。
  3. 递推关系（以 DNA 为例）：
     \[
     D(i,j) = \max\Big(
     D(i-1, j-1) + \text{score}(x_i, y_j), \quad
     D(i-1, j) + \text{gap penalty}, \quad
     D(i, j-1) + \text{gap penalty}
     \Big).
     \]
  4. 边界初始化：第一行、第一列通常按累加 gap 罚分方式初始化。
  5. 最后在 \(D(m,n)\) 位置得到最高分，通过回溯(backtrack)可得具体的全局比对方式。

- **特点**
  - 适合序列长度适中、需要保证从头到尾都对齐。
  - 复杂度：时间和空间均为 \(O(mn)\)。

---

## 2. Needleman-Wunsch 算法之仿射罚分

- **为什么需要仿射（affine）模型？**  
  在生物学中，更常见的是“插入/缺失（InDel）”通常呈连续块出现，而不是单个碱基频繁插空。为了更真实地反映生物进化，常使用**开启一个 gap 时一个固定罚分（gap open penalty）**，而后续在同一个 gap 中的延伸（gap extension）用一个较小的罚分。

- **模型定义**  
  将 gap 的罚分从原先的线性模式（比如“每空一个碱基就罚 -1 分”）改为仿射模式：
  \[
  \text{gap penalty} = \text{gap_open} + k \times \text{gap_extension}
  \]
  其中 \(k\) 是 gap 的长度减一（若 gap 已经打开，继续延伸每个碱基只罚延伸分）。

- **DP 的修改**  
  在 affine gap 下，通常需要三个矩阵来记录状态：

  1. \(M(i,j)\) ：对齐第 i、j 个碱基后，以“匹配/错配”结束的最高得分
  2. \(I_x(i,j)\)：序列 X 方向处于 gap 延伸的最高得分
  3. \(I_y(i,j)\)：序列 Y 方向处于 gap 延伸的最高得分  
     相互之间有相应的转移方程，以保证 gap 的开销与延伸开销分开计算。

- **结果**  
  回溯时同样从 \(M(m,n)\)、\(I_x(m,n)\) 或 \(I_y(m,n)\) 的最高值开始，可得到最终全局比对结果。

---

## 3. 局部比对 Smith-Waterman 算法

- **应用场景**  
  并非所有序列都需要在全长度上对齐，比如在两个长序列里查找相似的局部片段（motifs），Smith-Waterman 用于“局部比对（local alignment）”。

- **算法原理**  
  Smith-Waterman 与 Needleman-Wunsch 类似，也用 DP 矩阵，但递推关系多了一个“与 0 比较取最大”的步骤：
  \[
  D(i,j) = \max\Big(
  D(i-1,j-1) + \text{score}(x_i, y_j), \quad
  D(i-1,j) + \text{gap penalty}, \quad
  D(i,j-1) + \text{gap penalty}, \quad
  0
  \Big).
  \]
  这样，一旦遇到明显不匹配的片段，就会产生 0 并“终止”局部对齐。

- **回溯**  
  DP 矩阵中的最大值对应局部对齐得分最高的终点，回溯到遇到 0 为止，得到局部匹配片段。

- **特点**
  - 只在相似片段内部进行对齐，不要求对齐到两端。
  - 常用于查找保守区域、功能位点等。
  - 同样可以扩展到仿射罚分模型。

---

## 4. Smith-Waterman 算法之仿射罚分

- **类似于 NW 仿射罚分的思路**  
  局部比对中同样引入 gap open 与 gap extension 的区分，用三个矩阵记录对齐状态与 gap 延伸状态，但在每次取最大时也要与 0 比较。

- **公式略示**

  1. \(M(i,j) = \max\big( M(i-1,j-1)+\text{match/mismatch},\, I_x(i-1,j-1)+\dots,\,I_y(i-1,j-1)+\dots,\,0\big)\)
  2. \(I_x(i,j)\) / \(I_y(i,j)\) 分别做 gap open、gap extension 的递推。
  3. 取三者最大时，与 0 比较保留非负值。

- **意义**  
  更真实地描述生物学上的插入缺失，并且只在局部匹配区域内积极得分，不匹配区域及时清零。

---

## 5. 重复匹配问题的动态规划算法

- **概念**  
  “重复匹配（重复比对）”常指在一条序列中寻找它与另一条序列的多个匹配位置，或一条序列内部含有重复结构的匹配问题。  
  比如：在基因组中寻找某一条短序列的多次出现位置，或者在蛋白序列中找重复的基序。

- **思路**  
  可以基于全局或局部比对的 DP 思想加以扩展，允许多个起点、多个终点。

  - 在全局比对里，如果允许“多次启动匹配”，可对 DP 矩阵做一些修改，让其在一行或多行中重复使用 Smith-Waterman 或 NW 的局部递推。
  - 或者在一条序列上滑窗，每个位置都做一次局部比对（虽然效率不高，但思路直观）。

- **实用性**  
  重复匹配问题在序列分析（基因家族、串联重复序列识别等）中十分常见，经常需要在算法上做剪枝或借助索引结构（如 Suffix Array、Suffix Tree）来提高效率。

---

## 6. 交叉匹配问题

- **交叉匹配（Cross Match）**  
  一种特殊的序列比对情形：给定两个序列集合，寻找它们之间所有可能的匹配、包括交叉区域和重复区域。有时也指一条序列自身的交叉比对，用于找重复片段。

  - 例如：系统性地找人和小鼠基因组中相似的片段，会出现大量交叉匹配问题。

- **思路**

  1. 构建索引或使用 k-mer 预筛选，快速找到候选相似区。
  2. 再用局部比对算法（如 SW）来精确计算相似度。
  3. 需要注意重复区的多重匹配以及拼接区间的管理。

- **工具**  
  实际中，Cross_Match 是由 Phil Green 开发的一款序列比对程序，用于识别重复元素等，底层也利用了动态规划思想。

---

## 7. 序列比对之线性空间算法

- **背景**  
  经典的 NW/SW 动态规划需要 \(O(mn)\) 的空间来存储整个 DP 矩阵。当 \(m, n\) 都很大时（上百万碱基），内存消耗过高。

- **Hirschberg Algorithm**  
  为了降低空间复杂度，可使用分治式的线性空间算法（Hirschberg 算法）：

  1. 不再存储整个 DP 矩阵，而是只存储当前行（或列）和上一行（或列）的信息，计算出中间行的分割点。
  2. 通过递归的方式，一分为二地将问题分块处理，每次只需要 \(O(\min(m,n))\) 的空间。
  3. 总时间仍是 \(O(mn)\)，但空间降至 \(O(m + n)\)（或更精准的 \(O(\min(m,n))\)）。

- **应用**  
  在基因组级别的大规模比对中非常实用，是许多序列比对软件在内部实现时使用的关键优化。

---

## 8. 第一部分的小结

本部分主要讨论了**序列比对的基础原理与算法**，包括：

- **全局比对**（Needleman-Wunsch）与**局部比对**（Smith-Waterman）
- **仿射罚分**模型的引入让 gap 处理更符合生物学实际
- 以及对于复杂情况（重复匹配、交叉匹配、线性空间）的拓展思路

这些算法为生物信息学中最基本的“序列相似性分析”奠定了基础，广泛应用于基因组比对、蛋白质结构预测、系统发育分析等领域。

---

# 第二部分：隐马尔可夫模型（HMM）

## 9. 从掷骰子说起 HMM

- **掷骰子类比**  
  隐马尔可夫模型（HMM）的典型引入方式：假设我们看不到真正的骰子（或转移状态），只看到了投掷结果（符号序列），需要推断骰子的状态序列或整体概率。

  1. 状态转移：比如可能有公正骰子和偏骰子（隐状态）。
  2. 观测符号：每次投掷的点数（1～6）。
  3. 状态间转移概率、发射概率均已知（或待估计）。

- **核心思想**  
  HMM = (隐状态集合，观测集合，转移概率，发射概率，初始分布)。在生物学上应用广泛，如基因组预测基因结构、蛋白二级结构预测、序列打分等。

---

## 10. Viterbi 算法求解最大似然路径

- **问题描述**  
  给定一个 HMM 和一条观测符号序列，想知道“最可能的隐状态序列”是什么？这就是 Viterbi 算法要解决的最大似然路径问题（也称最优解码问题）。

- **Viterbi 动态规划公式**

  1. 定义 \(V_t(i)\) 表示：在时刻 \(t\) 观测到符号 \(o_t\) 时，且状态为 \(i\) 的所有可能状态序列的最高概率。
  2. 递推：  
     \[
     V*t(i) = \max*{j} \Big( V*{t-1}(j) \times a*{j \to i} \Big) \times b*i(o_t),
     \]
     其中 \(a*{j \to i}\) 是状态转移概率，\(b_i(o_t)\) 是发射概率。
  3. 最后通过回溯得到最优路径。

- **复杂度**  
  时间复杂度约为 \(O(T \times N^2)\)，其中 \(T\) 为观测序列长度，\(N\) 为状态数。

---

## 11. 计算符号序列的全概率

- **前向算法（Forward Algorithm）**  
  为了计算给定观测序列 \(O\) 的总似然概率 \(P(O)\)，可用“前向算法（forward algorithm）”来高效地累加所有可能的状态路径概率。

  1. 定义前向变量 \(\alpha*t(i)\) 表示在时刻 \(t\) 状态为 \(i\) 并且已观测到 \(O*{1..t}\) 的概率。
  2. 递推：  
     \[
     \alpha*t(i) = \Big(\sum*{j} \alpha*{t-1}(j) \times a*{j \to i}\Big) \times b_i(o_t).
     \]
  3. 最终 \(P(O) = \sum_i \alpha_T(i)\)。

- **后向算法（Backward Algorithm）**  
  类似地，还可定义 \(\beta_t(i)\) 用于自时刻 \(t\) 开始到序列末尾的观测概率，用于后面计算后验概率。

---

## 12. 计算后验概率

- **后验概率**  
  对于时刻 \(t\)，状态为 \(i\) 的后验概率 \(\gamma_t(i)\)，可以用前向与后向变量结合来计算：  
  \[
  \gamma_t(i) = \frac{\alpha_t(i) \times \beta_t(i)}{P(O)}.
  \]

- **意义**  
  这告诉我们在观测序列给定的情况下，时刻 \(t\) 处于状态 \(i\) 的概率是多少，对于软解码（soft decoding）以及参数估计都很重要。

---

## 13. 后验解码

- **定义**  
  后验解码（Posterior Decoding）即在每个时刻 \(t\) 直接取后验概率最高的状态 \(\arg\max_i \gamma_t(i)\)。这是基于“每个时刻独立最大后验”的决策方案。

- **与 Viterbi 区别**
  - Viterbi 给出的是整条序列整体最可能的状态路径。
  - 后验解码在每个位置独立选择最优，不一定保证整条路径的全局最优。

---

## 14. Viterbi 算法和后验解码的比较

- **Viterbi**

  - 优点：找到最可能的“整体路径”。
  - 缺点：个别时刻的状态可能并不是该时刻的最高后验状态（因为可能要服从整体路径一致性）。

- **后验解码**

  - 优点：保证每个时刻选取后验概率最高的状态。
  - 缺点：不一定得到可行的“全局路径”（可能违反状态转移约束，或整体概率并不最大）。

- **应用场景**
  - 基因预测中常用 Viterbi，保证获得一致的外显子/内含子结构。
  - 若对每个位点独立地看最有可能的状态（如碱基变异位置），则后验解码也可行。

---

## 15. EM 算法以及 Baum-Welch 算法的推导

- **EM（期望最大化）算法概念**  
  当模型参数部分未知而我们只能观测到“显变量”时，需要对隐变量进行猜测，再基于猜测更新模型参数，反复迭代直到收敛。

- **Baum-Welch 算法**

  - HMM 中估计状态转移矩阵和发射概率矩阵最常用的方法，本质上就是 EM 的特例。
  - “E 步”计算期望（前向后向算法，求解状态/状态转移出现次数的期望），“M 步”更新转移概率与发射概率。

- **推导思路**
  1. 写出对数似然函数 \(\ln P(O|\theta)\)。
  2. 用隐变量表示状态序列，将对数似然的求导转化为 EM 过程。
  3. 在 E 步中，用前向后向变量得到 \(\xi*{t}(i,j)\)（从状态 \(i\) 到 \(j\) 的期望出现次数），\(\gamma*{t}(i)\)（状态 \(i\) 在时刻 \(t\) 的出现次数期望）。
  4. 在 M 步中，更新 \(a\_{ij}\), \(b_j(k)\) 等参数。

---

## 16. Baum-Welch 算法估算 HMM 参数

- **更新公式**（简略表示）  
  \[
  a*{ij} \leftarrow \frac{\sum*{t=1}^{T-1} \xi*t(i,j)}{\sum*{t=1}^{T-1} \gamma*t(i)},
  \quad
  b_j(v_k) \leftarrow \frac{\sum*{t=1}^{T} \gamma*t(j)\,\mathbb{I}(o_t=v_k)}{\sum*{t=1}^{T} \gamma_t(j)}.
  \]
  其中 \(\xi_t(i,j)\) = 后验概率(状态 \(i\) 在 \(t\) 转移到 \(j\) 在 \(t+1\))。

- **迭代**  
  不断重复 E 步和 M 步，直到对数似然函数收敛或达到迭代次数限制。

- **优点**
  - 能够在没有“标注的状态序列”的前提下自适应估计 HMM 的参数。
- **缺点**
  - 可能收敛到局部最优，对初值敏感。

---

## 17. 第二部分的小结

HMM 在生物信息学和自然语言处理等领域有着广泛应用，核心在于：

1. **解码**：给定模型与观测序列，如何求最可能的隐藏状态序列（Viterbi、后验解码）；
2. **模型训练**：给定观测序列，但模型参数未知，使用 Baum-Welch（EM）算法估计参数。

这些方法在基因注释、蛋白质结构域识别、拼写纠错、词性标注等都有重要地位。

---

# 第三部分：更多字符串与比对问题

（此部分主题较为零散，涵盖重复匹配、基序发现、最长公共子串/子序列、KMP/Trie/AC 自动机、BWT 等经典字符串算法和应用。）

## 18. 重复匹配问题的补充说明

- **与第 5 条的联系**  
  前面提到的“重复匹配问题”可从 DP 角度讨论，也能用后缀数组、后缀树等高级数据结构处理。
- **实用案例**  
  基因组中识别串联重复、散在重复、低复杂度序列等；重复序列往往对进化、结构等有重要意义。

---

## 19. 基序发现和中间字符串问题

- **基序（motif）发现**

  - 在一组序列中找到一个短的保守序列片段，通常在调控区域、蛋白质功能区域等出现。
  - 例如：多个转录因子结合位点往往有共同的短序列模式。

- **中间字符串问题**
  - 给定多条序列，找一个最短（或一定长度）的“字符串”使得它是所有序列的子串。
  - 例如：找一个“共同子串”作为候选 motif，用于实验验证。

---

## 20. 基序发现问题的算法及实现代码

- **典型算法**

  - **位点模型**（Position Weight Matrix，PWM）方法：对可能的 motif 进行打分；
  - **Pattern Branching & Pruning**：枚举所有可能长短的模式并在序列中检查（往往使用回溯加剪枝）。
  - **Expectation-Maximization** 或 Gibbs Sampling：基于统计模型的方法来估计 motif。

- **实现思路简述**
  1. **穷举/Branch & Bound**：在搜索空间中遍历候选模式（可能结合 k-mer 的方法），对每条序列打分筛选；
  2. **EM/Gibbs**：从随机初始化开始，不断更新 motif 的 PWM；
  3. **代码示例**通常较长，这里不展开，核心是：
     - 读取序列 => 搜索或迭代 => 评估得分 => 更新模式 => 迭代直到收敛。

---

## 21. 中间字符串问题的算法及实现代码

- **问题描述**  
  给定一组 DNA 序列，每条序列长度为 \(l\)。寻找一条长度为 \(k\) 的短串，使得它与每条序列的某一子串的 Hamming 距离不超过 \(d\)。该问题有多种变体，又称“近似子串问题”、“median string problem”或“closest string problem”。

- **典型算法**

  1. **Branch and Bound**：枚举所有可能的 k-mer（\(4^k\) 对 DNA），对每条序列找与该 k-mer 最相近的子串得分，汇总最优；
  2. **启发式/贪心** 或 **进化算法** 等也可用。

- **思路**
  - 若 \(k\) 不大，\(4^k\) 是有限的，可以完成穷举；
  - 对每条序列，在滑窗中计算与枚举的 k-mer 的差异度（Hamming distance），累加后选最小。
- **实现**
  - 伪代码框架：
    ```
    best_motif = None
    best_score = +∞
    for each possible pattern p in all 4^k k-mers:
       score = 0
       for each seq in sequences:
          dist = min( HammingDistance(subseq_of_seq, p) )  // 遍历seq中所有长度k的子串
          score += dist
       if score < best_score:
          best_score = score
          best_motif = p
    return best_motif
    ```

---

## 22. 中间字符串分支定界方法中更紧的界

- **分支定界（Branch & Bound）**

  - 在第 21 条中的穷举，如果枚举空间过大，可在中途剪枝：若部分前缀已经导致与序列距离过大，无需继续扩展。
  - 更紧的界指的是在前缀阶段就能估算“最小可能距离”或“最小可能得分”，一旦发现它已经超过当前最佳解，就停止扩展该分支。

- **意义**
  - 显著减少搜索空间，使原本指数级的枚举在实践中可行。
  - 常用在 motif 搜索、近似子串、Median String 等问题里。

---

## 23. 最长公共子字符串（Longest Common Substring, LCSstr）

- **定义**  
  在两（或多）条字符串中，找到**长度最长的一个**连续子串（substring），与“子序列（subsequence）”有别，要求在原串中是连续的。

- **常见算法**

  - **DP**：二维表法，记录当 \(x_i = y_j\) 时可在某个表格里计数+1，否则清 0，保持最大值。
  - **后缀数组 / 后缀树**：构建后缀结构后，再找公共节点或公共前缀长度。适合处理大规模字符串。

- **应用**  
  查找重复片段、比较两个基因组或文本文件中最长的共同连续片断等。

---

## 24. 最长公共子序列（Longest Common Subsequence, LCSseq）

- **定义**  
  与“子字符串”不同，“子序列”可以不连续，但必须保持相对顺序。LCSseq 的经典应用就是比较序列相似度。

- **DP 解法**  
  \[
  LCS(i,j) = \begin{cases}
  0, & i=0 \text{ or } j=0;\\
  LCS(i-1,j-1) + 1, & x_i = y_j;\\
  \max(LCS(i-1,j),\, LCS(i,j-1)), & \text{otherwise.}
  \end{cases}
  \]

  - 时间复杂度 \(O(mn)\)，空间同上，可用线性空间优化（Hirschberg）。

- **应用**
  - 生物序列：DNA/蛋白比对，衡量相似度的一种指标；
  - 版本控制：比较文件差异（如 diff 工具）。

---

## 25. 编辑距离（Edit Distance）

- **定义**  
  最常见是 Levenshtein 距离：将字符串 A 转换成字符串 B 所需的“插入、删除、替换”操作总数的最小值。

- **DP 公式**  
  \[
  d(i,j) = \min\Big(
  d(i-1,j) + 1,\; d(i,j-1) + 1,\; d(i-1,j-1) + \delta(x_i,y_j)
  \Big),
  \]
  其中 \(\delta(x_i,y_j) = 0\) 若相同，否则为 1。

- **与比对算法的关系**
  - 编辑距离与序列比对非常类似，只是打分体系是：匹配 = 0，错配 = 1，gap = 1。
  - 应用于拼写纠错、DNA 序列差异度计算、自然语言处理等。

---

## 26. 精准匹配之 KMP 算法、Trie 树以及 AC 自动机

- **KMP（Knuth–Morris–Pratt）**

  - 用于在主串中查找一个模式串的所有出现位置，时间复杂度 \(O(m+n)\)。
  - 核心在于计算部分匹配表（failure function / lps 数组），当不匹配时能快速跳过一部分字符。

- **Trie 树**

  - 多模式串匹配的经典结构，将多个模式串构建成 Trie 树，可在查询时进行前缀匹配。
  - 在生物信息学中常用于存储 k-mer 集合或词典。

- **AC（Aho–Corasick）自动机**
  - 多模式串匹配的效率利器，在 Trie 基础上加“失配指针(failure links)”，可在文本中同时搜索多种模式，复杂度近似线性。
  - 常用于基因组中批量寻找 motif 集。

---

## 27. BWT（Burrows–Wheeler Transform）算法

- **原理与应用**

  1. **BWT** 将一段文本转换成一个更易压缩的形式；在生物信息学中广泛应用于构建 FM-Index，用于快速序列比对（如 BWA、Bowtie 的核心索引结构）。
  2. **核心步骤**：
     - 对字符串添加终止符 \$；
     - 构建其所有旋转的后缀表并排序；
     - 取排序后矩阵的最后一列组成 BWT 串。
  3. **逆变换** 依赖 LF-mapping（基于字符出现频次和前缀和来定位原始字符位置）。

- **优点**
  - 转换后适合做游程压缩（run-length encoding），在文本搜索时也能用 FM-Index 实现快速的子串匹配。
- **在序列比对中的意义**
  - 大型基因组的指数级增长需要快速搜索，BWT + FM-Index 可以在 \(O(k)\)（k 为模式串长度）的时间完成子串匹配，而且所需内存远小于传统索引结构。

---

## 总结

1. **第一部分**：从 **Needleman-Wunsch**（全局比对）到 **Smith-Waterman**（局部比对），再到各类**特殊比对问题（重复、交叉、线性空间）**，构成了生物序列比对的理论基石。
2. **第二部分**：**HMM** 的框架及 **Viterbi/前向后向/Baum-Welch** 算法，为在序列上建模隐藏状态（如蛋白结构域、基因注释）提供了强大工具。
3. **第三部分**：包含 **Motif 发现**、**Longest Common Substring/Subsequence**、**编辑距离**、**KMP/Trie/AC 自动机** 等常见字符串算法，以及在高通量测序时代不可或缺的 **BWT**。

这些方法或算法广泛用于生物信息学的各种场景：测序读段比对、基因组注释、motif 寻找、差异分析、模式识别等。同时，也与经典的字符串算法和概率模型在理论与实现上紧密交织，是计算生物学与计算机科学交叉的核心内容。
