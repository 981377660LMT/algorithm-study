## 1. BWT 是什么？

- **定义**：Burrows–Wheeler Transform（简称 BWT）是一种可逆的字符串变换。给定一个字符串 \( S \)，BWT 会输出一个与 \( S \) 长度相同、但字符顺序不同的新字符串 \( L \)。可逆性意味着可以通过 \( L \) 反向恢复出原字符串 \( S \)。
- **背景**：BWT 由 Michael Burrows 和 David Wheeler 于 1994 年提出，被广泛应用于数据压缩和文本检索（例如 bzip2 压缩、FM-Index 等）。
- **核心思路**：通过构造字符串的所有循环位移（rotations），对这些位移按字典序进行排序后，记录每个位移“末尾字符”而得到的序列，即为 BWT 的输出。

---

## 2. 为什么要使用 BWT？

1. **方便后续压缩**  
   BWT 使得原来分散的相同字符在变换结果中更容易聚集在一起。例如，英文文本中，如果某些字母或字符常常成批出现，经过 BWT 变换后，变换得到的字符串可以更好地展示出这些可压缩的模式。
2. **可逆性**  
   无论在数据压缩，还是在其它使用场合（如索引构造），可逆是非常重要的特性：只有能从变换后的结果无损还原原字符串，才能真正应用在压缩或索引中。BWT 恰好满足这一需求。

3. **在搜索和索引中的应用**  
   像 FM-Index、Suffix Array 一类高效的字符串检索数据结构，都与 BWT 有着紧密联系。FM-Index 便是利用 BWT 可以高效地对 DNA 序列、文本等进行模式匹配搜索。

---

## 3. BWT 怎么做？（构造过程）

### 3.1 构造 BWT

假设我们有一个字符串 \( S \)，长度为 \( n \)。为了方便处理，一般会在字符串尾部添加一个终止符（比如 `\$`），此字符在字典序上小于所有其它字符。记添加后字符串为 \( S' = S + \$ \)，长度为 \( n + 1 \)。

1. **生成所有循环位移（Rotations）**  
   令 \( S' \) 的所有循环位移构成一个矩阵 \( M \)，其中第 \( i \) 行（下标从 0 开始）代表将 \( S' \) 从第 \( i \) 个字符开始的循环位移。

   - 例如 \( S' = \text{"banana\$"} \)，长度为 7。
   - 它的循环位移共有 7 行，每一行是将 \( S'[i] \) 作为起始，然后一直到串末，再连接串开头到 \( S'[i-1] \)。
   - 举例：第 2 行就是从第二个字符（假设下标从 0 开始）开始的循环位移：  
     \[
     \text{"nana\$ba"}
     \]

2. **对矩阵 \( M \) 的所有行按字典序（Lexicographical order）进行排序**

   - 如上述示例，当我们对所有循环位移进行排序，就会得到一个排序后的矩阵 \( M\_{sorted} \)。

3. **记录每行位移的最后一个字符，得到输出 \( L \)**
   - 例如排序后的矩阵中，每行最后一个字符依次记下来，就得到 BWT 的结果 \( L \)。
   - 仍以 `banana$` 为例，进行 BWT 后得到的结果（只举例，不详细列所有排序行）：  
     \[
     L = \text{"annb\$aa"}
     \]
   - 具体地，\( L[i] \) 就是 \( M\_{sorted}[i] \) 的最后一个字符。

这一过程可以概括为：  
\[
BWT(S') = \bigl(\,\text{the last column of the lexicographically sorted rotations of } S' \bigr).
\]

> **注意**：在实际压缩工具中，并不会真正构造出完整的 \((n \times n)\) 矩阵，而是使用后缀数组、后缀数组的变形或其它高效的数据结构来完成相同的操作，以节省内存和提高速度。

---

### 3.2 BWT 的逆过程（Inverse BWT）

BWT 的一个重要性质是可逆，但它可逆并不显而易见。下面简单展示 BWT 逆过程的思路。

给定变换后的字符串 \( L \)，以及事先记录的「原字符串在排序矩阵中的哪一行」，就可以**唯一**地恢复原字符串 \( S' \)。在实现压缩算法时，这个「哪一行」通常会在 BWT 结果的旁边一起记录。在不记录行信息的情况下，可以通过在 \( L \) 里找终止符 `\$` 所在的位置来推断具体行。

设：

- \( L \) 为 BWT 的结果，长度为 \( n + 1 \)（含终止符）。
- 记 \( F \) 为对 \( L \) 的字符进行「排序」所得到的序列（它恰好是矩阵 \( M\_{sorted} \) 的第一列）。
- 令 \( LF \) 表示一个能把 BWT 结果 \( L \) 的下标与字符排序后的结果 \( F \) 相对应的「映射关系」。
  - 核心观察：在循环位移矩阵按字典序排序后，“第一列”和“最后一列”其实包含了完全相同的字符集合，只是顺序不同。但是，如果我们将「第 \( i \) 个出现的字符」对上，能够建立「一次扫描」的对应，从而一步步重构原文。

恢复的过程（简要示例）：

1. 找到 `\$` 在 \( L \) 中的位置，它对应了排序矩阵中“原始字符串在最后列的行”（等价于第一列的那行）。
2. 利用 \( LF \) 映射，每次都可以找到当前字符在第一列中对应的下一个字符在最后列的位置。
3. 不断重复，直到恢复整个字符串。
4. 去掉终止符 `\$`，得到原字符串 \( S \)。

在实际编程时，这一步的操作往往会利用“前缀频次”来计算 \( LF \) 映射关系，具体会进行一些基于计数的构建，以达到线性或接近线性时间。

---

## 4. BWT 在压缩中的作用

由于 BWT 的输出会将相同字符集中到一起，后续如果接上 **游程编码（RLE, Run-Length Encoding）** 或者 **Move-To-Front（MTF）** 等变换，再结合 Huffman 编码，就可以极大地提高压缩率，并且保持编码过程和解码过程的一致性。例如：

- **bzip2** 工具：
  - bzip2 的核心流程与 BWT 紧密相关。先对输入数据做 BWT，然后再做 MTF 和 RLE 等多种优化，最后用 Huffman 进行熵编码，这便能显著压缩常见的文本数据。
- **文本检索中的索引**：
  - 例如 FM-Index，是一种基于 BWT 的索引结构，广泛应用于 DNA 序列处理。当需要查找某一模式串在基因组（或文本）中的出现位置时，借助 FM-Index 可以在近似线性时间内完成。

---

## 5. 小结

1. **BWT 是什么**：

   - 一种可逆的字符串变换，把所有循环位移排好序后取“末尾列”作为输出。

2. **BWT 为什么**：

   - 可以将同一字符相对集中，利于压缩；且可逆性使得它在压缩和索引中都能应用。

3. **BWT 怎么做**：
   1. 在末尾添加终止符 `\$`；
   2. 构造所有循环位移并排序；
   3. 取每行位移的最后一个字符，得到 BWT 结果 \( L \)；
   4. 借助记录（或根据终止符位置）和 \( LF \) 映射关系，反向恢复原字符串。

**Burrows–Wheeler Transform** 是一种简单又优雅、同时又十分实用的变换。理解其思路与逆过程，不仅能够帮助我们掌握诸如 bzip2 压缩的原理，也为在大数据或生物信息等场景中处理和索引海量字符串数据提供了高效的思路。
