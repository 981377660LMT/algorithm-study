https://github.com/shenwei356/bwt
https://github.com/crazyleg/burrow-wheelers-golang
https://hc1023.github.io/2020/03/17/Short-Read-Alignment/
https://blog.csdn.net/stormlovetao/article/details/7048481

---

# Burrows–Wheeler Transform (BWT) 详细讲解

下面是一篇系统性地介绍 **Burrows–Wheeler Transform (BWT)** 的文章，依然采用“是什么、为什么、怎么办”的结构，帮助你在概念、动机、具体实现与应用中对 BWT 有一个透彻的理解。

---

## 一、BWT 是什么？

### 1. 定义

- **Burrows–Wheeler Transform (BWT)** 是一种可逆的字符串变换算法，由 Michael Burrows 和 David Wheeler 于 1994 年提出。
- 虽然它本身并不直接压缩数据，但它能将`字符串重新排列为更利于压缩算法处理的形式`，从而在随后使用游程编码 (Run-Length Encoding) 或熵编码（如霍夫曼编码）时能取得较好的压缩效果。
- BWT 的核心思想是：将`字符串的所有循环位移（rotations）进行字典序排序，然后取出排序后最后一列的字符序列`，这列就是 **BWT 变换结果**。同时，还会记录原字符串在排序表中的行号或其他信息，以便后续可以无损地进行逆变换。

### 2. 典型应用

BWT 最常见的用途是用于**文本数据压缩**，如经典的 **bzip2** 压缩工具就基于 BWT 等后续编码算法（RLE、Move-to-Front 编码等），来实现比传统 LZ77、LZ78 更好的压缩率。  
此外，BWT 在 **FM-Index**（全文本检索索引结构）中也发挥着重要作用，可用于**快速子串搜索**（例如在生物信息学中进行 DNA 序列匹配）。

### 3. 小例子

设原字符串为 `S = "banana"`, 在 BWT 中，我们会构造所有循环位移并按字典序排序。具体如下（假设在字符串结尾加一个终止符 `'$'`，实际实现中通常会这样做，以确保“最小”或“最大”排序）：

假设 `S = "banana$"` （长度 7）  
所有循环位移（7 行），并按字典序排序：

| 循环位移       | 排序后索引 |
| -------------- | ---------- |
| `banana$` (原) |            |
| `anana$b`      |            |
| `nana$ba`      |            |
| `ana$ban`      |            |
| `na$bana`      |            |
| `a$banan`      |            |
| `$banana`      |            |

将它们按字典序排序，然后取最后一列，就得到 BWT 的结果。我们会在下面的“怎么办”部分更详细示范。

---

## 二、为什么需要 BWT？

### 1. 更好的可压缩性

BWT 之后，字符串的相似字符通常会聚集在一起，产生更多的**重复子串**或**游程**。这对于 RLE（游程编码）、移动到前编码 (Move-to-Front) 或霍夫曼编码都有利，可获得更高的压缩比。

- 在原字符串中，如果字符分散，传统压缩算法可能无法捕捉这些局部特征；
- BWT 重排后，“连续出现的字符”更有可能聚在一起，成为高频统计对象。

### 2. 易于逆变换

BWT 是**可逆**的（Invertible）：意味着通过保留少量辅助信息（比如原行在排序矩阵中的位置），可以从 BWT 的结果**无损**地还原出原字符串。

- 这一点非常关键：如果无法逆变换，纯粹的“洗牌”就没有太大意义。

### 3. 应用在 FM-Index 中实现高效模式匹配

- 在全文索引 (Full-text Indexing) 中，BWT 常被用来构造 **FM-Index**；
- FM-Index 以 BWT 为核心结构，加上额外的前缀频率表、后缀数组等信息，可在 O(m) 或 O(m \* \log n) 的时间内完成对长度 n 字符串中某模式 (长度 m) 的搜索，且占用的空间比传统索引方式（如倒排表）更小。

---

## 三、怎么办（如何进行 BWT 及其逆变换）？

### 1. BWT 的前向变换（Forward Transform）

以 `S = "banana"` 为例，通常在实践中会在结尾添加一个**终止符** `'$'`，它在 ASCII 中比所有字母都小，能确保在排序中放在最前面。故我们先令 `S = "banana$"`：

1. **构建所有循环位移（Rotation）**  
   对 `S = "banana$"`（长度 7），构造 7 条循环位移：

   ```
   0: banana$   (原字符串)
   1: anana$b
   2: nana$ba
   3: ana$ban
   4: na$bana
   5: a$banan
   6: $banana
   ```

2. **对这些循环位移按字典序（lexicographic order）排序**  
   排序结果如下（在此表中，左侧是排序后行号，右侧是对应的循环位移）：

   ```
   0: $banana   (行号0)
   1: a$banan   (行号5)
   2: ana$ban   (行号3)
   3: anana$b   (行号1)
   4: banana$   (行号0)
   5: na$bana   (行号4)
   6: nana$ba   (行号2)
   ```

3. **取“最后一列”字符序列**

   - 第 0 行 (排序后) 的最后一个字符： `a`
   - 第 1 行 的最后一个字符： `n`
   - 第 2 行 的最后一个字符： `n`
   - 第 3 行 的最后一个字符： `b`
   - 第 4 行 的最后一个字符： `$`
   - 第 5 行 的最后一个字符： `a`
   - 第 6 行 的最后一个字符： `a`

   因而得到 BWT 变换的结果： `ANNB$AA`  
   （其中大写只是为了突出字符顺序，实际可直接写成 `annb$aa`）

4. **记录原字符串在排序后矩阵中的行号**
   - 原字符串 `banana$` 在排序表中位于第 4 行（从 0 开始）。
   - 故会保存一个索引 `idx = 4`。
   - 有了 `BWT(S) = "annb$aa"` 和 `idx = 4`，我们就可以**逆向**还原到 `banana$`。

> **注意**：不同文档或不同实现可能有略微的顺序差异或者索引风格（从 0 开始或从 1 开始），但思路一致。

### 2. BWT 的逆变换（Inverse Transform）

给定 BWT 的结果 `L = "annb$aa"` 及原行号 `idx = 4`，如何还原 `banana$`？

这里给出逆变换的核心思路：

1. 将最后一列命名为 `L`；如果把排序后矩阵的第一列命名为 `F`（实际上是 `L` 的字符按字典序排序），因为所有旋转行都包含相同的字符集，所以 `F` 与 `L` 中的字符集相同，只是顺序不同。
2. 在矩阵的每一行 (索引 i)，`L[i]` 和 `F[i]` 其实分别代表了“这一行最后一个字符”与“这一行第一个字符”的对应关系。
3. 通过构造“LF 映射”（Last-to-First mapping）可以从 `L` 的某个位置跳到相应 `F` 中对应的行，从而一步步回溯完整的行。
4. 最终，从 `idx` 行开始，通过 `LF` 过程迭代长度 `n` 次，就能重构原字符串（包含 `'$'`）。

具体操作比较繁琐，这里不做每步表格演示，通常的教科书及 BWT 资料都会有详细示例。核心结论是：

- **BWT 逆变换只需要 BWT 序列和原字符串所在行号**，就能无损还原原文。

### 3. 实际压缩流程

在应用中，BWT 通常会与其他算法结合使用：

1. **BWT**：先对字符串做 BWT。
2. **RLE 或 Move-to-Front 编码**：对变换后的序列进行游程编码或 MTF 编码；
3. **熵编码（Huffman / Arithmetic / ANS）**：对以上结果做熵编码以减少冗余。

这一整套流水线会显著提升压缩效率，典型例子就是 **bzip2**。

### 4. 复杂度与性能

- **前向变换**：需要对所有循环位移排序，这可以用 **后缀数组** (Suffix Array) 的构建算法来完成。后缀数组构建的常见复杂度有 \(O(n \log n)\) 甚至 \(O(n)\) 算法，也可在实践中找到折中实现。
- **逆变换**：主要依赖 LF-Mapping（Last-First Mapping），可在 \(O(n)\) 时间内恢复字符串。
- BWT 最适合在较大的文本上使用，且在有较多重复字符或局部相关性的场景下能取得好的压缩效果。

---

## 四、常见应用与案例

1. **bzip2**

   - 经典的文件压缩工具，使用 BWT + MTF + RLE + Huffman 来实现优秀的压缩比和解压性能。
   - 整个算法流程类似上文描述：BWT 只是其中关键的预处理环节。

2. **FM-Index**

   - 全文检索或字符串检索领域（如生物信息学中的 DNA 序列比对）经常使用 FM-Index。
   - FM-Index 核心存储 BWT 的结果，并在其上构建快速定位某字符出现频次和位置的附加数据结构，从而在无需存储整条字符串的情况下完成子串检索。

3. **DNA 序列分析**
   - DNA 序列通常包含 4 种碱基字符 (A/C/G/T)，容易出现长段重复；
   - BWT + FM-Index 的方法非常适合快速处理和搜索大规模基因数据。

---

## 五、总结

1. **是什么**

   - **BWT** 是一种可逆的字符串变换，通过对字符串的所有循环位移进行排序，并取最后一列字符形成结果序列。
   - 它本质是对字符串的一种“重排”，常与终止符 `'$'` 一同使用，能完整保留原信息。

2. **为什么**

   - BWT 能将字符串的相似字符集中，形成更长的重复或游程，对后续的 RLE、霍夫曼或移动到前编码等算法十分有利，提升压缩比。
   - BWT 还能与 FM-Index 结合，实现高效的子串搜索。

3. **怎么办**
   - **构建**：可以借助后缀数组等算法在 \(O(n)\) 到 \(O(n \log n)\) 的时间内生成 BWT；
   - **逆变换**：通过“LF 映射”在 \(O(n)\) 的时间内重建原字符串。
   - **应用**：将 BWT 与 RLE / MTF / Huffman 编码结合形成完整的压缩管线（例如 bzip2）；或在 FM-Index 中用于快速子串搜索。

---

**Burrows–Wheeler Transform (BWT)** 是一种在数据压缩领域广受关注的可逆变换。它的主要特点是能够将输入序列（通常为字符串）的字符重新排列，使得相同或相似的字符在变换后更趋于聚集，从而有利于后续使用游程编码（Run-Length Encoding, RLE）或其它编码算法（例如 MTF、Huffman 等）来进一步压缩。  
下面我们从「是什么、为什么、怎么办」三个维度，详细分析和讲解 BWT。
