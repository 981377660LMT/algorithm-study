**在构建和存储树形数据结构时，Level Order Unary Degree Sequence（简称 LOUDS）是一种常见且高效的“精简（succinct）”表示方法**。它在无需存储父指针、子指针等显式链接的前提下，利用一个或多个位向量（bit vector）就能在常数或对数时间内完成树上常见操作（如定位父节点、定位子节点等）。LOUDS 常用于表示**有序树（ordinal tree）**，特别是在大规模字典、索引或压缩数据结构中应用广泛。

下面我们从概念、基本原理、编码过程、示例以及如何进行树上操作等角度，详细讲解 LOUDS 的核心思想和实现细节。

---

## 1. 概念与动机

### 1.1 什么是“精简（succinct）”表示

在数据结构中，“精简”或“Succinct Data Structure”强调利用**最少的存储空间**（往往接近信息论的下界）来表示数据，并且在此基础上提供快速的查询、遍历等操作。对于一棵节点数为 \(n\) 的树来说，传统存储方式需要存储指针或对象引用（比如子节点列表），在内存中往往占据相当大的空间。精简数据结构则致力于将空间开销压缩到与树形结构的理论下界相近的程度，同时还能支持常用操作的快速执行。

### 1.2 LOUDS 与有序树

**有序树（ordinal tree）**是指对每个节点的子节点有从左到右的顺序要求的树。例如 XML 文档树、DOM 树或字典树（Trie）都属于有序树。LOUDS 就是为有序树设计的一种表示方法，可以很好地支持以下操作：

1. 找到根节点
2. 找到任意节点的父节点
3. 找到任意节点的第一个子节点、最后一个子节点或第 \(k\) 个子节点
4. 在树的层次结构上进行导航、遍历

---

## 2. LOUDS 的基本思想

LOUDS 全称为 **Level-Order Unary Degree Sequence**，其核心可以拆解为：

1. **Level-Order**：按**层次遍历（BFS）**的顺序访问树的各个节点。
2. **Unary Degree Sequence**：用**一元（unary）编码**记录每个节点的子节点数量。对一个节点，若有 \(d\) 个子节点，则记录 \(d\) 个 `1`，再紧跟一个 `0` 表示子节点列表结束。

换言之，LOUDS 做了两件事：

- 首先将树的节点按照层序排成一个队列（从上到下、从左到右）。
- 随后，用一连串的 `1`（子节点个数）加一个 `0`（结束标记）来表示每个节点所拥有的子节点数量，并将所有节点的信息串在一起得到一个位向量（bit vector）。

在该位向量中：

- **`1`** 表示“还有一个子节点尚未描述”；
- **`0`** 表示“该节点子节点列表描述结束”。

---

## 3. LOUDS 的编码过程

下面用一个**示例**说明如何进行 LOUDS 编码。

### 3.1 示例树结构

假设我们有一棵有序树，节点数为 7，结构如下（括号内是节点编号，仅便于描述）：

```
          A(1)
        /   |   \
       B(2) C(3) D(4)
           / \
          E(5) F(6)
         /
        G(7)
```

- A 有 3 个子节点：B、C、D
- B 有 0 个子节点
- C 有 2 个子节点：E、F
- D 有 0 个子节点
- E 有 1 个子节点：G
- F 有 0 个子节点
- G 有 0 个子节点

### 3.2 第一步：层序遍历

对这棵树做 BFS（按层次遍历）得到节点顺序为：

```
A (1), B (2), C (3), D (4), E (5), F (6), G (7)
```

### 3.3 第二步：记录子节点数量的 unary 序列

按层序顺序，依次查看每个节点的子节点数，用 `1` 表示子节点，`0` 表示结束：

1. **A(1)** 有 3 个子节点 ——> `1 1 1 0`
2. **B(2)** 有 0 个子节点 ——> `0`
3. **C(3)** 有 2 个子节点 ——> `1 1 0`
4. **D(4)** 有 0 个子节点 ——> `0`
5. **E(5)** 有 1 个子节点 ——> `1 0`
6. **F(6)** 有 0 个子节点 ——> `0`
7. **G(7)** 有 0 个子节点 ——> `0`

把这些序列按节点顺序串联起来，就得到完整的 LOUDS 位序列：

```
A(1): 1 1 1 0
B(2): 0
C(3): 1 1 0
D(4): 0
E(5): 1 0
F(6): 0
G(7): 0

合并为： 1 1 1 0 0 1 1 0 0 1 0 0 0
```

我们往往会把它记作一个连续的 bit vector：

```
LOUDS = 1110 0 110 0 10 0 0
       = 1 1 1 0 0 1 1 0 0 1 0 0 0
```

为了可读性，这里用空格隔开不同节点的段落，实际存储通常是紧凑的二进制序列。

---

## 4. 基于 LOUDS 的树操作

通过上面这串位向量就能够以**常数或对数时间**完成许多树操作。关键在于我们需要对 LOUDS 的位向量执行 **rank** 和 **select** 操作（这是操作位向量的基本技能）：

- **rank_1(i)**：从位向量开头到位置 \(i\) 为止，有多少个 `1`
- **select_1(k)**：位向量中第 \(k\) 个 `1` 出现在什么位置
- 类似还有 rank_0(i) 和 select_0(k)

LOUDS 中的核心思想是：

- 第 \(i\) 个 `0`（表示节点结束）的位置，**对应了**层序遍历中的第 \(i\) 个节点。
- 第 \(i\) 个 `1`（表示一个子节点的出现）的**后面**的 `0`可以和具体哪个节点关联起来，从而让我们找到节点的父子关系。

### 4.1 找到节点的父节点

如果知道节点在层序遍历中的编号 \(i\)，可以通过查找其对应的 `0` 在位向量中的位置，然后再找到这个 `0` 前面若干个 `1` 对应的是哪个父节点。该过程利用 rank 和 select 操作完成。

### 4.2 找到节点的子节点

同理，如果知道节点 \(i\) 所对应的 `0` 在位向量中的位置，可以确定从那里往后有多少个连续的 `1` 直到 `0`，那一串 `1` 就表示了节点 \(i\) 的所有子节点。

### 4.3 在层序上导航

由于编码本身是基于 BFS 的顺序，因此根据节点在位向量中的次序，我们可以很快知道它在层上的位置，与相邻节点的层次关系等。

> 实际的实现中，为了高效执行 rank 和 select 操作，需要对位向量做额外的预处理（例如采用 **Fenwick Tree** 或 **Wavelet Tree**，或其他可以在 \(O(1)\) 时间内做 rank / select 的结构）。

---

## 5. 空间分析与优点

1. **空间复杂度**

   - 对于一棵 \(n\) 节点的有序树，LOUDS 的位序列长度大致是 \(2n\) 到 \(2n + O(\log n)\) 比特（具体会因实现而微调）。这是非常紧凑的，因为一棵 \(n\) 节点树的结构信息在信息论上需要近似 \(2n\) 比特来编码。
   - 因此 LOUDS 以接近理论下界的空间量级存储了整棵树的结构。

2. **优点**

   - **紧凑性**：仅使用一个或少量的位向量（可能还需要一些额外辅助结构进行 rank / select），就能完整表示一棵有序树。
   - **快速导航**：可以在常数或对数时间内执行常见的树操作（如查找父节点、子节点、遍历等）。
   - **适合大规模数据**：在构建搜索引擎、字典等需要处理海量树结构数据的场景下，LOUDS 表示能显著降低内存占用。

3. **缺点**
   - **更新成本高**：对于动态更新（插入、删除节点）的场景，位向量需要在中间插入或删除位，这往往成本较高。LOUDS 更适用于静态或更新不频繁的树结构。
   - **实现复杂度**：为了实现 \(O(1)\) 的 rank / select，需要进一步构建额外的数据结构或索引（如 \(\mathcal{O}(n)\) 空间的帮助表）。初次实现需要一定的代码和算法功底。

---

## 6. 相关变体与扩展

- **LOUDS-DS**（两段式 LOUDS）  
  一种对 LOUDS 进行改进的变体，进一步压缩或简化对子节点导航的操作。
- **Succinct Trie**  
  在构建前缀树（Trie）等大规模字典结构时，LOUDS 可以与字母表或跳跃表结构结合，使得在有限内存中存储大量字符串成为可能。
- **Balanced Parentheses 表示**  
  有些树形结构的精简表示也可以用 “平衡括号序列” 来做编码。LOUDS 与其在思路上存在相似之处，但构造和导航方式略有不同。

---

## 7. 总结

**Level Order Unary Degree Sequence（LOUDS）** 是一种针对有序树的**紧凑**（succinct）表示方法。它通过层序遍历节点，并使用一元编码记录每个节点的子节点数量（若有 \(d\) 个子节点，就写 \(d\) 个 `1`，最后一个 `0` 表示结束），从而在一个或少量的位向量中存储了整棵树的结构信息。借助对位向量的 **rank**/**select** 操作，可以在近乎常数时间内完成对树的导航和查询。

LOUDS 在处理大规模字典、XML/HTML 树或索引时非常有用，它兼顾了**空间效率**与**查询效率**。当然，若需要频繁地修改树结构，LOUDS 的更新就不够灵活。因此，在实际应用中，需要根据是否静态或动态、对内存或查询速度的要求，来权衡是否采用 LOUDS 及其变体。

---

### 参考与进一步阅读

1. _Succinct Data Structures_ - Gonzalo Navarro, 2012.
2. _Jacobson’s Rank and Select_ - 1989.
3. _Peter F. Dietz, Daniel Dominic Sleator, Two algorithms for maintaining order in a list_ - 1987. (并非直接关于 LOUDS，但 rank / select 相关基础)
4. _Ulrich Germann (2014). Binary Tree Coding and the LOUDS Data Structure._

通过以上介绍，希望能帮助您更好地理解 LOUDS 的来龙去脉与编码原理，以及它为何在需要紧凑表示有序树的领域广受欢迎。
