Radix Tree（基数树/压缩 Trie）和 DAWG（有向无环词图）都可以用于高效地存储和检索字符串集，但它们在**结构、压缩方式以及构建方法**等方面存在一定差异。下面从几个角度来对比二者：

---

## 1. 基本定义与核心思想

1. **Radix Tree（基数树 / 压缩 Trie）**

   - 核心思路：对 Trie 进行“链式节点”压缩。即当一个节点只有唯一的子节点时，可以将这条“单一路径”压缩成一个边（Edge），用一个字符串片段表示，而不是一个字符一个节点。
   - 数据结构：Radix Tree 看起来仍然类似一棵树，只是节点更少、边上承载的是**一段**字符，而非单一字符。

2. **DAWG（有向无环词图）**
   - 核心思路：将 Trie 中**重复的后缀（子树）**完全合并，得到无环的图结构；其本质类似于对 Trie 进行最小化，形成最小确定有限自动机（MDFA）的过程。
   - 数据结构：DAWG 不一定是“树”形，而是**有向无环图**，可能有不同的前缀路径最终合并到同一个后缀节点上。

---

## 2. 压缩方式的区别

- **Radix Tree**

  - 仅仅把“单一路径”在 Trie 中的多个节点合并为一个节点，用一整段字符串来表示这条路径。
  - 如果存在不同分支（分叉），则需要在此处切分出新的节点，并分别存储各分支上的字符串片段。
  - 不会主动去合并两个完全相同的子树分支。只是在**纵向**方向（从父到子的一条路径上）进行压缩。

- **DAWG**
  - 不但在**纵向**可进行压缩（因为如果单一路径也可以被合并为一条边），还在**横向**（不同分支的相同后缀/子树）进行合并。
  - 只要发现有两个节点及其后续子树在结构和标记上完全相同，就会被合并为同一个节点。
  - 这样就可能出现一个节点被多个前缀指向，形成“图”而不是“树”，并且保证图无环。

---

## 3. 节点数量与存储占用

1. **Radix Tree**

   - 较原始 Trie 来说，Radix Tree 节点数量会显著减少，但其压缩仅针对“单一路径”。
   - 对于共享后缀很多的单词集，Radix Tree 依旧**不会**把同样的后缀“合并”为同一个分支，因此其压缩率受限。
   - 总体上，对不同的前缀重复度较多、但后缀重复度有限的场景，Radix Tree 通常能起到不错的效果。

2. **DAWG**
   - 通过跨分支合并重复后缀，大规模字典中常能大幅度减少节点数，尤其当单词中存在大量共同后缀时。
   - 对应的存储占用常常**更小**，因为一个相同后缀只存一次。
   - 一般来说，在大量单词、重复后缀很多的情况下，DAWG 比 Radix Tree 在存储上更优。

---

## 4. 构建与维护的复杂度

1. **Radix Tree**

   - 比 Trie 稍复杂，但本质仍是“插入（或查询）时找到最长可匹配的边字符串，然后决定是否要分裂或者继续深入”。
   - 动态增删相对方便，可以在插入或删除时通过检查节点的使用情况来合并或分裂。

2. **DAWG**
   - 构建过程中不仅需要逐字符（或逐前缀）插入，还需要对“当前已构建的部分”进行等价性检测，找出可以合并的子树。
   - 这往往意味着要进行**最小化**操作，与最小化自动机的过程相似，可能使用哈希或排序来快速对比子树是否等价。
   - **动态增删**更复杂，因为一旦合并了两个子树，删除或修改其一也会影响共享节点上的其他单词。
   - 在实践中，DAWG 通常被构建成**只读结构**，一次性地批量构建，然后应用于高速查询。

---

## 5. 查询、检索特性

1. **Radix Tree**

   - 查询时需要在边上逐字符匹配，当走完某条边后可能直接匹配到节点，也可能需要在边的中途发生匹配失败或分裂。
   - 前缀搜索的实现也相对简单，只要匹配到某个节点，再继续遍历子节点即可。

2. **DAWG**
   - 与 Trie 类似，查询单词或前缀时依旧是顺着字符边来走，复杂度 O(L)（L 为查询字符串长度）。
   - 不同在于，若多个前缀指向同一个后缀，走到后缀节点后就**只需存储一次**。
   - 前缀搜索同理，走到前缀对应的节点后，再收集所有可达的终止节点。

---

## 6. 使用场景的差异

- **Radix Tree 适用场景：**

  1. 有较多且比较长的“单一路径”（长前缀）需要压缩；
  2. 数据量大，但后缀的共享程度不是非常高；
  3. 需要较频繁的插入、删除等动态更新；
  4. 查找、前缀匹配等功能要求中等，但对最小化存储的要求没有特别高。

- **DAWG 适用场景：**
  1. 大规模词典/字符串集，有**大量后缀重叠**（如同样的后缀出现在众多单词中）；
  2. 对存储空间要求非常苛刻，希望最大程度削减重复；
  3. 构建后大多“只读”查询的场景（例如搜索引擎的关键词字典、输入法词典等）；
  4. 对前缀查询、单词检索要求高效。

---

## 7. 小结

- **Radix Tree**：可以理解为在“纵向”上对 Trie 进行合并（压缩单一路径），仍保持树的结构；实现和维护都相对简单，动态更新也比较灵活。
- **DAWG**：不仅在“纵向”压缩，甚至会在“横向”对重复子树进行合并，因此得到的结构是有向无环图。它往往在大规模字典中实现**最小化**存储，但动态修改复杂，一般用于批量构建、只读访问。

如果你需要在**查询性能与空间占用**之间取得平衡，同时还要**频繁更新**数据集，Radix Tree 通常更简单实用；如果你有一个非常庞大的词典且**后缀重复度很高**，并且大部分场景是**一次构建、多次查询**，那么 DAWG 会在**存储效率**和**查询性能**上具备显著优势。
