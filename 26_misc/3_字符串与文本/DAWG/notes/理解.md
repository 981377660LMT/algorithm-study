# 可以这样理解吗：DAWG 是只读版本的 Trie，比一般的 Trie 更节省空间，但代价是不支持动态更新

这是一个相对**直观**、但也带有**简化**的理解方式。从工程应用的角度看，确实可以把 **DAWG** 视作一种“**构建完成后只读**”的 Trie，它通过合并重复的后缀子树来达到**节省存储空间**的目的。相应地，它往往**不便于或不支持**频繁的动态更新（增删改），因为一旦合并了若干子树，拆分、重构这些子树往往并不容易。

更准确地说，DAWG 可以理解为：

1. **基于 Trie 的最小化自动机**：

   - 从 Trie 入手，将所有**等价的子树**合并成一个节点及其后缀分支，形成一个有向无环图。
   - 构造结束后，一般会固定下来，不再做大规模增删，以确保合并关系不被破坏。

2. **只读性**：
   - 常见的实现里，DAWG 一旦构建完成，就**不再进行**大的更新操作。
   - 如果有新增词汇，通常有两种做法：要么完全重建 DAWG，要么在工程中使用增量式合并算法，但实现较为复杂。

所以，如果你需要一个**大规模字典**的结构，且主要用途是**查询**（如前缀检索、存在性检查），而对**动态更新**的需求较少，那么 DAWG 非常合适；反之，如果需要经常增删，那么普通 Trie（或者基数树 / Radix Tree）可能更加灵活。

> **一句话总结**：把 **DAWG** 看作“**只读的、最小化存储**的 Trie”是一个**不错的概念性简化**，但要注意它实际上是一种**最小化自动机**，动态更新非常不便。
