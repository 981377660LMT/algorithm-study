https://stevehanov.ca/blog/?id=104

### 文章分析与解读

本文主要探讨了JSON（JavaScript Object Notation）作为数据交换格式在效率上的不足，并提出了一种通过自动类型提取来压缩JSON数据的方法。以下是对文章的详细分析与解读：

#### 1. JSON的效率问题

**文本转化导致的冗余：**

- JSON将所有数据转换为文本，这在某些情况下会导致数据膨胀。例如，数值`3.141592653589793`在内存中只占用8字节，但经过`JSON.stringify()`处理后扩展为17字节。

**过多的引号使用：**

- 每个字符串属性都需要使用引号包裹，这为每个字符串增加了额外的两个字节。例如，属性名`"x"`和`"y"`在JSON中分别占用2个字节，而这些引号在数据量大的情况下会显著增加总体数据大小。

**缺乏标准的模式（Schema）：**

- 当在同一消息中序列化多个对象时，每个对象的属性键名都必须重复，即使这些键名在多个对象中是相同的。这种重复导致了数据的不必要膨胀。

#### 2. JSON的优势与局限

**优势：**

- 相较于XML，JSON通常更为紧凑，并且被许多Web编程语言广泛支持。

**局限性：**

- 早期JSON的一个主要优势是能够被JavaScript引擎直接解析，但随着安全性和互操作性问题的出现，这一优势已经减弱。

#### 3. JSON压缩的重要性

在需要将大型数据结构从Web浏览器传输到服务器的场景中，压缩JSON数据显得尤为重要。特别是在这种单向传输中，使用`浏览器无法预先确定服务器是否支持gzip压缩`，因此需要一种保守且高效的压缩方法。

#### 4. 提出的方法：自动类型提取的JSON压缩

**核心思路：**

- 通过自动推导多个对象的模式（schema），减少重复的键名，从而压缩JSON数据。

**具体实现：**

1. **模式模板（templates）：**
   - 将相同结构的对象的键名提取出来，存储在`templates`数组中。每个模板可以引用之前的模板，从而实现键名的复用。
2. **值数组（values）：**

   - 将对象的具体值存储在`values`数组中，每个对象通过一个类型标识符引用对应的模板。

3. **示例分析：**

   - 原始JSON中，多个对象重复使用了相同的键名，如`"x"`和`"y"`。
   - 通过定义模板，可以将这些键名只存储一次，其他地方通过引用模板来表示，从而减少了数据量。

4. **进一步优化：**
   - 将类型标识符嵌入到值数组的首位，避免单独存储`"type"`字段。
   - 使用简化的属性名（如`"f"`、`"t"`、`"v"`）来进一步压缩数据。

**最终压缩后的JSON结构示例：**

```json
{
  "f": "cjson",
  "t": [
    [0, "x", "y"],
    [1, "width", "height"]
  ],
  "v": [{ "": [1, 100, 100] }, { "": [2, 100, 100, 200, 150] }, {}]
}
```

#### 5. 自动类型提取的算法

**挑战：**

- 找出共享相同键名集合的对象类型，类似于集合覆盖（Set Cover）问题，其最优解是NP完全的。

**解决方案：**

- 采用近似算法，通过树结构来构建模式模板。
- 在构建值数组时，遍历对象并按遇到的顺序将其键名添加到树中。
- 最终通过遍历树节点来生成模板，确保共享的键名只存储一次。

**优化考虑：**

- 插入键名的顺序会影响最终生成的模板，因此可以通过贪婪算法预先排序键名，以提高压缩效率。
- 尽管贪婪算法可以带来更好的压缩效果，但会增加额外的处理开销，作者认为收益可能不大，因此未采用。

#### 6. 应用与实用性

**兼容性：**

- 该压缩方法可以作为`JSON.stringify()`和`JSON.parse()`的替代品，无需重大代码改动。
- 由于压缩后的JSON格式进行了属性重命名和结构调整，可能需要在服务器和客户端同时支持该压缩和解压缩逻辑。

**潜在收益：**

- 在传输大量重复结构数据时，压缩效果显著，特别是在需要传输成千上万的对象时，减少的数据量可以显著提升传输效率和降低带宽消耗。

#### 7. 总结与展望

本文提出的通过自动类型提取压缩JSON的方法，针对JSON在数据传输中的冗余问题提供了一种有效的解决方案。通过引入模式模板和类型引用，显著减少了重复的键名和数据量。然而，该方法的实际应用需要在客户端和服务器端同时实现相应的压缩与解压缩逻辑。此外，随着时间的推移，虽然JSON在效率上有所改进，但在特定场景下，诸如`Protocol Buffers、MessagePack等二进制序列化`格式可能提供更高效的替代方案。

总体而言，本文的方法在特定应用场景下具有实用价值，尤其是在需要频繁传输大量结构化数据的Web应用中。然而，选择合适的数据交换格式还需综合考虑兼容性、开发复杂度以及性能需求等多方面因素。
