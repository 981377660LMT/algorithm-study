# 删除变撤销(undo)

本质是“可逆操作 + 历史记录”。

1. 可逆操作  
   删除并不会真正抹掉数据，而是生成一条“删除”命令，并保存它的逆操作（insert 或 restore）。这样才能在需要时执行反向命令完成撤销。

2. 历史记录（命令栈 / 快照）  
   编辑器把每一次变更按时间顺序压入栈：  
   • 栈顶  →  最近一次操作（删除）  
   • 弹栈  →  执行逆命令（撤销）  
   进一步还能支持 redo，只要把已撤销的命令转存到另一条栈即可。

实现方式常见两种：  
• 命令模式(undoredo)：记录操作及其 inverse。  
• 快照 / 持久化数据结构(copy)：记录变更前后的状态差分或完整拷贝。

因此，“删除”只是把“删除命令 + 恢复信息”写入历史；“撤销”则是按逆序执行该命令的 inverse——两者依靠同一套可逆日志来工作。

---

在算法竞赛中，“删除变撤销”的本质是**可逆操作的设计**，即让删除操作可以被恢复，从而支持回溯、分支搜索等算法。

### 具体本质

1. **状态可逆性**  
   删除操作通常不可逆，为了支持撤销，需要保存被删除的信息，使状态可以回退。

2. **回溯/搜索的需要**  
   在 DFS、回溯、分治等竞赛常用算法中，经常需要“试探性删除”，然后撤销，恢复到之前的状态，继续搜索其他分支。

3. **实现方式**
   - 用栈保存操作历史（如被删除元素及其位置），撤销时弹出并恢复。
   - 用持久化数据结构（如可持久化线段树、可持久化并查集），支持历史版本回退。
   - 手动记录并恢复状态（如数组、链表的手动回滚）。

### 典型例子

- 回溯算法中的“撤销选择”
- 并查集的“撤销合并”（如带撤销的并查集）
- 图搜索中的“撤销边/点删除”

### 总结

**删除变撤销的本质是：让操作可逆，便于算法回溯和分支搜索，保证每次递归/搜索后能恢复到原始状态。**

---

## 删除与撤销的本质

在信息论层面管理状态变换的可逆性。

- 本质上是一种“可逆状态机”：
  - **删除：`状态从 S₀ → S₁`，是状态变更**
  - **撤销：`状态从 S₁ 回退到 S₀`，也是状态变更**

## 常见实现方式

- 快照/版本控制  
  保存多个状态快照或使用持久化数据结构（persistent DS）。
  例如：完全可持久化栈(git)。
- 命令模式  
  将操作封装为 Command，提供 execute() 和 undo() 接口。
  工程实现中常用。
- 操作日志  
  记录每次操作（类型、位置、值），撤销时执行逆操作。
  例如：可撤销数组、可撤销并查集。
  核心原则：只保存撤销所需的最少信息。

## 核心权衡

- 空间 vs 时间  
  快照需更多内存，日志则需重放或逆操作
- 撤销深度  
  无限撤销（日志/版本） vs 有限撤销（固定栈大小）
- 操作开销  
  单次删除 O(1) vs 支持撤销的删除通常需 O(n)（插入/拷贝）
