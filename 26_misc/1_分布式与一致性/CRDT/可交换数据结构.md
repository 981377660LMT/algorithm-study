https://inria.hal.science/inria-00555588/document

在分布式系统与协同编辑等并发场景中，**CRDT (Conflict-Free Replicated Data Types)** 为我们提供了一条“无中心、无锁”就能实现最终一致的路径。它通过预先定义好的合并规则，让所有副本在离线-在线混合、网络分区等复杂环境下依旧可以并行处理本地操作，并在消息到达后自动合并到一致的状态。

然而，CRDT 主要围绕**可交换（commutative）/无冲突**的思想来定义合并操作。例如常见的 G-Counter、PN-Counter、OR-Set、序列型 CRDT（RGA、WOOT、LSEQ 等）都在各自的数据抽象层面提供“并发更新可交换”的合并函数。

近几年来，研究者也在思考：

- 能否设计出更**通用**或**可组合**的数据结构，让不同种类的并发操作能够自动做“拓扑排序”并合并？
- 当操作之间并非完全可交换时，如何在系统层或数据结构层进行**依赖顺序**（partial order）的推理，并在必要时决定操作的可见次序？

这就引出了对**可交换数据结构 (Commutative/Composable Data Structures)** 以及**自动拓扑排序**的扩展讨论。本文将从几个方面展开：

1. **基本概念：并发操作与可交换性**
2. **CRDT 与可交换数据结构的关联与局限**
3. **可交换数据结构如何“自动做拓扑排序”**
4. **典型案例：拓扑排序式合并在协同编辑/事务场景中的应用**
5. **挑战与未来方向**

---

## 1. 基本概念：并发操作与可交换性

### 1.1 并发操作的部分有序关系

- 在一个分布式系统或协同场景中，多个副本/用户可能并发地产生操作（Insert/Update/Delete 等）。
- 一些操作之间存在**因果依赖**：若操作 A 的结果被 B 所基于，那么 B 必须在 A 之后生效。
- 但另一些操作之间则互不依赖，可以任意顺序合并（比如不同字段、不同位置的更新）。

于是，所有并发操作在逻辑上构成了一个**部分有序 (partial order)** 的集合。要想把这些操作应用到同一个副本上，需要**拓扑排序 (topological sort)**：

- 在尊重因果依赖的前提下，将可无依赖的操作并行或任意顺序地合并。
- 如果数据结构的合并规则**可交换**（commutative），那么无论并发操作到达的先后顺序如何，最终结果都相同（或遵循一致的决策方式）。

### 1.2 可交换 (Commutativity) 与无冲突 (Conflict-Free)

- 如果一组操作在任意顺序下都能得到相同最终状态，就称它们彼此**可交换**；
- CRDT 中的“无冲突”通常是指**合并函数**满足交换律、结合律、幂等性等，保证并发更新不会丢失或相互覆盖；
- 当操作不可交换时，需要在数据结构或系统层面进行冲突解决（例如加时间戳选最新，或保留多版本等）。

---

## 2. CRDT 与可交换数据结构的关联与局限

### 2.1 CRDT 的核心：内建合并函数

CRDT 把**合并 (merge)** 视为核心：

- 状态型 CRDT（CvRDT）有一个 `merge(stateA, stateB) -> newState`；
- 操作型 CRDT（CmRDT）通过广播操作并在接收方执行，天然地保证并发可交换。

这些合并逻辑往往**针对特定数据抽象**（计数器、集合、序列等）手写了“无冲突”规则。例如：

- **G-Counter**：每个副本维护一个向量计数，合并时逐坐标取最大值；
- **OR-Set**：给每次插入赋唯一标识，删除只移除已插入的对应标识；合并时取并集再减去删除标识。

### 2.2 CRDT 的局限：数据类型 & 合并语义通常是固定的

- 传统 CRDT 通常针对**简单**或**中等复杂度**的数据结构（计数、集合、map、文本序列），事先定义好了合并规则；
- 如果要支持**更多样的操作**（如带业务逻辑依赖的多字段更新、跨对象操作等），CRDT 并不直接提供自动拓扑排序；
- 开发者可能需要自己动手，区分**可并发**与**不可并发**操作，或者附加因果关系与冲突解决策略。

因此，引出了对**更通用或可扩展**的数据结构的需求，让它们能“自动”对操作进行依赖排序并合并结果。

---

## 3. 可交换数据结构如何“自动做拓扑排序”

### 3.1 概念：并发操作 = 有向无环图（DAG）

当我们把所有操作看作节点，把“必须在 A 之后执行”看作有向边，就得到一个**有向无环图 (DAG)**：

- 无环是因为无法自相依赖；
- 任意一个**线性扩展 (linear extension)**（也称拓扑排序）都表示一种可行的执行顺序。
- 如果一些操作可以交换，那么它们之间没有边，就能在拓扑排序中自由对换顺序。

### 3.2 数据结构层的做法

一个具备“自动拓扑排序并合并结果”能力的数据结构，需要：

1. **对操作进行依赖管理**：识别哪些操作必须先于哪些操作；
2. **当操作到达时，能判断是否可以直接合并，或需要等待其依赖操作先生效**；
3. **对可交换的操作进行并行或任意顺序合并，保证最终状态一致**。

#### 3.2.1 增强版的 Operation-based CRDT

- 在操作型 CRDT 中，每条操作携带因果信息（比如版本向量/vector clock）表示自己依赖于哪些操作；
- 若数据结构更复杂，可以在操作层注入更多“类型”或“自定义约束”，当收到新操作时，对其依赖做检查：
  - 如果依赖操作尚未应用，就暂存；
  - 当所有依赖满足后再执行。
- 这样，在副本本地就**隐式地**对操作做了可行的拓扑排序——只不过这个顺序不一定唯一，而是只要满足因果先后即可。

#### 3.2.2 Commutative Replicated Data Type (CmRDT) 的一般化

- 对于那些**不可完全交换**的操作，可在数据结构层添加**部分序**约束；
- 当两个操作确实冲突时，需要显式解决冲突或保留多版本；
- 只有在**独立**或**兼容**的操作之间，才能省略因果边并发执行。

换言之，数据结构在“合并操作”的实现中，需要动态检查操作之间的依赖与冲突，一旦确认它们“可交换”，就可以**不分先后**地应用；若确认有先后顺序，必须先执行前置操作后再执行当前操作。

### 3.3 示例：多字段对象 & 条件更新

想象一个分布式对象 `UserProfile`，有字段 `(name, age, city)`，并且存在业务约束：`age` 的更新必须基于当前已有值，或 `city` 的更新只有在 `age >= 18` 时才有效……

- 一些操作之间就存在依赖/冲突；
- 如果操作 A 和 B 涉及不同字段，无依赖，就能并发合并；
- 若 B 依赖 A 更新后的 `city` 值，就必须先执行 A 再执行 B。

要在数据结构层“自动化”这些约束，需要对操作进行更细化的描述：**预期旧值**、**待更新新值**、**依赖条件**……，并为合并过程（apply operation）添加检查逻辑，若不满足条件要么延迟，要么拒绝（或保留多版本）。

---

## 4. 典型案例：拓扑排序式合并在协同编辑 / 事务场景中的应用

### 4.1 协同编辑中的序列 CRDT

- 例如 RGA、WOOT、Logoot 等序列 CRDT，本质上也在管理一批“插入/删除字符”的操作，并将它们按照**位置依赖**与**因果依赖**做合并。
- 当两个插入操作位置不同且无因果关系，就可并发（操作可交换）。当删除操作依赖特定插入 ID，则必须在插入生效后执行删除。
- 这些 CRDT 在内部通过标识符 (identifier) 机制，或通过“墓碑” (tombstone) 标记，让并行操作能够组合成一个有序文本。

### 4.2 分布式事务 / Event Sourcing

- 一些事件溯源 (Event Sourcing) 系统中，把对数据库的更新视作一连串事件。若事件之间有部分依赖，就可以在本地做 DAG 式存储。
- 合并时，把远端的事件合并进本地，如果发现依赖事件缺失，则等待拉取或回放那条事件；若事件之间独立，就可无序并入。
- 数据库最终在应用完所有事件后达到一致状态，期间实际上做了一个**隐式拓扑排序**。

---

## 5. 挑战与未来方向

1. **表达能力 vs 可交换性**

   - 若想让数据结构“自动识别并发操作间的依赖”并合并，就需要事先在**操作定义**中显式声明哪些操作可并发，哪些需要因果或顺序；
   - 这种**丰富的操作描述**往往比传统 CRDT 更复杂，需要开发者提供更多业务逻辑或元数据。

2. **性能与可扩展**

   - 维护一个潜在非常大的操作 DAG，或要跟踪细粒度依赖，可能带来较高的存储与通信成本；
   - 如何在保证**最终一致**与**可交换**的前提下进行**增量同步**、**垃圾回收**（移除无用元数据）是个持续研究课题。

3. **与强一致模型的结合**

   - 有的系统在局部或小范围内需要强一致（线性化），在大范围内又想使用可交换/最终一致的模式；
   - 这需要在架构上做**混合**，有时要通过共识协议（Raft/Paxos）在关键环节锁定顺序，有时又放手让可交换操作并行合并。

4. **多对象、跨对象依赖**
   - 更复杂的分布式应用往往涉及多表、多文档甚至跨组件的更新；
   - 若要让数据结构自动处理跨对象依赖并做拓扑排序，需要**全局**的依赖跟踪或**事务性**CRDT，这在理论和工程上都更具挑战。

---

## 总结

“**可交换数据结构**”可以理解为：

- 在并发场景下，数据结构内部能够根据操作的**依赖关系**和**可交换性**，自动进行拓扑排序和合并。
- 它是对传统 **CRDT** 思想的扩展：不仅在固定的数据抽象上预定义合并规则，还能在更灵活或更复杂的操作集上，通过**因果依赖**、**冲突检测**或**多版本保留**来保证最终一致。

大多数现有的 CRDT 算法（G-Counter、PN-Counter、OR-Set、RGA 等）都可以视作“可交换数据结构”的特例，只是它们的**操作集**和**合并逻辑**相对固定、单一。要让这些结构适用于更复杂的并发场景，需要更通用的框架来：

1. **声明操作及其依赖/冲突**；
2. **在系统内部维护一个局部或全局的操作有向无环图**；
3. **当依赖就绪时，按拓扑顺序应用**；对可交换操作，可以并发或任意顺序合并。

从协同编辑、分布式存储到事件溯源与“分布式事务”，无不需要在一致性与并发性之间平衡。**可交换数据结构**体现了这样一种思路：在能交换的地方尽量无锁并发，在有依赖的地方自动排队或保持多版本，以实现**最终一致**且**高可用**的分布式体验。这是分布式系统中一个极具研究与应用价值的方向，随着对 CRDT 的推广与拓展，未来会出现更多通用化、可组合的“可交换数据结构”方案。
