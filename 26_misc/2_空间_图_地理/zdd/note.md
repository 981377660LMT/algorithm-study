在**布尔函数**以及**组合爆炸**问题的研究中，**BDD (Binary Decision Diagram, 二叉决策图)** 与其改进形式 **ZDD (Zero-suppressed BDD, 零抑制 BDD)** 是两类核心的数据结构。它们都能以**图**的方式紧凑、高效地表示集合或布尔函数，并在大量应用场景（硬件验证、组合优化、离散问题求解等）中显著减少存储和运算复杂度。

下面将从以下几个方面系统地介绍 BDD 与 ZDD 的原理、构造、运算及应用场景：

1. **BDD：二叉决策图**  
   1.1. BDD 的背景与动机  
   1.2. BDD 的定义和结构  
   1.3. 归约（Reduced BDD）与正则形（Canonical form）  
   1.4. BDD 的主要运算与算法  
   1.5. BDD 的优势与局限

2. **ZDD：Zero-suppressed BDD（零抑制 BDD）**  
   2.1. ZDD 与 BDD 的关系  
   2.2. ZDD 的主要思想  
   2.3. ZDD 在集合/组合枚举中的优势  
   2.4. ZDD 的运算与应用

3. **典型应用场景**

   - 布尔函数的表示与操作
   - 硬件电路验证（Model Checking）
   - 组合优化与离散求解
   - 子集与路径枚举 (ZDD)
   - 软件包依赖解决、配置空间分析

4. **总结与延伸**

---

# 1. BDD：二叉决策图

## 1.1. BDD 的背景与动机

在计算机科学、电子设计自动化 (EDA) 以及人工智能中，需要处理大量的**布尔函数**(Boolean Functions)。

- 例如，硬件电路可以抽象为布尔函数，其输入是电路输入信号，输出是电路输出信号；
- 同理，SAT / 约束求解也依赖对布尔表达式的操作。

传统上，我们可以用逻辑表达式(如与/或/非门)、真值表、卡诺图 (K-map) 等方法来表示布尔函数。然而，对于 n 个变量的函数，真值表大小可达 \(2^n\)，在 n 较大时快速膨胀。

**BDD (Binary Decision Diagram)** 通过将布尔函数表示为一个**有向无环图**，配合一些简化规则，往往能极大压缩存储空间，并使**逻辑运算**（如与、或、非、异或、量化等）高效可行。

---

## 1.2. BDD 的定义和结构

### 1.2.1 非正式定义

- BDD 是一棵**有序二叉决策树**的压缩形式，每个**内部节点**对应一个布尔变量 \(x_i\)，根据该变量取值 0 或 1 分别指向两个子分支；
- 树的**叶子节点**一般是两个：**TRUE** (1) 和 **FALSE** (0)，表示在该路径上布尔表达式的最终求值结果。

### 1.2.2 有序 BDD (OBDD)

我们通常使用**有序 BDD** (Ordered BDD)，即对所有节点所对应的变量顺序固定不变。例如，若变量顺序为 \(x_1, x_2, \ldots, x_n\)，则沿着从根到叶的路径，变量出现的顺序必须是这个固定次序。这种约束能保证 BDD 表示的**唯一性**（在经过适当归约后），也简化了运算。

### 1.2.3 BDD 的图结构

- **内部节点**：标注某个变量 \(x_i\)。有两个子分支：
  - `low` / `0` 分支（当 \(x_i = 0\)）
  - `high` / `1` 分支（当 \(x_i = 1\)）
- **终端节点**：只有两个特别的叶子：**0**（假）和**1**（真）。
- **有向无环**：若 BDD 是归约且有序的，其结构不会形成环。

---

## 1.3. 归约（Reduced BDD）与正则形（Canonical form）

### 1.3.1 减少冗余节点

在构建 BDD 时，可能出现多个节点拥有**相同的子图结构**，或者 `low` 分支与 `high` 分支指向同一子节点。此时可以通过**合并**或**去除**这些冗余节点来减小图的规模。例如：

- 若某个节点的 `low` 分支和 `high` 分支都相同，则该节点可以直接省略，用其子分支替代；
- 若两个节点 `(var = x_i, low = A, high = B)` 和 `(var = x_i, low = A, high = B)` 完全一致，则只保留一个节点即可。

### 1.3.2 正则形 (Canonical)

当且仅当**变量顺序固定**且**冗余节点已合并/删减**，我们就可以得到一个**归约有序 BDD（ROBDD）**。对于同一个布尔函数 \(f\)，在指定的变量顺序下，ROBDD 的结构是**唯一**的。这使得在**函数等价检测**中非常有用：只要查看两个 BDD 是否是同一个图，就可知对应布尔函数是否相同。

---

## 1.4. BDD 的主要运算与算法

### 1.4.1 基本布尔操作（与、或、非 等）

- 可以对两个 BDD \(F\) 和 \(G\) 进行**节点递归**，对照每个变量并计算结果 BDD：
  - 例如 \(F \land G\) (与操作)：若 \(F\) 或 \(G\) 在某分支上为 0，则该分支结果为 0；否则再递归匹配子节点。
  - 通过记忆化（hash）实现可避免大量重复计算。

### 1.4.2 量化操作（\(\exists, \forall\)）

- 在模型检测和公式简化中，会常用到**存在量化** \(\exists x_i. f\) 或**全称量化** \(\forall x_i. f\)；
- 对应 BDD 的操作是**消除**节点 \(x*i\) 的影响：\(\exists x_i. f = f|*{x*i=0} \lor f|*{x_i=1}\)；可通过**递归合并**子分支实现。

### 1.4.3 动态变量重排序

- BDD 大小对**变量顺序**非常敏感；某些不良顺序会导致 BDD 膨胀。
- 实际实现 often 提供**动态重排序**(Sifting, Window Permutation 等算法)，在构造和运算过程中自动调优，以期得到更小的 BDD。

---

## 1.5. BDD 的优势与局限

- **优势**
  - 表达**布尔函数**的**正则形**，比较/等价检测非常容易；
  - 对逻辑运算（与/或/非/量化）有高效的图算法；
  - 在大量 EDA 工具、模型检测器中广泛应用。
- **局限**
  - 不当的变量顺序可能导致 BDD 尺寸指数级膨胀；
  - BDD 多用于**布尔函数**层面，若用来表示一些特定类型的**组合集合**，可能存在大量 0 分支浪费等情况。

---

# 2. ZDD：Zero-suppressed BDD（零抑制 BDD）

## 2.1. ZDD 与 BDD 的关系

**ZDD** 是 **BDD** 的一个专门变体，由 **Shin-ichi Minato** 在 1990年代提出，目标是更有效地表示**稀疏集合**（即大部分元素不出现）的情形。它最初并不是直接针对布尔表达式的简化，而是**聚焦“集合的子集”**相关的组合枚举。ZDD 也采用“二叉决策图”的思想，但在节点合并/裁剪规则上与 BDD 不同，以应对大量的 0 分支（“不包含该元素”）时更好地进行压缩。

---

## 2.2. ZDD 的主要思想

### 2.2.1 用于表示集合族

ZDD 常用于表示一个**集合的集合**(family of sets)：

- 假设有 n 个元素 \(\{e_1, e_2, \ldots, e_n\}\)，每个子集可用一个 n 位布尔向量指示是否包含某元素；
- ZDD 用一棵二叉图来表示**所有“感兴趣的”子集**，把它们的布尔向量共享在一个结构中。

### 2.2.2 省略 0 分支（Zero-suppressed 规则）

与 BDD 不同：

- 对于变量 \(x_i\)，ZDD 在节点合并时优先处理**当变量 = 0** 分支如果指向终端 0（空），则**删除**该节点；因为这表示“当不包含元素 i 时，就没有对后续集合的贡献”。
- 反之，若 BDD 是“只要 `low` 分支与 `high` 分支相同就合并”，ZDD 则重点处理“`low` = 0 时更激进地省略节点”。
- 这样做的直觉：在集合枚举时，大量子集会以“元素 i 不出现”的形式出现，将其统一合并为一个空分支可大幅节省空间。

### 2.2.3 终端节点

ZDD 和 BDD 一样有两个特殊叶子节点：`1`（表示集合已完整构造的有效状态）和 `0`（表示集合不存在/空解），但它们在ZDD场景下有时也加上一些含义扩展。

---

## 2.3. ZDD 在集合/组合枚举中的优势

1. **适合稀疏集合**
   - 当大量子集中都“不包含某些元素”时，ZDD 可以在图结构中把这些 0 分支“抑制”掉。
2. **操作接口**
   - ZDD 提供类似 BDD 的运算(如并/交/差、子集生成等)；还增加了对**集合操作**的优化，如**Enumerate all sets**、**Add/Remove element** 等。
3. **典型用途**
   - 子集枚举、约束组合（如背包问题的解集）、路径/匹配/分区等离散问题存储；
   - 在将解集存到 ZDD 后，再做进一步分析（计数、枚举、运算）往往更快。

---

## 2.4. ZDD 的运算与应用

### 2.4.1 基本运算

- **Union / Intersection / Difference**：类似 BDD 做节点递归，但遵循 ZDD 的节点合并规则；
- **Subset / Superset**：可在 ZDD 结构上做选择性遍历；
- **Counting solutions**：ZDD 的图形可快速统计子集数、或进行加权计数（若定义了权重）。

### 2.4.2 应用示例

- **多项式展开**：例如在组合学中，某些多项式的展开对应到 ZDD 上，可以“以图替代符号”来管理项；
- **路径或子图枚举**：如在一个图中寻找所有满足某些条件的子图集合；ZDD 可能比 BDD 更省内存；
- **软件包依赖/组合配置**：可将所有可行安装组合存为一个 ZDD，并快速查询与统计。

---

# 3. 典型应用场景

以下罗列 BDD/ZDD 各自或交叉的一些主要应用领域：

1. **硬件电路验证** (BDD)

   - 在 EDA 中，用 BDD 表示电路的逻辑函数，进行**功能等价检测**、**故障仿真**、**状态空间搜索** (symbolic model checking) 等。
   - 此处主要用到 BDD 对布尔函数的紧凑表示及逻辑运算高效特性。

2. **SAT / 约束求解** (BDD, ZDD)

   - 可以用 BDD 来替代 CNF，一旦生成 BDD 后，可更直观地进行**解计数 (#SAT)** 或**量化消去 (QBF)**；
   - 当问题解集中大量 0 分支，可用 ZDD 来表示解空间更紧凑。

3. **组合优化 / 动态规划** (ZDD)

   - 在**背包问题**、**集合覆盖**等离散问题中，用 ZDD 构建所有可行解集，然后做合并或过滤操作，能更快地进行解统计或进一步约束。
   - 特别适合**同时枚举**和**后续分析**的场景。

4. **路径或模式枚举** (ZDD)

   - 在图或网络中，每条路径都可视为对边的子集；ZDD 可以表示“所有满足约束的路径”或“所有子图”，存储与查找都比 naive 列举快得多。

5. **配置空间 / 软件包依赖** (ZDD)
   - 在 Linux 包管理或通用软件产品线中，需要存储与处理**兼容性约束**和**可行安装组合**；
   - 用 ZDD 存储所有可行组合，可以快速判断新约束下是否仍有解、或有多少解。

---

# 4. 总结与延伸

- **BDD**：

  - 旨在**布尔函数**的表示与运算，广泛用于**电路验证**、**模型检测**、**SAT/#SAT** 等领域。
  - **变量顺序**至关重要，常需要**动态重排序**来保持 BDD 规模可控。
  - “Reduced & Ordered” 形式可以成为**唯一表示**，方便等价判断。

- **ZDD**：
  - 专为**稀疏集合**场景设计，通过**抑制 zero 分支**来显著压缩存储；
  - 适用于**子集/子图/路径**等大规模枚举、**组合解空间**存储及操作；
  - 同样具备丰富的**集合运算**与**归约**技巧。

二者都属于**基于决策图 (decision graph)** 的数据结构，通过**合并冗余子图**、**共享公共子结构**，实现**指数级**的压缩与快速运算。它们在离散数学、组合优化、EDA、AI 推理、配置管理等诸多领域发挥不可或缺的作用。

若读者有进一步兴趣，可查阅以下资料：

- Randal E. Bryant: “Graph-Based Algorithms for Boolean Function Manipulation.” IEEE Transactions on Computers, 1986. (BDD 核心论文)
- Shin-ichi Minato: “Zero-suppressed BDDs for set manipulation in combinatorial problems.” DAC, 1993. (ZDD 核心)
- 库与工具：**CUDD** (A BDD/ZDD Package by Fabio Somenzi), **BuDDy**, **Sylvan** 等。

通过**BDD/ZDD** 的理论与实务结合，我们可以在极其庞大的布尔或集合空间中做**高效**、**可扩展**的搜索与运算，从而解决许多原本棘手的组合爆炸问题。
