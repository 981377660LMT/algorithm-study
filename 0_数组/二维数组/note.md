MxN 的矩阵 有
row === ~~(index/N)
col === index%N

注意对角线元素 i+j 或者 i-j 的和

1. 矩阵中某个位置的状态如果发生改变，那么这种题的解法一般是两次遍历整个矩阵。第一遍遍历时，用一个不可能出现在原矩阵中的中间值来保存状态的变化（这样在此次遍历时，不影响其他的位置的判断，比如我们可以用“$”这种没人用的字符）；第二遍遍历时，把中间值刷新成为变化后应该变成的值。

2. 如果遍历到某个位置时，需要查看它周边的位置，此时如果每一个周围的位置都手写，然后再判断是否越界，就很麻烦。可以先用一个数组保存向周边位置变化的坐标偏移值，一次性通过一个循环，来遍历完周边的位置，并且方便进行越界判断。

旋转数组

```JS
var rotate = function(nums, k) {
  k = k % nums.length
  const reverse = (l, r) => {
    while (l < r) {
      ;[nums[l], nums[r]] = [nums[r], nums[l]]
      l++
      r--
    }
  }

  reverse(0, nums.length - 1)
  // 注意这里k-1 的边界
  reverse(0, k - 1)
  reverse(k, nums.length - 1)

};
```
