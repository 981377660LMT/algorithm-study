1. std::fmt 包含多种 trait（特质）来控制文字显示，其中重要的两种 trait 的基本形式如下：

- fmt::Debug：使用 {:?} 标记。格式化文本以供调试使用。Rust 也通过 {:#?} 提供了 “美化打印” 的功能.
- fmt::Display：使用 {} 标记。以更优雅和友好的风格来格式化文本。
  实现 fmt::Display trait，它会自动提供 ToString。

2. Rust 有两种常量，可以在任意作用域声明，包括全局作用域。它们都需要显式的类型声明：

const：不可改变的值（通常使用这种）。
static：具有 `'static 生命周期的`，可以是可变的变量（译注：`须使用 static mut 关键字`）。

3. From 和 Into
   Into trait 就是把 From trait 倒过来而已。也就是说，如果你为`你的类型实现了 From，那么同时你也就免费获得了 Into`。
   使用 Into trait 通常要求指明要转换到的类型，因为编译器大多数时候不能推断它。

4. 指针和引用

- 解引用使用 `*`
- 解构使用 &、ref、和 ref mut
  不方便 用 & 的地方，可以用 ref
  `match 的模式匹配上只能使用 ref，在函数声明上只能使用&来表示引用类型`
  https://www.jianshu.com/p/ac519d8c5ec9

  单纯 Rust 语言上考虑。

  我们在不同情况下解释&的意思：
  在表达式上，表示的是借用。
  在变量绑定上，表示解地址操作与`*`类似。
  在类型声明上，表示引用类型。
  在模式匹配上，无效关键字

  那么 ref 的通用解释是：
  在表达式上，无效关键字。
  在变量绑定上，表示引用类型。
  在类型声明上，无效关键字。
  在模式匹配上，表示引用类型。

  非要给区分 ref 和&到底哪个是引用，哪个是借用。我们可以先从词性划分，引用我归类为名词，而借用归类为动词。&A 在表达式上 表示借用 A，这是一个动作，那结果就是产出一个引用类型。所以 let ref B 表示声明了一个引用类型，它只能绑定到某次借用动作上。

  `所以 ref 更适合叫引用， &叫借用。`

5. attriubtes
   An attribute is metadata applied to some module, crate or item.
   Attributes can take arguments with different syntaxes:

   - #[attribute = "value"]
   - #[attribute(key = "value")]
   - #[attribute(value)]

   - 条件编译可能通过两种不同的操作符实现：

     cfg 属性：在属性位置中使用 #[cfg(...)]
     cfg! 宏：在布尔表达式中使用 cfg!(...)

6. 空泛型
   即使一个 trait 不包含任何功能，你仍然可以用它作为约束。标准库中的 Eq 和 Ord 就是这样的 trait。

7. 关联项（Associated Items）
   关联项是一个 trait 的一部分，它是一个类型或常量。关联项的类型可以是任何类型，包括关联类型。
   它是 trait 泛型的扩展，允许在 trait 内部定义新的项。

   解决的问题：
   trait 如果对实现了它的容器类型是泛型的，则须遵守类型规范要求——trait 的使用者必须指出 trait 的全部泛型类型。
   但是，有时候我们并不想这样，我们只想要一个泛型类型，而不是全部泛型类型。

   一个对象上的泛型参数来自两个部分：

   - 对象本身的泛型参数，重要 => 可以用泛型
   - 对象上的某些方法的泛型参数，不那么重要 => 可以用关联类型来解决

8. 虚类型参数(PhantomData)
   虚类型（phantom type）参数是一种在`运行时不出现，而在（且仅在）编译时进行静态检查`的类型参数。

   可以用额外的泛型类型参数指定数据类型，该类型可以充当标记，也可以供编译时类型检查使用。这些额外的参数没有存储值，也没有运行时行为。

   解决的问题：
   有时候我们`需要一个泛型类型，但是并不需要这个泛型类型的值`，只是为了让编译器检查类型。这时候就可以使用虚类型参数。
