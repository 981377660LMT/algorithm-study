[rust 语言圣经](https://course.rs/about-book.html)

1. 包管理工具最重要的意义就是任何用户拿到你的代码，都能运行起来，而不会因为各种包版本依赖焦头烂额。
2. 很多语言中，你并不需要深入了解栈与堆。 但对于 Rust 这样的系统编程语言，值是位于栈上还是堆上非常重要, 因为这会影响程序的行为和性能。

- 栈中的所有数据都**必须占用已知且固定大小的内存空间**，假设数据大小是未知的，那么在取出数据时，你将无法取到你想要的数据
- 与栈不同，对于**大小未知或者可能变化的数据**，我们需要将它存储在堆上。
  当向堆上放入数据时，需要请求一定大小的内存空间。操作系统在堆的某处找到一块足够大的空位，把它标记为已使用，并返回一个表示该位置地址的**指针**, 该过程被称为在**堆上分配内存，有时简称为 “分配”(allocating)**。
  接着，该指针会被推入**栈**中，因为指针的大小是已知且固定的，在后续使用过程中，你将通过栈中的**指针**，来获取数据在堆上的实际内存位置，进而访问该数据。
  想象一下去餐馆就座吃饭: 进入餐馆，告知服务员有几个人，然后服务员找到一个够大的空桌子（堆上分配的内存空间）并领你们过去。如果有人来迟了，他们也可以通过桌号（栈上的指针）来找到你们坐在哪。
  在堆上分配内存则需要更多的工作，这是因为操作系统必须**首先找到一块足够存放数据的内存空间**，接着做一些记录为下一次分配做准备，如果**当前进程分配的内存页不足时(缺页中断)，还需要进行系统调用来申请更多内存**。 因此，处理器在栈上分配数据会比在堆上分配数据更加高效。

  https://github.com/youngyangyang04/TechCPP/blob/master/problems/%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD.md
  缺页中断是计算机操作系统中的一个重要概念，发生在程序访问虚拟内存时，需要加载的页面不在主存中，需要从辅存（如硬盘）中读取的情况下。当程序试图访问一个已经被映射到虚拟地址空间但尚未载入物理内存的页面时，就会引发缺页中断。

  具体来说，当程序访问一个虚拟地址时，操作系统会首先检查该地址对应的页面是否已经在主存中。如果页面在主存中，那么程序可以直接访问；如果页面不在主存中，就会触发缺页中断。此时，操作系统会进行以下步骤：

  中断处理：CPU 接收到缺页中断信号后，暂停当前正在执行的程序，将控制权交给操作系统内核。
  处理程序：操作系统会根据页面表或其他映射信息确定页面所在的位置（通常是磁盘），并将页面加载到主存中的空闲页面框中。
  更新页表：操作系统更新页表中有关该页面的信息，包括物理地址等。
  恢复程序：一旦页面加载到内存中，操作系统会重新启动之前暂停的程序，使其继续执行。
