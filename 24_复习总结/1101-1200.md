#1102 **得分最高的路径**  
中等
`优先队列启发式搜索+visited`

#1103 **分糖果 II**  
简单
`糖果数取min，index取模`

#1104 **二叉树寻路**  
中等
`match = min + max - label`

#1105 **填充书架**  
中等
`dfs(cur,height,remain) 可以不用建新书架，也可以新建书架`

#1106 **解析布尔表达式**  
困难
`类似计算器，一个栈存操作符，一个栈存t/f`

#1110 **删点成林**  
中等
`dfs 携带isParentDeleted 参数`
`删点:root.left=dfs/root.right=dfs`
`res里的点:父节点删除，当前节点不删，即断开连接`

#1111 **有效括号的嵌套深度**  
中等
todo

#1121 **将数组分成几个递增序列**  
困难
`贪心；仅取决于出现次数最多的那个元素的出现次数`

#1122 **数组的相对排序**  
简单
`项的相对顺序和 arr2 中的相对顺序相同:稳定排序`

#1123 **最深叶节点的最近公共祖先**  
中等
`比较子树高度`

#1124 **表现良好的最长时间段**  
中等
`maximum size subarray 让它的和大于 0`

#1125 **最小的必要团队**  
困难
`每个技能赋予唯一ID，每位候选人的技能压缩成数字`
`dfs(index,state) state等于target表示选完了，返回空列表`

#1129 **颜色交替的最短路径**  
中等
`visited[nodeid][color]`
`每个点处更新res`
`color用0和1,换颜色只需color^1`

#1130 **叶值的最小代价生成树**  
中等
将数组中相邻的数两两合并，计算他们的乘积之和，求最小的乘积之和
`值较小的叶子节点就要尽量放到底部，因为越是底部的叶子节点，被用来做乘法的次数越多`
`每次pop`最小数`，然后乘以相邻的值=>这个找最小数的过程可以暴力，也可以用单调栈代替`
`res += min(stack[-1], num) * tmp_min`

#1131 **绝对值表达式的最大值**  
中等
`曼哈顿距离，枚举符号`
`arr1[i] * dx + arr2[i] * dy + i * sign`

#1135 **最低成本联通所有城市**  
中等
`kruskal板子`

#1138 **字母板上的路径**  
中等
`字母index映射到二维坐标`

#1139 **最大的以 1 为边界的正方形**  
中等
`countDown countRight 预处理；候选大到小找到一个就break`

#1140 **石子游戏 II**  
中等
`dfs(index,M)；自己拿的减去对手拿的`

#1143 **最长公共子序列**  
中等
`经典题`

#1144 **递减元素使数组呈锯齿状**  
中等
`两种情况;调奇数位置和偶数位置；比较两边，如果大了，就要减`

#1145 **二叉树着色游戏**  
中等
`dfs后序统计子树大小`

#1146 **快照数组**  
中等
`为每个位置存一个action字典Map<actionId,value>+二分查找`

#1147 **段式回文**  
困难
1 <= text.length <= 1000
`字符串哈希`

#1150 **检查一个数是否在数组中占绝大多数**  
简单
一个按 非递减 顺序排列的数组 nums
`二分；检查bisect_left(nums, target)+len(nums) >> 1`

#1151 **最少交换次数来组合所有的 1**  
中等
`固定区间，假设最后的全1就在当前的窗口；则窗口内0的个数==需要交换的次数`

#1152 **用户网站访问行为分析**  
中等
`userHistory邻接表`
`patternCounter邻接表`

#1153 **字符串转化**  
困难
`关键是：len(set(zip(str1, str2))) == len(set(str1))，即映射关系相等`

#1155 **掷骰子的 N 种方法**  
中等
`dp[色子数][点数]；dp[i][j] = (dp[i][j] + dp[i - 1][j - k]`

#1156 **单字符重复子串的最大长度**  
中等
`groupby api 分两种情况`

#1157 **子数组中占绝大多数的元素**  
困难
`索引邻接表二分`

#1161 **最大层内元素和**  
中等
`哈希表key为depth`

#1162 **地图分析**  
中等
`多源bfs`

#1163 **按字典序排在最后的子串**  
困难
`最小表示法`

#1166 **设计文件系统**  
中等
`获取父路径:path.slice(0, path.lastIndexOf('/'))`

#1167 **连接棒材的最低费用**  
中等
`哈夫曼树`

#1168 **水资源分配优化**  
困难
`水井:连接虚拟源点`

#1170 **比较字符串最小字母出现频次**  
中等
`二分`

#1171 **从链表中删去总和值为零的连续节点**  
中等
`哈希表前缀和，记录某个值最后出现的结点`

#1172 **餐盘栈**  
困难
`二分搜索popIndedx+树状数组查询前缀和；注意index要+1处理成bit里的索引`

#1175 **质数排列**  
简单
`素数筛`

#1177 **构建回文串检测**  
中等
最多替换 k 个字符重拍后变成回文
`最多替换k个字符重拍后变成回文；`
`子串：使用异或预处理前缀；偶数个位0,奇数个位1；最后统计1的个数即可`

#1178 **猜字谜**  
困难
puzzles[i].length == 7
`状压;只关注是否出现=>或运算压缩单词`
`求出puzzle[0] + subset(puzzle[1:N - 1]) 对应的二进制数字之后，累加 hashmap 中该二进制数字出现的次数，就是该 puzzle 对应的 word 有多少。`

#1181 **前后拼接**  
中等
`每个字符串，用数组存储每个字符串（index表示）的[第一个word,最后一个word]`
`两次遍历，拼接`

#1182 **与目标颜色间的最短距离**  
中等
`记录并更新pre，两遍扫描确定在i时的最短距离`

#1183 **矩阵中 1 的最大数量**  
困难
`计算左上角正方形的每个格子在整个矩形中有多少个等效位置，取等效位置最多的前maxOnes个即可`

#1185 **一周中的第几天**  
简单
`new Date('2022-01-01').getDay()`

#1186 **删除一次得到子数组最大和**  
中等
求连续子数组最大和 可以删除一次元素;删除一个元素后，子数组 不能为空。
`最大子数组的进阶版本;dp[i][0]表示不删除得到的最大值，dp[i][1] 表示已经删除其中一个得到的最大值`

#1187 **使数组严格递增**  
困难
`dfs(i, prev);比较min(swap, noswap)`

#1189 **“气球” 的最大数量**  
简单
`短板效应`

#1190 **反转每对括号间的子串**  
中等
`(入栈索引，)出栈索引并反转这段`

#1191 **K 次串联后最大子数组之和**  
中等
`k === 1、k === 2，k>2 的情况`

#1192 **查找集群内的「关键连接」**  
困难
`寻找联通无向图的桥`

#1197 **进击的骑士**  
中等
`4个象限关于（0，0）对称。都转化成第一象限，方便处理和计算`
`bfs,根据数据范围合理剪枝`

#1198 **找出所有行中最小公共元素**  
中等
`直接reduce取交集`

#1199 **建造街区的最短时间**  
困难
`总是优先挑选两个最小的节点来进行合并`

#1200 **最小绝对差**  
简单
`只存在于相邻元素间`
