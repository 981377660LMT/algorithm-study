#901 **股票价格跨度**  
中等
`stack 存 [price,gap] gap表示当前影响范围`

#902 **最大为 N 的数字组合**  
困难
`小于 len 位的`
`等于len位时 n的高位向低位对比`

#903 **DI 序列的有效排列**  
困难
`def dfs(cur: int, less: int, more: int) -> int:`

#904 **水果成篮**  
中等
`counter left right指针 while (counter.size > 2) `

#906 **超级回文数**  
困难
构造九位数的回文
`枚举构造回文`

#907 **子数组的最小值之和**  
中等
`计算贡献`

#909 **蛇梯棋**  
中等
`bfs`

#910 **最小差值 II**  
中等
`-k+k 等价于每个数+0 或 +2k`
`排序后，在某一个节点，之前的数全部加2k`

#911 **在线选举**  
中等
`最右二分`

#913 **猫和老鼠**  
困难
`dfs(steps,cat,mouse)->bool`

#915 **分割数组**  
中等
left 中的每个元素都小于或等于 right 中的每个元素
`等价于左边最大值<=右边最小值，左右遍历两遍维护leftMax与rightMin即可`

#916 **单词子集**  
中等
`counter子集关系：交小并大`

#917 **仅仅反转字母**  
简单
`头尾双指针找合法位置`

#918 **环形子数组的最大和**  
中等
`最大的环形子数组和 = max(最大子数组和，数组总和-最小子数组和)`
`无环：最大和子数组不包含首尾元素`
`有环：最大和子数组包含首尾元素,即最小和子数组不能包含首尾元素`

#919 **完全二叉树插入器**  
中等
`关键是记录层序遍历结果，利用完全二叉树性质找parent`

#920 **播放列表的数量**  
困难
`如果当前的歌和`前面的都不一样`/如果当前的歌和`前面的有重复的``

#921 **使括号有效的最少添加**  
中等
`左括号入栈，右括号判断，中间有栈空，结束非空栈`

#923 **三数之和的多种可能**  
中等
`定一移二；三个相等/有两个相等(只取一种情况)/都不想等(只取一种情况)`

#924 **尽量减少恶意软件的传播**  
困难
`并查集拯救被感染的帮派；哪个帮派大就帮谁`

#926 **将字符串翻转到单调递增**  
中等
`dp[i][j] 表示 在 i 位置的时候，其为 j 状态的时候，保持单调的最小翻转的次数`

#927 **三等分**  
困难
`找到三个组的开头`

#928 **尽量减少恶意软件的传播 II**  
困难
`反向并查集:忽略所有感染节点，只考虑正常节点。然后将感染源逐一考虑进去`

#932 **漂亮数组**  
中等
`A 中的每一个数 x 进行 kx + b 的映射，其仍然为漂亮数组`
`如果数组 A 和 B 分别是不同奇偶性的漂亮数组，那么将 A 和 B 拼接起来仍为漂亮数组`

#934 **最短的桥**  
中等
`dfs 将一半岛全部加入 queue 原地标记-1`
`bfs找到另一半岛的最短路径 找到1就返回`

#935 **骑士拨号器**  
中等
`dfs(cur, remain) `

#936 **戳印序列**  
困难
`入度为窗口内与印章不同的字符数`

#939 **最小面积矩形**  
中等
`两两枚举作为对角线，看另外两个点在不在集合里`

#940 **不同的子序列 II**  
困难
`endswith [0]*26 dp`

#941 **有效的山脉数组**  
简单
`头尾指针`

#942 **增减字符串匹配**  
简单
`头尾指针，I取左，D取右`

#943 **最短超级串**  
困难
`在一个图中，从某个点出发将所有点恰好遍历一遍，使得最后路过的路径长度最长`
`dist[cur][state] = cost 控制入队`

#945 **使数组唯一的最小增量**  
中等
`counter计数题`

#946 **验证栈序列**  
中等
`模拟，记录出栈index`

#947 **移除最多的同行或同列石头**  
中等
`并查集 union石头`

#948 **令牌放置**  
中等
`Buy at the cheapest and sell at the most expensive.`

#949 **给定数字能组成的最大时间**  
中等
`全排列`
`两个限制条件: 1. p[:2]<(2,4) 2. p[2]<6`

#951 **翻转等价二叉树**  
中等
`都不存在，只有一个存在，都存在`

#952 **按公因数计算最大组件大小**  
困难
`因数并查集，求最大帮派大小`

#953 **验证外星语词典**  
简单
`非allEqual:前的权重不能大于后`
`allEuqual：前的长度不能大于后`

#954 **二倍数对数组**  
中等
`遍历 sorted(counter) ，配对元素减去当前需要的元素数`

#956 **最高的广告牌**  
困难
两个和相等且最大的子序列
`字典dp,dp={0:0},表示和为0时的最大正数和为0`
`等价转换：对任何一个数，`可以用三种方式对待它，乘以 1，-1 或 0`，目标是求和为0时的最大正数和`

#957 **N 天后的牢房**  
中等
`visited 取模加速 while 循环`

#958 **二叉树的完全性检验**  
中等
`层序遍历；记录是否碰到null标志位；如果是完全二叉树，Null之后不能有结点`

#959 **由斜杠划分区域**  
中等
`二维并查集`

#960 **删列造序 III**  
困难
`dp[i]表示以第i个字符结尾所能达到的最长字典序子序列,但是这里的针对对象不是单个字符串,而是多个字符串`
`dp[i] = Math.max(dp[i], dp[j] + 1)`

#962 **最大宽度坡**  
中等
`单调栈;先吧单减的序列入栈，再逆序遍历，看这个数比前面多少个数大`

#963 **最小面积矩形 II**  
中等
矩形的边不一定平行于 x 轴和 y 轴。
`向量点乘判断ij ik是否是直角，向量叉乘得面积`

#964 **表示数字的最少运算符**  
困难
todo
`不停做“乘法”直到乘到正好小于target和正好大于target两个数。小于target的那个数加一个“加号”，继续递归。大的那个数反过来走向target。`
`dfs(cur: int)`

#967 **连续差相同的数字**  
中等
`bt保持搜索顺序`

#968 **监控二叉树**  
困难
`后序dfs返回状态`

#970 **强整数**  
中等
`枚举`

#971 **翻转二叉树以匹配先序遍历**  
中等
`记录遍历的index`

#972 **相等的有理数**  
困难
`直接算出来即可`

#973 **最接近原点的 K 个点**  
中等
`数据流topK：堆`

#974 **和可被 K 整除的子数组**  
中等
`前缀和取mod，Counter计数`

#976 **三角形的最大周长**  
简单
`排序，用next`
`两边之和大于第三边是充要条件`
`排序，从后向前遍历，如果符合条件直接返回`

#977 **有序数组的平方**  
简单
`头尾双指针，不断从两端选出最大的`

#978 **最长湍流子数组**  
中等
`记录up down`

#979 **在二叉树中分配硬币**  
中等
`后序dfs`
`返回 lMoves + rMoves + root.val - 1`

#980 **不同路径 III**  
困难
`dfs 标记回溯`

#981 **基于时间的键值存储**  
中等
在不同时间戳存储对应同一个键的多个值，并针对特定时间戳检索键对应的值。
`TreeSet`

#982 **按位与为零的三元组**  
困难
`哈希表存两个数的异或，加速`

#983 **最低票价**  
中等
`dp；每个点三种选择`

#984 **不含 AAA 或 BBB 的字符串**  
中等
`递归`
`B > A 选 bba `
`A > B 选 aab`

#985 **查询后的偶数和**  
中等
`乐观更新`

#991 **坏了的计算器**  
中等
`让y尽可能除2，最快地接近x`

#992 **K 个不同整数的子数组**  
困难
`题目转换成求：不超过 k 种元素的子数组个数 - 不超过 k-1 种元素的子数组个数(转化为水果成蓝问题)`
`notMoreThanK`

#993 **二叉树的堂兄弟节点**  
简单
`dfs携带parent和depth信息`

#995 **K 连续位的最小翻转次数**  
困难
`使用队列模拟滑动窗口，该滑动窗口的含义是前面 K - 1 个元素中，以哪些位置起始的 子区间 进行了翻转`
`((queue.length & 1) ^ nums[i]) === 0 表示需要反转当前位`

#996 **正方形数组的数目**  
困难
`dfs(cur: int, state: int)`
`哈密尔顿回路`
`注意最后消除重复排列`

#997 **找到小镇的法官**  
简单
`入度0出度n-1`

#999 **可以被一步捕获的棋子数**  
简单
`join行列，忽略空白，检查是否有 Rp pR`

#1000 **合并石头的最低成本**  
困难
todo
