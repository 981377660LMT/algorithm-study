#701 **二叉搜索树中的插入操作**  
中等
`root.right root.left 递归`

#702 **搜索长度未知的有序数组**  
中等
`注意初始化边界`

#705 **设计哈希集合**  
简单
`质数个的分桶,定长拉链数组/不定长拉链数组`

#709 **转换成小写字母**  
简单
`^32 |32 &-33`

#710 **黑名单中的随机数**  
困难
`black 存 black 到 white 的映射 关闭一扇门，打开一扇窗`

#711 **不同岛屿的数量 II**  
困难
`每座岛屿翻转 8 个方向，全部加入 set`
`八方旅人`

#712 **两个字符串的最小 ASCII 删除和**  
中等
0 < s1.length, s2.length <= 1000
`dp[i][j]双字符串dp`

#713 **乘积小于 K 的子数组**  
中等
`滑窗;res += right - left + 1`

#715 **Range 模块**  
困难
`bisectLeft/bisecRight 判断区间；奇数代表区间内，偶数代表区间外`

#716 **最大栈**  
简单
`有序字典+有序集合;有序字典顺序检索，有序集合维护最大值`
`有序字典按 push 顺序维护 <id,x>，有序集合按大小顺序维护 <x, id>。`

#717 **1 比特与 2 比特字符**  
简单
`while (i < bits.length - 1)`

#718 **最长重复子数组**  
中等
1 <= len(A), len(B) <= 1000
`dp`

#719 **找出第 k 小的距离对**  
困难
`二分加滑窗,count函数求不大于mid的对数，小于k就右移`

#720 **词典中最长的单词**  
简单
`前缀树 + 深度优先搜索`

#722 **删除注释**  
中等
`不可以加flag 's'即点匹配换行符 因为只有/* */允许多行匹配 而// 只允许单行匹配`

#723 **粉碎糖果**  
中等
`删除标记，置为负数`
`下落，逆序读写指针`

#725 **分隔链表**  
中等
`先把长度求出来，然后确定每一组的长度`

#726 **原子的数量**  
困难
`逆序遍历，因为从后往前会碰到结束的标志位大写;记录count与单词`

#727 **最小窗口子序列**  
困难
`邻接表模式匹配`
`哈希表存出现的 index,二分查找(bisectRight)出现的位置 索引需要递增`

#730 **统计不同回文子序列**  
困难
todo

#732 **我的日程安排表 III**  
困难
`差分+treemap`

#734 **句子相似性**  
简单
`相似关系是不具有传递性：暴力`

#735 **行星碰撞**  
中等
`相邻删除问题使用栈`

#736 **Lisp 语法解析**  
困难
todo

#737 **句子相似性 II**  
中等
`相似关系具有传递性：并查集`

#738 **单调递增的数字**  
中等
`找到第一个转折点，后面全填9；mono标志位判断`

#740 **删除并获得点数**  
中等
`打家劫舍不能选相邻的`

#741 **摘樱桃**  
困难
`记忆化dfs(x1, y1, x2, y2)`

#742 **二叉树最近的叶节点**  
中等
`将树转换为图，从目标值 k出发通过bfs找到最近的叶子节点`
`叶子节点:邻接表长度为1`

#743 **网络延迟时间**  
中等
`dijk`

#744 **寻找比目标字母大的最小字母**  
简单
`二分`

#745 **前缀和后缀搜索**  
困难
`建树时在树中插入 suffix + '#' + word `

#747 **至少是其他数字两倍的最大数**  
简单
`记数组中最大值 max，数组中第二最大值 secondMax。`

#749 **隔离病毒**  
困难
todo

#750 **角矩形的数量**  
中等
n<=200
`dp[col][rightCol] 与上面的行们可以组成矩阵的个数`

#751 **IP 到 CIDR**  
中等
todo

#752 **打开转盘锁**  
中等
`双向 bfs`

#753 **破解保险箱**  
困难
todo
返回一个最短的字符串满足：n 位每位由 0~k-1 构成的字符串都是其子串
`dfs(cur,path)`

#754 **到达终点数字**  
中等
`最小的i,使得S>=target且S-target为偶数`

#755 **倒水**  
中等
`一滴一滴地找，先左后右，找不到就原地+1`

#756 **金字塔转换矩阵**  
中等
`建图，dfs(char: str)；zip(char, char[1:]`

#757 **设置交集大小至少为 2**  
困难
排序加贪心不好想
todo

#759 **员工空闲时间**  
困难
`所有区间全部push，排序 ,记录preEnd，然后找不重叠`

#760 **找出变位映射**  
简单
`索引邻接表indexes`

#761 **特殊的二进制序列**  
困难
`level == 0表示这是一截有效的括号字符串，可以递归处理这段子串`

#763 **划分字母区间**  
中等
同一字母最多出现在一个片段中：需要知道每个字母后面还有木有，需要记录`每个字符最后出现索引`
`如果找到字符最远出现位置下标和当前下标相等了，则找到了分割点`

#764 **最大加号标志**  
中等
`对每个mines,更新mines所在行列`

#765 **情侣牵手**  
困难
`贪心,我们遍历每个偶数位置 2 * i ，把它的对象安排到它右边的奇数位置 2 * i + 1。`

#766 **托普利茨矩阵**  
简单
`以第 0 行的每一个点做起点,以第0列的每一个点做起点,向右下方验证一条对角线`

#767 **重构字符串**  
中等
`分成两半，交叉插入数组,前一半长度不少于后一半`

#768 **最多能完成排序的块 II**  
困难
`单调栈;不是分割区块，而是`融合`区块`

#774 **最小化去加油站的最大距离**  
困难
`二分答案;l = mid + eps`

#775 **全局倒置与局部倒置**  
中等
`如果i之前的最大值>a[i+2] 那么不成立`

#776 **拆分二叉搜索树**  
中等
`后序dfs`

#777 **在 LR 字符串中交换相邻字符**  
中等
`‘R’只能向右移动，并且只能移向’X’，‘L’只能向左移动，并且只能移向’X’。,zip即可`

#778 **水位上升的泳池中游泳**  
困难
`1631`
`二分+dfs`

#779 **第 K 个语法符号**  
中等
`折半递归`

#781 **森林中的兔子**  
中等
`比较 freq > same_color + 1 `

#782 **变为棋盘**  
困难
`所有行全部参考第一行，所有列全部参考第一列`

#784 **字母大小写全排列**  
中等
`每个位置，笛卡尔积`

#785 **判断二分图**  
中等
`dfs(cur: number, color: Color): boolean `

#786 **第 K 个最小的素数分数**  
困难
`topk 多路归并`

#787 **K 站中转内最便宜的航班**  
中等
`带限制的最短路径；Bellman–Ford单源动态规划最短路径；最多k个中转点，即更新k+1次`

#788 **旋转数字**  
中等
`暴力+子集关系`

#789 **逃脱阻碍者**  
中等
`比谁先到`

#790 **多米诺和托米诺平铺**  
中等
`f(n) = 2 * f(n-1) + f(n-3)`

#791 **自定义字符串排序**  
中等
`indexOf比较权重`

#792 **匹配子序列的单词数**  
中等
`索引邻接表预处理`

#793 **阶乘函数后 K 个零**  
困难
`二分;count等于k返回5，不等于k返回0`

#795 **区间子数组个数**  
中等
`atMostK(nums,k)：子数组的全部元素都不大于 k的子数组个数`
`容斥原理`

#796 **旋转字符串**  
简单
`s.length === goal.length && goal.repeat(2).includes(s)`

#797 **所有可能的路径**  
中等
`回溯`

#798 **得分最高的最小轮调**  
困难
`差分,记录每个元素调度多少次后开始让分数较少；除了第一个元素移动到最后面会使score+1外，其他的数的左移会使score减小`

#799 **香槟塔**  
中等
`处理溢出的情况`

#800 **相似 RGB 颜色**  
简单
`x11, 0x22, 0x33, 0x44... 都是 0x11 的倍数;00 到 ff 中找到一个相似度最大的;除以17，>8四舍五入`
