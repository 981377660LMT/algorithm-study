#1401 **圆和矩形是否有重叠**  
中等
`圆心在矩形内/看矩形边上，距离圆心最近的点`

#1402 **做菜顺序**  
困难
`nestedInterger 的 bfs 型，先看的权重最大`

#1403 **非递增顺序的最小子序列**  
简单
`子序列：排序`

#1404 **将二进制表示减到 1 的步骤数**  
中等
`python模拟/js用BigInt`

#1405 **最长快乐字符串**  
中等
`358. K 距离间隔重排字符串`

#1406 **石子游戏 III**  
困难
`dfs(index)`

#1408 **数组中的字符串匹配**  
简单
按 任意 顺序返回 words 中是其他单词的子字符串的所有单词

```Python
class Solution:
    def stringMatching(self, words: List[str]) -> List[str]:
        a = " ".join(words)
        return [w for w in words if a.count(w)>1]
```

#1409 **查询带键的排列**  
中等
`模拟题`

#1410 **HTML 实体解析器**  
中等
`amp替换&必须放在最后`

#1411 **给 N x 3 网格图涂色的方案数**  
困难
todo
`121 123 模式`

#1414 **和为 K 的最少斐波那契数字数目**  
中等
`枚举，倒序遍历`

#1415 **长度为 n 的开心字符串中字典序第 k 小的字符串**  
中等
1 <= n <= 10
`bt；超过k直接返回`

#1416 **恢复数组**  
困难
`dfs(i):以i为字符串起点的方案数，枚举分割点`

#1417 **重新格式化字符串**  
简单
任意两个相邻字符的类型都不同；请你返回 重新格式化后 的字符串；
`正则匹配分组，获取short/long组;zip_longest long在前`

```Python
class Solution:
    def reformat(self, s: str) -> str:
        alphas = findall(r'[a-z]', s)
        digits = findall(r'\d', s)
        if abs(len(alphas) - len(digits)) > 1:
            return ''
        short, long = sorted([alphas, digits], key=len)
        return ''.join(a + b for a, b in zip_longest(long, short, fillvalue=''))
```

#1418 **点菜展示表**  
中等
`食物名=>SortedSet`
`每桌的情况=>每桌都是一个Counter`

#1420 **生成数组**  
困难
`dp[i][j][k]代表符合长度为n,跳跃数为j,最大值确定为k这三个条件的数组个数`

#1423 **可获得的最大点数**  
中等
`定长滑窗:维护一个len-k的窗口，保证窗口里面和最小，然后剩余的k个数的和就是最大`

#1425 **带限制的子序列和**  
困难
`dp+单调队列,队列存[sum,index]，队首存当前最大值`

#1428 **至少有一个 1 的最左端列**  
中等
`从右下角开始，遇到1往左走(因为想找到包含 1 的最左端列的索引)，遇到0往上走(看看本列还有没有1)`

#1429 **第一个唯一数字**  
中等
`两个集合即可`

#1432 **改变一个整数能得到的最大差值**  
中等
`最大：不等于9的换成9`
`最小:首位是否为1，`

#1433 **检查一个字符串是否可以打破另一个字符串**  
中等
`counter计数，两个标志位`

#1434 **每个人戴不同帽子的方案数**  
困难
`dfs(i: int, state: int)遍历帽子`

#1436 **旅行终点站**  
简单
`出度为0/start集合不存在`

#1437 **是否所有 1 都至少相隔 k 个元素**  
简单
`记录preOne`

#1438 **绝对差不超过限制的最长连续子数组**  
中等
`滑动窗口 + 有序集合`
`仅需要统计当前窗口内的最大值与最小值=>两个单调队列`

#1439 **有序矩阵中的第 k 个最小数组和**  
困难
`多路归并`

#1442 **形成两个异或相等数组的三元组数目**  
中等
`前缀异或`
`a==b有a^a==0==a^b 则只需找前缀 prefix[k+1] == prefix[i] 中间j随便取`

#1443 **收集树上所有苹果的最少时间**  
中等
`dfs后序标记经过的结点，统计经过的边数res，2*res即为所求`
`难题基本上是后序dfs`

#1444 **切披萨的方案数**  
困难
`def dfs(x, y, k);前缀和加速`

#1447 **最简分数**  
中等
`return [f"{j}/{i}" for i in range(2, n + 1) for j in range(1, i) if gcd(i, j) == 1]`

#1448 **统计二叉树中好节点的数目**  
中等
`前序dfs`

#1449 **数位成本和为目标值的最大数字**  
困难
`完全背包组合问题，选出背包，求最后组成的数的最大值`

#1453 **圆形靶内的最大飞镖数量**  
困难
`枚举两个点可以求出圆心，然后再遍历一次求出每个圆心半径内都有多少个点符合要求。`

#1455 **检查单词是否为句中其他单词的前缀**  
简单
`findIndex`

#1457 **二叉树中的伪回文路径**  
中等
1 <= Node.val <= 9
`看到值很小可以位运算`

#1458 **两个子序列的最大点积**  
困难
`dfs(i,j)`

#1461 **检查一个字符串是否包含所有长度为 K 的二进制子串**  
中等
`return all(bin(i)[2:] in s for i in range(n, n // 2, -1))`

#1462 **课程表 IV**  
中等
`判断两点间是否联通，等价于最短距离不为Infinity`

#1463 **摘樱桃 II**  
困难
`dfs(i1, j1, i2, j2)`

#1464 **数组中两元素的最大乘积**  
简单
`维护两个最大值cand`

#1465 **切割后面积最大的蛋糕**  
中等
`最大长*最大宽即可`

#1466 **重新规划路线**  
中等
`当作无向图处理`
`从原点dfs遍历，看有多少对(cur,parent)在道路中`

#1467 **两个盒子中球的颜色数相同的概率**  
困难
`def dfs(index, ball1, ball2, color1, color2) -> int:`

#1470 **重新排列数组**  
简单
`nums[::2],nums[1::2]=nums[:n],nums[n:]`

#1471 **数组中的 k 个最强值**  
中等
`自定义排序`

#1472 **设计浏览器历史记录**  
中等
`first,last双指针,再用一个stack表示history`

#1473 **粉刷房子 III**  
困难
`dfs(index: number, remain: number, preColor: number): number`

#1477 **找两个和为目标值且不重叠的子数组**  
中等
`不允许重叠：分割数组为两半，维护leftMin并找rightSum是否存在`

#1478 **安排邮筒**  
困难
`dfs(index,remain)`

#1481 **不同整数的最少数目**
中等
`按counter 频率排序`

#1482 **制作 m 束花所需的最少天数**  
中等
`二分`

#1483 **树节点的第 K 个祖先**  
困难
`如果每次查找的步长是1，会超时`
`dp[i][j]: 结点j 的， 距离为2^i 的祖先结点`

#1484 **克隆含随机指针的二叉树**  
中等
`克隆=>WeakMap存储结点=>克隆结点`

#1487 **保证文件名唯一**  
中等
`有了就改名，还有的话就while循环继续改名`

#1488 **避免洪水泛滥**  
中等
`优先队列存离现在最近的下雨天；晴天直接抽干`
`从前向后遍历, 将`已经满了的湖的下一个下雨日期`加入优先队列中,`

#1489 **找到最小生成树里的关键边和伪关键边**  
困难
todo

#1490 **克隆 N 叉树**  
中等
`后序 dfs`

```JS
function cloneTree(root: Node | null): Node | null {
  if (!root) return root
  const newNode = new Node(root.val)

  for (const child of root.children) {
    newNode.children.push(cloneTree(child))
  }

  return newNode
};
```

#1492 **n 的第 k 个因子**  
中等
`small, big两两配对，如果最后一对相等(完全平方数)，则pop一个`

#1493 **删掉一个元素以后全为 1 的最长子数组**  
中等
`fix模型`

#1494 **并行课程 II**  
困难
`bfs `最短路问题``

#1496 **判断路径是否相交**  
简单
`visited即可,复数表示`
`record = {'N': 1j, 'S': -1j, 'E': 1, 'W': -1}`

#1497 **检查数组对是否可以被 k 整除**  
中等
`按模counter计数;注意mod为0的情况单独讨论`

#1498 **满足条件的子序列数目**  
中等
`排序+双指针查找+计算贡献`

#1499 **满足不等式的最大值**  
困难
请你找出 yi + yj + |xi - xj| 的 最大值，其中 |xi - xj| <= k
`yi + yj + |xi - xj| = (yi - xi) + (yj + xj)`
`使用单调队列/堆 维护yi-xi的最大值`

#1500 **设计文件分享系统**  
中等
`Map<number, Set<number>> 记录 chunkToUser、userToChunk`
`最小堆维护一个id池用于回收；uuid全局自增`
