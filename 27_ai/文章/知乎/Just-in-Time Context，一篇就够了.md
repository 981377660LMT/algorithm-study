### 1. 核心概念：从被动到主动的转变

文章首先回顾了上下文工程的重要性（对抗 LLM 注意力衰减和上下文窗口限制），然后提出了一个关键的范式转移：

- **Pre-computed Context (预计算上下文)**：
  - **模式**：传统 RAG（检索增强生成）。
  - **流程**：用户提问 -> 检索系统（基于语义相似度）找资料 -> 塞给 LLM -> LLM 回答。
  - **缺点**：LLM 是被动的。`检索系统基于“语义相似”假设，但很多时候逻辑相关的代码（如 Bug 原因和报错日志）在语义上并不相似，导致检索失效。`
- **Just-in-Time Context (即时上下文)**：
  - **模式**：Agent 主导的探索。
  - **流程**：LLM 拿到任务 -> **LLM 决定**需要什么信息 -> LLM 调用工具（ls, grep, read_file）获取信息 -> LLM 决策。
  - **优点**：LLM 变成了主动探索者。`它根据逻辑链条（而非语义相似度）去寻找信息，能更精准地定位问题，减少幻觉。`

### 2. JIT Context 的实现机制

要实现 JIT Context，文章提出了两个关键点：

- **References as Context (引用即上下文)**：
  - Agent 不需要一开始就知道所有文件的内容。它只需要知道“地图”（文件路径、目录结构）。
  - **比喻**：就像你去图书馆，不需要背下所有书，只需要看目录索引。
- **Progressive Disclosure (渐进式披露)**：
  - Agent 通过工具逐步获取信息。
  - **典型路径**：`ls` (看结构) -> `grep` (搜关键词) -> `read_file` (确认相关后才读取内容)。
  - **价值**：只把真正需要的 Token 加载到上下文中，极大地节省了注意力预算。

### 3. JIT 的代价与治理（代谢机制）

JIT 虽然精准，但带来了新的问题：**过程噪音**。Agent 在探索过程中会产生大量的中间步骤（试错的 grep 结果、无关的文件列表），这些会迅速填满上下文窗口。

为了解决这个问题，文章提出了一套“代谢机制”：

#### A. Compress (压缩)

- **基于模型的语义压缩**：让 LLM 定期总结历史，只保留架构决策和关键信息，丢弃冗余输出。（Coding Agent 主流做法）
- **基于规则的结构化剪枝 (Context Editing)**：
  - **热数据**：保留最近 N 轮对话。
  - **冷数据**：清除早期的工具输出，只留占位符。
  - **副作用**：会破坏 Prompt Caching（前缀缓存），需要权衡成本。

#### B. Write (卸载/外化)

- **Scratchpad (草稿纸)**：Agent 维护一个 `Plan.md` 或笔记文件。
- **Swap 机制**：在清除上下文之前，把重要信息写入外部文件。
- **意义**：实现了“上下文的无限延伸”，即使窗口重置，记忆依然保存在磁盘上。

#### C. Isolate (隔离)

- **子代理架构**：主 Agent 派发任务给子 Agent。
- **原理**：子 Agent 在独立的上下文中“脏”地干活（产生大量噪音），最后只把干净的结论汇报给主 Agent。
- **效果**：主 Agent 的上下文始终保持清爽。

### 4. 总结图解

为了更直观地理解，我们可以用一个简单的流程图来概括 JIT Context 的生命周期：

```mermaid
graph TD
    A[任务开始] --> B{需要信息?};
    B -- 是 --> C[JIT 摄入阶段];
    C --> D[查看引用 (ls/地图)];
    D --> E[渐进式探索 (grep/read)];
    E --> F[获得信息];
    F --> G{上下文太长?};
    G -- 否 --> B;
    G -- 是 --> H[代谢治理阶段];
    H --> I[Compress: 压缩摘要];
    H --> J[Write: 写入外部文件];
    H --> K[Isolate: 子Agent处理];
    I --> B;
    J --> B;
    K --> B;
```

### 5. 关键结论

- **Agentic vs Semantic**：这是两个正交的维度。Agentic 强调“谁在决策”（LLM 主动），Semantic 强调“怎么找”（语义搜索）。JIT Context 强调的是 Agentic。
- **混合策略 (Hybrid Strategy)**：工程上最好的做法是 **Push + Pull**。
  - **Push**：预加载必用的信息（如项目规范 `CLAUDE.md`）。
  - **Pull**：让 Agent 按需探索不确定的信息。
- **核心哲学**：上下文工程的本质是**信息密度的优化**。既不能缺信息，也不能被噪音淹没。

这篇文章非常有深度，它不仅指出了 RAG 的局限性，还给出了一套完整的工程化解决方案（摄入 + 代谢），对于构建复杂的 Agent 系统非常有指导意义。
