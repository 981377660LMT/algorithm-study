https://the-pocket.github.io/PocketFlow/guide.html

这份文档是 **Agentic Coding（智能代理编码）** 的宣言与操作手册，它定义了一种全新的软件开发范式：**人类负责高层设计与架构，AI 代理负责具体实现与细节填充。**

---

### 一、 核心哲学：设计驱动开发 (Design-Driven Development)

文档的核心思想是：**AI 系统的质量上限取决于人类设计的清晰度。**

1.  **角色分工明确化：**
    - **人类 (Architect):** 处理模糊性、定义商业价值、提供上下文（Context）、制定高层流程（Flow）和评估结果。人类是“大脑的指挥官”。
    - **AI (Builder):** 处理繁琐细节、编写代码、实现数据结构、编写测试用例、处理边界情况。AI 是“强大的执行手”。
2.  **先设计，后编码：**
    - 严禁直接跳入代码实现。必须先产生 `docs/design.md`。
    - 如果人类无法用自然语言和流程图理清逻辑，AI 就无法将其转化为可靠的代码。

---

### 二、 8 步开发工作流深度解析

这不仅是步骤，是一套**协作协议**：

| 阶段                    | 关键点内化                                                                                                                                                                                          | 为什么这么重要？                                   |
| :---------------------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :------------------------------------------------- |
| **1. 需求**             | **人类主导**。以“用户故事”而非“功能列表”的形式定义问题。明确 AI _能做什么_（常识、转换）和 _不能做什么_（复杂决策、模糊战略）。                                                                     | 防止 AI 在错误的路径上浪费算力。                   |
| **2. 流程 (Flow)**      | **协作核心**。必须画出 Mermaid 图。区分模式：<br>- **Map Reduce:** 处理长文本/批量任务。<br>- **Agent:** 处理基于上下文的工具调用。<br>- **RAG:** 知识检索。<br>- **Workflow:** 线性多步骤任务。    | 这是系统的骨架。没有这个，系统就是一堆散乱的函数。 |
| **3. 工具 (Utilities)** | **定义“身体”**。这是 AI 与现实世界交互的接口（读写文件、发邮件、搜索）。<br>**关键区分：** 纯 LLM 任务（摘要、情感分析）属于 _Node_ 的内部逻辑，**不是** Utility。Utility 应当是确定性的 I/O 操作。 | 隔离副作用。Utility 只管“动作”，Node 管“思考”。    |
| **4. 数据**             | **AI 主导**。设计共享存储（Shared Store）的 Schema。                                                                                                                                                | 数据契约决定了节点间如何解耦。                     |
| **5. 节点 (Node)**      | **AI 主导**。Input (Prep) -> Process (Exec) -> Output (Post)。<br>不要在 Node 内部做复杂的异常处理，利用框架的 `retry` 机制。                                                                       | 保持节点的原子性和可重用性。                       |
| **6. 实现**             | **AI 主导**。根据设计文档写代码。**原则：KISS (Keep It Simple, Stupid)**。                                                                                                                          | 避免过度工程化。快速实现 MVP。                     |
| **7. 优化**             | **人类反馈，AI 调整**。Prompt Engineering (提示词工程) 和 In-Context Learning (上下文学习) 是微调的主要手段。                                                                                       | LLM 系统是非确定性的，需要通过迭代来收敛效果。     |
| **8. 可靠性**           | **AI 编写测试**。重点在于 Corner Cases（边界情况）和 Retries（重试机制）。                                                                                                                          | 弥补 LLM 偶尔的不稳定性。                          |

---

### 三、 架构设计模式：PocketFlow 范式

文档隐含了一套特定的 Python 框架思维（称为 `PocketFlow`），其架构特点如下：

#### 1. 数据通信：共享存储 (Shared Store)

- **概念：** 不通过函数参数在节点间层层传递数据，而是使用一个全局的字典（Context）。
- **优势：** 彻底解耦。Node B 不需要知道 Node A 的存在，只需要知道 Shared Store 里有 `"summary"` 这个字段。
- **代码体现：**
  ```python
  shared = {
      "user_input": "...",
      "intermediate_result": "...",
      "final_output": "..."
  }
  ```

#### 2. 代码结构标准化

一个标准的 Agentic Coding 项目结构必须清晰：

- **`docs/design.md` (圣经):** 一切开发的源头。包含 Mermaid 流程图、数据结构定义、Utility 列表。无代码，仅设计。
- **`utils/` (手脚):** 独立的 API 调用文件（如 `call_llm.py`）。每个文件必须包含 `if __name__ == "__main__":` 的自测代码。
- **`nodes.py` (处理单元):** 继承自 `Node` 类。
  - `prep()`: 从 Shared Store 读数据。
  - `exec()`: 核心逻辑（调用 LLM 或 Utility）。**不写 try-catch**，让系统层处理重试。
  - `post()`: 将结果写回 Shared Store。
- **`flow.py` (编排):** 定义节点连接关系（例如 `node_a >> node_b`）。
- **`main.py` (入口):** 初始化 Shared Store，启动 Flow。

---

### 四、 避坑指南 (Best Practices)

1.  **关于 Utility 的误区：**
    - 不要把 `summarize_text()` 做成 Utility。这是 Node 的工作。
    - 要把 `fetch_email()` 做成 Utility。这是 I/O。
2.  **关于异常处理 (Fail Fast)：**
    - 不要在 Utility 里吞掉错误。如果 API 挂了，就让它崩，或者让 Node 的 `max_retries` 接管。
    - 这有助于快速暴露系统弱点。
3.  **关于复杂性：**
    - 不要一开始就做完整的类型检查和复杂的类继承。
    - 使用简单的字典和 Python 的动态特性来快速迭代。

### 五、 核心内化总结

作为 AI 辅助编程代理，在接到您的指令时，我将遵循以下元规则：

1.  **拒绝盲目编码：** 如果您没有提供设计文档或清晰的流程，我会先要求澄清或帮您生成 `design.md`。
2.  **关注数据流：** 我会优先确认 Shared Store 的数据结构（输入是什么，输出存哪里）。
3.  **拥抱工具化：** 我会将外部 API 封装为独立的、可测试的 `utils` 模块。
4.  **原子化节点：** 我会建议将大任务拆解为小的 `Node`，并通过 `Flow` 连接。

**这句话是整个方法的灵魂：**

> _If Humans can’t specify the flow, AI Agents can’t automate it!_ > **如果人类无法指定流程，AI 代理就无法将其自动化！**
