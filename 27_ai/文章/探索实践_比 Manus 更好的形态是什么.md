# 探索实践-比 Manus 更好的形态是什么

https://blog.zihanjian.com/article/2e89db82-fa86-80c7-a60f-ef4f0e03081c

这篇文章《【探索实践】比 Manus 更好的形态是什么》是由作者 Zylan 撰写的，探讨了当前 AI 工具形态的局限性，并提出了一个新的产品理念 **UniLot**。

作者认为，AI 工具不应只是“聊天的对话框”或“写代码的自动化工具”，而应该是**让 AI 进入用户的语境，在统一的语义空间内与用户“域内共建”**。

以下是对这篇文章的深度详细讲解，分为背景洞察、痛点分析、核心理念、技术实现及未来展望五个部分。

---

### 一、 核心背景与行业观察：AI 工具的演进

作者回顾了过去两年 AI 工具的发展，将其划分为三个阶段，清晰地指出了当前市场的空缺：

1.  **第一阶段：对话即一切 (Chatbot)**
    - **代表产品**: ChatGPT, Manus (早期形态)。
    - **形态**: 聊天界面。
    - **问题**: “信息的黑洞”。用户必须手动复制粘贴输入输出，AI 不知上下文，输出难以直接应用。
2.  **第二阶段：Copilot 模式**
    - **代表产品**: GitHub Copilot, Cursor。
    - **形态**: 嵌入 IDE (集成开发环境)。
    - **局限**: 隐含假设是“工作环境 = 代码编辑器”。这对程序员有效，但对产品经理、运营、分析师等**非开发者**无效，因为数据散落在文档、SaaS、数据库中，没有统一的 IDE。
3.  **第三阶段：Workspace 模式 (当前趋势)**
    - **代表产品**: Claude Artifacts, OpenAI Canvas, Flowith, 以及 Claude 新出的 "Cowork" 概念。
    - **形态**: **工具适配用户**。建立一个空间，把 AI 需要的数据源接进来。
    - **UniLot 的定位**: 正是属于这一阶段的探索，旨在为非开发者提供一个类似 IDE 的统一工作空间。

### 二、 市场痛点：为什么用户觉得现有工具不够好？

作者指出了当前非开发者用户面临的**三个核心困境**：

1.  **信息割裂 (Information Silos)**
    - 真实工作流涉及截图、文档、数据库、设计稿等多个系统。
    - Chatbot 只能看到用户粘贴的那一小段文字，**AI 的能力上限被“能不能访问信息”锁死了**。
2.  **输出无处安放 (Output Fragmentation)**
    - AI 生成了内容（如 SQL、图表），但用户还得手动复制到飞书、Excel 调整格式。AI 是“生成器”而非“工作流的一部分”。
3.  **理解偏差的代价 (Cost of Misunderstanding)**
    - 全自动 Agent (如 Manus) 容易出错。如果一开始理解错了业务语义（比如“最近 7 天”的定义），跑完全流程才发现错误，前面的等待全是浪费。

### 三、 UniLot 的核心解法：域内共建 (Co-construction)

这是文章最精彩的部分。作者并没有追求“全自动”，而是选择了 **“人机共建”**。

#### 1. 核心理念：Hierarchical (层级系统) 统一一切

作者提出了一个深刻的技术洞见：AI 需要处理的三种信息，都可以用**文件系统（层级结构）**作为统一原语。

| 信息类型           | 定义               | 传统做法   | UniLot 做法 (文件化) | 技术支撑                                      |
| :----------------- | :----------------- | :--------- | :------------------- | :-------------------------------------------- |
| **Memory (长期)**  | 跨会话知识、经验   | 向量数据库 | **摘要树、知识文档** | **RAPTOR**: 递归构建层级树，更懂长文本        |
| **Data (中期)**    | 数据库、文档       | API 连接器 | **映射为虚拟文件**   | 将数据库表视为文件夹/文件                     |
| **Context (短期)** | 当前对话、临时输出 | 内存注入   | **工具输出即文件**   | **Cursor 模式**: 动态发现上下文，而非静态注入 |

**为什么选择“文件”作为抽象？**

- **层级结构**: 天然对应知识树。
- **增量访问**: AI 按需读取 (grep/open)，无需一次性把几百万字塞给模型 (省 Token)。
- **用户熟悉**: 每个人都懂文件夹和文件，不需要学习新概念。

#### 2. 交互模式对比：全自动 vs. 共建

- **Manus (全自动) 的风险**: 用户给一个模糊指令 -> AI 猜测并全自动执行 -> 结果不对 -> 全部推翻重来。用户像个旁观者，不仅心累，还不可控。
- **UniLot (共建) 的流程**:
  1.  用户写一点需求。
  2.  AI 调研现有资源（层级搜索），问：“你想用这张表吗？”
  3.  用户确认或修正。
  4.  AI 执行一步，展示结果。
  5.  用户基于结果继续调整。
  - **优势**: **实时纠偏**。用户始终掌控方向，AI 处理繁琐细节。

### 四、 实际产品形态与技术实现

UniLot 的具象化形态是一个 **“由于数据源驱动的类 IDE 编辑器”**。

- **界面**: 左侧不是聊天历史，而是 **Explorer (资源管理器)**。
  - 它可以挂载：本地文件夹 + MySQL 表 + ClickHouse + 飞书文档。
  - 在 AI 眼里，MySQL 的一张表就是一个文件，可以读取 Schema，可以查询数据。
- **技术架构**:
  - 基于 **VSCode OSS** 魔改 (站在巨人的肩膀上)。
  - **统一数据源层**: 抽象了 DataSource 协议，不管是云盘还是数据库，都适配成标准接口。
  - **ReAct 循环**: AI 通过 Read/Write/Search 等工具操作这些“文件”。

### 五、 总结与启示

这篇文章不仅仅是一个 Side Project 的介绍，更是一篇关于 **AI Native 应用设计哲学** 的深度思考：

1.  **不要迷信 Chatbot**: 对话框是信息的黑洞，对于复杂专业工作流，Chatbot 效率极低。
2.  **从“更聪明”转向“更懂语境”**: 护城河不在于模型多强，而在于如何让模型最低成本地获取用户所有的**上下文 (Memory/Data/Context)**。
3.  **回归简单原语**: 用最古老、最稳健的 **“文件系统”** 概念，去承载最前沿的 AI 记忆和检索需求 (RAG)，这是一种非常优雅的工程审美。

正如作者 Zylan 所说：**“最好的范式也许更像一个自定义的语义空间”**。UniLot 试图让 AI 只有在真正看到你所有的数据、文档和历史后，才能真正成为你的 Co-worker。

---

根据文档详细描述，UniLot 的设计实现围绕着将一切信息抽象为“文件系统层级”这一核心理念，具体的技术实现方案如下：

### 1. 基础架构：站在巨人的肩膀上

- **核心基座**：基于 **VSCode OSS**（VSCode 开源版本）进行魔改。
  - _理由_：利用现成熟的 IDE 框架，复用其强大的编辑器、文件资源管理器和插件系统，避免从零构建复杂的编辑器 UI。

### 2. 核心抽象层：统一数据源协议 (Unified Data Source Layer)

这是整个系统的灵魂。不论是云端文档还是数据库，都被抽象为标准的文件系统接口。

- **数据源映射**：
  - **本地文件**：直接挂载。
  - **数据库 (MySQL/ClickHouse)**：表（Table）被映射为虚拟文件。
    - Schema 读取 -> 文件内容预览。
    - 数据查询 -> 文件读取/搜索操作。
  - **SaaS 文档 (飞书/Notion)**：通过 API 映射为虚拟文件树。
- **协议适配**：即实现一个中间层，让 AI 觉得它在操作这一堆异构数据时，就是在操作普通的本地文件（open, read, grep）。

### 3. AI 交互逻辑：ReAct 循环与工具链

AI 不再是单纯的对话模型，而是通过操作“文件”来完成任务。

- **ReAct 循环**：AI 处于一个 观察(Observe) -> 思考(Think) -> 行动(Act) 的循环中。
- **工具集 (Tools)**：
  - `Read`: 读取文件内容（或读取数据库表结构）。
  - `Search`: 搜索文件（或查询数据库数据）。
  - `Write`: 写入文件（生成代码、SQL、文档草稿）。
  - `Grep`: 在大量数据中检索关键信息。

### 4. 上下文管理：以层级结构为核心

基于 **“Hierarchical (层级系统) 统一一切”** 的理念处理三种维度的信息：

- **长期记忆 (Memory)**：
  - **技术**: **RAPTOR** (递归构建层级树)。
  - **实现**: 将长文档、跨会话知识递归生成摘要树，存为文件结构，供 AI 按层级检索。
- **中期数据 (Data)**：
  - **技术**: 虚拟文件系统映射。
  - **实现**: 数据库表即文件，AI 按需挂载和读取，而非一次性注入 Context Window。
- **短期语境 (Context)**：
  - **技术**: **Cursor 模式** (动态发现)。
  - **实现**: 将工具的输出、对话历史都视为产生的新“文件”。AI 通过搜索这些临时文件来获取上下文，而不是被动等待 Prompt 注入，节省 Token 并提高准确度。

### 总结

实现的核心在于**“去 Chatbot 化”和“类 IDE 化”**。不构建一个新的聊天界面，而是构建一个能够连接所有数据孤岛的**资源管理器**，让 AI 像程序员在 IDE 里操作代码文件一样，去操作业务人员的数据和文档。

---

**VSCode OSS (Visual Studio Code Open Source Software)** 是目前全球最流行的代码编辑器 Visual Studio Code 的开源核心代码库，托管在 GitHub 上 (`microsoft/vscode`)。

在文章提到的 UniLot 项目中，作者选择“站在巨人的肩膀上”魔改 VSCode OSS，这是一个非常经典且明智的技术决策。

以下是对 VSCode OSS 的深度技术讲解，包括它是什么、核心架构、关键扩展能力以及它与微软官方 VS Code 的区别。

### 1. 什么是 VSCode OSS？

简单来说：**VS Code (官方产品) = VSCode OSS (源码) + 微软专有配置 + 遥测 (Telemetry) + 官方图标/品牌。**

- **VSCode OSS**：是基于 MIT 协议开源的代码仓库。任何人都可以拉取代码、编译并构建自己的编辑器。
- **VS Code (微软发布版)**：是微软基于 OSS 构建的二进制发行版。它包含了一些微软专有的定制（如同步设置服务器、特定的调试器许可证），并受微软的使用条款约束。

### 2. 核心架构：为什么它适合作为基座？

VSCode OSS 之所以被 Cursor、UniLot、Windsurf 等 AI 编辑器选为基座，是因为它有着极度灵活、解耦的架构。

#### A. 进程隔离架构 (Process Isolation)

VS Code 为了保证稳定性，采用了多进程架构：

1.  **主进程 (Main Process)**：基于 Electron，负责窗口管理、菜单、生命周期。
2.  **渲染进程 (Renderer Process)**：负责 UI 显示，其中核心组件是 **Monaco Editor**（极为强大的代码编辑控件）。
3.  **扩展宿主进程 (Extension Host)**：**这是最关键的设计**。所有的插件（Extensions）都运行在一个独立的 Node.js 进程中。
    - _优势_：即便某个插件（比如 UniLot 的 AI 逻辑）卡死或崩溃，主界面（编辑器）依然流畅响应，不会带着整个软件一起崩溃。

#### B. 核心协议 (LSP & DAP)

VSCode OSS 定义了行业标准协议，使得任何语言/工具都能轻松接入：

- **LSP (Language Server Protocol)**：让编辑器“听懂”任何语言（跳转定义、补全）。
- **DAP (Debug Adapter Protocol)**：让编辑器“调试”任何语言。

### 3. UniLot 依赖的关键 API：为何能“统一一切”？

UniLot 的核心理念是“将数据库/文档映射为文件”，这完全依赖于 VSCode OSS 提供的几个强大 API：

#### A. FileSystemProvider API (虚拟文件系统)

这是 UniLot 实现“数据库表即文件”的核心。

- **原理**：VSCode 允许插件注册一个 `scheme`（例如 `mysql://` 或 `notion://`）。
- **作用**：当 VSCode 试图读取 `mysql://users.table` 时，它不会去读磁盘，而是调用插件提供的 `readFile()` 方法。插件可以在这个方法里执行 SQL 查询，把结果转换成文本返回。
- **结果**：对用户和 AI 来说，数据库就像普通的本地文件夹一样，可以用 `grep` 搜索，用编辑器打开。

#### B. Custom Editor API (自定义编辑器)

- **原理**：允许插件接管文件的渲染方式。
- **作用**：当你打开一个 `.csv` 或数据库查询结果时，插件可以用 HTML/React 渲染一个漂亮的交互式表格，而不是纯文本。

#### C. TreeView API (侧边栏视图)

- **作用**：允许插件自定义左侧的资源管理器（Explorer）。UniLot 正是利用这一点，构建了一个统一展示本地文件、数据库表和云端文档的“超级资源管理器”。

### 4. VSCode OSS vs. 微软官方 VS Code 的区别

对于开发者或二次开发者（如 UniLot 作者），理解以下区别很重要：

| 特性         | VSCode OSS (开源版)                    | VS Code (微软官方版)    | 影响                         |
| :----------- | :------------------------------------- | :---------------------- | :--------------------------- |
| **构建**     | 需自行编译 (`yarn watch`)              | 官方提供安装包          | 二次开发必须用 OSS           |
| **插件市场** | 默认无，或配置 Open VSX                | Microsoft Marketplace   | OSS 无法直接合法使用微软市场 |
| **遥测**     | 默认移除                               | 包含微软数据收集        | OSS 更隐私安全               |
| **专有功能** | **无** (无 Remote-SSH, Dev Containers) | **有** (这部分源码闭源) | 二次开发版很难支持远程开发   |
| **配置文件** | `product.json` (未配置)                | 包含 API Keys 和 URL    | OSS 需自行配置服务地址       |

### 5. 著名的基于 VSCode OSS 的项目

UniLot 并不是唯一一个这么做的，它加入了一个庞大的生态：

1.  **Cursor**: 目前最火的 AI 编辑器，基于 VSCode OSS 魔改，深度集成了 AI 补全和 Chat。
2.  **VSCodium**: 一个纯净构建版。它就是 VSCode OSS 编译出来的二进制文件，去除了微软的遥测，旨在提供隐私保护。
3.  **GitPod / Codespaces**: 浏览器端的云 IDE，核心也是基于 VSCode OSS (Web 版)。

### 总结

对于 UniLot 来说，选择 VSCode OSS 意味着：

1.  **省去了 90% 的工作量**：不用重写文本编辑器、文件管理、插件系统、语法高亮。
2.  **专注于 10% 的核心创新**：利用 **FileSystemProvider** 将所有异构数据（Database, SaaS）伪装成文件，让 AI 在一个统一的“文件宇宙”里通过标准的文件操作（Read/Write）来完成复杂的业务逻辑。

这是一种极为高效的工程实现路径，用成熟的底层架构来承载前卫的产品理念。
