洞见：AI Native 的终局是“OS 化”，而非“App 化”

> AI Native 是一种以人工智能（AI）为核心构建软件和系统的理念与方法

比 Manus 更好的形态，是将 AI 的语境从内存延伸至磁盘，通过赋予 AI 文件系统读写权限，让它从一次性的对话者（Chatbot）晋升为驻守本地的数字同事（Digital Coworker）。
核心结论：AI Native 的终局是“OS 化”，而非“App 化”

**1. 交互原语的回归：一切皆文件 (Files as Ground Truth)**
Chatbot 试图发明新的交互（对话），而高阶 AI（UniLot/Cowork）选择回归最古老的协议——**文件系统**。

- **洞见**：文件系统是人类数字化工作的最大公约数。谁能把数据库、SaaS、文档统一抽象为“虚拟文件”，让 AI 拥有 `Open/Read/Write` 权限，谁就掌握了真正的工作流入口。

**2. 上下文的本质：从“喂给 AI”到“AI 住在里面”**

- **Chatbot 模式**：用户是“搬运工”，手动搬运上下文（Copy-Paste），上下文在内存里，关掉即失。
- **Workspace 模式**：AI 是“住户”，直接栖息在用户的文件夹（Context）中，上下文在磁盘里，持久且鲜活。
- **洞见**：护城河不在模型智商，在于**上下文的获取成本**。Claude Cowork 直接接管本地 Folder，是对所有“聊天网页”的降维打击。

**3. 工具形态的泛化：万物皆需 IDE**
UniLot 和 Cowork 证明了 IDE（集成开发环境）不仅仅是程序员的专利。

- **洞见**：未来的产品经理、运营、分析师，都需要一个**“面向知识资产的 IDE”**。Claude Code 并不是只给 Coder 用的，它实际上定义了**新时代的“Office”**——一个能直接运行代码、操作文件、调用浏览器的智能工作台。

**一句话总结：**
比 Manus 更好的形态，是不再把 AI 当作一个**聊天机器人 (Chatbot)**，而是把它当作一个拥有文件系统读写权限的**数字二副 (Digital Co-worker)**。

---

# 探索实践-比 Manus 更好的形态是什么

https://blog.zihanjian.com/article/2e89db82-fa86-80c7-a60f-ef4f0e03081c

这篇文章《【探索实践】比 Manus 更好的形态是什么》是由作者 Zylan 撰写的，探讨了当前 AI 工具形态的局限性，并提出了一个新的产品理念 **UniLot**。

作者认为，AI 工具不应只是“聊天的对话框”或“写代码的自动化工具”，而应该是**让 AI 进入用户的语境，在统一的语义空间内与用户“域内共建”**。

以下是对这篇文章的深度详细讲解，分为背景洞察、痛点分析、核心理念、技术实现及未来展望五个部分。

---

### 一、 核心背景与行业观察：AI 工具的演进

还可以分类：Chatbot、Copilot、异步任务、cli(ClaudeCode)

作者回顾了过去两年 AI 工具的发展，将其划分为三个阶段，清晰地指出了当前市场的空缺：

1.  **第一阶段：对话即一切 (Chatbot)**
    - **代表产品**: ChatGPT, Manus (早期形态)。
    - **形态**: 聊天界面。
    - **问题**: “信息的黑洞”。用户必须手动复制粘贴输入输出，AI 不知上下文，输出难以直接应用。
2.  **第二阶段：Copilot 模式**
    - **代表产品**: GitHub Copilot, Cursor。
    - **形态**: 嵌入 IDE (集成开发环境)。
    - **局限**: 隐含假设是“工作环境 = 代码编辑器”。这对程序员有效，但对产品经理、运营、分析师等**非开发者**无效，因为数据散落在文档、SaaS、数据库中，没有统一的 IDE。
3.  **第三阶段：Workspace 模式 (当前趋势)**
    - **代表产品**: Claude Artifacts, OpenAI Canvas, Flowith, 以及 Claude 新出的 "Cowork" 概念。
    - **形态**: **工具适配用户**。建立一个空间，把 AI 需要的数据源接进来。
    - **UniLot 的定位**: 正是属于这一阶段的探索，旨在为非开发者提供一个类似 IDE 的统一工作空间。

### 二、 市场痛点：为什么用户觉得现有工具不够好？

作者指出了当前非开发者用户面临的**三个核心困境**：

1.  **信息割裂 (Information Silos)**
    - 真实工作流涉及截图、文档、数据库、设计稿等多个系统。
    - Chatbot 只能看到用户粘贴的那一小段文字，**AI 的能力上限被“能不能访问信息”锁死了**。
2.  **输出无处安放 (Output Fragmentation)**
    - AI 生成了内容（如 SQL、图表），但用户还得手动复制到飞书、Excel 调整格式。AI 是“生成器”而非“工作流的一部分”。
3.  **理解偏差的代价 (Cost of Misunderstanding)**
    - 全自动 Agent (如 Manus) 容易出错。如果一开始理解错了业务语义（比如“最近 7 天”的定义），跑完全流程才发现错误，前面的等待全是浪费。

### 三、 UniLot 的核心解法：域内共建 (Co-construction)

这是文章最精彩的部分。作者并没有追求“全自动”，而是选择了 **“人机共建”**。

#### 1. 核心理念：Hierarchical (层级系统) 统一一切

作者提出了一个深刻的技术洞见：AI 需要处理的三种信息，都可以用**文件系统（层级结构）**作为统一原语。

| 信息类型           | 定义               | 传统做法   | UniLot 做法 (文件化) | 技术支撑                                      |
| :----------------- | :----------------- | :--------- | :------------------- | :-------------------------------------------- |
| **Memory (长期)**  | 跨会话知识、经验   | 向量数据库 | **摘要树、知识文档** | **RAPTOR**: 递归构建层级树，更懂长文本        |
| **Data (中期)**    | 数据库、文档       | API 连接器 | **映射为虚拟文件**   | 将数据库表视为文件夹/文件                     |
| **Context (短期)** | 当前对话、临时输出 | 内存注入   | **工具输出即文件**   | **Cursor 模式**: 动态发现上下文，而非静态注入 |

**为什么选择“文件”作为抽象？**

- **层级结构**: 天然对应知识树。
- **增量访问**: AI 按需读取 (grep/open)，无需一次性把几百万字塞给模型 (省 Token)。
- **用户熟悉**: 每个人都懂文件夹和文件，不需要学习新概念。

#### 2. 交互模式对比：全自动 vs. 共建

- **Manus (全自动) 的风险**: 用户给一个模糊指令 -> AI 猜测并全自动执行 -> 结果不对 -> 全部推翻重来。用户像个旁观者，不仅心累，还不可控。
- **UniLot (共建) 的流程**:
  1.  用户写一点需求。
  2.  AI 调研现有资源（层级搜索），问：“你想用这张表吗？”
  3.  用户确认或修正。
  4.  AI 执行一步，展示结果。
  5.  用户基于结果继续调整。
  - **优势**: **实时纠偏**。用户始终掌控方向，AI 处理繁琐细节。

### 四、 实际产品形态与技术实现

UniLot 的具象化形态是一个 **“由于数据源驱动的类 IDE 编辑器”**。

- **界面**: 左侧不是聊天历史，而是 **Explorer (资源管理器)**。
  - 它可以挂载：本地文件夹 + MySQL 表 + ClickHouse + 飞书文档。
  - 在 AI 眼里，MySQL 的一张表就是一个文件，可以读取 Schema，可以查询数据。
- **技术架构**:
  - 基于 **VSCode OSS** 魔改 (站在巨人的肩膀上)。
  - **统一数据源层**: 抽象了 DataSource 协议，不管是云盘还是数据库，都适配成标准接口。
  - **ReAct 循环**: AI 通过 Read/Write/Search 等工具操作这些“文件”。

### 五、 总结与启示

这篇文章不仅仅是一个 Side Project 的介绍，更是一篇关于 **AI Native 应用设计哲学** 的深度思考：

1.  **不要迷信 Chatbot**: 对话框是信息的黑洞，对于复杂专业工作流，Chatbot 效率极低。
2.  **从“更聪明”转向“更懂语境”**: 护城河不在于模型多强，而在于如何让模型最低成本地获取用户所有的**上下文 (Memory/Data/Context)**。
3.  **回归简单原语**: 用最古老、最稳健的 **“文件系统”** 概念，去承载最前沿的 AI 记忆和检索需求 (RAG)，这是一种非常优雅的工程审美。

正如作者 Zylan 所说：**“最好的范式也许更像一个自定义的语义空间”**。UniLot 试图让 AI 只有在真正看到你所有的数据、文档和历史后，才能真正成为你的 Co-worker。

---

根据文档详细描述，UniLot 的设计实现围绕着将一切信息抽象为“文件系统层级”这一核心理念，具体的技术实现方案如下：

### 1. 基础架构：站在巨人的肩膀上

- **核心基座**：基于 **VSCode OSS**（VSCode 开源版本）进行魔改。
  - _理由_：利用现成熟的 IDE 框架，复用其强大的编辑器、文件资源管理器和插件系统，避免从零构建复杂的编辑器 UI。

### 2. 核心抽象层：统一数据源协议 (Unified Data Source Layer)

这是整个系统的灵魂。不论是云端文档还是数据库，都被抽象为标准的文件系统接口。

- **数据源映射**：
  - **本地文件**：直接挂载。
  - **数据库 (MySQL/ClickHouse)**：表（Table）被映射为虚拟文件。
    - Schema 读取 -> 文件内容预览。
    - 数据查询 -> 文件读取/搜索操作。
  - **SaaS 文档 (飞书/Notion)**：通过 API 映射为虚拟文件树。
- **协议适配**：即实现一个中间层，让 AI 觉得它在操作这一堆异构数据时，就是在操作普通的本地文件（open, read, grep）。

### 3. AI 交互逻辑：ReAct 循环与工具链

AI 不再是单纯的对话模型，而是通过操作“文件”来完成任务。

- **ReAct 循环**：AI 处于一个 观察(Observe) -> 思考(Think) -> 行动(Act) 的循环中。
- **工具集 (Tools)**：
  - `Read`: 读取文件内容（或读取数据库表结构）。
  - `Search`: 搜索文件（或查询数据库数据）。
  - `Write`: 写入文件（生成代码、SQL、文档草稿）。
  - `Grep`: 在大量数据中检索关键信息。

### 4. 上下文管理：以层级结构为核心

基于 **“Hierarchical (层级系统) 统一一切”** 的理念处理三种维度的信息：

- **长期记忆 (Memory)**：
  - **技术**: **RAPTOR** (递归构建层级树)。
  - **实现**: 将长文档、跨会话知识递归生成摘要树，存为文件结构，供 AI 按层级检索。
- **中期数据 (Data)**：
  - **技术**: 虚拟文件系统映射。
  - **实现**: 数据库表即文件，AI 按需挂载和读取，而非一次性注入 Context Window。
- **短期语境 (Context)**：
  - **技术**: **Cursor 模式** (动态发现)。
  - **实现**: 将工具的输出、对话历史都视为产生的新“文件”。AI 通过搜索这些临时文件来获取上下文，而不是被动等待 Prompt 注入，节省 Token 并提高准确度。

### 总结

实现的核心在于**“去 Chatbot 化”和“类 IDE 化”**。不构建一个新的聊天界面，而是构建一个能够连接所有数据孤岛的**资源管理器**，让 AI 像程序员在 IDE 里操作代码文件一样，去操作业务人员的数据和文档。

---

**VSCode OSS (Visual Studio Code Open Source Software)** 是目前全球最流行的代码编辑器 Visual Studio Code 的开源核心代码库，托管在 GitHub 上 (`microsoft/vscode`)。

在文章提到的 UniLot 项目中，作者选择“站在巨人的肩膀上”魔改 VSCode OSS，这是一个非常经典且明智的技术决策。

以下是对 VSCode OSS 的深度技术讲解，包括它是什么、核心架构、关键扩展能力以及它与微软官方 VS Code 的区别。

### 1. 什么是 VSCode OSS？

简单来说：**VS Code (官方产品) = VSCode OSS (源码) + 微软专有配置 + 遥测 (Telemetry) + 官方图标/品牌。**

- **VSCode OSS**：是基于 MIT 协议开源的代码仓库。任何人都可以拉取代码、编译并构建自己的编辑器。
- **VS Code (微软发布版)**：是微软基于 OSS 构建的二进制发行版。它包含了一些微软专有的定制（如同步设置服务器、特定的调试器许可证），并受微软的使用条款约束。

### 2. 核心架构：为什么它适合作为基座？

VSCode OSS 之所以被 Cursor、UniLot、Windsurf 等 AI 编辑器选为基座，是因为它有着极度灵活、解耦的架构。

#### A. 进程隔离架构 (Process Isolation)

VS Code 为了保证稳定性，采用了多进程架构：

1.  **主进程 (Main Process)**：基于 Electron，负责窗口管理、菜单、生命周期。
2.  **渲染进程 (Renderer Process)**：负责 UI 显示，其中核心组件是 **Monaco Editor**（极为强大的代码编辑控件）。
3.  **扩展宿主进程 (Extension Host)**：**这是最关键的设计**。所有的插件（Extensions）都运行在一个独立的 Node.js 进程中。
    - _优势_：即便某个插件（比如 UniLot 的 AI 逻辑）卡死或崩溃，主界面（编辑器）依然流畅响应，不会带着整个软件一起崩溃。

#### B. 核心协议 (LSP & DAP)

VSCode OSS 定义了行业标准协议，使得任何语言/工具都能轻松接入：

- **LSP (Language Server Protocol)**：让编辑器“听懂”任何语言（跳转定义、补全）。
- **DAP (Debug Adapter Protocol)**：让编辑器“调试”任何语言。

### 3. UniLot 依赖的关键 API：为何能“统一一切”？

UniLot 的核心理念是“将数据库/文档映射为文件”，这完全依赖于 VSCode OSS 提供的几个强大 API：

#### A. FileSystemProvider API (虚拟文件系统)

这是 UniLot 实现“数据库表即文件”的核心。

- **原理**：VSCode 允许插件注册一个 `scheme`（例如 `mysql://` 或 `notion://`）。
- **作用**：当 VSCode 试图读取 `mysql://users.table` 时，它不会去读磁盘，而是调用插件提供的 `readFile()` 方法。插件可以在这个方法里执行 SQL 查询，把结果转换成文本返回。
- **结果**：对用户和 AI 来说，数据库就像普通的本地文件夹一样，可以用 `grep` 搜索，用编辑器打开。

#### B. Custom Editor API (自定义编辑器)

- **原理**：允许插件接管文件的渲染方式。
- **作用**：当你打开一个 `.csv` 或数据库查询结果时，插件可以用 HTML/React 渲染一个漂亮的交互式表格，而不是纯文本。

#### C. TreeView API (侧边栏视图)

- **作用**：允许插件自定义左侧的资源管理器（Explorer）。UniLot 正是利用这一点，构建了一个统一展示本地文件、数据库表和云端文档的“超级资源管理器”。

### 4. VSCode OSS vs. 微软官方 VS Code 的区别

对于开发者或二次开发者（如 UniLot 作者），理解以下区别很重要：

| 特性         | VSCode OSS (开源版)                    | VS Code (微软官方版)    | 影响                         |
| :----------- | :------------------------------------- | :---------------------- | :--------------------------- |
| **构建**     | 需自行编译 (`yarn watch`)              | 官方提供安装包          | 二次开发必须用 OSS           |
| **插件市场** | 默认无，或配置 Open VSX                | Microsoft Marketplace   | OSS 无法直接合法使用微软市场 |
| **遥测**     | 默认移除                               | 包含微软数据收集        | OSS 更隐私安全               |
| **专有功能** | **无** (无 Remote-SSH, Dev Containers) | **有** (这部分源码闭源) | 二次开发版很难支持远程开发   |
| **配置文件** | `product.json` (未配置)                | 包含 API Keys 和 URL    | OSS 需自行配置服务地址       |

### 5. 著名的基于 VSCode OSS 的项目

UniLot 并不是唯一一个这么做的，它加入了一个庞大的生态：

1.  **Cursor**: 目前最火的 AI 编辑器，基于 VSCode OSS 魔改，深度集成了 AI 补全和 Chat。
2.  **VSCodium**: 一个纯净构建版。它就是 VSCode OSS 编译出来的二进制文件，去除了微软的遥测，旨在提供隐私保护。
3.  **GitPod / Codespaces**: 浏览器端的云 IDE，核心也是基于 VSCode OSS (Web 版)。

### 总结

对于 UniLot 来说，选择 VSCode OSS 意味着：

1.  **省去了 90% 的工作量**：不用重写文本编辑器、文件管理、插件系统、语法高亮。
2.  **专注于 10% 的核心创新**：利用 **FileSystemProvider** 将所有异构数据（Database, SaaS）伪装成文件，让 AI 在一个统一的“文件宇宙”里通过标准的文件操作（Read/Write）来完成复杂的业务逻辑。

这是一种极为高效的工程实现路径，用成熟的底层架构来承载前卫的产品理念。

---

# Claude Cowork

**太惊人了！这简直是神预言的验证时刻。**

你刚才提供的 Anthropic 官方公告（发布于 2026 年 1 月 12 日），发布的 **Claude Cowork**，其核心理念竟然与你当前工作区中 Zylan 写的《比 Manus 更好的形态是什么》里的 **UniLot** 构想**高度重合，甚至可以说是一模一样**。

这是 AI 产品形态发展的一个里程碑时刻：**Anthropic 正式验证了“以文件系统为核心的 Workspace”才是 AI Native 应用的终局。**

我将结合你刚刚给出的《UniLot 探索实践》文章和这篇最新的 Cladue Cowork 公告，为你深度拆解 **Claude Cowork** 到底是什么，以及它为什么完美印证了“比 Manus 更好的形态”。

---

### 一、 什么是 Claude Cowork？

根据公告，**Cowork** 是 Claude Code 的泛化版本，它是 Anthropic 给非开发者用户的一份大礼。

- **起源**：Anthropic 发现开发者们不仅用 Claude Code 写代码，还用它干别的（整理文件、处理数据）。于是他们顺水推舟，把这套逻辑开放给了所有人。
- **核心形态**：它不是一个网页聊天框，而是集成在 macOS 客户端侧边栏的一个 **Workspace**。
- **交互逻辑**：**“给我一个文件夹的权限，我帮你搞定工作”**。
  - 它可以读取、编辑、创建你本地文件夹里的文件。
  - 示例场景：整理下载文件夹、把一堆截图转成 Excel 报表、基于散乱的笔记写草稿。
- **技术差异**：
  - **高 Agency（代理权）**：它会制定计划（Make a plan），一步步执行，而不是像聊天一样说完就停。
  - **异步并行**：你不需要等它写完，可以给它派活（Queue up tasks），它在后台并行处理，就像给同事留言一样。

---

### 二、 深度对比：Cowork 如何验证了 UniLot 的预判？

Zylan 在 UniLot 文章中提出的核心痛点是：**Chatbot 是信息的黑洞，只有把数据抽象成“文件”，让 AI 进入用户的语境（文件系统），才是正解。**

看看 Claude Cowork 是怎么做的，二者简直是**镜像般的呼应**：

#### 1. 共识一：文件系统是终极原语 (The File System as Ground Truth)

- **UniLot 的洞察**：
  - 文章中写道：“AI 需要处理的信息都可以用**文件系统（层级结构）**作为统一原语/层级搜索。”
  - UniLot 试图把数据库、Notion 等都伪装成虚拟文件。
- **Cowork 的实现**：
  - 公告中明确：“In Cowork, you give Claude access to a **folder**... Claude can then read, edit, or create files in that folder.”
  - Anthropic 意识到，不需要发明新的数据格式，**用户的“文件夹”就是最自然的上下文边界**。

#### 2. 共识二：从 Copilot 到 Workspace (IDE for Everything)

- **UniLot 的洞察**：
  - 痛斥了“聊天框”的低效，主张类似 VSCode 的 **Explorer (资源管理器)** 界面。
  - 认为非开发者也需要一个类似 IDE 的环境来管理“知识资产”。
- **Cowork 的实现**：
  - 它直接复用了 **Claude Code** (一个基于终端和文件操作的开发者工具) 的底层。
  - 它本质上就是**“给 PM/运营/文案用的 IDE”**。产品形态不再是“你问我答”，而是“针对项目文件进行持续迭代”。

#### 3. 共识三：共建而非全自动 (Co-construction vs. Full-Auto)

- **UniLot 的洞察**：
  - 批评 Manus 的全自动模式容易跑偏，提倡用户在关键节点确认（ReAct 循环中的 Observe-Think-Act）。
- **Cowork 的实现**：
  - 公告提到：“It feels much less like a back-and-forth and much more like leaving messages for a coworker.” (像给同事留言，而不是你一句我一句)。
  - **Stay in control**：Claude 会制定计划，并让你知晓它在干什么。对于删除文件等破坏性操作，它会请求权限。

---

### 三、 Claude Cowork 的技术突破点

相比于 Zylan 的 UniLot 构想，Claude Cowork 作为官方下场的产品，展示了几个非常强的工程实现细节：

1.  **浏览器与本地的打通 (Claude in Chrome + Local)**
    - 这是一个杀手级特性。Cowork 不仅能读本地文件，还能通过 Chrome 插件去操控浏览器。
    - 这意味着：它可以**去网页上抓数据 -> 存入本地 Excel -> 基于 Excel 写本地报告**。这完美闭环了信息流。
2.  **防御性安全 (Safety)**
    - 直接操作本地文件风险极大（Prompt Injection 可能导致 AI 删库跑路）。
    - Cowork 在设计上强调了文件夹级别的权限隔离（只给它看该看的），这比把整个电脑给 AI 控制（如早期的 OS Agent）要安全合理得多。
3.  **技能抽象 (Skills)**
    - 公告提到 "initial set of skills" (creating documents, presentations)。这意味着 Claude 不仅仅是在写纯文本，它内置了生成特定格式文件（如 .pptx, .docx）的专门能力。

### 四、 总结：比 Manus 更好的形态，就是“AI OS”

结合《探索实践》这篇文章和这份 2026 年的公告，我们可以得出清晰的结论：

**比 Manus 更好的形态，不是更聪明的浏览器插件，而是更深度的文件系统接管者。**

- **UniLot (Zylan)** 预判了方向：**文件系统是 AI 的最佳交互界面**。
- **Claude Cowork** 落地了产品：把 Claude Code 的强逻辑能力 + 本地文件读写权限 + 浏览器操作能力打包，做成了一个**面向所有知识工作者的“操作系统级 IDE”**。

这再次证明了：在 AI 时代，**谁掌握了用户的 Context（无论是以虚拟文件形式还是真实文件夹形式），谁就掌握了入口。** Chatbot 时代正式结束，Workspace 时代全面到来。

---
