这份文档详细介绍了 **Deep Agents** 的文件系统后端（Backends）配置。Deep Agents 通过 `ls`, `read_file`, `write_file` 等工具向 Agent 暴露文件系统接口，而这些工具的底层实现是可插拔的。

以下是核心内容总结：

### 1. 内置后端类型

| 后端类型 | 描述 | 适用场景 |
| :--- | :--- | :--- |
| **StateBackend** (默认) | 临时存储在 LangGraph 的 Agent 状态中。仅在当前线程内持久化。 | 临时草稿、自动驱逐的大型工具输出。 |
| **FilesystemBackend** | 读写本地磁盘文件。支持沙盒模式 (`virtualMode`)。 | 本地开发、CI 环境、挂载持久卷。 |
| **StoreBackend** | 使用 LangGraph 的 `BaseStore` 进行存储。跨线程持久化。 | 长期记忆、跨对话共享的知识库。 |
| **CompositeBackend** | 路由后端。根据路径前缀将操作分发给不同的后端。 | 混合存储策略（例如 `/memories/` 持久化，其他临时）。 |

### 2. 配置后端

在创建 Agent 时通过 `backend` 参数指定：

```typescript
import { createDeepAgent, FilesystemBackend } from "deepagents";

// 使用本地文件系统
const agent = createDeepAgent({
  backend: new FilesystemBackend({ rootDir: "./workspace", virtualMode: true }),
});
```

### 3. 路由配置 (CompositeBackend)

这是最灵活的方式，允许你混合使用不同的存储策略。

```typescript
import { createDeepAgent, CompositeBackend, StateBackend, StoreBackend } from "deepagents";
import { InMemoryStore } from "@langchain/langgraph";

// 定义混合后端
const compositeBackend = (rt) => new CompositeBackend(
  new StateBackend(rt), // 默认路由：临时状态存储
  {
    "/memories/": new StoreBackend(rt), // /memories/ 路径：持久化存储
  }
);

const store = new InMemoryStore();
const agent = createDeepAgent({ backend: compositeBackend, store });
```

### 4. 自定义后端与策略

*   **虚拟文件系统**: 你可以实现 `BackendProtocol` 接口来创建自定义后端，例如将 S3 或数据库映射为文件系统。
*   **策略钩子**: 可以通过继承或包装现有后端来实施企业策略（例如，禁止写入特定目录）。

### 5. 协议规范

自定义后端必须实现 `BackendProtocol`，包括 `ls_info`, `read`, `write`, `edit`, `glob_info`, `grep_raw` 等方法。这些方法需要返回特定的结构化数据（如 `FileInfo`, `WriteResult`）以供工具层使用。