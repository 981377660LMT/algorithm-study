这份文档详细指南介绍了如何在 **LangChain.js** 中构建 **Custom Middleware (自定义中间件)**。通过实现特定的钩子（Hooks），开发者可以在 Agent 执行流程的关键点进行拦截、修改或控制。

以下是文档的核心内容解析：

### 1. 两种钩子类型 (Hooks)
中间件提供了两种截然不同的拦截方式：

*   **Node-style Hooks (节点式钩子)**
    *   **特点**：在特定时间点顺序执行。
    *   **用途**：日志记录、验证、状态更新。
    *   **可用钩子**：
        *   `beforeAgent` / `afterAgent`：Agent 启动前/结束后（单次调用仅触发一次）。
        *   `beforeModel` / `afterModel`：每次模型调用前后。
*   **Wrap-style Hooks (包裹式钩子)**
    *   **特点**：包裹目标函数的执行，由开发者控制何时（甚至是否）调用原处理函数 `handler`。
    *   **用途**：重试逻辑、结果缓存、动态修改请求参数。
    *   **可用钩子**：
        *   `wrapModelCall`：包裹模型调用。
        *   `wrapToolCall`：包裹工具调用。

### 2. 数据管理：State vs Context
文档区分了两种数据传递方式：

*   **Custom State (`stateSchema`)**
    *   **生命周期**：在 Agent 的整个执行过程中**持久化**。
    *   **用途**：计数器、累加器、内部标志。
    *   **隐私**：以 `_` 开头的字段为私有字段，不会包含在最终返回结果中。
*   **Custom Context (`contextSchema`)**
    *   **生命周期**：**单次调用有效**，只读，不持久化。
    *   **用途**：传递外部元数据，如 `userId`、`tenantId`、`apiKey`。
    *   **强制性**：如果在 Schema 中定义了必填项，调用 `agent.invoke()` 时必须传入，否则会有 TypeScript 类型错误。

### 3. 流程控制 (Agent Jumps)
中间件可以通过返回 `jumpTo` 指令来改变执行流，实现“短路”或跳转：
*   `jumpTo: "end"`：立即结束 Agent 执行（常用于拦截违规内容）。
*   `jumpTo: "model"`：跳回模型节点。
*   `jumpTo: "tools"`：跳转到工具节点。

### 4. 执行顺序
当注册多个中间件时（如 `[m1, m2, m3]`），执行顺序遵循“洋葱模型”：
1.  **Before Hooks**：顺序执行 (m1 -> m2 -> m3)。
2.  **Wrap Hooks**：嵌套执行 (m1 包裹 m2，m2 包裹 m3)。
3.  **After Hooks**：**逆序**执行 (m3 -> m2 -> m1)。

### 5. 常见应用场景示例
文档提供了几个实用的代码模式：
*   **动态模型选择**：根据消息长度或复杂度，在 `wrapModelCall` 中动态切换 `gpt-4o` 和 `gpt-4o-mini`。
*   **工具监控**：在 `wrapToolCall` 中记录工具的输入参数和执行结果。
*   **动态工具筛选**：在调用模型前，根据上下文动态过滤掉不相关的工具，减少 Token 消耗。
*   **修改 System Message**：利用 `request.systemMessage.concat` 动态追加系统提示词。