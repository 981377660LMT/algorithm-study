这份文档详细介绍了 **LangChain.js 中的多智能体系统 (Multi-agent Systems)**。

多智能体系统通过将复杂的应用程序分解为多个协同工作的专业 Agent 来解决问题。这种架构比单一的全能 Agent 更适合处理复杂任务、管理庞大的上下文或需要特定领域专业知识的场景。

以下是文档的核心内容解读：

### 1. 两种核心模式 (Patterns)

文档主要介绍了两种多智能体协作模式：

| 模式 | **Tool Calling (工具调用)** | **Handoffs (移交)** |
| :--- | :--- | :--- |
| **工作原理** | 一个**主管 (Supervisor)** Agent 将其他 Agent 视为“工具”来调用。子 Agent 执行任务并返回结果，不直接与用户对话。 | 当前 Agent 决定将控制权**完全移交**给另一个 Agent。新的 Agent 直接与用户交互，直到它决定再次移交或结束。 |
| **控制流** | **中心化**：所有路由都经过主管 Agent。 | **去中心化**：Agent 之间可以互相传递控制权。 |
| **适用场景** | 任务编排、结构化工作流。 | 多领域对话、专家介入（如客服转接技术支持）。 |
| **用户交互** | 用户只与主管 Agent 对话。 | 用户与当前活跃的 Agent 对话。 |

### 2. 上下文工程 (Context Engineering)
多智能体设计的核心在于**上下文工程**，即决定每个 Agent 能看到什么信息。你需要控制：
*   传递给每个 Agent 的对话历史或状态部分。
*   针对子 Agent 的专用提示词 (Prompts)。
*   输入/输出格式的定制。

### 3. Tool Calling 模式详解与实现

在这种模式下，主 Agent (Controller) 负责编排，子 Agent (Subagent) 负责干活。

#### 基本实现
将子 Agent 封装为一个工具 (`tool`)，供主 Agent 调用。

```typescript
import { createAgent, tool } from "langchain";
import * as z from "zod";

// 1. 创建子 Agent
const subagent1 = createAgent({...});

// 2. 将子 Agent 包装为工具
const callSubagent1 = tool(
  async ({ query }) => {
    // 调用子 Agent
    const result = await subagent1.invoke({
      messages: [{ role: "user", content: query }]
    });
    // 返回结果文本
    return result.messages.at(-1)?.text;
  },
  {
    name: "subagent1_name", // 关键：主 Agent 通过名字识别它
    description: "subagent1_description", // 关键：主 Agent 通过描述决定何时调用
    schema: z.object({
      query: z.string().describe("发送给子 Agent 的查询"),
    }),
  }
);

// 3. 创建主 Agent 并赋予工具
const agent = createAgent({
  model,
  tools: [callSubagent1]
});
```

#### 进阶控制：输入与输出
你可以通过代码深度定制主 Agent 与子 Agent 之间的数据流：

*   **控制输入 (Input)**：
    *   不仅仅传递查询字符串，还可以通过 `getCurrentTaskInput<AgentState>()` 获取主 Agent 的完整状态（如历史消息），经过逻辑处理后传给子 Agent。
*   **控制输出 (Output)**：
    *   子 Agent 默认只返回文本，但你可以通过返回 `Command` 对象来更新主 Agent 的状态（State）。
    *   例如，子 Agent 计算出的中间变量或状态更新，可以通过 `Command` 合并回主 Agent 的状态中。

```typescript
// 示例：子 Agent 返回 Command 以更新主 Agent 的状态
return new Command({
  update: {
    exampleStateKey: result.exampleStateKey, // 传递额外状态
    messages: [ ... ] // 传递消息
  }
});
```

### 总结建议
*   如果你需要**中心化控制**工作流，或者子 Agent 只需要干活不需要跟人说话，选 **Tool Calling**。
*   如果你需要**类似人类的专家轮转**对话，选 **Handoffs**。
*   **混合使用**：你可以使用 Handoffs 进行 Agent 切换，而每个 Agent 内部又可以使用 Tool Calling 来调用更细分的子 Agent。