这份文档深入探讨了 **Context Engineering (上下文工程)** 在构建可靠 Agent 中的核心作用。

简单来说，**上下文工程**就是“在正确的时间，以正确的格式，向 LLM 提供正确的信息和工具”。
这是解决 Agent 不可靠问题的关键，因为大多数 Agent 失败不是因为模型不够聪明，而是因为传入的上下文不对。

以下是文档的核心概念解析：

### 1. 三大核心数据源 (Data Sources)
Agent 在运行过程中会从三个地方读取或写入数据：

*   **Runtime Context (运行时上下文)**：
    *   **定义**：静态配置信息。
    *   **生命周期**：单次对话范围。
    *   **例子**：用户 ID、API Key、数据库连接字符串、环境配置（生产/测试）。
*   **State (状态 / 短期记忆)**：
    *   **定义**：当前对话的状态。
    *   **生命周期**：单次对话范围。
    *   **例子**：聊天记录、上传的文件、当前工具的执行结果。
*   **Store (存储 / 长期记忆)**：
    *   **定义**：跨对话的持久化存储。
    *   **生命周期**：跨对话。
    *   **例子**：用户偏好设置、历史画像、从过去对话中提取的知识。

### 2. 三种上下文控制类型 (Context Types)
你可以控制 Agent 循环中的三个关键环节：

#### A. Model Context (模型上下文) - *瞬态 (Transient)*
这是指你发送给 LLM 的具体内容。你可以根据上述数据源动态调整以下 5 个方面：
1.  **System Prompt (系统提示词)**：根据用户角色（Runtime）或对话长度（State）动态修改指令。
2.  **Messages (消息历史)**：在发送给模型前，注入文件摘要（State）或合规规则（Runtime）。
3.  **Tools (工具列表)**：根据用户权限（Runtime）或当前认证状态（State）动态过滤可用工具。
4.  **Model (模型选择)**：根据任务复杂度或成本预算（Runtime），在 GPT-4o 和 GPT-4o-mini 之间切换。
5.  **Response Format (响应格式)**：根据对话阶段（State），要求模型返回简单或详细的 JSON 结构。

#### B. Tool Context (工具上下文) - *持久化 (Persistent)*
工具不仅是被调用的函数，它们也能感知上下文。
*   **读取 (Reads)**：工具可以访问 `runtime` 对象来获取 User ID 或读取 `store` 中的用户偏好。
*   **写入 (Writes)**：工具可以将执行结果写入 `State`（更新短期记忆）或 `Store`（保存长期偏好）。

#### C. Life-cycle Context (生命周期上下文) - *持久化 (Persistent)*
这是指在模型调用和工具执行**之间**发生的事情。
*   **机制**：通过 **Middleware (中间件)** 实现。
*   **典型场景**：**Summarization (总结)**。当对话过长时，中间件会自动压缩旧消息并更新 State。这是一种持久化的改变，不仅仅是修改单次请求。

### 3. 关键区分：瞬态 vs 持久化
文档特别强调了这一点：
*   **瞬态 (Transient)**：例如在 `wrapModelCall` 中修改消息列表。这只会影响**当前这一次**模型调用，不会改变 State 中保存的真实历史。
*   **持久化 (Persistent)**：例如 `summarizationMiddleware` 或工具写入 State。这会**永久修改**对话历史或状态，影响后续所有的步骤。

### 总结
LangChain.js 的 Agent 架构通过 **Middleware** 机制，允许开发者灵活地将 Runtime、State 和 Store 中的数据注入到模型调用（Model Context）和工具执行（Tool Context）中。掌握上下文工程，就是掌握如何利用这些数据源来动态调整 Agent 的行为。