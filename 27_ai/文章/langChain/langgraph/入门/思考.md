这份文档详细阐述了使用 **LangGraph** 构建 Agent 时的核心思维模式。

简单来说，LangGraph 的开发哲学是将复杂的 Agent 拆解为**离散的步骤（节点）**，通过**共享状态**连接，并明确定义**流转逻辑（边）**。

以下是构建 LangGraph Agent 的五个核心步骤：

### 1. 绘制工作流 (Map out workflow)
首先将业务流程画成流程图。每个步骤都是一个 **Node (节点)**，箭头代表可能的流转方向。
*   **示例**：客服邮件处理流程。
    *   `Read Email` -> `Classify Intent` (分类意图)
    *   根据意图分流 -> `Doc Search` (查文档) / `Bug Track` (报 Bug) / `Human Review` (人工审核)
    *   最终汇聚 -> `Draft Reply` (起草回复) -> `Send Reply` (发送)

### 2. 确定节点功能 (Identify node needs)
明确每个节点属于哪种类型，以及它需要什么上下文：
*   **LLM 节点**：负责理解、生成或决策（如 `Classify Intent`, `Draft Reply`）。
*   **数据节点**：负责从外部获取信息（如 `Doc Search`, `Customer History`）。
*   **动作节点**：执行外部操作（如 `Send Reply`, `Bug Track`）。
*   **用户输入节点**：需要人工干预（如 `Human Review`）。

### 3. 设计状态 (Design State)
**State (状态)** 是所有节点共享的“笔记本”。
*   **原则**：只存储**原始数据** (Raw Data)，不要存储格式化后的 Prompt。Prompt 应该在节点内部根据原始数据动态生成。
*   **内容**：
    *   必须持久化的数据（如原始邮件、分类结果）。
    *   昂贵的查询结果（如搜索结果、客户资料）。
    *   生成的草稿。
*   **代码示例**：
    ```typescript
    const EmailAgentState = z.object({
      emailContent: z.string(), // 原始邮件
      classification: EmailClassificationSchema.optional(), // 分类结果
      searchResults: z.array(z.string()).optional(), // 搜索结果
      responseText: z.string().optional(), // 回复草稿
    });
    ```

### 4. 构建节点 (Build Nodes)
节点本质上就是 JavaScript 函数：`(State) => Partial<State>`。
*   **输入**：当前状态。
*   **输出**：`要更新的状态片段（以及可选的下一步路由指令）。`
*   **错误处理**：
    *   **网络抖动**：使用 `retryPolicy` 自动重试。
    *   **LLM 错误**：将错误存入 State，让 LLM 重试。
    *   **需要人工**：使用 `interrupt()` 暂停执行。

### 5. 连接图 (Wire it together)
将节点和边组装成图。
*   **路由逻辑**：LangGraph 允许节点通过返回 `Command` 对象直接决定下一步去哪里（例如：`goto: "humanReview"`），这使得控制流非常清晰。
*   **持久化**：为了支持 `interrupt`（人机协同）和长运行任务，必须配置 `checkpointer`（如 `MemorySaver`）。

### 核心代码模式示例
这是一个典型的节点实现，展示了如何读取状态、调用 LLM、更新状态并决定下一步：

```typescript
async function classifyIntent(state: EmailAgentStateType) {
  // 1. 读取状态构建 Prompt
  const prompt = `Analyze: ${state.emailContent}`;
  
  // 2. 调用 LLM
  const classification = await structuredLlm.invoke(prompt);

  // 3. 决定下一步路由
  let nextNode = "draftResponse";
  if (classification.urgency === "critical") {
    nextNode = "humanReview";
  }

  // 4. 返回 Command：更新状态 + 跳转
  return new Command({
    update: { classification }, // 更新 State
    goto: nextNode, // 路由跳转
  });
}
```

### 总结
"Thinking in LangGraph" 的核心在于：**把 Agent 看作是一个状态机**。
你不再编写一个巨大的 `while` 循环，而是定义一系列小的、可测试的函数（节点），并通过状态的变化来驱动整个流程。