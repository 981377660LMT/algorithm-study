这份文档介绍了 LangGraph 的 **Time Travel (时间旅行)** 功能。

时间旅行允许你“回滚”图的执行状态到之前的某个检查点（Checkpoint），然后从那里重新开始执行。这对于调试 Agent 的决策过程、修复错误或探索替代路径（Forking）非常有用。

以下是实现时间旅行的核心步骤：

### 1. 核心概念
*   **Checkpointer**: 必须配置检查点保存器（如 `MemorySaver`）才能使用此功能。
*   **Thread ID**: 标识一次完整的对话或执行流。
*   **Checkpoint ID**: 标识 Thread 中的某个具体时刻（快照）。

### 2. 操作步骤

#### 第一步：运行图并生成历史
正常运行图，确保配置中包含 `thread_id`。

#### 第二步：获取历史状态
使用 `graph.getStateHistory(config)` 获取该线程的所有历史快照。快照通常按时间倒序排列（最新的在最前）。

#### 第三步：修改状态 (Forking)
找到你想要“穿越”回去的那个 `checkpoint_id`。使用 `graph.updateState()` 修改该检查点的状态。这会创建一个新的分支（Fork），并返回一个新的配置对象。

#### 第四步：恢复执行
使用新的配置对象调用 `graph.invoke(null, newConfig)`。注意输入为 `null`，表示从当前状态继续执行，而不是开始新的运行。

### 代码示例

以下示例展示了如何先生成一个关于“ice cream”的笑话，然后通过时间旅行修改主题为“chickens”，从而生成一个新的笑话。

```typescript
import { StateGraph, START, END, MemorySaver } from "@langchain/langgraph";
import { ChatAnthropic } from "@langchain/anthropic";
import * as z from "zod";
import { v4 as uuidv4 } from "uuid";

// 1. 定义状态和图
const State = z.object({
  topic: z.string().optional(),
  joke: z.string().optional(),
});

const model = new ChatAnthropic({ model: "claude-3-haiku-20240307" });

const workflow = new StateGraph(State)
  .addNode("generateTopic", async () => {
    const msg = await model.invoke("Give me a topic for a joke");
    return { topic: msg.content as string };
  })
  .addNode("writeJoke", async (state) => {
    const msg = await model.invoke(`Write a joke about ${state.topic}`);
    return { joke: msg.content as string };
  })
  .addEdge(START, "generateTopic")
  .addEdge("generateTopic", "writeJoke")
  .addEdge("writeJoke", END);

// 必须使用 checkpointer
const checkpointer = new MemorySaver();
const graph = workflow.compile({ checkpointer });

async function runDemo() {
  // 2. 初始运行
  const threadId = uuidv4();
  const config = { configurable: { thread_id: threadId } };
  
  console.log("--- 第一次运行 ---");
  const result1 = await graph.invoke({}, config);
  console.log("Topic:", result1.topic);
  console.log("Joke:", result1.joke);

  // 3. 获取历史并找到中间步骤
  // 我们想要回到 generateTopic 之后，writeJoke 之前
  const history = [];
  for await (const state of graph.getStateHistory(config)) {
    history.push(state);
  }
  
  // history[0] 是结束状态，history[1] 是 writeJoke 之前的状态
  const targetState = history[1]; 
  console.log("\n--- 目标检查点 ---");
  console.log("Checkpoint ID:", targetState.config.configurable?.checkpoint_id);
  console.log("Original Topic:", targetState.values.topic);

  // 4. 修改状态 (Time Travel & Fork)
  // 我们修改 topic 为 "chickens"，这会创建一个新分支
  const newConfig = await graph.updateState(
    targetState.config, 
    { topic: "chickens" }
  );

  // 5. 从修改后的点恢复执行
  // 传入 null 作为输入，表示继续执行
  console.log("\n--- 时间旅行后运行 ---");
  const result2 = await graph.invoke(null, newConfig);
  console.log("New Topic:", result2.topic);
  console.log("New Joke:", result2.joke);
}

runDemo();
```