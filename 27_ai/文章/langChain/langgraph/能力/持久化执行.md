这份文档介绍了 LangGraph 的 **Durable Execution (持久化执行)** 机制。

持久化执行允许工作流在关键点保存进度，支持暂停、恢复、人机协同（HITL）以及从错误中恢复。

以下是核心概念总结：

### 1. 什么是持久化执行？
它确保工作流的状态被保存到持久存储中。如果工作流因系统故障或人工干预而中断，它可以从上次记录的状态恢复，而无需重新处理所有步骤。
*   **前提**：只要配置了 Checkpointer（检查点保存器），LangGraph 就默认启用了此功能。

### 2. 实现要求
要利用此功能，你需要：
1.  **启用持久化**：配置 `checkpointer`。
2.  **使用 Thread ID**：执行时指定 `thread_id` 以追踪历史。
3.  **封装非确定性操作**：将副作用（如 API 调用）或随机性操作封装在 `task` 中。

### 3. 核心机制：确定性与重放 (Determinism & Replay)
当工作流恢复时，它**不会**从停止的那一行代码直接开始，而是从**当前节点（Node）或入口点（Entrypoint）的开头**开始**重放（Replay）**。

为了防止副作用被重复执行（例如重复扣款或重复发送请求），必须遵循以下原则：
*   **使用 `task` 封装副作用**：将 API 调用、文件写入等操作包裹在 `task` 中。当工作流重放时，如果该 `task` 之前已成功完成，LangGraph 会直接从数据库读取结果，而不会重新执行代码。
*   **保持幂等性**：尽可能确保操作是幂等的（即多次执行结果相同）。

### 4. 持久化模式 (Durability Modes)
你可以根据性能和安全性的需求选择不同的模式：

```typescript
graph.stream({ input: "test" }, { durability: "async" })
```

*   **`"exit"`** (最快，风险最高)：仅在工作流结束（成功、报错或中断）时保存。中间崩溃会导致状态丢失。
*   **`"async"`** (平衡)：在执行下一步的同时异步保存。性能好，但极少数情况下可能丢失检查点。
*   **`"sync"`** (最慢，最安全)：在执行下一步之前同步保存。确保每一步都被持久化。

### 5. 恢复执行 (Resuming)
*   **人机协同**：使用 `interrupt` 暂停，使用 `Command` 更新状态并恢复。
*   **错误恢复**：如果发生异常（如 LLM 超时），使用相同的 `thread_id` 并传入 `null` 作为输入，即可从上一个成功的检查点自动恢复。

### 6. 恢复的起始点
*   **StateGraph (Graph API)**: 从停止执行的 **Node (节点)** 开头恢复。
*   **Functional API**: 从停止执行的 **Entrypoint (入口函数)** 开头恢复。
*   **Subgraph**: 从调用子图的父节点开始，进入子图后从子图内停止的节点恢复。