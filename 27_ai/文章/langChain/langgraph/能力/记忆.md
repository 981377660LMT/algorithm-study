这份文档详细介绍了 **LangGraph** 中的 **Memory (记忆)** 机制。
记忆是 **AI 应用在多次交互中共享上下文的基础。**

LangGraph 提供了两种类型的记忆：

### 1. 短期记忆 (Short-term Memory)
用于在**单次会话（Thread）**内保持多轮对话的状态。
*   **实现方式**：通过 **Checkpointer**（检查点保存器）实现。
*   **作用**：让 Agent 记住刚才说了什么。
*   **用法**：
    1.  初始化 `MemorySaver` (开发用) 或 `PostgresSaver` (生产用)。
    2.  编译图时传入 `checkpointer`。
    3.  调用图时传入 `thread_id`。
    ```typescript
    const checkpointer = new MemorySaver();
    const graph = builder.compile({ checkpointer });
    await graph.invoke({ messages: [...] }, { configurable: { thread_id: "1" } });
    ```
*   **子图记忆**：父图的 Checkpointer 会自动传播给子图。如果希望子图有独立的记忆，可以在编译子图时设置 `{ checkpointer: true }`。

### 2. 长期记忆 (Long-term Memory)
用于在**跨会话（Cross-session）**甚至跨用户之间存储数据（如用户偏好、历史事实）。
*   **实现方式**：通过 **Store** 实现。
*   **作用**：记住用户的名字、喜好或历史交互摘要。
*   **用法**：
    1.  初始化 `InMemoryStore` 或 `PostgresStore`。
    2.  编译图时传入 `store`。
    3.  在节点内部通过 `config.store` 进行读写 (`put`/`get`/`search`)。
    ```typescript
    // 写入记忆
    await config.store.put(["user_1", "memories"], "mem_id", { food: "pizza" });
    // 读取记忆
    const memories = await config.store.search(["user_1", "memories"]);
    ```
*   **语义搜索**：Store 支持配置 Embedding 模型，允许通过语义相似度搜索记忆（例如搜索 "I'm hungry" 找到 "User likes pizza"）。

### 3. 管理短期记忆 (Context Window Management)
随着对话变长，消息历史可能会超出 LLM 的上下文窗口。LangGraph 提供了几种策略：

*   **Trim Messages (截断)**: 使用 `trimMessages` 工具，保留最后 N 条消息或基于 Token 数量截断。
*   **Delete Messages (删除)**: 使用 `RemoveMessage` 从状态中永久删除特定消息。
    ```typescript
    // 返回 RemoveMessage 对象来删除指定 ID 的消息
    return { messages: [new RemoveMessage({ id: "msg_id" })] };
    ```
*   **Summarize Messages (总结)**:
    1.  在状态中增加 `summary` 字段。
    2.  当消息数量达到阈值时，调用 LLM 生成摘要。
    3.  将摘要存入 `summary` 字段，并删除旧的 `messages`，只保留摘要和最近几条消息。

### 4. 数据库管理
在生产环境中（如使用 Postgres），需要在首次使用前运行迁移（Migration）以设置数据库 Schema。通常通过调用 `checkpointer.setup()` 或 `store.setup()` 来完成。

### 总结
*   **Thread (Checkpointer)** = 会话上下文 (短期记忆)
*   **Store** = 全局/用户数据 (长期记忆)
*   **Reducer/Utils** = 记忆维护 (防止上下文溢出)