这份文档详细介绍了 **LangGraph** 中的 **Subgraphs (子图)** 机制。子图是指将一个编译好的图（Graph）作为另一个图（Parent Graph）中的节点（Node）来使用。

这对于构建**多智能体系统 (Multi-agent systems)**、复用逻辑模块以及团队协作开发非常有用。

以下是核心概念和使用模式的总结：

### 1. 两种集成模式

#### 模式 A：在节点内部调用 (Invoke a graph from a node)
适用于父图和子图**状态 Schema 完全不同**（没有共享键）的情况。
*   **机制**：在父图的一个普通节点函数内部，手动调用 `await subgraph.invoke(...)`。
*   **数据流**：你需要手动将父图的状态转换为子图的输入，并将子图的输出转换回父图的状态更新。
*   **场景**：完全隔离的逻辑，或者子图需要私有的状态（如独立的 message history）。

#### 模式 B：将图作为节点添加 (Add a graph as a node)
适用于父图和子图**共享状态键 (Shared State Keys)** 的情况。
*   **机制**：直接将编译好的 `subgraph` 对象传给 `.addNode()`。
*   **数据流**：LangGraph 会自动将父图状态中匹配的键传递给子图，并将子图返回的更新合并回父图。
*   **场景**：多智能体协作，共享同一个 `messages` 列表。

### 2. 持久化 (Persistence)
*   **自动传播**：通常只需在**编译父图**时提供 `checkpointer`。LangGraph 会自动将其传播给子图，确保整个流程的状态都被保存。
*   **独立记忆**：如果你希望子图拥有完全独立的记忆（例如每个 Agent 维护自己的历史），可以在编译子图时设置 `{ checkpointer: true }`。

### 3. 流式传输 (Streaming)
要查看子图内部的执行过程，需要在调用 `.stream()` 时设置 `subgraphs: true`。
*   输出格式会变为 `[namespace, chunk]`，其中 `namespace` 标识了数据来自哪个子图节点。

### 代码示例

以下示例展示了 **模式 B (共享状态)**，这是最常用的模式。父图委托子图处理一部分逻辑，两者共享 `topic` 和 `notes` 状态。

```typescript
import { StateGraph, START, END } from "@langchain/langgraph";
import * as z from "zod";

// 1. 定义共享状态
// 父图和子图都使用这个 Schema (或其子集)
const State = z.object({
  topic: z.string(),
  notes: z.string().optional(),
  draft: z.string().optional(),
});

// 2. 定义子图 (Researcher)
// 子图负责生成 notes
const researcherBuilder = new StateGraph(State)
  .addNode("search", (state) => {
    return { notes: `Found info about ${state.topic}` };
  })
  .addEdge(START, "search")
  .addEdge("search", END);

const researcherGraph = researcherBuilder.compile();

// 3. 定义父图 (Writer)
// 父图包含子图，并负责生成 draft
const workflow = new StateGraph(State)
  // --- 关键点：直接将编译好的子图作为节点添加 ---
  .addNode("research_agent", researcherGraph)
  .addNode("writer_agent", (state) => {
    return { draft: `Drafting article based on: ${state.notes}` };
  })
  .addEdge(START, "research_agent")
  .addEdge("research_agent", "writer_agent")
  .addEdge("writer_agent", END);

const app = workflow.compile();

// 4. 运行并流式输出 (包含子图信息)
async function run() {
  const inputs = { topic: "LangGraph" };
  
  // 设置 subgraphs: true 以查看子图内部的输出
  for await (const chunk of await app.stream(inputs, { 
    streamMode: "updates", 
    subgraphs: true 
  })) {
    console.log(JSON.stringify(chunk, null, 2));
  }
}

run();
```

### 总结
*   **模块化**：子图让复杂的图变得易于管理。
*   **通信**：通过共享状态键（推荐）或手动转换输入输出进行通信。
*   **调试**：使用 `subgraphs: true` 参数可以在流式输出中看到子图的内部动作。