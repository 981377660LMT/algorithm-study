# 区间相交判定

https://atcoder.jp/contests/abc424/editorial/13900

### 题意（简述）

圆上均匀标出 1…N 个点，依次收到 Q 条线段请求 [Ai,Bi] (1≤Ai<Bi≤N)。  
必须保持所有线段两两不相交，问每个请求能否加入；若能则将其加入，输出 Yes / No。

切开圆得到 1…N 的线性区间后，问题化为“所有区间两两不相交”。

---

## 解法 1：线段树（维护覆盖 Ai 或 Bi 的最短区间）

性质  
区间 [Ai,Bi] 与已存在区间相交 ⟺  
存在已写区间 I 使
• I 含 Ai 而不含 Bi，或  
• I 含 Bi 而不含 Ai。

若把包含某个点 x 的已写区间按长度从大到小排，最短者唯一且长度最小。  
因此判断 Ai 侧是否矛盾，只需看“包含 Ai 的最短区间”是否也包含 Bi（Bi 侧同理）。

实现  
在线段树中对每个点维护“包含该点的最短区间的右端点 / 左端点”。  
一次查询只需两点查询，合法则再把 [Ai,Bi] 作为区间更新写入。  
用延迟标记（dual seg-tree）可使复杂度 O((N+Q) log N)。

---

## 解法 2：括号序列

把区间起点记作 ( ，终点记作 )。  
区间不相交 ⇒ 整体序列始终是一串合法括号序。  
单独抽出 [Ai,Bi] 所在子串也必须是合法括号序列。

合法括号序判定 = 前缀和最小值 ≥0 且区间和=0。  
在线段树维护 (↦+1, )↦−1 的：
• 区间和  
• 区间前缀最小值  
即可在 O(log N) 判断并更新。

---

## 解法 3：线段树记录最小端点

判定条件重写为：

存在已写区间 [L,R] 满足

1. L < Ai ≤ R < Bi，或
2. Ai ≤ L < Bi < R。

建一棵区间线段树，每个节点存：
• 覆盖区间内所有 [L,R] 的 L 的最小值（按 R 分类）  
• 覆盖区间内所有 [L,R] 的 R 的最小值（按 L 分类）

即可用两次区间最小值查询判断冲突，合法则在对应位置更新这两个最小值。  
时空均 O((N+Q) log N)。

---

## 解法 4：随机哈希（XOR）

区间 I 与 J 不相交 ⇔ I 内包含 J 的端点数为偶数。  
给每个端点 i 随机赋一个 B-bit 值 hi。  
若 Xor(I)=hi⊕… 为 0，则 I 内端点出现偶数次 ⇒ 不与已写区间相交。

处理方式  
使用 Fenwick 或差分 + XOR 维护端点值。加入 [Ai,Bi] 前查询 XOR(Ai,Bi)。  
错误概率 ≤ Q·2^−B；取 B=60 可忽略。  
时间 O((N+Q) log N)，实现简单。

---

### 复杂度对比

• 解法 1/2/3：确定性，O((N+Q) log N)。  
• 解法 4：随机化，O((N+Q) log N) 或 O(N+Q)，易写。

根据需求任选其一即可通过。
