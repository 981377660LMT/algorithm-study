https://www.zhihu.com/question/20733617

```JAVA
static final int hash(Object key) {
    int h;
    return key == null ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```

理论上散列值是一个 int 型，如果直接拿散列值作为下标访问 HashMap 主数组的话，考虑到 2 进制 32 位带符号的 int 表值范围从-2147483648 到 2147483648。前后加起来大概 40 亿的映射空间。只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。

但问题是一个 40 亿长度的数组，内存是放不下的。你想，HashMap 扩容之前的数组初始大小才 16。所以这个散列值是不能直接拿来用的。`用之前还要先做对数组的长度取模运算，得到的余数才能用来访问数组下标。源码中模运算是在这个 indexFor()函数里完成的。`

```JAVA
bucketIndex = indexFor(hash, table.length);
```

indexFor 的代码也很简单，就是把`散列值和数组长度做一个"与"操作，`

```JAVA
static int indexFor(int h, int length) {
  // length数组长度是2的整数次幂
  return h & (length -1)
}
```

顺便说一下，这也正好解释了为什么 `HashMap 的数组长度要取 2 的整次幂`。
因为这样（数组长度-1）正好相当于一个`“低位掩码”。`
“与”操作的结果就是散列值的高位全部归零，只保留低位值，用来做数组下标访问。以初始长度 16 为例，16-1=15。2 进制表示是 00000000 00000000 00001111。和某散列值做“与”操作，`结果就是截取了最低的四位值。`

但这时候问题就来了，这样就算我的散列值分布再松散，要是只取最后几位的话，碰撞也会很严重。更要命的是如果散列本身做得不好，分布上成等差数列的漏洞，恰好使最后几个低位呈现规律性重复，就无比蛋疼。

**这时候“扰动函数”的价值就体现出来了**
右位移 16 位，正好是 32bit 的一半，自己的高半区和低半区做异或，就是为了混合原始哈希码的高位和低位，以此来加大低位的随机性。而且混合后的低位掺杂了高位的部分特征，这样高位的信息也被变相保留下来。
