https://github.com/seiflotfy/cuckoofilter

用于判断某元素“可能存在/一定不存在”，减少磁盘或者网络访问。
在缓存、数据库层可有效过滤大量无效查询。
Cuckoo Filter 可以支持删除操作并且通常有更优的误判率。

---

**1. 什么是 Cuckoo Filter？**

Cuckoo Filter 是一种基于 Cuckoo Hashing（布谷鸟哈希）的**概率性数据结构**，主要用于快速判断某个元素是否在一个集合中（即**近似成员查询**）。它和布隆过滤器（Bloom Filter）一样，都会产生**假阳性（false positive）**，但不会产生**假阴性（false negative）**。不过，与布隆过滤器相比，Cuckoo Filter 有以下几个显著特点：

1. **支持删除（Deletion）**：  
   布隆过滤器在插入元素后，无法精确地删除某个特定元素（除非使用一些额外的技巧，但这些技巧往往会损失过滤器精度和增加实现复杂度）。而 Cuckoo Filter 天生就能支持在常数时间内完成删除操作。

2. **更灵活的插入和扩容**：  
   对于布隆过滤器，如果在初始化时没有分配足够的位大小，一旦后期需要插入的元素超出预期，就需要整体扩容，或者接受更高的误报率。Cuckoo Filter 则可在一定范围内通过 Cuckoo Hashing 的搬移（kick-out）操作来容纳更多元素；如果容量达上限，还能通过扩容或多级结构的方式继续插入。

3. **在同等误报率下可能更省空间（在某些场景下）**：  
   根据论文 [1] 中的实验证明，在大多数情况下，Cuckoo Filter 可以在相同的假阳性率要求下，比布隆过滤器拥有更低的空间占用。但需要注意，这和具体实现、负载因子等参数强相关。

---

**2. 为什么需要 Cuckoo Filter？**

在实际的分布式系统、数据库、缓存系统中，我们经常需要快速判断“某个元素是否已经出现过”或者“某个键是否在某个集合中”，以决定下一步的处理逻辑。这些场景包括：

- **去重**：爬虫需要判断某个 URL 是否已经抓取过；
- **缓存**：判断某个 key 是否已经在缓存中；
- **数据库索引**：在索引前先用过滤器拦截一部分不存在的查询，提高效率；
- **安全检测**：判断某个请求或指纹是否在黑名单中。

若`我们直接使用哈希表（Hash Table）来存储所有元素，空间占用可能过大`，并且对于某些只需要“是否存在”判断的场景，会浪费大量空间。  
这时候，**概率性数据结构**（如布隆过滤器、Cuckoo Filter 等）的出现，可以显著减少存储空间，同时在可接受的范围内承担小概率的“误报”。

但是，如果我们需要**删除操作**，或者需要在运行时不停地**插入新元素**而又不想经常重建数据结构时，Cuckoo Filter 就显得特别有优势。它比布隆过滤器更适合动态场景，且在许多负载情况下空间效率更好。

---

**3. Cuckoo Filter 的原理：**

Cuckoo Filter 的核心思想来自 **Cuckoo Hashing**：

- 在 Cuckoo Hashing 中，每个元素通过哈希函数分配到两个桶（bucket）中的其中一个，如果插入时桶已满，就把其中一个已有元素“踢”到它的另一个桶去……这个过程可能持续多次，直到所有元素都安顿好或触发扩容。
- 在 Cuckoo Filter 中，我们并不存储元素本身，而是存储**元素的指纹（fingerprint）**。指纹通常是由元素通过哈希函数计算得到的一个较短的比特串（如 8 位或 12 位等），这样可以大大节省空间。

下面是一个简要流程图解：

1. **计算元素指纹**：对元素 \(x\) 做哈希，得到一个短指纹 \(f\)。
2. **计算两个桶位置**：
   \[
   i_1 = \text{hash}(x), \quad
   i_2 = i_1 \oplus \text{hash}(f)
   \]
   这意味着元素的指纹 \(f\) 可能会被放在桶 \(i_1\) 或者 \(i_2\) 中（\(\oplus\) 表示异或操作）。
3. **插入流程**：
   - 尝试把指纹 \(f\) 放入桶 \(i_1\)。如果桶没满，就直接插入；如果满了，就尝试桶 \(i_2\)。
   - 如果两个桶都满了，就随机“踢”出其中一个已经存在的指纹到它的“另一个桶”，反复进行，直到某个桶可以插入或触发扩容。
4. **查询流程**：
   - 对要查询的元素 \(x\) 计算出它的指纹 \(f\) 和可能的两个桶位置 \(i_1, i_2\)，查看这两个桶中是否存在指纹 \(f\)。若存在，则返回“可能在集合中”（存在一定误报概率）；若不存在，则返回“肯定不在集合中”。
5. **删除流程**：
   - 类似查询，只要找到该元素的指纹，在相应桶中将它移除即可。

这种**“双桶 + 指纹 + 踢出”**的做法，让 Cuckoo Filter 能够既保持较好的空间效率，又允许在常数时间内执行插入、查询和删除。

---

**4. Cuckoo Filter 的使用方法（怎么办）**

1. **数据结构初始化**：

   - 根据预估的元素数量 \(n\) 和期望的误报率 \(\varepsilon\)，确定指纹长度、桶大小、总桶数等参数。
   - 分配相应的存储空间（例如一个数组或多维数组来表示所有桶），每个桶可容纳若干指纹。

2. **插入元素**：

   - 计算元素的指纹 \(f\)；
   - 计算桶索引 \(i_1\)，如果桶未满，插入；若满，尝试 \(i_2\)；如果依旧满，进行踢出（kick-out）过程：
     - 选定一个指纹，将其踢出到它的另一个桶；
     - 如果另一个桶也满，则继续踢出。
     - 如果在规定次数内无法完成插入，可能需要扩容或做别的策略（如重哈希）。

3. **查询元素**：

   - 计算指纹 \(f\)；
   - 到桶 \(i_1\) 和 \(i_2\) 中检查是否存在指纹 \(f\)，若找到则返回“存在”，否则返回“不存在”。

4. **删除元素**：

   - 计算指纹 \(f\)，并到桶 \(i_1\) 和 \(i_2\) 检查。
   - 如果找到，则删除该指纹（置空对应槽位），否则说明这个元素不在过滤器中。

5. **维护和扩容**：
   - 当负载因子过高（大部分桶都快满了）或者插入时踢出次数过多且仍无法插入，就需要考虑扩容或重哈希。
   - 具体做法可以是增加新的桶组，或者把原有桶容量翻倍，并重新分配指纹。

---

**5. 可能的应用场景**

- **缓存热点检测**：在缓存系统中用来快速判断一个 key 是否已经在缓存里，节省真正查找缓存或后端数据库的成本；
- **分布式去重**：如大规模爬虫，对海量 URL 或内容片段进行去重检查；
- **安全和风控**：维护黑名单、白名单的过滤器，用来初步判断请求是否合法；
- **数据库查询优化**：用 Cuckoo Filter 附加到数据库索引上，减少无关查询落到真实数据上。

---

**6. 小结**

Cuckoo Filter 继承了布谷鸟哈希的踢出（kick-out）机制，并通过只存储指纹而大幅节省了空间。它相较于布隆过滤器最大的优点在于能够**灵活地执行删除操作**，并且在很多情况下拥有**更好的空间效率**。当然，复杂的踢出过程也会带来一定的实现复杂度，且在高负载下可能需要较多次的搬移或扩容操作。

在实际系统中，如果需要一个**支持删除**并且**动态插入**的近似成员判断数据结构，Cuckoo Filter 往往是一个非常优秀的选择。

---

**参考资料**

- [1] Bin Fan, David G. Andersen, Michael Kaminsky, and Michael D. Mitzenmacher. _Cuckoo Filter: Practically Better Than Bloom._ In _Proceedings of the 10th ACM International on Conference on emerging Networking Experiments and Technologies_, 2014.
- [2] Michael Mitzenmacher. _Some open questions related to cuckoo hashing._ In _European Symposium on Algorithms_, 2009.
