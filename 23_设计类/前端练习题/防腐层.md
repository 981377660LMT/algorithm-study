## 防腐层 (Anti-Corruption Layer, ACL) —— 隔离脏数据

**业务场景**：

- **后端重构**：后端把 `user.user_name` 改成了 `user.name`，前端几百个文件都要改。
- **第三方 SDK**：接入了 Google Maps，后来想换成 Mapbox，发现代码里到处都是 `google.maps.Marker`，改不完了。
- **遗留系统**：后端返回的数据结构极其混乱（嵌套深、字段名拼音混杂），直接在 UI 组件里用会恶心死人。

**核心痛点**：
外部依赖（后端 API、第三方库）的变化直接冲击内部业务逻辑。

**抽象实现 (Adapter/Mapper)**：
在 API 调用和 UI 组件之间，强制插入一层转换逻辑。**UI 组件永远只依赖前端定义的 Model，不依赖后端返回的 DTO。**

```typescript
// 1. 定义前端需要的完美数据结构 (Domain Model)
interface UserProfile {
  id: string
  fullName: string
  avatar: string
  isActive: boolean
}

// 2. 定义后端返回的恶心数据结构 (DTO)
interface BackendUserDTO {
  u_id: number
  f_name: string
  l_name: string
  icon_url?: string
  status: '1' | '0' // 1是激活，0是禁用
}

// 3. 防腐层转换器 (ACL)
class UserAdapter {
  static toDomain(dto: BackendUserDTO): UserProfile {
    // 处理空值、类型转换、字段重命名、逻辑判断
    return {
      id: String(dto.u_id),
      fullName: `${dto.f_name} ${dto.l_name}`,
      avatar: dto.icon_url || 'default.png', // 默认值处理
      isActive: dto.status === '1'
    }
  }

  // 如果需要回传给后端，也可以定义 toDTO
}

// --- 业务实战 ---

// API 层
async function getUser() {
  const response = await fetch('/api/user')
  const data = await response.json()
  // 关键：在这里截断！不要把 data 直接 return 出去
  return UserAdapter.toDomain(data)
}

// UI 组件层
// 组件只知道 UserProfile，完全不知道后端有个字段叫 u_id
function UserCard({ user }: { user: UserProfile }) {
  return <div>{user.fullName}</div>
}
```
