你的直觉有一半是对的，但另一半存在一个非常隐蔽的**“坐标偏移”**风险。

你是对的：**被替换的那一个**结果，确实因为文本被修改（或删除）而消失了，它对应的那个高亮框通常会被编辑器自动处理掉。

但是，**问题不在于“被替换的那个”，而在于“同一个文件里剩下的那 99 个”结果。**

### 场景推演：为什么会错位？

假设文件内容如下，我们要把 `apple` 替换为 `orange`（长度变了）：

```text
Line 1: apple  <-- 结果 A (Range: 1,0 -> 1,5)
Line 2: banana <-- 结果 B (Range: 2,0 -> 2,6)
```

#### 1. 执行替换

你调用 `module.replace(resultA, 'orange')`。
文本变成了：

```text
Line 1: orange
Line 2: banana
```

注意：第一行长度增加了 1 个字符。

#### 2. 此时的状态（危险窗口期）

- **文本 (Editor)**: 已经变成了 `orange`。
- **Store (Model)**: 仍然存着旧数据！
  - 结果 A: (1,0 -> 1,5) -> 指向 `orang` (少了一个 e)
  - 结果 B: (2,0 -> 2,6) -> 指向 `banana` (这个例子里行没变，看起来还好)

#### 3. 更极端的例子：换行

如果把 `apple` 替换为：

```text
apple
pie
```

(增加了一行)

- **文本**:
  ```text
  Line 1: apple
  Line 2: pie
  Line 3: banana  <-- 原来的 Line 2 被挤到了 Line 3
  ```
- **Store (Model)**: 仍然认为结果 B 在 **Line 2**。
- **编辑器表现**:
  - 如果不清除高亮，编辑器里原本画在 Line 2 的高亮框，现在依然画在 Line 2。
  - **结果**: 用户看到 `pie` 这个词被高亮了，而真正的 `banana` 在 Line 3 却没有高亮。

这就是**“幽灵高亮” (Ghost Decorations)**。

### 为什么必须清空？

在 `replace` 完成后，到 `research` 重新算出新坐标之前，Store 里的**所有**坐标数据相对于当前的文本来说，都是**脏数据 (Dirty Data)**。

虽然现代编辑器（如 Monaco）的高亮装饰器（Decorations）具有一定的“粘性”（Stickiness），能跟随文本移动，但依赖这种隐式行为是非常不可靠的，特别是当：

1.  替换逻辑比较复杂（如正则替换）。
2.  View 层可能会因为 Store 的更新（`setModuleResults([], ...)`）而触发重绘。

**最安全的做法**：
一旦文本发生变更（Dirty），立即承认“我现在不知道结果在哪里了”，**清空所有高亮**，等待新的搜索结果（Fresh Data）回来再重新绘制。

所以，我依然强烈建议在 `_researchModule` 里加上这行代码：

```typescript
// ...existing code...
  private _researchModule(module: ISearchModule): void {
    if (!this._currentTask) return

    // 1. Store 清空：告诉侧边栏“正在搜，先别显示旧的”
    this._store.setModuleResults(module.id, [])

    // 2. View 清空：告诉编辑器“文本变了，旧坐标失效，先别画框，免得画错”
    // 如果不加这一行，编辑器可能会把旧的坐标画在新的文本上
    this._renderModule(module, [])

    this._currentTask.searchModule(module)
  }
// ...existing code...
```
