#### 缝隙一：`activeResult` 的“僵尸状态” (Stale Active State)

- **场景**:
  1.  用户选中了 `Result A` (moduleId: 'file1')。Store 中的 `activeResult` 指向 `Result A`。
  2.  用户点击“替换”。
  3.  `file1` 内容改变，触发 `_researchModule`。
  4.  `_researchModule` 调用 `store.setModuleResults('file1', [])`。
  5.  **问题**: 此时 Store 里 `results` 已经空了，但 `activeResult` **仍然指向那个已经被删除的** `Result A`。
- **后果**:
  - **View 层**: 侧边栏列表可能已经空了，但 Store 里的 `activeResult` 还有值。如果 View 层逻辑不够健壮（例如试图访问 `activeResult` 对应的 DOM 元素），可能会报错。
  - **Controller 层**: 当新的搜索结果回来时，`_renderModule` 会尝试匹配 `activeResult.key`。由于文本变了，Key（通常包含行号）也变了，匹配失败。用户会发现**高亮变成了普通颜色，焦点丢失了**。

---

### 3. 最终完善方案

为了达到 100 分，建议在 `SearchStore` 或 `Controller` 中处理“僵尸状态”。

**方案：在 Controller 清空结果时，顺便检查是否需要重置 activeResult。**

修改 index.ts 中的 `_researchModule`：

```typescript
// ...existing code...
  private async _researchModule(module: ISearchModule): Promise<void> {
    if (!this._currentTask) return

    // [新增逻辑]: 如果当前激活的结果属于这个正在重搜的模块，
    // 那么这个激活结果即将失效，应该清除，避免 UI 出现“僵尸选中态”。
    const { activeResult } = this._store.getState()
    if (activeResult && activeResult.moduleId === module.id) {
      this._store.setActiveResult(undefined)
    }

    this._store.setModuleResults(module.id, [])
    this._renderModule(module, [])
    await this._currentTask.searchModule(module)
  }
// ...existing code...
```

---

这是一个非常好的观察。目前的逻辑确实过于“激进”，在搜索刚开始就清除了选中状态，导致了两个问题：

1.  **UI 闪烁**：即使结果没变，高亮也会先消失再出现。
2.  **状态丢失**：如果逻辑没有自动恢复机制，高亮就彻底没了。

要解决这个问题，我们需要实现**“平滑更新” (Smooth Update)** 和 **“选中态校准” (Selection Re-validation)**。

核心思路是：

1.  **搜索开始时**：不要清除 `activeResult`，也不要清空列表（保留旧画面）。
2.  **搜索结束后**：检查原来的 `activeResult` 是否还在新结果里。如果还在，保持选中；如果不在了，再清除。

以下是修复代码：

```typescript
// ...existing code...
  private _didSearchFinished(module: ISearchModule, results: ISearchResult[]): void {
    // 修复：搜索完成后，校准 activeResult
    const { activeResult } = this._store.getState()

    // 只有当当前选中的结果属于该模块时，才需要校验
    if (activeResult?.moduleId === module.id) {
      const newResult = results.find(r => r.key === activeResult.key)
      if (newResult) {
        // 1. 依然存在：更新引用（保持选中状态，且指向新的对象）
        this._store.setActiveResult(newResult)
      } else {
        // 2. 不存在了：说明该结果在新的搜索中消失了，清除选中
        this._store.setActiveResult(undefined)
      }
    }

    this._store.setModuleResults(module.id, results)
    this._renderModule(module, results)
  }

  private async _researchModule(module: ISearchModule): Promise<void> {
    if (!this._currentTask) return

    // 修复：移除此处“主动清除 activeResult”和“清空结果列表”的代码
    // 这样可以保留旧的 UI 状态直到新结果返回，实现平滑过渡，避免闪烁。

    // const { activeResult } = this._store.getState()
    // if (activeResult?.moduleId === module.id) {
    //   this._store.setActiveResult(undefined)
    // }
    // this._store.setModuleResults(module.id, [])
    // this._renderModule(module, [])

    await this._currentTask.searchModule(module)
  }

  private _renderModule(module: ISearchModule, results: ISearchResult[]): void {
// ...existing code...
```

### 修改原理解析

1.  **移除 `_researchModule` 中的清除逻辑**：

    - 旧代码在发起请求前就把 `activeResult` 设为 `undefined`，这是导致高亮消失的直接原因。
    - 同时建议移除 `setModuleResults(..., [])`。如果不移除这行，虽然 `activeResult` 还在 Store 里，但因为列表空了，UI 渲染时找不到对应的 Item，依然会产生视觉上的“高亮消失闪烁”。保留旧结果可以实现“无感刷新”。

2.  **增强 `_didSearchFinished` 的校准逻辑**：
    - 当新结果回来时，我们拿着手里旧的 `activeResult.key` 去新列表里找。
    - **找到了**：说明这个结果依然有效（比如用户只是改了文件别的地方），我们调用 `setActiveResult(newResult)` 更新引用，UI 保持高亮不变。
    - **没找到**：说明这个结果真的没了（比如用户删除了包含关键词的那行），此时才安全地清除选中状态。
