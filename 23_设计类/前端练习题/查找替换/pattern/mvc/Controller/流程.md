这份代码实现了一个非常经典且健壮的 **搜索与替换（Search & Replace）** 功能的 **MVC 架构** 核心逻辑。它不仅处理了数据的存储，还重点解决了**异步并发、竞态条件（Race Condition）和任务取消**等复杂的前端工程问题。

为了确保没有任何遗漏，我将从**架构概览**开始，然后深入拆解**六大核心流程**。

---

### 0. 架构概览

- **Model (`SearchStore`)**: 单一数据源，负责存储搜索关键词、所有模块的搜索结果、当前选中的结果。它是一个简单的发布订阅模式（Pub/Sub）。
- **View (抽象接口 `ISearchModule`)**: 这里没有具体的 UI 代码，而是定义了 UI/插件 应该实现的行为（`render`, `reveal`）。
- **Controller (`SearchController`)**: 大脑。负责协调模块注册、触发搜索、处理替换逻辑。
- **Task (`SearchTask`)**: 工人。专门负责一次特定关键词的搜索任务，管理异步流程和取消令牌（Cancellation Token）。

---

### 1. 模块注册流程 (Lifecycle)

在搜索开始前，系统需要知道有哪些地方（模块）可以被搜索。

1.  **注册**: 外部调用 `controller.registerModule(module)`。
2.  **查重**: Controller 检查 `_modules` 数组，防止重复注册 ID。
3.  **依赖注入 (`onInit`)**:
    - Controller 调用模块的 `module.onInit(context)`。
    - **关键点**: 传入了 `research` 回调。这使得模块（比如文件监听器）可以在文件内容变化时，主动通知 Controller：“我变了，请重新搜索我”。
4.  **即时搜索**: 如果当前 Controller 正在进行某个任务（`_currentTask` 存在），新注册的模块会被立即加入到当前任务中执行搜索。

---

### 2. 核心搜索流程 (The Search Flow)

这是最复杂的流程，涉及用户输入和并发控制。

#### A. 启动搜索

用户输入字符，调用 `controller.search('keyword')`。

1.  **取消旧任务**: `this._currentTask?.cancel()`。如果上一次搜索还没跑完（比如用户打字很快），立即废弃，防止旧结果覆盖新结果。
2.  **创建新任务**: 实例化 `SearchTask`。这个对象包含了本次搜索的“全局取消令牌” (`_mainCancelSource`)。
3.  **并发执行**: 使用 `Promise.allSettled` 遍历所有注册的模块，调用 `_researchModule(m)`。

#### B. 任务执行与竞态处理 (`SearchTask` 内部)

进入 index.ts 的 `searchModule` 方法。这是**防抖和防乱序**的核心。

1.  **全局检查**: 刚进来先看 `_mainCancelSource`。如果用户已经又输入了新词，直接返回，不浪费资源。
2.  **局部互斥 (Re-search Mutex)**:
    - 检查 `_moduleCancelSources`。如果同一个模块上一次的搜索还在跑（比如文件变化触发了重搜），调用 `prevSource.cancel()` 杀掉上一次请求。
    - **目的**: 保证同一个模块在同一时间只有一个搜索在运行。
3.  **生成局部令牌**: 创建 `localSource`，传给插件。
4.  **执行插件逻辑**: `await module.search(keyword, { token })`。
    - 插件内部应当在耗时操作（如遍历大文件）中定期检查 `token.isCancellationRequested`。
5.  **二次检查 (Double Check)**:
    - `await` 回来后，**世界可能已经变了**。
    - 检查 `_mainCancelSource`：用户是否换词了？
    - 检查 `localSource`：是否因为文件变化触发了新的重搜，导致当前这次结果过时了？
    - **如果任一为 true，直接丢弃结果**。这是防止“幽灵结果”出现的关键。
6.  **完成回调**: 如果一切正常，调用 `_didSearchFinished`。

#### C. 结果提交与渲染

回到 `Controller` 的 `_didSearchFinished`。

1.  **更新 Store**: `store.setModuleResults` 更新数据模型。
2.  **通知视图**: 调用 `_renderModule`。
    - 模块的 `render` 方法被触发。
    - UI 层根据结果绘制高亮（Decorations）或更新侧边栏列表。

---

### 3. 模块主动重搜流程 (Re-search)

场景：用户修改了文件内容，或者文件被外部程序修改。

1.  **触发**: 模块内部调用 `onInit` 时拿到的 `context.research()`。
2.  **Controller 响应**: 调用 `_researchModule(module)`。
3.  **清理状态**:
    - 如果当前 `activeResult` 属于该模块，将其置空（防止指向不存在的代码行）。
    - 清空该模块在 Store 中的旧结果。
    - 调用 `_renderModule` 清空视图上的旧高亮。
4.  **加入任务**: 调用 `_currentTask.searchModule(module)`。
    - 复用当前的关键词。
    - 走上述 **2.B** 的流程（会触发局部互斥，取消该模块正在进行的旧搜索）。

---

### 4. 结果交互流程 (Interaction)

用户在侧边栏点击某个搜索结果。

1.  **调用**: `controller.setActiveResult(result)`。
2.  **校验**: 确认该结果依然存在于 Store 中（防止点击了过时列表项）。
3.  **更新 Store**: `store.setActiveResult(result)`。
4.  **视图同步**:
    - `_renderModule`: 通知模块重新渲染（可能用于高亮当前选中项）。
    - **关键动作**: `module.reveal(result)`。
    - **Reveal 的语义**: 模块负责打开文件 -> 展开折叠代码 -> 滚动到可视区域 -> 移动光标。

---

### 5. 替换流程 (Replace)

#### 单个替换

1.  **调用**: `controller.replace(newText)`。
2.  **获取目标**: 从 Store 获取 `activeResult`。如果没有选中项，不执行。
3.  **执行**: 调用 `module.replace(result, newText)`。
    - 注意：这里没有自动重新搜索。通常 `module.replace` 修改文件后，会触发文件系统的 change 事件，进而触发 **流程 3 (Re-search)**，从而自动更新搜索结果列表。

#### 全部替换

1.  **调用**: `controller.replaceAll(newText)`。
2.  **并发执行**: 遍历所有模块。
3.  **执行**: 获取每个模块的所有结果，调用 `module.replaceAll(results, newText)`。
    - 同样，依赖文件变化事件来刷新结果。

---

### 6. 销毁与清理流程 (Dispose)

防止内存泄漏的关键。

1.  **Controller Dispose**:
    - 取消当前任务 `_currentTask.cancel()`。
    - 遍历所有模块调用 `module.onDispose()`（让插件清理自己的监听器）。
    - 清空模块列表。
    - 调用 `store.dispose()`。
2.  **Store Dispose**:
    - 清空所有监听器 `_listeners`。
    - 重置状态 `_state`。
3.  **Task Dispose (Cancel)**:
    - 触发 `_mainCancelSource`，通知所有正在运行的 Promise 停止。
    - 触发所有 `_moduleCancelSources`。

---

### 总结：设计的精妙之处

1.  **分离关注点**: Controller 不关心怎么搜（那是 Module 的事），也不关心怎么存（那是 Store 的事），只关心流程控制。
2.  **CancellationToken**: 在 `Task` 类中完美处理了异步操作中最头疼的“取消”问题。如果不这么做，用户快速输入 "abc" -> "abcd"，可能会先收到 "abcd" 的结果，然后被 "abc" 的慢速结果覆盖，导致 UI 显示错误。
3.  **不可变数据流**: Store 更新使用 `{ ...state, ...newState }`，配合 React 等视图层使用时性能更好。
4.  **稳定的 Key**: `ISearchResult` 强制要求 `key`，这对于 Diff 算法和列表渲染至关重要。
