除了 **轮询 (Polling)** 和 **批处理 (Batching)**，在处理异步任务、系统稳定性和流量控制时，还有几个非常经典且实用的抽象模式。

以下是三个最常用的模式及其 TypeScript 实现：

### 1. 重试模式 (Retry Pattern)

**核心思想**：当操作失败（通常是网络请求）时，不要立即报错，而是等待一段时间后再次尝试，直到达到最大重试次数。通常配合 **指数退避 (Exponential Backoff)** 策略使用（每次失败等待时间翻倍）。

```typescript
interface RetryOptions {
  retries: number // 最大重试次数
  baseDelay: number // 初始等待时间 (ms)
  factor?: number // 退避因子 (默认 2)
}

export async function retry<T>(fn: () => Promise<T>, options: RetryOptions): Promise<T> {
  const { retries, baseDelay, factor = 2 } = options
  let lastError: any

  for (let attempt = 0; attempt <= retries; attempt++) {
    try {
      return await fn()
    } catch (error) {
      lastError = error
      if (attempt < retries) {
        // 计算等待时间：baseDelay * 2^attempt
        const delay = baseDelay * Math.pow(factor, attempt)
        console.warn(`Attempt ${attempt + 1} failed. Retrying in ${delay}ms...`)
        await new Promise(resolve => setTimeout(resolve, delay))
      }
    }
  }
  throw lastError
}

// 使用示例
// retry(() => api.fetchData(), { retries: 3, baseDelay: 1000 });
```

---

### 2. 熔断模式 (Circuit Breaker)

**核心思想**：保护系统防止雪崩。当某个服务连续失败达到阈值时，**“跳闸” (Open)**，后续请求直接拒绝（不发网络请求），给下游服务恢复时间。过一段时间后进入 **“半开” (Half-Open)** 状态，尝试放行一个请求，如果成功则恢复正常 **(Closed)**。

```typescript
enum CircuitState {
  CLOSED, // 正常
  OPEN, // 熔断（拒绝请求）
  HALF_OPEN // 半开（尝试恢复）
}

export class CircuitBreaker {
  private state = CircuitState.CLOSED
  private failureCount = 0
  private nextAttempt = 0

  constructor(
    private threshold: number = 5, // 失败多少次跳闸
    private cooldown: number = 10000 // 冷却时间 (ms)
  ) {}

  public async exec<T>(request: () => Promise<T>): Promise<T> {
    if (this.state === CircuitState.OPEN) {
      if (Date.now() > this.nextAttempt) {
        this.state = CircuitState.HALF_OPEN // 冷却结束，尝试一次
      } else {
        throw new Error('Circuit is OPEN') // 快速失败
      }
    }

    try {
      const result = await request()
      this.onSuccess()
      return result
    } catch (err) {
      this.onFailure()
      throw err
    }
  }

  private onSuccess() {
    this.failureCount = 0
    this.state = CircuitState.CLOSED
  }

  private onFailure() {
    this.failureCount++
    if (this.failureCount >= this.threshold || this.state === CircuitState.HALF_OPEN) {
      this.state = CircuitState.OPEN
      this.nextAttempt = Date.now() + this.cooldown
    }
  }
}
```

---

### 3. 管道/中间件模式 (Pipeline / Middleware)

**核心思想**：将复杂的处理逻辑拆分为多个独立的步骤（函数），数据像流过管道一样依次经过这些步骤。常用于数据转换、请求预处理（如 Redux 中间件、Koa/Express 框架）。

```typescript
type Next = () => Promise<void> | void
type Middleware<T> = (context: T, next: Next) => Promise<void> | void

export class Pipeline<T> {
  private middlewares: Middleware<T>[] = []

  // 注册中间件
  use(middleware: Middleware<T>) {
    this.middlewares.push(middleware)
    return this
  }

  // 执行管道
  async execute(context: T) {
    let index = -1

    const dispatch = async (i: number): Promise<void> => {
      if (i <= index) throw new Error('next() called multiple times')
      index = i

      const fn = this.middlewares[i]
      if (!fn) return

      // 执行当前中间件，并将下一个 dispatch 作为 next 参数传入
      await fn(context, () => dispatch(i + 1))
    }

    await dispatch(0)
  }
}

// 使用示例
// const pipe = new Pipeline<{ data: number }>();
// pipe.use(async (ctx, next) => {
//   ctx.data += 1;
//   await next();
//   console.log('End');
// });
```

### 总结

| 模式                       | 解决的问题               | 关键词               |
| :------------------------- | :----------------------- | :------------------- |
| **Polling (轮询)**         | 持续获取状态更新         | 定时器、递归         |
| **Batching (批处理)**      | 减少高频调用，合并请求   | 缓冲、阈值           |
| **Retry (重试)**           | 处理瞬时故障（网络抖动） | 指数退避、最大尝试   |
| **Circuit Breaker (熔断)** | 防止系统雪崩，故障隔离   | 状态机 (Open/Closed) |
| **Pipeline (管道)**        | 逻辑解耦，流程编排       | 责任链、Next 函数    |
