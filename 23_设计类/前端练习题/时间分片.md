时间分片（Time Slicing）的核心目的是**避免长任务阻塞主线程**，保持 UI 响应。

最优雅的抽象方式是利用 **Generator（生成器）** 来控制任务的暂停与恢复，配合 **Scheduler（调度器）** 来管理执行时间。

以下是两种通用的 TS 抽象模式：

### 1. 基于 Generator 的通用调度器 (最灵活)

这种模式将“任务逻辑”与“时间控制”完全解耦。任务只需要在合适的地方 `yield`，调度器负责决定是继续跑还是让出主线程。

```typescript
/**
 * 调度器配置
 */
interface SchedulerOptions {
  frameBudget?: number // 每帧允许执行的时间 (ms)，默认 5ms (React Concurrent Mode 标准)
  signal?: AbortSignal // 支持取消
}

class TimeSlicer {
  // 核心调度函数
  static async run(
    taskGenerator: Generator<any, void, unknown>,
    options: SchedulerOptions = {}
  ): Promise<void> {
    const { frameBudget = 5, signal } = options

    let result = taskGenerator.next()

    while (!result.done) {
      // 1. 检查是否被取消
      if (signal?.aborted) {
        throw new DOMException('Task aborted', 'AbortError')
      }

      // 2. 执行一小段任务 (在一个时间片内尽可能多执行几步)
      const startTime = performance.now()

      // 当耗时小于预算时，持续执行 generator 的下一步
      // 这样可以避免过于频繁的 setTimeout 带来的宏任务开销
      while (!result.done && performance.now() - startTime < frameBudget) {
        result = taskGenerator.next()
      }

      // 3. 如果任务还没完，但时间片用完了，让出主线程
      if (!result.done) {
        await new Promise(resolve => setTimeout(resolve, 0))
      }
    }
  }
}

// --- 使用示例 ---

// 1. 定义任务：使用 generator，像写同步代码一样，只需在耗时处 yield
function* heavyCalculationTask(count: number) {
  console.log('Task started')

  for (let i = 0; i < count; i++) {
    // 模拟耗时操作
    const temp = Math.sqrt(i) * Math.random()

    // 每处理 100 个数据，或者在关键节点，主动 yield 一下
    // 这里的 yield 只是一个"检查点"，调度器会决定是否真的暂停
    if (i % 100 === 0) yield
  }

  console.log('Task finished')
}

// 2. 执行任务
const controller = new AbortController()

TimeSlicer.run(heavyCalculationTask(50000), {
  frameBudget: 10, // 稍微放宽一点预算
  signal: controller.signal
}).catch(err => console.error(err))

// 模拟中途取消
// setTimeout(() => controller.abort(), 100);
```

### 2. 基于数组的高阶函数模式 (最常用)

大多数场景下，时间分片是用来处理**大数组**的。我们可以封装一个专门处理数组的异步函数。

```typescript
type ProcessFn<T> = (item: T, index: number) => void

/**
 * 数组分片处理器
 * @param items 要处理的数据源
 * @param processItem 处理单个数据的逻辑
 * @param options 配置项
 */
async function processInChunks<T>(
  items: T[],
  processItem: ProcessFn<T>,
  options: { chunkSize?: number; signal?: AbortSignal } = {}
): Promise<void> {
  const { chunkSize = 100, signal } = options

  // 使用 for 循环而不是 forEach，以便支持 await
  for (let i = 0; i < items.length; i += chunkSize) {
    // 1. 检查取消
    if (signal?.aborted) {
      throw new DOMException('Aborted', 'AbortError')
    }

    // 2. 让出主线程 (关键点)
    // 放在循环开头，确保每一轮大循环之间都有喘息机会
    // 第一次循环可以跳过等待，立即执行
    if (i > 0) {
      await new Promise(resolve => setTimeout(resolve, 0))
    }

    // 3. 执行当前分片
    // 注意：这里是同步执行一个 chunk，确保效率
    const end = Math.min(i + chunkSize, items.length)
    for (let j = i; j < end; j++) {
      processItem(items[j], j)
    }
  }
}

// --- 使用示例 ---

const bigList = Array.from({ length: 100000 }, (_, i) => i)

console.log('Start processing...')

processInChunks(
  bigList,
  (item, index) => {
    // 你的业务逻辑，比如渲染 DOM 或计算
    const div = document.createElement('div')
    div.textContent = `Item ${item}`
  },
  { chunkSize: 500 } // 每 500 个让出一次主线程
).then(() => {
  console.log('All done!')
})
```

### 核心逻辑总结

1.  **Yielding (让出)**: 必须使用 `await new Promise(r => setTimeout(r, 0))` (宏任务) 或 `MessageChannel` 来打断当前的 Call Stack，让浏览器有机会去重绘 UI (Repaint) 或响应点击事件。
2.  **Budgeting (预算)**: 纯粹的 `setTimeout` 每一个循环都等待会太慢（因为 `setTimeout` 有最小 4ms 延迟）。**最佳实践**是“执行一段时间（如 5ms） -> 休息一下 -> 再执行一段时间”。Generator 模式中的 `performance.now()` 检查就是为了实现这一点。

---

完全“无侵入”地将一个已经写好的**同步长任务**（比如一个巨大的 `for` 循环）变成**时间分片任务**，在 JavaScript 的单线程机制下是**不可能**的（除非移入 Web Worker）。

但是，我们可以通过**高阶函数封装**，将“对数据的遍历”这一行为进行抽象，从而做到**业务逻辑零修改**。你只需要把原来的 `array.forEach` 换成我们提供的工具函数即可。

这是一个高度封装、开箱即用的 `TimeSlicer` 工具类：

### 核心思路

1.  **接管循环控制权**：不再由 JS 引擎一口气跑完，而是由工具类控制 `index` 的递增。
2.  **时间预算 (Time Budget)**：每执行一次回调，检查当前帧是否耗时过长（默认 >5ms）。
3.  **宏任务让出**：如果超时，通过 `setTimeout` 暂停，下一帧继续。

### 代码实现

```typescript
interface SlicerOptions {
  /** 每帧的时间预算 (ms)，默认 5ms (React Concurrent 模式标准) */
  frameBudget?: number
  /** 取消信号 */
  signal?: AbortSignal
}

export class TimeSlicer {
  /**
   * 无侵入改造：将同步的 forEach 变为时间分片的异步执行
   * @param items 数据源
   * @param callback 业务逻辑（无需任何修改）
   * @param options 配置
   */
  static async forEach<T>(
    items: T[],
    callback: (item: T, index: number) => void,
    options: SlicerOptions = {}
  ): Promise<void> {
    const { frameBudget = 5, signal } = options
    const len = items.length

    let i = 0

    while (i < len) {
      // 1. 每一大轮循环开始前，检查是否取消
      if (signal?.aborted) {
        throw new DOMException('Aborted', 'AbortError')
      }

      // 2. 记录当前帧起始时间
      const start = performance.now()

      // 3. 在时间预算内，尽可能多地执行任务
      // 这里的 while 保证了在预算充足时是同步执行的，性能损耗极小
      while (i < len && performance.now() - start < frameBudget) {
        callback(items[i], i)
        i++
      }

      // 4. 如果任务还没跑完（说明时间预算用完了），暂停一下，让出主线程
      if (i < len) {
        // 关键：让出控制权给浏览器渲染或响应用户输入
        await new Promise(resolve => setTimeout(resolve, 0))
      }
    }
  }

  /**
   * 无侵入改造：将同步的 map 变为时间分片的异步执行
   */
  static async map<T, R>(
    items: T[],
    mapper: (item: T, index: number) => R,
    options: SlicerOptions = {}
  ): Promise<R[]> {
    const results: R[] = new Array(items.length)

    await this.forEach(
      items,
      (item, index) => {
        results[index] = mapper(item, index)
      },
      options
    )

    return results
  }
}
```

### 使用对比：侵入性极低

假设你原本有这样一段阻塞页面的代码：

```typescript
// ❌ 旧代码：会卡死页面 2秒
function renderBigList(data: number[]) {
  data.forEach(item => {
    heavyCalculation(item) // 耗时操作
    renderItem(item) // DOM 操作
  })
  console.log('Done')
}
```

**改造后**（业务逻辑 `heavyCalculation` 和 `renderItem` 完全不用动）：

```typescript
// ✅ 新代码：页面流畅，不卡顿
async function renderBigList(data: number[]) {
  const controller = new AbortController()

  try {
    // 只需要把 data.forEach 换成 await TimeSlicer.forEach
    await TimeSlicer.forEach(
      data,
      item => {
        // --- 这里的代码完全不用改 ---
        heavyCalculation(item)
        renderItem(item)
        // -------------------------
      },
      {
        frameBudget: 10, // 可选：每帧允许跑 10ms
        signal: controller.signal // 可选：支持取消
      }
    )

    console.log('Done')
  } catch (err) {
    if (err.name === 'AbortError') console.log('Task Cancelled')
  }
}
```

### 为什么说这是“无侵入”的极限？

1.  **不修改业务函数签名**：你的 `heavyCalculation` 不需要变成 `async`，也不需要接受 `yield`。
2.  **保持上下文**：回调函数依然可以使用外部的闭包变量。
3.  **类型安全**：利用泛型，TS 类型推导完全保留。

### 进阶：如果是递归任务怎么办？

如果你的任务不是数组循环，而是递归（比如遍历 DOM 树），上述数组方法就不适用了。
对于这种情况，我们可以提供一个**“自动打点器”**。

```typescript
/**
 * 递归任务生成器
 * 用法：在递归函数开头加一行 await slicer.check()
 */
export class AutoSlicer {
  private lastYieldTime = 0

  constructor(private frameBudget = 5, private signal?: AbortSignal) {}

  async check() {
    if (this.signal?.aborted) throw new DOMException('Aborted', 'AbortError')

    const now = performance.now()
    // 如果距离上次让出时间超过了预算，则强制让出
    if (now - this.lastYieldTime > this.frameBudget) {
      await new Promise(resolve => setTimeout(resolve, 0))
      this.lastYieldTime = performance.now() // 更新时间
    }
  }
}

// --- 用法 ---
async function traverseTree(node: any, slicer: AutoSlicer) {
  // ✅ 唯一侵入点：在函数入口检查一下
  await slicer.check()

  console.log('Process', node.val)
  if (node.left) await traverseTree(node.left, slicer)
  if (node.right) await traverseTree(node.right, slicer)
}

// 启动
const slicer = new AutoSlicer()
traverseTree(rootNode, slicer)
```

---

这段代码实现了一个非常高级且实用的模式：**基于 Generator 的“蹦床函数”（Trampoline）与时间分片结合**。

它的核心目的是解决两个问题：

1.  **爆栈（Stack Overflow）**：通过将递归调用改为 Generator `yield`，将系统调用栈（Call Stack）转移到堆内存中的数组（`itStack`）来管理，从而实现无限深度的递归。
2.  **阻塞主线程**：在手动管理的循环中插入时间检查，超时则 `await sleep()` 让出主线程。

### 深度解析：它是如何工作的？

通常递归是这样的：`A -> B -> C`，JS 引擎会保留 A、B 的上下文。
这段代码的模式是：

1.  `Executor` 执行 A。
2.  A 想要调用 B，它不直接调用，而是 `yield B`（把 B 这个生成器对象交出来）。
3.  `Executor` 拿到 B，把 A 暂停并压入栈底，开始执行 B。
4.  B 执行完 `return result`。
5.  `Executor` 拿到 result，弹出 A，把 result 传回给 A (`last.next(result)`)。

这实际上是**手动实现了一个协程调度器**。

---

### 优化建议

原代码有几个可以改进的地方：

1.  **耦合性过强**：`DiffInfo` 和 `DiffInfo.empty` 是业务逻辑，不应出现在通用工具里。
2.  **硬编码**：`64ms` 的时间片太长了（通常一帧是 16ms，React Concurrent 模式通常用 5ms），且不可配置。
3.  **类型定义复杂**：`TRecursionGenertor` 名字有拼写错误且难以理解。
4.  **错误处理**：Abort 时直接返回空值不太通用，抛出错误让调用者处理更好。

### 优化后的代码 (通用抽象版)

我们将它重命名为 `TrampolineScheduler` (蹦床调度器)，并使其完全通用。

```typescript
/**
 * 递归任务生成器类型
 * T: 最终返回值的类型
 * Yield: 产出的必须是同样的生成器类型
 * Next: 接收的必须是子任务的返回值 T
 */
export type RecursiveTask<T> = Generator<RecursiveTask<T>, T, T>

export interface SchedulerOptions {
  /** 每帧的时间预算 (ms)，默认 16ms */
  frameBudget?: number
  /** 取消信号 */
  signal?: AbortSignal
}

/**
 * 睡眠函数，利用宏任务让出主线程
 */
const yieldToMain = () => new Promise<void>(resolve => setTimeout(resolve, 0))

/**
 * 异步递归执行器（支持时间分片 + 防爆栈）
 */
export async function runRecursiveTask<T>(
  rootTask: RecursiveTask<T>,
  options: SchedulerOptions = {}
): Promise<T> {
  const { frameBudget = 16, signal } = options

  // 手动管理调用栈，替代 JS 引擎的 Call Stack
  const stack: RecursiveTask<T>[] = [rootTask]

  // 存储子任务的返回值，用于传回给父任务
  let lastValue: T | undefined = undefined

  let start = performance.now()

  while (stack.length > 0) {
    // 1. 检查取消
    if (signal?.aborted) {
      throw new DOMException('Task aborted', 'AbortError')
    }

    // 2. 获取栈顶任务（当前正在执行的任务）
    const currentTask = stack[stack.length - 1]

    // 3. 执行一步
    // next(lastValue) 相当于函数调用返回，把子任务结果传给父任务
    const res = currentTask.next(lastValue as T)

    if (res.done) {
      // 当前层级任务完成
      lastValue = res.value // 记录返回值
      stack.pop() // 弹出栈帧
    } else {
      // 当前任务 yield 了一个新的子任务
      // 压入栈顶，下一轮循环将执行这个子任务（实现了深度优先遍历）
      stack.push(res.value)
      // 重置 lastValue，因为新任务还没开始跑，没有返回值
      lastValue = undefined
    }

    // 4. 时间分片检查
    // 只有当栈里还有任务时才需要检查，避免最后一步多余的等待
    if (stack.length > 0) {
      const now = performance.now()
      if (now - start > frameBudget) {
        await yieldToMain() // 让出主线程
        start = performance.now() // 重置计时器
      }
    }
  }

  return lastValue as T
}

/**
 * 同步递归执行器（仅防爆栈，不分片）
 * 用于不需要异步但深度极深导致 Stack Overflow 的场景
 */
export function runRecursiveTaskSync<T>(rootTask: RecursiveTask<T>): T {
  const stack: RecursiveTask<T>[] = [rootTask]
  let lastValue: T | undefined = undefined

  while (stack.length > 0) {
    const currentTask = stack[stack.length - 1]
    const res = currentTask.next(lastValue as T)

    if (res.done) {
      lastValue = res.value
      stack.pop()
    } else {
      stack.push(res.value)
      lastValue = undefined
    }
  }

  return lastValue as T
}
```

### 如何使用（示例）

假设我们要计算斐波那契数列（虽然这个算法很烂，但适合演示递归），或者遍历一个巨大的树。

#### 1. 定义递归 Generator

注意：不要直接递归调用函数，而是 `yield` 函数调用的结果。

```typescript
import { RecursiveTask, runRecursiveTask } from './utils/trampoline-scheduler'

// 传统的递归写法（会爆栈，会卡死）
// function fib(n: number): number {
//   if (n <= 1) return n;
//   return fib(n - 1) + fib(n - 2);
// }

// ✅ 改造后的 Generator 写法
function* fibGenerator(n: number): RecursiveTask<number> {
  if (n <= 1) return n

  // 关键点：yield 递归调用，而不是直接调用
  // 这里的 yield 会暂停当前函数，把控制权交给调度器
  const a = yield fibGenerator(n - 1)
  const b = yield fibGenerator(n - 2)

  return a + b
}
```

#### 2. 调用执行器

```typescript
const controller = new AbortController()

// 启动任务
runRecursiveTask(fibGenerator(20), {
  frameBudget: 5, // 每帧只跑 5ms，保证极度流畅
  signal: controller.signal
})
  .then(result => {
    console.log('计算结果:', result)
  })
  .catch(err => {
    if (err.name === 'AbortError') {
      console.log('任务被取消')
    } else {
      console.error('发生错误', err)
    }
  })

// 模拟中途取消
// setTimeout(() => controller.abort(), 100);
```

### 总结优化点

1.  **解耦**：移除了 `DiffInfo`，现在它是一个通用的递归调度器，可以算斐波那契，也可以做 Diff，也可以做树遍历。
2.  **类型安全**：`RecursiveTask<T>` 明确了输入输出类型。
3.  **可配置**：`frameBudget` 不再写死 64ms，可以根据 UI 复杂度调整（例如动画密集时设为 5ms，后台计算设为 50ms）。
4.  **标准取消**：使用标准的 `AbortError` 抛出异常，符合 Promise 链式调用的标准错误处理流程。

---

为了让代码更灵活，适应**多维表格（大数据量渲染/计算）**和**编辑器（语法高亮/AST 解析）**等 CPU 密集型任务，我们需要将 `TimeSlicer` 改造为一个**通用的调度工具库**。

主要改进点：

1.  **泛型支持**：支持返回值，而不仅仅是 `void`。
2.  **多种模式**：除了支持 Generator，还应原生支持 **Array 遍历**（最常用）和 **手动打点**（最灵活）。
3.  **静态方法**：改为静态工具类，无需实例化即可使用。

以下是改造后的代码：

```typescript
export interface SchedulerOptions {
  /** 每帧的时间预算 (ms)，默认 5ms (React Concurrent Mode 标准) */
  frameBudget?: number
  /** 取消信号 */
  signal?: AbortSignal
}

/**
 * 核心调度器：用于将长任务切片，避免阻塞主线程
 */
export class TimeSlicer {
  /**
   * 1. Generator 模式：适合复杂的、有状态的流程控制（如状态机、递归算法）
   * @returns Generator 的最终返回值
   */
  static async runGenerator<T, R = any>(
    gen: Generator<T, R, unknown>,
    options: SchedulerOptions = {}
  ): Promise<R> {
    const { frameBudget = 5, signal } = options
    let lastYieldTime = performance.now()

    let res = gen.next()

    while (!res.done) {
      // 检查取消
      if (signal?.aborted) throw new DOMException('Aborted', 'AbortError')

      // 检查时间预算
      const now = performance.now()
      if (now - lastYieldTime > frameBudget) {
        // 超时，让出主线程
        await this.yieldToMain()
        lastYieldTime = performance.now() // 重置计时
      }

      // 继续执行
      res = gen.next()
    }

    return res.value as R
  }

  /**
   * 2. 数组遍历模式 (forEach)：适合表格行渲染、大数据处理
   * 替代 Array.prototype.forEach
   */
  static async forEach<T>(
    items: T[],
    iterator: (item: T, index: number) => void,
    options: SchedulerOptions = {}
  ): Promise<void> {
    const { frameBudget = 5, signal } = options
    const len = items.length
    let lastYieldTime = performance.now()

    for (let i = 0; i < len; i++) {
      // 批量执行检查：每处理一个元素检查一次可能太频繁，
      // 可以在这里加一个计数器优化 (例如 i % 10 === 0 才检查时间)，但为了通用性先每次检查

      const now = performance.now()
      if (now - lastYieldTime > frameBudget) {
        if (signal?.aborted) throw new DOMException('Aborted', 'AbortError')
        await this.yieldToMain()
        lastYieldTime = performance.now()
      }

      iterator(items[i], i)
    }
  }

  /**
   * 3. 数组映射模式 (map)：适合编辑器文本解析、数据转换
   * 替代 Array.prototype.map
   */
  static async map<T, R>(
    items: T[],
    mapper: (item: T, index: number) => R,
    options: SchedulerOptions = {}
  ): Promise<R[]> {
    const results: R[] = new Array(items.length)

    await this.forEach(
      items,
      (item, index) => {
        results[index] = mapper(item, index)
      },
      options
    )

    return results
  }

  /**
   * 4. 手动打点模式：适合无法拆分为数组的 while 循环
   * 返回一个检查函数，在循环内部调用
   */
  static createChecker(options: SchedulerOptions = {}) {
    const { frameBudget = 5, signal } = options
    let lastYieldTime = performance.now()

    return async () => {
      if (signal?.aborted) throw new DOMException('Aborted', 'AbortError')

      const now = performance.now()
      if (now - lastYieldTime > frameBudget) {
        await this.yieldToMain()
        lastYieldTime = performance.now()
      }
    }
  }

  // 私有：让出主线程
  private static yieldToMain() {
    // 优先使用 MessageChannel (宏任务)，比 setTimeout(0) 更快，延迟更低
    if (typeof MessageChannel !== 'undefined') {
      return new Promise<void>(resolve => {
        const channel = new MessageChannel()
        channel.port1.onmessage = () => resolve()
        channel.port2.postMessage(null)
      })
    }
    // 降级方案
    return new Promise<void>(resolve => setTimeout(resolve, 0))
  }
}
```

### 场景应用示例

#### 场景 A：多维表格大数据渲染 (使用 `forEach`)

表格通常有成千上万行，直接渲染会卡死浏览器。

```typescript
// 假设有 10万条数据
const largeTableData = Array.from({ length: 100000 }, (_, i) => ({ id: i, val: Math.random() }))

async function renderTable() {
  const container = document.getElementById('table-body')
  const controller = new AbortController()

  try {
    // 使用 TimeSlicer 替代 data.forEach
    await TimeSlicer.forEach(
      largeTableData,
      row => {
        const tr = document.createElement('tr')
        tr.innerHTML = `<td>${row.id}</td><td>${row.val}</td>`
        container?.appendChild(tr)
      },
      {
        frameBudget: 8, // 稍微放宽一点预算
        signal: controller.signal
      }
    )

    console.log('表格渲染完成，全程无卡顿')
  } catch (e) {
    console.log('渲染被取消')
  }
}
```

#### 场景 B：编辑器语法高亮 (使用 `map`)

编辑器需要对每一行文本进行 Tokenize（分词），这是典型的 CPU 密集型计算。

```typescript
const codeLines = sourceCode.split('\n') // 假设有 5000 行代码

async function highlightCode() {
  // 使用 TimeSlicer 替代 lines.map
  // 这样即使文件很大，编辑器也能保持响应（打字不卡）
  const tokens = await TimeSlicer.map(
    codeLines,
    line => {
      return expensiveTokenizer(line) // 耗时的正则匹配
    },
    { frameBudget: 5 }
  )

  renderTokens(tokens)
}
```

#### 场景 C：复杂解析器/编译 (使用 `createChecker`)

有些解析逻辑是 `while(char = next())` 形式的，很难用数组方法。

```typescript
async function parseStream(stream: string) {
  const checkTime = TimeSlicer.createChecker({ frameBudget: 5 })
  let i = 0

  while (i < stream.length) {
    // 在循环内部手动打点
    // 如果当前帧耗时过长，这里会自动 await 暂停
    await checkTime()

    processChar(stream[i])
    i++
  }
}
```
