这是一个非常硬核的挑战。我们要手写一个**基于二进制协议的 RPC 框架**。

为了达到“极致压缩”和“高性能”，我们将抛弃 JSON，设计一套自定义的 **TLV (Tag-Length-Value)** 二进制协议，并实现完整的客户端（Stub）和服务端（Skeleton）。

### 1. 协议设计 (Binary Protocol Spec)

我们需要定义一套二进制格式来传输函数调用和返回值。

**消息结构 (Message Structure)**:

```text
+---------+---------+---------+----------------+
|  Type   |  SeqID  | Len(4B) |    Payload     |
+---------+---------+---------+----------------+
| 1 Byte  | 4 Bytes | 4 Bytes |    N Bytes     |
+---------+---------+---------+----------------+
```

- **Type (1B)**: 消息类型。`0x01`=Request, `0x02`=Response, `0x03`=Error。
- **SeqID (4B)**: 请求序列号（用于匹配请求和响应）。
- **Len (4B)**: Payload 的长度。
- **Payload (N Bytes)**: 实际数据。

**Payload 编码 (TLV)**:
为了简单，我们支持三种类型：String, Int32, Buffer。

- String: `[Tag=1][Len][UTF8 Bytes]`
- Int32: `[Tag=2][4 Bytes]`
- Buffer: `[Tag=3][Len][Raw Bytes]`

---

### 2. 二进制编解码器 (Encoder / Decoder)

这是最底层的核心。我们需要直接操作 `Buffer` (Node.js) 或 `Uint8Array` (Browser)。

```typescript
// 类型常量
const TYPE_REQUEST = 0x01
const TYPE_RESPONSE = 0x02
const TYPE_ERROR = 0x03

const TAG_STRING = 1
const TAG_INT32 = 2

// 简单的 BufferWriter
class BufferWriter {
  private buffer: Buffer
  private offset: number = 0

  constructor(size: number = 1024) {
    this.buffer = Buffer.alloc(size)
  }

  ensure(size: number) {
    if (this.offset + size > this.buffer.length) {
      const newBuf = Buffer.alloc(this.buffer.length * 2 + size)
      this.buffer.copy(newBuf)
      this.buffer = newBuf
    }
  }

  writeUInt8(val: number) {
    this.ensure(1)
    this.buffer.writeUInt8(val, this.offset)
    this.offset += 1
  }

  writeUInt32(val: number) {
    this.ensure(4)
    this.buffer.writeUInt32BE(val, this.offset)
    this.offset += 4
  }

  writeInt32(val: number) {
    this.ensure(4)
    this.buffer.writeInt32BE(val, this.offset)
    this.offset += 4
  }

  writeString(val: string) {
    const len = Buffer.byteLength(val)
    this.ensure(len + 5) // Tag(1) + Len(4) + Bytes
    this.writeUInt8(TAG_STRING)
    this.writeUInt32(len)
    this.buffer.write(val, this.offset)
    this.offset += len
  }

  // 智能写入：根据类型自动选择 Tag
  writeAny(val: any) {
    if (typeof val === 'number') {
      this.ensure(5) // Tag(1) + Val(4)
      this.writeUInt8(TAG_INT32)
      this.writeInt32(val)
    } else if (typeof val === 'string') {
      this.writeString(val)
    } else {
      throw new Error('Unsupported type')
    }
  }

  toBuffer() {
    return this.buffer.subarray(0, this.offset)
  }
}

// 简单的 BufferReader
class BufferReader {
  private offset: number = 0

  constructor(private buffer: Buffer) {}

  readUInt8() {
    const val = this.buffer.readUInt8(this.offset)
    this.offset += 1
    return val
  }

  readUInt32() {
    const val = this.buffer.readUInt32BE(this.offset)
    this.offset += 4
    return val
  }

  readInt32() {
    const val = this.buffer.readInt32BE(this.offset)
    this.offset += 4
    return val
  }

  readString() {
    const len = this.readUInt32()
    const str = this.buffer.toString('utf8', this.offset, this.offset + len)
    this.offset += len
    return str
  }

  readAny() {
    const tag = this.readUInt8()
    if (tag === TAG_INT32) return this.readInt32()
    if (tag === TAG_STRING) return this.readString()
    throw new Error(`Unknown Tag: ${tag}`)
  }

  isEnd() {
    return this.offset >= this.buffer.length
  }
}
```

### 3. 协议封包与解包 (Packetizer)

负责将 RPC 的语义（函数名、参数）打包成上面的二进制格式。

```typescript
interface RpcPacket {
  type: number
  seqId: number
  payload: any[] // 参数列表 或 返回值
}

class Protocol {
  static encode(packet: RpcPacket): Buffer {
    const bodyWriter = new BufferWriter()

    // 写入 Payload (参数列表)
    packet.payload.forEach(arg => bodyWriter.writeAny(arg))
    const bodyBuffer = bodyWriter.toBuffer()

    // 写入 Header
    const headerWriter = new BufferWriter()
    headerWriter.writeUInt8(packet.type)
    headerWriter.writeUInt32(packet.seqId)
    headerWriter.writeUInt32(bodyBuffer.length)

    // 合并 Header + Body
    return Buffer.concat([headerWriter.toBuffer(), bodyBuffer])
  }

  static decode(buffer: Buffer): RpcPacket {
    const reader = new BufferReader(buffer)

    const type = reader.readUInt8()
    const seqId = reader.readUInt32()
    const len = reader.readUInt32() // Body 长度，这里简化处理，假设 buffer 就是完整包

    // 解析 Body
    const payload: any[] = []
    // 注意：这里应该截取 buffer 的后半部分作为 bodyReader
    // 为了简化，我们假设 reader 继续读下去就是 body
    while (!reader.isEnd()) {
      payload.push(reader.readAny())
    }

    return { type, seqId, payload }
  }
}
```

### 4. 服务端骨架 (Server Skeleton)

服务端负责监听网络端口，接收二进制流，解析出函数名和参数，执行本地函数，然后把结果编码回传。

```typescript
import * as net from 'net'

export class RpcServer {
  private methods = new Map<string, Function>()

  constructor() {}

  // 注册服务
  register(name: string, fn: Function) {
    this.methods.set(name, fn)
  }

  listen(port: number) {
    const server = net.createServer(socket => {
      console.log('[Server] Client connected')

      socket.on('data', async data => {
        // 1. 解码请求
        // 生产环境需要处理粘包/拆包 (Length-Prefixed Framing)，这里假设一次 data 就是一个完整包
        const req = Protocol.decode(data)

        if (req.type !== TYPE_REQUEST) return

        // 约定：Payload 的第一个元素是函数名，后面是参数
        const [methodName, ...args] = req.payload
        const seqId = req.seqId

        console.log(`[Server] Invoke: ${methodName}(${args})`)

        try {
          // 2. 执行本地函数
          const fn = this.methods.get(methodName)
          if (!fn) throw new Error(`Method ${methodName} not found`)

          const result = await fn(...args)

          // 3. 编码响应
          const resBuffer = Protocol.encode({
            type: TYPE_RESPONSE,
            seqId: seqId,
            payload: [result] // 响应也是个列表，虽然只有一个值
          })

          socket.write(resBuffer)
        } catch (err: any) {
          // 4. 编码错误
          const errBuffer = Protocol.encode({
            type: TYPE_ERROR,
            seqId: seqId,
            payload: [err.message]
          })
          socket.write(errBuffer)
        }
      })
    })

    server.listen(port, () => {
      console.log(`[Server] Listening on ${port}`)
    })
  }
}
```

### 5. 客户端存根 (Client Stub)

客户端负责把 `client.add(1, 2)` 转换成二进制包发送出去，并挂起 Promise 等待回包。

```typescript
export class RpcClient {
  private socket: net.Socket
  private seqId = 0
  private pending = new Map<number, { resolve: Function; reject: Function }>()

  constructor() {
    this.socket = new net.Socket()
  }

  connect(port: number): Promise<void> {
    return new Promise(resolve => {
      this.socket.connect(port, '127.0.0.1', () => {
        console.log('[Client] Connected')
        resolve()
      })

      // 监听回包
      this.socket.on('data', data => {
        const res = Protocol.decode(data)
        const task = this.pending.get(res.seqId)

        if (task) {
          if (res.type === TYPE_RESPONSE) {
            task.resolve(res.payload[0])
          } else if (res.type === TYPE_ERROR) {
            task.reject(new Error(res.payload[0]))
          }
          this.pending.delete(res.seqId)
        }
      })
    })
  }

  // 核心：动态代理
  // 让你像调用本地方法一样调用远程
  invoke(method: string, ...args: any[]): Promise<any> {
    const id = ++this.seqId

    return new Promise((resolve, reject) => {
      // 1. 挂起任务
      this.pending.set(id, { resolve, reject })

      // 2. 编码请求 (函数名 + 参数)
      const reqBuffer = Protocol.encode({
        type: TYPE_REQUEST,
        seqId: id,
        payload: [method, ...args]
      })

      // 3. 发送
      this.socket.write(reqBuffer)
    })
  }
}
```

### 6. 实战演示

把它们跑起来！

```typescript
// --- 1. 启动服务端 ---
const server = new RpcServer()

// 注册一个加法服务
server.register('add', (a: number, b: number) => {
  return a + b
})

// 注册一个字符串服务
server.register('hello', (name: string) => {
  return `Hello, ${name}!`
})

server.listen(8080)

// --- 2. 启动客户端 ---
;(async () => {
  // 等待服务器启动
  await new Promise(r => setTimeout(r, 500))

  const client = new RpcClient()
  await client.connect(8080)

  console.log('\n--- RPC Call 1: Add ---')
  // 发送二进制流：[Type=1][Seq=1][Len][Tag=String][add][Tag=Int][10][Tag=Int][20]
  const sum = await client.invoke('add', 10, 20)
  console.log('Result:', sum) // 30

  console.log('\n--- RPC Call 2: Hello ---')
  const greeting = await client.invoke('hello', 'World')
  console.log('Result:', greeting) // "Hello, World!"

  console.log('\n--- RPC Call 3: Error ---')
  try {
    await client.invoke('unknown_method')
  } catch (e: any) {
    console.error('Error:', e.message) // "Method unknown_method not found"
  }

  process.exit(0)
})()
```

### 核心设计思想总结

1.  **二进制协议 (Binary Protocol)**：
    我们没有发送 `{"method": "add", "args": [1, 2]}` 这样的 JSON 字符串（体积大、解析慢）。
    而是发送了紧凑的字节流。例如整数 `10` 只占用了 5 个字节（1 字节 Tag + 4 字节 Value），而在 JSON 中它可能占用更多（取决于字符编码），且解析 JSON 需要大量的字符串匹配操作。

2.  **TLV (Tag-Length-Value)**：
    这是二进制协议的灵魂。

    - **Tag**: 告诉解析器这是什么类型（Int? String?）。
    - **Length**: 告诉解析器读多少个字节（对于定长类型如 Int32 可以省略 Length）。
    - **Value**: 实际数据。
      这种结构使得协议具备了**自描述性**，且解析速度极快（只需要移动指针）。

3.  **请求/响应关联 (SeqID)**：
    TCP 是流式的，且是异步的。当你发送请求 A 和请求 B 后，服务器可能先返回 B 的结果。
    客户端必须维护一个 `Map<SeqID, Promise>`，通过回包里的 `SeqID` 找到对应的 Promise 并 `resolve` 它。

4.  **动态代理 (Dynamic Proxy)**：
    虽然上面的 `client.invoke` 还是显式调用，但在实际框架（如 gRPC/Dubbo）中，会结合 TypeScript 的 `Proxy` 或代码生成工具，让你写出 `client.add(1, 2)` 这样完全透明的代码。
