## FSM

这是一个非常经典的场景。在前端开发中，**拖拽 (Drag & Drop)** 往往是“状态管理噩梦”的重灾区。

如果不使用状态机，我们通常会写出这样的代码：

```javascript
let isDragging = false
let startX = 0
// 到处都是 if (isDragging) ...
```

一旦逻辑变复杂（比如：拖拽中按下 ESC 取消、拖拽出窗口边界、放置到非法区域），布尔值标志位就会指数级膨胀，导致 Bug 丛生。

下面我将手写一个**通用的有限状态机 (FSM) 引擎**，并用它完美解决拖拽交互。

### 1. 核心抽象：状态机引擎 (The Engine)

我们需要定义一套配置规范（Schema），并实现一个解释器（Interpreter）来运行它。

核心能力包括：

1.  **状态流转**：`Current State` + `Event` -> `Next State`。
2.  **上下文 (Context)**：存储扩展数据（如坐标 x, y）。
3.  **副作用 (Actions)**：
    - `entry`: 进入状态时触发（如：添加全局监听）。
    - `exit`: 离开状态时触发（如：移除全局监听）。
    - `actions`: 状态转换过程中触发（如：更新坐标）。

```typescript
// --- 类型定义 ---

// 上下文（数据）
type Context = Record<string, any>

// 事件
type Event = { type: string; payload?: any }

// 动作函数：(ctx, event) => Partial<Context> | void
// 返回值用于更新 Context (类似 Redux reducer)
type Action<TContext> = (context: TContext, event: Event) => Partial<TContext> | void

// 状态节点定义
interface StateNode<TContext> {
  entry?: Action<TContext>[] // 进入动作
  exit?: Action<TContext>[] // 离开动作
  on?: {
    [eventType: string]: {
      target?: string // 目标状态（可选，不填则为自转换）
      actions?: Action<TContext>[] // 转换过程中的动作
      guard?: (ctx: TContext, event: Event) => boolean // 守卫条件
    }
  }
}

// 机器配置
interface MachineConfig<TContext> {
  id: string
  initial: string
  context: TContext
  states: Record<string, StateNode<TContext>>
}

// --- 核心实现：解释器 ---

export class StateMachine<TContext> {
  private currentState: string
  private context: TContext
  private config: MachineConfig<TContext>
  private listeners = new Set<(state: string, ctx: TContext) => void>()

  constructor(config: MachineConfig<TContext>) {
    this.config = config
    this.currentState = config.initial
    this.context = { ...config.context }
  }

  // 订阅状态变化
  subscribe(listener: (state: string, ctx: TContext) => void) {
    this.listeners.add(listener)
    listener(this.currentState, this.context) // 立即回调当前状态
    return () => this.listeners.delete(listener)
  }

  // 核心：发送事件
  send(event: Event | string) {
    const evtObj = typeof event === 'string' ? { type: event } : event

    const stateNode = this.config.states[this.currentState]
    const transition = stateNode.on?.[evtObj.type]

    // 1. 拦截非法流转：如果没有定义该事件的处理逻辑，直接忽略
    if (!transition) {
      console.warn(`[FSM] Event '${evtObj.type}' dropped in state '${this.currentState}'`)
      return
    }

    // 2. 守卫检查 (Guard)
    if (transition.guard && !transition.guard(this.context, evtObj)) {
      console.log(`[FSM] Guard blocked transition for '${evtObj.type}'`)
      return
    }

    console.log(
      `[FSM] ${this.currentState} -> ${transition.target || '(self)'} | Event: ${evtObj.type}`
    )

    // 3. 执行当前状态的 Exit Actions
    if (transition.target && transition.target !== this.currentState) {
      stateNode.exit?.forEach(action => this.executeAction(action, evtObj))
    }

    // 4. 执行 Transition Actions (通常用于更新 Context)
    transition.actions?.forEach(action => this.executeAction(action, evtObj))

    // 5. 更新状态
    if (transition.target) {
      this.currentState = transition.target

      // 6. 执行新状态的 Entry Actions
      const newStateNode = this.config.states[this.currentState]
      newStateNode.entry?.forEach(action => this.executeAction(action, evtObj))
    }

    // 7. 通知视图更新
    this.notify()
  }

  private executeAction(action: Action<TContext>, event: Event) {
    const partialUpdate = action(this.context, event)
    if (partialUpdate) {
      // 简单的对象合并更新
      this.context = { ...this.context, ...partialUpdate }
    }
  }

  private notify() {
    this.listeners.forEach(fn => fn(this.currentState, this.context))
  }
}

// 辅助函数：创建机器
export function createMachine<T>(config: MachineConfig<T>) {
  return new StateMachine(config)
}
```

---

### 2. 业务实战：拖拽交互 (Drag & Drop)

现在我们用这套引擎来定义拖拽逻辑。

**设计思路**：

- **状态**：`idle` (空闲), `dragging` (拖拽中)。
- **事件**：`MOUSE_DOWN`, `MOUSE_MOVE`, `MOUSE_UP`, `KEY_ESC`。
- **难点解决**：
  - **全局监听**：只有在 `dragging` 状态下才需要监听 `mousemove` 和 `mouseup`。我们利用 `entry` 和 `exit` 自动管理，防止内存泄漏。
  - **位置更新**：利用 `actions` 更新 context 中的 x, y。
  - **取消拖拽**：按下 ESC 键，直接回到 `idle` 并重置坐标。

```typescript
// --- 1. 定义 Context ---
interface DragContext {
  x: number
  y: number
  startX: number
  startY: number
  itemId: string | null
}

// --- 2. 定义 Actions (纯函数逻辑) ---

// 记录初始位置
const setStartPos: Action<DragContext> = (ctx, event) => {
  return {
    startX: event.payload.x,
    startY: event.payload.y,
    x: event.payload.x,
    y: event.payload.y,
    itemId: event.payload.id
  }
}

// 更新位置
const updatePos: Action<DragContext> = (ctx, event) => {
  return { x: event.payload.x, y: event.payload.y }
}

// 重置
const reset: Action<DragContext> = () => {
  return { x: 0, y: 0, startX: 0, startY: 0, itemId: null }
}

// 副作用：绑定全局事件 (模拟)
const addGlobalListeners: Action<DragContext> = () => {
  console.log('>> [System] window.addEventListener("mousemove/up")')
}

// 副作用：解绑全局事件
const removeGlobalListeners: Action<DragContext> = () => {
  console.log('>> [System] window.removeEventListener("mousemove/up")')
}

// --- 3. 创建状态机 ---

const dragMachine = createMachine<DragContext>({
  id: 'drag-drop',
  initial: 'idle',
  context: {
    x: 0,
    y: 0,
    startX: 0,
    startY: 0,
    itemId: null
  },
  states: {
    // === 空闲状态 ===
    idle: {
      on: {
        MOUSE_DOWN: {
          target: 'dragging',
          actions: [setStartPos]
        }
      }
    },

    // === 拖拽状态 ===
    dragging: {
      // 关键：进入状态自动绑定事件，离开自动解绑
      // 这保证了逻辑的严密性，不会出现“没拖拽却在监听鼠标”的情况
      entry: [addGlobalListeners],
      exit: [removeGlobalListeners],

      on: {
        MOUSE_MOVE: {
          // 自转换：不改变状态，只执行动作
          actions: [updatePos]
        },
        MOUSE_UP: {
          target: 'idle',
          actions: [ctx => console.log(`Dropped item ${ctx.itemId} at (${ctx.x}, ${ctx.y})`)]
        },
        KEY_ESC: {
          target: 'idle',
          actions: [reset, () => console.log('Cancelled drag')]
        }
      }
    }
  }
})
```

### 3. 运行演示

让我们模拟用户的操作流，看看状态机如何响应。

```typescript
// 模拟 UI 订阅
dragMachine.subscribe((state, ctx) => {
  console.log(`[UI Render] State: ${state.toUpperCase()} | Pos: (${ctx.x}, ${ctx.y})`)
})

console.log('\n--- 1. 用户按下鼠标 ---')
dragMachine.send({
  type: 'MOUSE_DOWN',
  payload: { x: 10, y: 10, id: 'box-1' }
})
// 预期：进入 dragging，触发 entry (addListeners)，更新坐标

console.log('\n--- 2. 用户移动鼠标 ---')
dragMachine.send({
  type: 'MOUSE_MOVE',
  payload: { x: 15, y: 20 }
})
// 预期：状态保持 dragging，更新坐标

console.log('\n--- 3. 用户按下 ESC (取消) ---')
dragMachine.send({ type: 'KEY_ESC' })
// 预期：回到 idle，触发 exit (removeListeners)，重置坐标

console.log('\n--- 4. 用户乱动鼠标 (非法操作) ---')
// 此时已经是 idle 状态了
dragMachine.send({
  type: 'MOUSE_MOVE',
  payload: { x: 99, y: 99 }
})
// 预期：被拦截！idle 状态下没有定义 MOUSE_MOVE 事件。
// 这完美防止了“拖拽结束后，鼠标移动导致元素瞬移”的经典 Bug。
```

### 输出结果解析

```text
[UI Render] State: IDLE | Pos: (0, 0)

--- 1. 用户按下鼠标 ---
[FSM] idle -> dragging | Event: MOUSE_DOWN
>> [System] window.addEventListener("mousemove/up")  <-- Entry Action 自动执行
[UI Render] State: DRAGGING | Pos: (10, 10)

--- 2. 用户移动鼠标 ---
[FSM] dragging -> (self) | Event: MOUSE_MOVE
[UI Render] State: DRAGGING | Pos: (15, 20)

--- 3. 用户按下 ESC (取消) ---
[FSM] dragging -> idle | Event: KEY_ESC
>> [System] window.removeEventListener("mousemove/up") <-- Exit Action 自动执行
Cancelled drag
[UI Render] State: IDLE | Pos: (0, 0)

--- 4. 用户乱动鼠标 (非法操作) ---
[FSM] Event 'MOUSE_MOVE' dropped in state 'idle' <-- 自动防御
```

### 为什么这比 `if-else` 强？

1.  **防御性编程**：在 `idle` 状态下，无论你发多少个 `MOUSE_MOVE`，状态机都不会理你。你不需要写 `if (!isDragging) return`。
2.  **副作用管理**：`addEventListener` 和 `removeEventListener` 被严格绑定在状态的生命周期上。你永远不会忘记解绑事件。
3.  **可视化**：这套配置代码（JSON）`可以直接丢给可视化工具生成图表，逻辑一目了然。`
4.  **可扩展性**：如果以后要加一个 `DROPPING`（放置中，比如有个动画）状态，只需要在 `dragging` 和 `idle` 之间插一个状态节点，完全不影响其他逻辑。

---

## HFSM

tldraw 中使用了。

这是一个非常棒的进阶需求。

**扁平状态机 (FSM)** 的最大痛点是“状态爆炸”。
比如一个角色的状态：`站立`、`行走`、`奔跑`、`跳跃`。
如果加上“持枪”逻辑，状态就会变成：`站立`、`站立持枪`、`行走`、`行走持枪`... 状态数量呈笛卡尔积增长。

**层次状态机 (HFSM)** 允许我们将 `行走` 和 `奔跑` 归纳为 `移动 (Moving)` 的子状态。

- **父状态 (Moving)**：处理通用的逻辑（比如：受到攻击会掉血）。
- **子状态 (Walk/Run)**：处理具体的逻辑（比如：速度不同）。

下面我将手写一套支持 **无限嵌套** 的 HFSM 引擎。

### 1. 核心抽象：支持嵌套的配置结构

我们需要修改 `StateNode` 的定义，使其支持 `states`（子状态）和 `initial`（子状态默认值）。

```typescript
// --- 类型定义 ---

type Context = Record<string, any>
type Event = { type: string; payload?: any }
type Action<TContext> = (context: TContext, event: Event) => Partial<TContext> | void

interface StateNode<TContext> {
  // 核心：支持嵌套
  initial?: string // 如果有子状态，必须指定默认进入哪个子状态
  states?: Record<string, StateNode<TContext>> // 子状态表

  // 基础属性
  entry?: Action<TContext>[]
  exit?: Action<TContext>[]
  on?: {
    [eventType: string]: {
      target?: string // 目标状态路径，例如 'idle' 或 'moving.run'
      actions?: Action<TContext>[]
    }
  }
}

interface MachineConfig<TContext> {
  id: string
  initial: string
  context: TContext
  states: Record<string, StateNode<TContext>>
}
```

### 2. 核心引擎：路径解析与冒泡机制

HFSM 的核心难点在于：

1.  **路径解析**：如何表示当前状态？不再是一个字符串，而是一个**路径数组**（例如 `['moving', 'run']`）。
2.  **事件冒泡**：如果子状态不处理某个事件，应该交给父状态处理（类似 DOM 事件冒泡）。
3.  **递归进出**：从 `moving.run` 切换到 `idle`，需要依次触发 `run.exit` -> `moving.exit` -> `idle.entry`。

```typescript
export class HierarchicalStateMachine<TContext> {
  // 当前状态路径，例如 ['moving', 'run']
  private statePath: string[] = []
  private context: TContext
  private config: MachineConfig<TContext>

  constructor(config: MachineConfig<TContext>) {
    this.config = config
    this.context = { ...config.context }
    // 初始化：进入根状态的 initial
    this.enterState([config.initial])
  }

  // --- 核心逻辑 1: 递归查找节点 ---
  private getNode(path: string[]): StateNode<TContext> | undefined {
    let current: any = this.config
    for (const key of path) {
      if (!current.states || !current.states[key]) return undefined
      current = current.states[key]
    }
    return current
  }

  // --- 核心逻辑 2: 事件处理与冒泡 ---
  send(event: Event | string) {
    const evtObj = typeof event === 'string' ? { type: event } : event
    console.log(`\n[HFSM] Event: ${evtObj.type}`)

    // 从当前最深层的子状态开始，向上冒泡查找处理逻辑
    // 例如路径是 ['moving', 'run']
    // 1. 先看 'moving.run' 是否处理
    // 2. 再看 'moving' 是否处理
    // 3. 最后看 根节点 是否处理

    let handled = false
    // 这是一个从深到浅的循环
    for (let i = this.statePath.length; i >= 0; i--) {
      const currentPath = this.statePath.slice(0, i) // 当前层级的路径
      const node = i === 0 ? this.config : this.getNode(currentPath) // i=0 是根配置

      // 检查该节点是否定义了该事件的转换
      const transition = node?.on?.[evtObj.type]

      if (transition) {
        console.log(`  -> Handled by state: '${currentPath.join('.') || 'ROOT'}'`)

        // 1. 执行 Transition Actions
        transition.actions?.forEach(fn => this.executeAction(fn, evtObj))

        // 2. 如果有 target，进行状态切换
        if (transition.target) {
          this.transitionTo(transition.target, currentPath, evtObj)
        }

        handled = true
        break // 停止冒泡
      }
    }

    if (!handled) {
      console.log(`  -> Ignored (No handler found in path: ${this.statePath.join('.')})`)
    }
  }

  // --- 核心逻辑 3: 状态切换 (LCA - 最近公共祖先算法) ---
  private transitionTo(targetStr: string, sourcePath: string[], event: Event) {
    // 解析目标路径，支持相对路径和绝对路径
    // 这里简化处理，假设 target 都是绝对路径，如 'idle' 或 'moving.run'
    const targetPath = targetStr.split('.')

    // 1. 找到最近公共祖先 (LCA)
    // 例如：从 ['moving', 'run'] 切换到 ['idle']，LCA 是 [] (根)
    // 例如：从 ['moving', 'run'] 切换到 ['moving', 'walk']，LCA 是 ['moving']
    let lcaIndex = 0
    while (
      lcaIndex < this.statePath.length &&
      lcaIndex < targetPath.length &&
      this.statePath[lcaIndex] === targetPath[lcaIndex]
    ) {
      lcaIndex++
    }

    // 2. Exit: 从当前状态向上退出，直到 LCA
    for (let i = this.statePath.length; i > lcaIndex; i--) {
      const path = this.statePath.slice(0, i)
      const node = this.getNode(path)
      console.log(`  << Exit: ${path.join('.')}`)
      node?.exit?.forEach(fn => this.executeAction(fn, event))
    }

    // 3. Entry: 从 LCA 向下进入，直到目标状态
    // 注意：这里需要处理 initial 状态的递归进入
    // 如果 target 是 'moving'，但 moving 有 initial: 'run'，则最终路径应该是 ['moving', 'run']

    const finalPath = [...targetPath]

    // 补全路径：如果目标节点还有子状态，必须进入其 initial
    let currentNode = this.getNode(finalPath)
    while (currentNode && currentNode.initial) {
      finalPath.push(currentNode.initial)
      currentNode = currentNode.states?.[currentNode.initial]
    }

    // 开始逐层进入
    for (let i = lcaIndex + 1; i <= finalPath.length; i++) {
      const path = finalPath.slice(0, i)
      const node = this.getNode(path)
      console.log(`  >> Entry: ${path.join('.')}`)
      node?.entry?.forEach(fn => this.executeAction(fn, event))
    }

    // 更新当前路径
    this.statePath = finalPath
    console.log(`  == Current State: ${this.statePath.join('.')}`)
  }

  // 初始化进入状态
  private enterState(path: string[]) {
    // 递归补全 initial
    const finalPath = [...path]
    let currentNode = this.getNode(finalPath)
    while (currentNode && currentNode.initial) {
      finalPath.push(currentNode.initial)
      currentNode = currentNode.states?.[currentNode.initial]
    }

    this.statePath = finalPath

    // 触发 Entry (简化版，仅触发最终路径上的)
    for (let i = 1; i <= finalPath.length; i++) {
      const p = finalPath.slice(0, i)
      const node = this.getNode(p)
      node?.entry?.forEach(fn => this.executeAction(fn, { type: 'INIT' }))
    }
    console.log(`[HFSM] Initialized at: ${this.statePath.join('.')}`)
  }

  private executeAction(fn: Action<TContext>, event: Event) {
    const partial = fn(this.context, event)
    if (partial) Object.assign(this.context, partial)
  }
}
```

### 3. 业务实战：角色移动系统

我们来模拟一个游戏角色的状态：

- **Idle (空闲)**
- **Moving (移动)** - 父状态
  - **Walk (走)** - 子状态
  - **Run (跑)** - 子状态

**需求**：

1.  在 `Walk` 或 `Run` 状态下，按下 `STOP` 都能回到 `Idle`（**父状态处理公共逻辑**）。
2.  在 `Walk` 状态下按 `SHIFT` 切换到 `Run`。
3.  在 `Moving` 状态下（无论是走还是跑），受到攻击 `HIT` 都会掉血（**父状态处理公共逻辑**）。

```typescript
// --- 配置 ---

const playerMachine = new HierarchicalStateMachine({
  id: 'player',
  initial: 'idle',
  context: { hp: 100, speed: 0 },
  states: {
    // === 1. 空闲 ===
    idle: {
      entry: [() => console.log('  (Anim) Play Idle Animation')],
      on: {
        MOVE: { target: 'moving' } // 默认进入 moving.walk
      }
    },

    // === 2. 移动 (父状态) ===
    moving: {
      initial: 'walk', // 默认子状态

      // 父状态的 Entry/Exit 会包裹子状态
      entry: [() => console.log('  (Logic) Enable Physics')],
      exit: [() => console.log('  (Logic) Disable Physics')],

      // **关键：父状态处理公共事件**
      on: {
        STOP: { target: 'idle' }, // 无论在走还是跑，STOP 都回 idle
        HIT: {
          actions: [
            ctx => {
              ctx.hp -= 10
              console.log(`  (Logic) Ouch! HP: ${ctx.hp}`)
            }
          ]
        }
      },

      states: {
        // --- 2.1 走 ---
        walk: {
          entry: [ctx => ({ speed: 5 })], // 设置速度
          on: {
            SHIFT_DOWN: { target: 'moving.run' } // 切换兄弟状态
          }
        },

        // --- 2.2 跑 ---
        run: {
          entry: [ctx => ({ speed: 10 })],
          on: {
            SHIFT_UP: { target: 'moving.walk' }
          }
        }
      }
    }
  }
})

// --- 运行演示 ---

// 1. 开始移动 (Idle -> Moving -> Walk)
// 触发顺序：Idle Exit -> Moving Entry -> Walk Entry
playerMachine.send('MOVE')

// 2. 加速 (Walk -> Run)
// 触发顺序：Walk Exit -> Run Entry (注意：Moving 没有退出！)
playerMachine.send('SHIFT_DOWN')

// 3. 受到攻击 (冒泡机制)
// Run 状态没有定义 HIT，事件冒泡给 Moving，Moving 处理了 HIT
playerMachine.send('HIT')

// 4. 停止 (Run -> Idle)
// Run 状态没有定义 STOP，冒泡给 Moving，Moving 定义了去 Idle
// 触发顺序：Run Exit -> Moving Exit -> Idle Entry
playerMachine.send('STOP')
```

### 输出结果解析

```text
[HFSM] Initialized at: idle
  (Anim) Play Idle Animation

[HFSM] Event: MOVE
  -> Handled by state: 'idle'
  << Exit: idle
  >> Entry: moving
  (Logic) Enable Physics
  >> Entry: moving.walk
  == Current State: moving.walk

[HFSM] Event: SHIFT_DOWN
  -> Handled by state: 'moving.walk'
  << Exit: moving.walk
  >> Entry: moving.run
  == Current State: moving.run

[HFSM] Event: HIT
  -> Handled by state: 'moving'  <-- 关键：子状态没处理，父状态接管了
  (Logic) Ouch! HP: 90

[HFSM] Event: STOP
  -> Handled by state: 'moving'  <-- 关键：父状态统一处理停止逻辑
  << Exit: moving.run
  << Exit: moving                <-- 关键：父状态也退出了
  (Logic) Disable Physics
  >> Entry: idle
  (Anim) Play Idle Animation
  == Current State: idle
```

### 总结：HFSM 的威力

1.  **消除重复代码**：
    如果没有 HFSM，你需要在 `walk` 和 `run` 里都写一遍 `STOP` 事件的处理逻辑。现在只需要在 `moving` 里写一次。
2.  **逻辑解耦**：
    `moving` 负责物理引擎的开关（Entry/Exit），`walk/run` 负责具体的参数调整（Speed）。职责分明。
3.  **状态组合**：
    你可以轻松地把 `moving` 状态复用到其他角色身上，或者把 `moving` 作为一个子状态嵌入到更大的 `alive` 状态中。

这就是游戏引擎 AI 和复杂 UI 交互背后的核心秘密。

---

除了 **FSM (有限状态机)** 和 **HFSM (层次状态机)**，在复杂系统设计中，还有两种非常重要且强大的状态机变体：

1.  **并行状态机 (Parallel State Machine / Orthogonal Regions)**
    - **核心价值**：解决“多线程”状态问题。比如一个角色一边“开枪”一边“跑步”，这两个状态是正交的，互不干扰。
2.  **下推自动机 (Pushdown Automaton - PDA)**
    - **核心价值**：解决“递归”或“历史回溯”问题。比如 UI 的路由导航（A -> B -> C，点返回回到 B），或者解析嵌套语法（`((()))`）。

下面我将为你手写这两套机制的抽象。

---

### 1. 并行状态机 (Parallel State Machine)

**业务场景**：
你在开发一个富文本编辑器。

- **文本样式状态**：可以是 `Bold`, `Italic`, `Underline` 中的任意组合（或者互斥组）。
- **对齐状态**：`Left`, `Center`, `Right`（互斥）。
- **交互状态**：`Editing`, `Selecting`, `Dragging`。

这三个维度的状态是**同时存在**且**独立流转**的。如果用普通 FSM，你需要定义 `Bold_Left_Editing`, `Bold_Center_Editing`... 状态数量会爆炸（组合爆炸）。

**抽象实现**：
我们将状态机划分为多个**区域 (Regions)**，每个区域独立运行一个 FSM。

```typescript
// --- 类型定义 ---
type Event = { type: string; payload?: any }
type Action = () => void

interface RegionConfig {
  initial: string
  states: {
    [key: string]: {
      on?: { [event: string]: string } // Event -> Target
      entry?: Action
    }
  }
}

interface ParallelMachineConfig {
  regions: { [key: string]: RegionConfig }
}

// --- 核心引擎 ---

export class ParallelStateMachine {
  // 存储每个区域的当前状态: { style: 'bold', align: 'left' }
  private currentStates: Record<string, string> = {}
  private config: ParallelMachineConfig

  constructor(config: ParallelMachineConfig) {
    this.config = config
    // 初始化所有区域
    Object.keys(config.regions).forEach(regionKey => {
      const region = config.regions[regionKey]
      this.currentStates[regionKey] = region.initial
      // 触发初始状态的 entry
      region.states[region.initial].entry?.()
    })
    console.log('[Parallel] Initialized:', this.currentStates)
  }

  send(event: Event | string) {
    const evtType = typeof event === 'string' ? event : event.type
    console.log(`\n[Parallel] Event: ${evtType}`)

    // 广播事件给所有区域 (Broadcast)
    Object.keys(this.config.regions).forEach(regionKey => {
      this.processRegion(regionKey, evtType)
    })

    console.log('  == Current States:', this.currentStates)
  }

  private processRegion(regionKey: string, eventType: string) {
    const region = this.config.regions[regionKey]
    const currentStateKey = this.currentStates[regionKey]
    const stateNode = region.states[currentStateKey]

    // 检查该区域是否响应该事件
    const targetState = stateNode.on?.[eventType]

    if (targetState) {
      console.log(`  -> Region '${regionKey}': ${currentStateKey} -> ${targetState}`)

      // 简单的切换逻辑 (省略 Exit/Entry 以保持代码精简)
      this.currentStates[regionKey] = targetState

      // 触发新状态 Entry
      region.states[targetState].entry?.()
    } else {
      // 该区域忽略此事件
    }
  }
}

// --- 业务实战：富文本编辑器状态 ---

const editorMachine = new ParallelStateMachine({
  regions: {
    // 区域 1: 文本加粗状态 (开关式)
    style: {
      initial: 'normal',
      states: {
        normal: { on: { TOGGLE_BOLD: 'bold' } },
        bold: { on: { TOGGLE_BOLD: 'normal' }, entry: () => console.log('     (Style) Apply Bold') }
      }
    },
    // 区域 2: 对齐方式 (互斥式)
    align: {
      initial: 'left',
      states: {
        left: { on: { ALIGN_CENTER: 'center', ALIGN_RIGHT: 'right' } },
        center: {
          on: { ALIGN_LEFT: 'left', ALIGN_RIGHT: 'right' },
          entry: () => console.log('     (Align) Set Center')
        },
        right: { on: { ALIGN_LEFT: 'left', ALIGN_CENTER: 'center' } }
      }
    },
    // 区域 3: 系统状态
    system: {
      initial: 'idle',
      states: {
        idle: { on: { SAVE: 'saving' } },
        saving: {
          entry: () => console.log('     (Sys) Saving to cloud...'),
          on: { SAVE_SUCCESS: 'idle' }
        }
      }
    }
  }
})

// 1. 用户点击加粗
editorMachine.send('TOGGLE_BOLD')
// 结果: { style: 'bold', align: 'left', system: 'idle' }

// 2. 用户点击居中
editorMachine.send('ALIGN_CENTER')
// 结果: { style: 'bold', align: 'center', system: 'idle' }

// 3. 自动保存 (只影响 system 区域，不影响 style 和 align)
editorMachine.send('SAVE')
// 结果: { style: 'bold', align: 'center', system: 'saving' }
```

---

### 2. 下推自动机 (Pushdown Automaton - PDA)

**业务场景**：

- **UI 导航栈**：首页 -> 列表 -> 详情 -> 个人中心。点击“返回”时，你需要知道上一个状态是谁。普通 FSM 没有记忆，它不知道你是从哪跳过来的。
- **模态框管理**：弹窗 A 打开弹窗 B，弹窗 B 关闭后应该回到弹窗 A，而不是关闭所有。
- **语法解析**：解析嵌套的括号 `((()))`。

**核心机制**：
FSM + **栈 (Stack)**。
状态流转不再只是 `A -> B`，而是支持 `Push(B)`（入栈并切换）和 `Pop()`（出栈并返回）。

**抽象实现**：

```typescript
// --- 类型定义 ---
type Event = { type: string; payload?: any }

interface StateNode {
  on?: {
    [eventType: string]:
      | { type: 'push'; target: string } // 入栈切换
      | { type: 'pop' } // 出栈返回
      | { type: 'replace'; target: string } // 替换当前栈顶 (普通 FSM 行为)
  }
  entry?: () => void
  exit?: () => void
}

interface PDAMachineConfig {
  initial: string
  states: Record<string, StateNode>
}

// --- 核心引擎 ---

export class PushdownAutomaton {
  // 状态栈：栈顶就是当前状态
  private stack: string[] = []
  private config: PDAMachineConfig

  constructor(config: PDAMachineConfig) {
    this.config = config
    this.stack.push(config.initial)
    this.enter(config.initial)
  }

  getCurrentState() {
    return this.stack[this.stack.length - 1]
  }

  send(event: string) {
    const currentState = this.getCurrentState()
    const node = this.config.states[currentState]
    const transition = node.on?.[event]

    console.log(`\n[PDA] Event: ${event} | Stack: [${this.stack.join(' > ')}]`)

    if (!transition) {
      console.log('  -> Ignored')
      return
    }

    // 1. PUSH 操作
    if (transition.type === 'push') {
      console.log(`  -> PUSH ${transition.target}`)
      // 当前状态暂停 (不触发 exit，或者触发 suspend)
      this.stack.push(transition.target)
      this.enter(transition.target)
    }
    // 2. POP 操作
    else if (transition.type === 'pop') {
      if (this.stack.length <= 1) {
        console.warn('  -> Cannot pop root state')
        return
      }
      console.log(`  -> POP ${currentState}`)
      this.exit(currentState)
      this.stack.pop()
      // 恢复上一个状态 (触发 resume)
      const prevState = this.getCurrentState()
      console.log(`  -> Resume ${prevState}`)
    }
    // 3. REPLACE 操作 (普通跳转)
    else if (transition.type === 'replace') {
      console.log(`  -> REPLACE ${transition.target}`)
      this.exit(currentState)
      this.stack.pop()
      this.stack.push(transition.target)
      this.enter(transition.target)
    }
  }

  private enter(state: string) {
    this.config.states[state].entry?.()
  }

  private exit(state: string) {
    this.config.states[state].exit?.()
  }
}

// --- 业务实战：App 路由导航 ---

const routerMachine = new PushdownAutomaton({
  initial: 'Home',
  states: {
    Home: {
      on: {
        OPEN_LIST: { type: 'push', target: 'ProductList' },
        OPEN_SETTINGS: { type: 'push', target: 'Settings' }
      },
      entry: () => console.log('    Render <Home />')
    },
    ProductList: {
      on: {
        OPEN_DETAIL: { type: 'push', target: 'ProductDetail' },
        BACK: { type: 'pop' }
      },
      entry: () => console.log('    Render <ProductList />')
    },
    ProductDetail: {
      on: {
        BACK: { type: 'pop' },
        BUY_NOW: { type: 'push', target: 'Checkout' },
        // 相似商品推荐，点击后是替换当前详情，还是入栈？通常是入栈
        RELATED_ITEM: { type: 'push', target: 'ProductDetail' }
      },
      entry: () => console.log('    Render <ProductDetail />'),
      exit: () => console.log('    Unmount <ProductDetail />')
    },
    Checkout: {
      on: {
        PAY_SUCCESS: { type: 'replace', target: 'SuccessPage' }, // 支付成功后，不能按返回键回到支付页，所以用 replace
        BACK: { type: 'pop' }
      },
      entry: () => console.log('    Render <Checkout />')
    },
    SuccessPage: {
      on: {
        GO_HOME: { type: 'replace', target: 'Home' } // 或者是清空栈回到 Home，这里简化处理
      },
      entry: () => console.log('    Render <SuccessPage />')
    }
  }
})

// 1. 首页 -> 列表
routerMachine.send('OPEN_LIST')
// Stack: Home > ProductList

// 2. 列表 -> 详情 A
routerMachine.send('OPEN_DETAIL')
// Stack: Home > ProductList > ProductDetail

// 3. 详情 A -> 详情 B (递归入栈)
routerMachine.send('RELATED_ITEM')
// Stack: Home > ProductList > ProductDetail > ProductDetail

// 4. 详情 B -> 返回 -> 详情 A
routerMachine.send('BACK')
// Stack: Home > ProductList > ProductDetail

// 5. 详情 A -> 支付 -> 成功 (Replace)
routerMachine.send('BUY_NOW')
routerMachine.send('PAY_SUCCESS')
// Stack: Home > ProductList > ProductDetail > SuccessPage
// 注意：此时按 BACK 会回到 ProductDetail，而不是 Checkout，符合预期
```

### 总结

| 状态机类型          | 核心特征          | 解决的问题                 | 典型场景                 |
| :------------------ | :---------------- | :------------------------- | :----------------------- |
| **FSM (有限)**      | 单一状态          | 简单的逻辑流转             | 按钮开关、Promise 状态   |
| **HFSM (层次)**     | 状态嵌套、冒泡    | 状态数量爆炸、公共逻辑复用 | 游戏角色 AI、复杂表单    |
| **Parallel (并行)** | 正交区域、广播    | 多维度独立状态             | 富文本编辑器、仪表盘     |
| **PDA (下推)**      | 状态栈 (Push/Pop) | 历史回溯、递归结构         | 路由导航、语法解析、向导 |

这四种状态机涵盖了软件工程中 99% 的状态管理需求。掌握了它们，你就拥有了对复杂系统行为进行建模的上帝视角。
