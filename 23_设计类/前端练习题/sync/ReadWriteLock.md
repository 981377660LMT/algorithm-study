# TypeScript 实现读写锁 (ReadWriteLock)

读写锁是一种特殊的锁，它允许多个读操作同时进行，但写操作必须独占访问。这种锁在读多写少的场景中特别有效。

## 读写锁实现详解

### 1. 核心概念

读写锁是一种特殊的锁机制，它把对共享资源的访问分为两种模式：

- **读模式**：多个线程可以同时持有读锁，实现并发读取
- **写模式**：写锁是排他的，持有写锁时禁止任何其他读或写操作

这种机制特别适合于读多写少的场景，显著提高并发性能。

### 2. 关键设计点

1. **状态跟踪**：

   - `_readCount`：当前持有读锁的线程数
   - `_writing`：是否有线程持有写锁
   - `_writeRequested`：是否有写操作在等待

2. **公平模式**：

   - 防止写操作饥饿，当有写操作在等待时，新的读操作会被阻塞
   - 可通过构造函数参数控制是否启用

3. **等待队列**：

   - `_readWaiters`：等待获取读锁的线程队列
   - `_writeWaiters`：等待获取写锁的线程队列

4. **锁升级/降级**：
   - 本实现不直接支持锁升级（读锁→写锁），因为可能导致死锁
   - 可以释放读锁后再获取写锁来实现类似功能

### 3. 主要方法详解

1. **读锁操作**：

   - `readLock(timeout?)`：获取读锁，如果有写操作则等待
   - `readUnlock()`：释放读锁，如果是最后一个读者且有写操作等待，则唤醒写操作
   - `tryReadLock()`：非阻塞尝试获取读锁

2. **写锁操作**：

   - `writeLock(timeout?)`：获取写锁，如果有其他操作则等待
   - `writeUnlock()`：释放写锁，按优先级唤醒等待的操作
   - `tryWriteLock()`：非阻塞尝试获取写锁

3. **便利方法**：

   - `withReadLock(fn)`：使用读锁执行函数，自动处理锁的获取和释放
   - `withWriteLock(fn)`：使用写锁执行函数，自动处理锁的获取和释放
   - `getStatus()`：获取当前锁状态的信息

4. **控制方法**：
   - `setFairMode(fairMode)`：动态切换公平模式

### 4. 唤醒策略

释放锁时的唤醒策略影响性能和公平性：

1. **写锁释放时**：

   - 在公平模式下，优先唤醒等待的写操作
   - 如果没有写操作或非公平模式，唤醒所有等待的读操作
   - 如果没有读操作且有写操作，唤醒一个写操作

2. **读锁释放时**：
   - 仅当最后一个读者释放锁且有写操作等待时才唤醒写操作

### 5. 实现特色

1. **公平性可调**：

   - 公平模式防止写操作饥饿
   - 非公平模式提高吞吐量，但可能导致写操作长时间等待

2. **超时支持**：

   - 所有阻塞操作都支持超时机制
   - 防止死锁和长时间等待

3. **诊断与监控**：

   - 提供详细的状态信息
   - 有助于调试和性能优化

4. **易用API**：
   - withReadLock/withWriteLock方法简化锁的使用
   - 提供非阻塞尝试方法，增加编程灵活性

### 6. 使用场景

1. **读多写少的数据结构**：

   - 缓存系统
   - 配置管理
   - 字典和查找表

2. **需要高并发读取但写入较少的系统**：

   - 数据库连接池
   - 网络服务器中的共享资源

3. **批量读取与偶尔更新的场景**：
   - 报表生成系统
   - 监控和统计数据收集

这个读写锁实现既保证了正确性，又提供了可配置的公平性和超时机制，是并发编程工具箱中的重要组件。
