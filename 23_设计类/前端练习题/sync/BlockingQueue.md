# TypeScript 实现阻塞队列 (BlockingQueue)

阻塞队列是一种线程安全的队列，当队列为空时，获取元素的线程会被阻塞；当队列已满时，添加元素的线程会被阻塞。这种同步集合在生产者-消费者模式中特别有用。

## BlockingQueue 实现详解

### 核心特性

1. **有界队列**:

   - 支持设置最大容量，默认为无限制
   - 当队列已满时，阻塞添加操作

2. **阻塞操作**:

   - `put(element, timeout?)`: 添加元素，队列满时阻塞
   - `take(timeout?)`: 获取元素，队列空时阻塞
   - 两种操作都支持可选的超时参数

3. **非阻塞操作**:

   - `offer(element)`: 尝试添加元素，不阻塞，返回操作是否成功
   - `poll()`: 尝试获取元素，不阻塞，队列为空时返回 undefined

4. **直通操作**:
   - 当生产者添加元素时，如果有消费者正在等待，则元素直接传递给消费者
   - 当消费者获取元素后，如果有生产者正在等待，则立即允许一个生产者添加元素

### 数据结构

1. **内部队列** (`_queue`):

   - 使用数组存储队列中的元素

2. **等待队列**:
   - `_putters`: 等待添加元素的生产者队列
   - `_takers`: 等待获取元素的消费者队列
   - 每个等待项都包含解决 Promise 的函数和可能的超时处理器

### 关键方法详解

1. **构造函数**:

   - 接受可选的容量参数，默认为 Infinity（无界队列）
   - 验证容量必须大于0

2. **put(element, timeout?)**:

   - 首先检查是否有等待的消费者，有则直接传递元素
   - 如果队列未满，直接添加元素
   - 如果队列已满，创建一个Promise并将生产者放入等待队列
   - 支持超时机制，超时后自动从等待队列移除并拒绝Promise

3. **take(timeout?)**:

   - 首先检查队列是否有元素，有则直接返回
   - 取出元素后，如果有等待的生产者，允许其添加元素
   - 如果队列为空，创建一个Promise并将消费者放入等待队列
   - 支持超时机制，超时后自动从等待队列移除并拒绝Promise

4. **offer(element)**:

   - 尝试立即添加元素，不阻塞
   - 如果有等待的消费者或队列未满，则添加成功并返回true
   - 否则返回false，表示添加失败

5. **poll()**:

   - 尝试立即获取元素，不阻塞
   - 如果队列为空，返回undefined
   - 否则返回并移除队列头部元素

6. **clear()**:
   - 清空队列
   - 尝试唤醒等待的生产者，因为现在队列有空间了
   - 注意：这会保持消费者继续等待

### 实现亮点

1. **直通优化**:

   - 当生产者和消费者都在等待时，实现了元素的直接传递
   - 减少了元素在队列中的不必要存储和移动

2. **超时处理**:

   - 阻塞操作支持超时机制，防止无限等待
   - 超时后自动清理资源并通知调用者

3. **公平性**:

   - 使用队列（先进先出）管理等待的生产者和消费者
   - 确保先等待的线程先得到处理

4. **全API支持**:

   - 实现了完整的阻塞队列API，包括阻塞和非阻塞操作
   - 兼容类似Java BlockingQueue的方法名称和行为
   - 还提供了辅助方法如peek(), clear(), toArray()等

5. **静态工厂方法**:
   - 提供了静态方法BlockingQueue.of()用于创建带初始元素的队列

### 使用场景

1. **生产者-消费者模式**:

   - 多个生产者可以安全地添加元素
   - 多个消费者可以安全地获取元素
   - 自动处理速度不匹配的情况

2. **工作队列**:

   - 作为任务调度系统的核心组件
   - 管理等待执行的任务

3. **数据流控制**:

   - 在数据处理流程中作为缓冲区
   - 调节生产者和消费者的速度差异

4. **异步编程模式**:
   - 在异步编程中安全地传递数据
   - 确保数据按正确顺序处理

这个实现完全基于Promise，与JavaScript/TypeScript的异步编程模型完美结合，同时借鉴了Java BlockingQueue的设计理念，提供了一个功能完善、类型安全的阻塞队列。
