电梯调度算法（Elevator Dispatching Algorithm）是操作系统调度和实时控制领域的经典问题。

### 核心算法解析

#### 1. 单电梯算法：SCAN (扫描算法) / LOOK 算法

最基础的电梯调度并不是简单的“先来先服务”（FCFS），而是基于当前移动方向的**SCAN 算法**（也称为电梯算法）。

- **逻辑**：电梯保持当前方向移动，直到该方向上没有更多的请求，然后改变方向。
- **改进版 (LOOK)**：SCAN 会扫到顶层或底层才回头，而 LOOK 算法只移动到该方向最远的请求楼层即回头，效率更高。

#### 2. 多电梯调度：群控算法

多电梯系统的核心在于**派梯策略**（Dispatching Strategy），即当某一层有请求时，指派哪一部电梯去响应。
常见的策略采用了评分/代价函数（Cost Function）：
$$ Cost = \sum (等待时间 + 运行时间 + 停站惩罚) $$

常用的启发式策略包括：

- **最小等待时间策略**：计算每部电梯到达请求楼层所需的预计时间，选最短的。
- **分区响应**：高层电梯只停高层，低层电梯只停低层。
- **闲置策略**：闲置电梯自动停靠在特定楼层（如 1 楼或中间层）待命。

---

### TypeScript 代码抽象

下面的代码展示了一个包含多电梯调度系统的抽象架构。它实现了 LOOK 算法作为单梯逻辑，并使用“最小预估时间”作为群控派梯策略。

你可以将此代码保存为 `elevator-system.ts`。

```typescript
/**
 * 电梯的方向
 */
enum Direction {
  UP = 1,
  DOWN = -1,
  IDLE = 0
}

/**
 * 电梯的状态接口
 */
interface ElevatorStatus {
  id: number
  currentFloor: number
  direction: Direction
  targetFloors: Set<number> // 无论是指派的任务还是内部按下的楼层都存在这里
}

/**
 * 单个电梯类
 * 实现了 LOOK 算法逻辑
 */
class Elevator {
  public id: number
  public currentFloor: number = 1
  public direction: Direction = Direction.IDLE
  // 使用 Set 自动去重
  public targetFloors: Set<number> = new Set()

  constructor(id: number) {
    this.id = id
  }

  /**
   * 添加目标楼层（乘客在电梯内按下，或系统指派）
   */
  addRequest(floor: number) {
    if (floor === this.currentFloor) return // 已经在该层
    this.targetFloors.add(floor)
    this.updateDirection()
  }

  /**
   * 模拟电梯运行一步（例如每秒调用一次）
   */
  step() {
    if (this.direction === Direction.IDLE) return

    // 移动逻辑
    this.currentFloor += this.direction
    console.log(`[电梯 ${this.id}] 到达 ${this.currentFloor} 层`)

    // 到达处理
    if (this.targetFloors.has(this.currentFloor)) {
      console.log(`[电梯 ${this.id}] 开门 - 乘客上下`)
      this.targetFloors.delete(this.currentFloor)
    }

    this.updateDirection()
  }

  /**
   * 核心调度逻辑 (LOOK 算法)
   * 决定下一步的方向
   */
  private updateDirection() {
    if (this.targetFloors.size === 0) {
      this.direction = Direction.IDLE
      return
    }

    // 获取当前方向上的所有请求
    const requests = Array.from(this.targetFloors)
    const above = requests.filter(f => f > this.currentFloor)
    const below = requests.filter(f => f < this.currentFloor)

    if (this.direction === Direction.UP) {
      // 如果向上还有请求，继续向上；否则如果下面有请求，掉头
      if (above.length > 0) {
        this.direction = Direction.UP
      } else if (below.length > 0) {
        this.direction = Direction.DOWN
      } else {
        this.direction = Direction.IDLE
      }
    } else if (this.direction === Direction.DOWN) {
      // 如果向下还有请求，继续向下；否则如果上面有请求，掉头
      if (below.length > 0) {
        this.direction = Direction.DOWN
      } else if (above.length > 0) {
        this.direction = Direction.UP
      } else {
        this.direction = Direction.IDLE
      }
    } else {
      // IDLE 状态：去往最近的请求方向
      // 简单策略：优先向上，或者找最近的（此处简化处理）
      const nearest = requests.reduce((prev, curr) =>
        Math.abs(curr - this.currentFloor) < Math.abs(prev - this.currentFloor) ? curr : prev
      )
      this.direction = nearest > this.currentFloor ? Direction.UP : Direction.DOWN
    }
  }

  /**
   * 估算到达某层所需的代价（用于群控系统决策）
   * 代价 = 距离 + 停顿惩罚
   */
  calculateCost(targetFloor: number): number {
    if (this.currentFloor === targetFloor) return 0

    let cost = 0
    const distance = Math.abs(targetFloor - this.currentFloor)

    // 1.若是闲置，代价主要是距离
    if (this.direction === Direction.IDLE) {
      return distance
    }

    // 2.若顺路 (例如电梯向上，目标在上方)
    // 且目标在当前运行区间内，代价较小
    const isUp = this.direction === Direction.UP
    const isOnPath = isUp ? targetFloor > this.currentFloor : targetFloor < this.currentFloor

    if (isOnPath) {
      cost = distance
      // 加上沿途停站的惩罚（假设每停一次增加 5 个单位时间）
      this.targetFloors.forEach(f => {
        if (
          (isUp && f < targetFloor && f > this.currentFloor) ||
          (!isUp && f > targetFloor && f < this.currentFloor)
        ) {
          cost += 5
        }
      })
      return cost
    }

    // 3.若不顺路（需要折返），代价极大
    // 简单估算：当前方向走到尽头 + 从尽头回来的距离
    // 这里只是一个简单的启发式估算
    return distance + 100
  }
}

/**
 * 电梯群控系统
 */
class ElevatorSystem {
  private elevators: Elevator[]

  constructor(count: number) {
    this.elevators = Array.from({ length: count }, (_, i) => new Elevator(i + 1))
  }

  /**
   * 处理外部的楼层呼叫（例如在 3 楼按上）
   */
  public requestElevator(floor: number, direction: Direction) {
    console.log(`>>>收到请求：${floor} 楼，方向 ${direction === Direction.UP ? '上' : '下'}`)

    // 简单的派梯策略：寻找代价最小的电梯
    let bestElevator: Elevator | null = null
    let minCost = Infinity

    for (const elevator of this.elevators) {
      const cost = elevator.calculateCost(floor)
      // 甚至可以加入负载判断，如果电梯满员则 cost 无穷大
      if (cost < minCost) {
        minCost = cost
        bestElevator = elevator
      }
    }

    if (bestElevator) {
      console.log(`>>> 指派 [电梯 ${bestElevator.id}] 响应请求 (预计代价: ${minCost})`)
      bestElevator.addRequest(floor)
    }
  }

  /**
   * 模拟系统运行
   */
  public runSimulationStep() {
    this.elevators.forEach(e => e.step())
  }

  // 供测试用：模拟内部按键
  public pressTotalButton(elevatorId: number, floor: number) {
    const elevator = this.elevators.find(e => e.id === elevatorId)
    if (elevator) {
      console.log(`>>> 乘客在 [电梯 ${elevatorId}] 内部按下 ${floor}`)
      elevator.addRequest(floor)
    }
  }
}

// --- 自动测试脚本 ---

const sys = new ElevatorSystem(2) // 2部电梯

// 场景模拟
// 电梯1在 1 楼，电梯2在 1 楼

// 1. 电梯1 接到去 10 楼的任务
sys.pressTotalButton(1, 10)

// 模拟运行几步
console.log('--- 时间流逝 ---')
sys.runSimulationStep()
sys.runSimulationStep()
sys.runSimulationStep() // 电梯1 应该到了 4 楼左右

// 2. 此时 5 楼有人按上
// 理论上电梯1顺路，代价小；电梯2虽闲置但有距离成本，
// 具体取决于 cost 算法对闲置和顺路的权重分配
sys.requestElevator(5, Direction.UP)

// 3. 此时 2 楼有人按下
// 电梯1已经过了，只能派电梯2
sys.requestElevator(2, Direction.DOWN)

console.log('--- 时间流逝 ---')
for (let i = 0; i < 10; i++) {
  sys.runSimulationStep()
}
```
