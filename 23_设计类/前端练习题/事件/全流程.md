这确实是前端开发中最容易混淆的“百慕大三角”。要彻底搞懂，我们需要建立一个**“双重宇宙”**的上帝视角。

不要把它们混在一起看，要把它们拆分为：**物理世界（DOM 树）** 和 **逻辑世界（Fiber 树）**。

---

### 核心公理：大一统模型

请记住这三条铁律，它们能解释一切怪象：

1.  **双轨制**：浏览器跑的是 **DOM 事件流**；React 跑的是 **合成事件流**。
2.  **接触点**：React 的合成事件流，是在原生 DOM 事件**冒泡到 `root` 节点**（React 17+）时才启动的。
3.  **逻辑优先**：React 的冒泡是沿着 **组件树（Fiber）** 走的，而不是沿着 **DOM 树** 走的。（这就是 Portal 能冒泡的原因）。

---

### 深度解析：全流程时间轴

假设场景：

- DOM 结构：`body` -> `div#root` -> `div#parent` -> `button#child`
- React 结构：`App` -> `Parent` -> `Child`
- 我们在 `button` 上点击。

请按顺序看这个**绝对执行序列**：

#### 第一阶段：物理世界（原生 DOM 狂奔）

用户点击按钮，浏览器接管，开始标准的 W3C 流程：

1.  **原生捕获**：`window` -> `document` -> `body` -> `#root` -> `#parent`
2.  **原生目标**：到达 `#child` (button)。
    - _注意：如果你在 button 上写了 `ref.current.addEventListener`，这里就会执行。_
3.  **原生冒泡（开始）**：`#child` -> `#parent`。
    - _注意：如果你在 parent 的 DOM 上写了原生监听，这里执行。_

#### 第二阶段：接触点（React 介入）

4.  **原生冒泡到达 `#root`**：
    - React 在 `#root` 上绑定了全局监听器（`dispatchEvent`）。
    - React 捕获到了这个原生事件。
    - React 看着手里的原生事件对象 `event.target`（即 `#child`），问自己：“这个 DOM 节点对应哪个 React 组件？”
    - React 找到了 Fiber 节点：`Child` 组件。

#### 第三阶段：逻辑世界（React 模拟）

React 拿着找到的 `Child` Fiber 节点，开始在**虚拟的组件树**上模拟一遍流程：

5.  **React 收集**：从 `Child` 沿着 **Fiber 树** 向上找父级 (`Parent` -> `App`)，把所有的 `onClick` 和 `onClickCapture` 收集起来。
6.  **React 捕获执行**：按顺序执行收集到的 `onClickCapture`。
7.  **React 冒泡执行**：按顺序执行收集到的 `onClick`。
    - `Child` 的 `onClick`
    - `Parent` 的 `onClick`
    - `App` 的 `onClick`

#### 第四阶段：物理世界（余音）

8.  **原生冒泡（继续）**：
    - React 执行完了，原生事件继续从 `#root` 往上冒泡 -> `body` -> `document` -> `window`。

---

### 疑难杂症一针见血

#### 1. 为什么 Portal（传送门）能冒泡？

**现象**：
你用 `createPortal` 把 Modal 渲染到了 `document.body` 下（视觉上和 `#root` 平级）。
但在 React 代码里，Modal 是写在 `Parent` 组件里的。
点击 Modal 里的按钮，`Parent` 的 `onClick` 居然触发了！

**真相**：

- **物理上（DOM）**：事件从 Modal 冒泡到了 `body`，根本没经过 `#root` 里的 `#parent` DOM 节点。
- **逻辑上（React）**：React 的事件处理不看 DOM 结构！
  - 当事件触发时，React 发现 target 是 Modal 里的按钮。
  - React 查 Fiber 树：Modal 的 `return` 指针（父级）指向的是 `Parent` 组件。
  - 所以 React 模拟冒泡时：Modal -> Parent -> App。
  - **结论：React 冒泡是“认祖归宗”（Fiber 亲缘），不是“顺藤摸瓜”（DOM 结构）。**

#### 2. 阻止冒泡 (`stopPropagation`) 的大坑

这里有两个层面的阻止：

- **在 React 事件中调用 `e.stopPropagation()`**：

  - **阻止了 React 冒泡**：父组件的 `onClick` 不会触发。
  - **阻止了 原生 冒泡（继续向上）**：React 会调用底层的原生 `e.stopPropagation()`。这意味着事件不会继续冒泡到 `document` 或 `window`。
  - _但是_：它无法阻止同级或下级已经发生过的原生冒泡（因为 React 执行时，原生冒泡已经到了 root）。

- **在 原生 事件中调用 `e.stopPropagation()`**：
  - 如果你在 `#child` (button) 的原生监听器里写了 `e.stopPropagation()`。
  - 事件在 `#child` 就断了，**永远到不了 `#root`**。
  - React 的全局监听器收不到信号。
  - **结果：所有的 React 事件（无论是 Child 还是 Parent）统统失效！**

#### 3. 谁先执行？

这是一个经典面试题：原生事件和 React 事件混用，谁快？

- **原生子元素监听器** > **React 监听器** > **原生父元素监听器 (document/body)**
  - 原因：原生子元素先冒泡 -> 冒泡到 root (React 执行) -> 继续冒泡到 document。

### 终极图解（脑补版）

想象一条河流（事件流）：

1.  **上游（DOM 子节点）**：水流先经过这里（原生事件）。
2.  **大坝（React Root）**：水流汇聚到大坝。
    - 大坝内部有一个**全息投影系统**（React Fiber）。
    - 系统根据水流来源，在投影里模拟了一次水流倒流和顺流（React 捕获与冒泡）。
    - 投影里的 Portal 就像虫洞，水流直接跳跃到了逻辑父级。
3.  **下游（DOM 父节点/Document）**：大坝放水，水流继续流向大海。

### 总结口诀

> **原生先跑路，冒泡到 Root。** > **React 才苏醒，Fiber 树上走。** > **Portal 虽远房，Fiber 牵着手。** > **阻止原生泡，React 命没有。**

---

好的，我们继续深入，补充一些在实际开发中非常棘手、但理解了上述模型后就能迎刃而解的高级场景和细节。

我们将重点补充以下三个方面：

1.  **React 16 vs React 17+ 的关键变革（为什么以前的代码现在不行了？）**
2.  **微任务与批处理（Batching）对事件的影响**
3.  **实战：点击外部关闭弹窗（Click Outside）的最佳实践**

---

### 1. 历史的包袱：React 16 vs 17+ 的变革

很多老教程或者老代码库还在讲 React 16 的行为，这会导致巨大的认知偏差。

#### 变革点：挂载目标 (Attachment Target)

- **React 16**：所有事件委托给 `document`。
- **React 17+**：所有事件委托给 `rootNode` (即 `ReactDOM.createRoot(rootNode)` 中的那个容器)。

**这个改变解决了什么痛点？—— “多版本共存”与“微前端”**

**场景**：你的页面是一个 jQuery 老项目（或者微前端基座），里面嵌入了一个 React 应用。

- **在 React 16 中**：如果你在 jQuery 的外层容器上写了 `e.stopPropagation()`，试图阻止事件冒泡。
  - 结果：**无效**。因为 React 的事件是挂在 `document` 上的，事件必须冒泡到顶层 `document` 才能被 React 捕获。jQuery 在中间截断了，React 就“死”了。
- **在 React 17+ 中**：React 监听器挂在 `root` 容器上。
  - 只要事件能冒泡到 `root`，React 就能正常工作。外部 jQuery 容器阻止冒泡不再影响 React 内部逻辑。

#### 变革点：执行时机

- **React 16**：React 事件处理逻辑是在原生事件冒泡到 `document` 时才执行。这意味着，**原生事件早已跑完了整个 DOM 树**。
- **React 17+**：React 事件处理逻辑是在原生事件冒泡到 `root` 时执行。

**影响**：
如果你在 React 组件里写：

```javascript
useEffect(() => {
  document.addEventListener('click', () => console.log('Document Native'))
}, [])

return <button onClick={() => console.log('React Button')}>Click</button>
```

- **React 16**: 输出顺序 `Document Native` -> `React Button` (因为 React 也是在 document 上，且通常后绑定)。
- **React 17+**: 输出顺序 `React Button` -> `Document Native` (符合直觉：React 在 root 处理完，继续冒泡才到 document)。

---

### 2. 隐形的手：合成事件与批处理 (Batching)

React 的事件处理函数不仅仅是执行逻辑，它还包裹了一层 **`batchedUpdates`**。

#### 自动批处理 (Automatic Batching)

**场景**：

```javascript
const handleClick = () => {
  setCount(c => c + 1)
  setFlag(f => !f)
  // React 18 之前：这里会触发一次重渲染（合并了）
  // React 18：这里依然是一次重渲染
}
```

**差异在于异步操作**：

```javascript
const handleClick = () => {
  setTimeout(() => {
    setCount(c => c + 1)
    setFlag(f => !f)
  }, 0)
}
```

- **React 17 及之前**：`setTimeout` 脱离了 React 事件的执行上下文。React **无法**自动批处理。结果：**触发两次重渲染**。
- **React 18**：引入了自动批处理机制。无论在哪里（Promise, setTimeout, native event），只要是同一个“宏任务/微任务”周期内的更新，都会合并。结果：**触发一次重渲染**。

**这对事件有什么影响？**
如果你在 React 事件中混用了原生 DOM 操作和 State 更新，可能会遇到“状态不同步”的问题，因为 State 更新是异步批处理的，而 DOM 操作是同步的。

---

### 3. 实战：Click Outside (点击外部关闭)

这是最能检验你对“双重宇宙”理解深度的场景。

**需求**：点击按钮打开弹窗，点击弹窗内部不关闭，点击弹窗外部（包括按钮本身）关闭。

#### 错误写法 (常见坑)

```javascript
// ❌ 错误示范
function Popover() {
  const [show, setShow] = useState(false)

  useEffect(() => {
    const close = e => {
      // 试图判断点击的是否是弹窗内部
      // 但如果弹窗里有 Portal，contains 判断会失效！
      if (popoverRef.current.contains(e.target)) return
      setShow(false)
    }
    document.addEventListener('click', close)
    return () => document.removeEventListener('click', close)
  }, [])

  const handleButtonClick = e => {
    // 阻止冒泡，防止触发 document 的 close
    // 坑点：React 17+ 中，e.stopPropagation() 确实能阻止冒泡到 document
    // 但如果这是 React 16，这行代码拦不住 document 上的原生监听器！
    e.stopPropagation()
    setShow(true)
  }

  return (
    <div>
      <button onClick={handleButtonClick}>Toggle</button>
      {show && <div ref={popoverRef}>Content</div>}
    </div>
  )
}
```

#### 完美写法 (利用捕获与逻辑判断)

最佳实践是不依赖 `stopPropagation`，而是依赖**逻辑判断**。

```javascript
// ✅ 最佳实践
function Popover() {
  const [show, setShow] = useState(false)
  const buttonRef = useRef(null)
  const popoverRef = useRef(null)

  useEffect(() => {
    const handleClickOutside = e => {
      // 核心逻辑：判断点击目标是否在“白名单”内
      // 1. 点击了按钮本身 -> 忽略（由按钮自己的 onClick 处理）
      // 2. 点击了弹窗内部 -> 忽略
      const target = e.target

      if (
        (buttonRef.current && buttonRef.current.contains(target)) ||
        (popoverRef.current && popoverRef.current.contains(target))
      ) {
        return
      }

      setShow(false)
    }

    // 技巧：使用 'mousedown' 或 'pointerdown' 体验更好，
    // 且挂载在 document 上能覆盖所有情况
    document.addEventListener('mousedown', handleClickOutside)
    return () => document.removeEventListener('mousedown', handleClickOutside)
  }, [])

  return (
    <div>
      <button ref={buttonRef} onClick={() => setShow(!show)}>
        Toggle
      </button>

      {show && (
        // 即使这里用了 Portal，ref.contains(e.target) 依然有效
        // 因为 e.target 是物理 DOM 节点
        <div ref={popoverRef}>Content</div>
      )}
    </div>
  )
}
```

### 补充总结：调试技巧

当你再次遇到事件诡异问题时，按以下步骤排查：

1.  **看 target**：在控制台打印 `e.target`。它是物理世界中真正被点击的那个最小的 DOM 元素。
2.  **看 `currentTarget`**：
    - 原生事件中，它是绑定监听器的元素。
    - React 事件中，它是当前组件对应的 DOM 元素。
3.  **查 Portal**：如果有 Portal，记住 React 事件流会跳跃，但 DOM 事件流不会。
4.  **查版本**：确认是 React 16 还是 17+，决定了原生冒泡到 document 还是 root。

希望这套补充能帮你彻底打通前端事件的任督二脉！

---

这是一个非常经典的问题。很多人写了几年代码，依然是“哪个有值用哪个”，完全靠蒙。

要彻底终结这个疑惑，你只需要记住一个**“快递员模型”**。

---

### 核心模型：快递员与收件人

想象一个场景：

- **事件对象 (`event`)** = **快递包裹**。
- **target** = **包裹的原始发货地**（肇事者）。
- **`currentTarget`** = **当前拿着包裹的人**（处理者）。

---

### 1. 一句话区分

- **target (目标)**：**永远不变**。它是事件发生的**源头**，是用户手指头真正点到的那个最内层的 DOM 元素。
- **`currentTarget` (当前目标)**：**一直在变**。它是事件流（冒泡/捕获）当前流经的那个元素，也就是**你 `addEventListener` 绑定的那个元素**。

---

### 2. 动态图解（脑补版）

假设 HTML 结构如下：

```html
<div id="parent" onclick="handler(event)">
  <button id="child">点我</button>
</div>
```

#### 场景 A：你点击了 `button#child`

事件开始冒泡，包裹从 `button` 传给 `div`。

1.  **当事件在 `button` 上触发时（如果有监听器）：**

    - target: `button` (肇事者)
    - `currentTarget`: `button` (当前处理者)
    - _状态：两者相等。_

2.  **当事件冒泡到 `div#parent` 时（执行 `handler`）：**
    - target: **`button`** (肇事者永远是 button，因为你点的是它)
    - `currentTarget`: **`div`** (现在是 div 在处理事件)
    - _状态：两者不相等。_

#### 场景 B：你点击了 `div#parent` 的空白处（没有点到 button）

1.  **当事件在 `div` 上触发时：**
    - target: `div` (肇事者是 div)
    - `currentTarget`: `div` (当前处理者是 div)
    - _状态：两者相等。_

---

### 3. 为什么需要这两个？（实战价值）

#### target 的用途：事件委托 (Event Delegation)

这是 target 存在的最大意义。因为 target 永远指向最内层元素，所以我们可以在父元素上监听，然后通过 target 知道具体点了哪个子元素。

```javascript
// 只需要在 ul 上绑定一次，不用给 1000 个 li 绑定
document.querySelector('ul').addEventListener('click', function (e) {
  // e.currentTarget 是 ul (永远是它)
  // e.target 可能是 li, span, i 等等 (取决于你点到了谁)

  if (e.target.tagName === 'LI') {
    console.log('你点击了列表项')
  }
})
```

#### `currentTarget` 的用途：获取绑定数据

当你需要获取**绑定事件的那个元素**上的属性时，必须用 `currentTarget`。

```javascript
// <button data-id="123"> <span>图标</span> 提交 </button>

button.addEventListener('click', function (e) {
  // ❌ 错误写法
  // 如果用户点到了 <span>，e.target 就是 span
  // span 上没有 dataset.id，导致代码报错或逻辑错误
  console.log(e.target.dataset.id) // undefined

  // ✅ 正确写法
  // 无论点到 span 还是 button，e.currentTarget 永远是 button
  console.log(e.currentTarget.dataset.id) // "123"
})
```

---

### 4. React 中的特殊情况

在 React 中，逻辑完全一致，但有一个**巨大的坑**（仅限 React 16 及更早版本，React 17+ 已修复）：

在 React 事件回调中，`e.currentTarget` 只有在事件回调函数执行期间有效。如果你在 `setTimeout` 或 `await` 之后打印它，它可能已经变成了 `null`。

**但在现代 React (17+) 开发中，你只需要记住：**

> **`e.currentTarget` === `this`**
> (在原生 DOM 事件中，`currentTarget` 就等于函数内部的 `this`。在 React 中虽然 `this` 不指向 DOM，但 `currentTarget` 的语义就是“我当前挂载组件对应的那个 DOM”)。

### 终极口诀

> **target 是案发现场，谁被点了就是谁，天王老子来了也不变。** > **`currentTarget` 是派出所，案子转到谁那处理，就是谁。**
