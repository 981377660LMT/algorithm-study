## 点击弹出的抽屉后，抽屉的点击事件冒泡到画布，选择的组件变化，导致面板关闭

这个问题通常是因为弹出的抽屉组件使用了 React Portal 将 DOM 挂载到了 `body` 上，但 React 的事件冒泡机制仍然会沿着组件树向上传递，导致画布容器捕获到了点击事件。

由于弹出的组件抽屉的 DOM 实际上并不在画布容器的 DOM 内部，我们可以通过检查 `e.target` 是否包含在 `e.currentTarget`（画布容器）中来过滤掉这些冒泡上来的事件。

请在 useCanvasEvents.tsx 中修改 `onPointerDown` 方法：

```typescript
// ...existing code...
      onPointerDown: (e: React.PointerEvent) => {
        if ((e as any).dead) {
          return;
        } else {
          (e as any).dead = true;
        }

        // 阻止 React Portal 冒泡的事件（如抽屉、弹窗）触发画布交互
        // 如果事件目标不在当前容器内，说明它是通过 Portal 冒泡过来的(不是点击画布内的元素，就不要冒泡到画布)
        if (e.currentTarget && !e.currentTarget.contains(e.target as Node)) {
          return;
        }

        if (!inputs.pointerIsValid(e)) {
          return;
        }

        // setPointerCapture 会使onClick事件无法冒泡，导致 textinput输入框的清除icon点击失效，或下拉框的下拉选择失效等。
// ...existing code...
```

**原理说明：**

- `e.currentTarget` 是绑定了事件监听器的元素（即画布容器）。
- `e.target` 是实际被点击的元素（即抽屉内的元素）。
- 如果是 React Portal 渲染的抽屉，`e.target` 在 DOM 结构上位于 `body` 下，不在 `e.currentTarget` 内部。
- `!e.currentTarget.contains(e.target)` 为 `true`，从而直接返回，不再执行后续的选中/取消选中逻辑。

---

这段代码和解释完美地应用了我们刚才讨论的 **“双重宇宙”**（物理 DOM vs 逻辑 Fiber）和 **“快递员模型”**（target vs currentTarget）。

让我们用刚才建立的模型来“解剖”这个 bug 修复方案。

### 1. 场景还原

- **画布容器 (Canvas)**：绑定了 `onPointerDown`，用于处理画布上的点击交互（比如选中节点）。
- **抽屉 (Drawer)**：这是一个弹出的组件，使用了 **React Portal**。
  - **逻辑上**：抽屉写在画布组件里面（或者层级之下），所以 React 认为它是画布的“子孙”。
  - **物理上**：抽屉的 DOM 被传送到了 `document.body` 下，**完全脱离**了画布容器的 DOM 结构。

### 2. 问题产生：幽灵冒泡

当你点击抽屉里的按钮时：

1.  **物理世界**：点击发生在 `body > Drawer > Button`。事件在 DOM 上冒泡，根本碰不到 `Canvas` 的 DOM。
2.  **逻辑世界 (React)**：React 捕获到事件，发现 `Button` 组件在 Fiber 树里是 `Canvas` 组件的后代。
3.  **React 模拟冒泡**：React 强行把事件传给了 `Canvas` 的 `onPointerDown`。

**结果**：你点抽屉，画布却以为你点了它，触发了画布的选中逻辑（比如取消选中了画布上的其他元素）。

### 3. 解决方案解析：利用“双重宇宙”的裂缝

代码的核心逻辑是这一句：

```typescript
if (e.currentTarget && !e.currentTarget.contains(e.target as Node)) {
  return
}
```

让我们套用模型：

- **`e.currentTarget` (派出所)**：

  - 这是 **画布容器** 的 DOM 节点。
  - 因为事件处理函数是绑定在画布上的。

- **`e.target` (案发现场)**：

  - 这是 **抽屉里被点击的那个元素** 的 DOM 节点。
  - 它位于 `document.body` 下。

- **`contains` (物理检查)**：

  - 我们在问浏览器：**“物理上，这个案发现场（抽屉元素）是在派出所（画布容器）的地盘里吗？”**

- **判定**：
  - **如果是普通子组件**：target 就在 `currentTarget` 肚子里。`contains` 返回 `true`。逻辑继续。
  - **如果是 Portal 抽屉**：target 在 `body` 下，`currentTarget` 在画布区域。两者物理上八竿子打不着。`contains` 返回 `false`。

### 4. 总结

这段代码利用了 **React 逻辑冒泡** 和 **DOM 物理结构** 之间的**不一致性**。

- React 说：“这是你的子组件事件，给你处理。”（逻辑冒泡）
- 代码反手查了一下户口本（DOM 树）：“不对，物理上它根本不在我家院子里。”（物理检测）
- 结论：“这是个 Portal 带来的‘幽灵’事件，忽略它。”

这就是处理 React Portal 冒泡副作用的标准“大招”。

---

## 有的抽屉不会有这个问题，原因是什么

有的抽屉没有这个问题，通常是因为它们打破了产生“幽灵冒泡”的两个必要条件之一。

回顾一下产生问题的条件：

1.  **逻辑亲缘**：抽屉组件在 React 代码里写在了 `Canvas` 组件的**内部**（是它的子孙）。
2.  **事件放行**：抽屉组件内部没有阻止事件冒泡（没有调用 `e.stopPropagation()`）。

只要打破其中任何一个，问题就不会出现。以下是具体原因分析：

### 原因一：它是“邻居”，不是“孩子” （架构不同）

这是最常见的原因。很多时候，我们将抽屉（Drawer）或弹窗（Modal）定义在组件树的**顶层**，而不是深层嵌套在某个容器里。

**不会出问题的结构（兄弟关系）：**

```jsx
function App() {
  return (
    <>
      {/* 画布和抽屉是兄弟关系 */}
      <CanvasWrapper onPointerDown={handleCanvasClick} />

      {/* 抽屉虽然视觉上盖在画布上，但逻辑上它是独立的 */}
      <Drawer>
        <button>Click Me</button>
      </Drawer>
    </>
  )
}
```

- **逻辑流向**：点击 Drawer -> 冒泡到 App。
- **结果**：事件根本不会经过 `CanvasWrapper`，所以 `onPointerDown` 永远不会被触发。

**会出问题的结构（父子关系）：**

```jsx
function CanvasWrapper() {
  return (
    <div onPointerDown={handleCanvasClick}>
      {/* 抽屉写在了画布组件里面 */}
      <Drawer>
        <button>Click Me</button>
      </Drawer>
    </div>
  )
}
```

- **逻辑流向**：点击 Drawer -> 冒泡到 CanvasWrapper。
- **结果**：触发 `handleCanvasClick`。

---

### 原因二：它自带“盾牌” （内部实现不同）

很多成熟的 UI 组件库（如 Ant Design, MUI）在实现 Modal 或 Drawer 时，为了防止这种副作用，已经在组件内部的遮罩层（Mask）或内容容器（Content）上帮你写好了阻止冒泡。

**组件库内部可能长这样：**

```jsx
// 弹出的 Drawer 组件源码示意
function Drawer(props) {
  return createPortal(
    <div className="drawer-mask">
      <div
        className="drawer-content"
        // 关键点：组件库帮你把冒泡掐断了
        onClick={e => e.stopPropagation()}
        onPointerDown={e => e.stopPropagation()}
      >
        {props.children}
      </div>
    </div>,
    document.body
  )
}
```

- **结果**：事件在 Drawer 内部就被杀死了，根本没有机会冒泡出来去骚扰 `Canvas`。
- **注意**：如果组件库只阻止了 `onClick`，而你的画布监听的是 `onPointerDown`，那么“漏网之鱼”依然会触发画布事件。

---

### 原因三：它根本没用 Portal （物理位置不同）

虽然少见，但有些简单的侧边栏是直接通过 CSS `position: absolute` 渲染在当前 DOM 树里的，没有用到 `createPortal`。

```jsx
<div className="canvas" onPointerDown={...}>
  <div className="drawer-inline" style={{ position: 'absolute', zIndex: 10 }}>
     ...
  </div>
</div>
```

- **情况**：这种情况下，`e.target`（抽屉）确实在 `e.currentTarget`（画布）内部。
- **结果**：`!contains` 检查会返回 `false`（代码认为这是内部点击）。
- **为什么没问题？**：通常这种内联抽屉会配合 **原因二**（阻止冒泡）一起使用。如果它既内联又没阻止冒泡，那点击它**百分之百**会触发画布事件，但这属于符合预期的 DOM 行为，而不是 Portal 带来的“诡异”行为。

### 总结

如果你的抽屉没有这个问题，大概率是因为：

1.  你在代码里把它放到了 `App` 根节点附近，和画布是**兄弟**。
    > 在 fiber 树中，你的 抽屉/弹窗组件与画布是兄弟关系，冒泡不会到兄弟；而弹出的组件在画布子孙节点中，冒泡会影响。
2.  你用的组件库比较贴心，自带 `e.stopPropagation()` **盾牌**。
3.  都冒泡了，但是事件处理逻辑里有其他判断。

---

### 3. 为什么 `!contains` 能作为判断依据？

正因为 React 搞了这种“逻辑冒泡”，我们需要一种方法来区分 **“真点击”**（点击了画布内部）和 **“假冒泡”**（点击了 Portal 里的东西）。

`e.currentTarget.contains(e.target)` 就是这面照妖镜：

- **e.currentTarget**：是画布原本的 DOM 节点。
- **e.target**：是你实际点击的 DOM 节点。
- **contains 方法**：是原生 DOM API，它只认**物理结构**。

**判断逻辑：**

- 如果 `contains` 返回 `true`：说明点击的是画布里的矩形、线条等（物理上在内部）。 -> **这是有效交互。**
- 如果 `contains` 返回 `false`：说明 React 虽然触发了事件，但点击的那个东西物理上根本不在我肚子里（比如 Portal 出去的抽屉）。 -> **这是 React 模拟的冒泡，应该忽略。**

### 总结

- **React** 关心的是“组件父子关系”，所以它让 Portal 冒泡。
- **DOM API (`contains`)** 关心的是“元素包含关系”。
- 利用这两者的差异，我们就能精准地过滤掉那些“身在曹营心在汉”（身在 Body，心系 Canvas）的 Portal 事件。

---

如果弹出的组件**没有使用 Portal**（即它是直接渲染在当前 DOM 树中的，物理上也是画布的子元素），那么 `!e.currentTarget.contains(e.target)` 这个判断就会失效，因为 `contains` 会返回 `true`。

在这种情况下，点击抽屉依然会冒泡触发画布的事件。要解决这个问题，我们需要根据具体场景选择以下几种策略：

### 策略一：阻止冒泡（最直接）

这是最标准、最推荐的做法。既然你不希望事件传给父级，那就应该在源头切断它。

在你的代码中，包裹这个弹出的组件，并拦截事件：

```tsx
// 在使用弹出的组件的地方
<div
  // 拦截点击事件
  onClick={e => e.stopPropagation()}
  // 拦截指针事件（如果画布用的是 onPointerDown）
  onPointerDown={e => e.stopPropagation()}
  // 拦截鼠标按下事件（保险起见）
  onMouseDown={e => e.stopPropagation()}
>
  <ThirdPartyDrawer />
</div>
```

- **原理**：在事件到达画布之前，先在包裹层把它“吃掉”。
- **优点**：简单粗暴，逻辑清晰。
- **缺点**：如果弹出的组件内部有某些逻辑依赖于冒泡（极少见），可能会受影响。

---

### 策略二：CSS `pointer-events` 控制（最优雅）

如果这个抽屉是覆盖在画布上的（例如侧边栏），你可以利用 CSS 让事件根本不穿透。

但这通常用于“点击穿透”场景。对于“点击抽屉触发画布”这个问题，如果抽屉是画布的子元素，CSS 无法直接阻止冒泡。但我们可以反向思考：**让画布只响应特定区域的事件**。

或者，如果抽屉是一个浮层，确保它有独立的背景和交互层：

```css
.drawer-wrapper {
  /* 确保抽屉区域能捕获所有鼠标事件，不让它们“漏”到底下 */
  pointer-events: auto;
}
```

_(注：这通常解决的是视觉重叠时的穿透问题，对于父子关系的冒泡，CSS 作用有限，还是推荐策略一)_

---

### 策略三：白名单/黑名单机制（逻辑判断）

如果你无法修改弹出的组件的包裹结构（例如它是通过某种配置生成的），你只能在画布的事件处理函数里做文章。

既然 `contains` 不好使了，我们需要找其他的特征来区分“点击的是画布”还是“点击的是抽屉”。

#### 1. 通过类名判断 (黑名单)

检查 `e.target` 或其祖先是否包含特定的类名。

```typescript
const onPointerDown = (e: React.PointerEvent) => {
  const target = e.target as HTMLElement

  // 如果点击的目标或者其祖先包含 'drawer-content' 类名，则忽略
  if (target.closest('.third-party-drawer-class-name')) {
    return
  }

  // ... 画布原有逻辑
}
```

#### 2. 通过 `data-*` 属性标记 (白名单)

给画布内的有效元素（节点、连线等）打上标记。只有点击了带标记的元素或者是画布背景才响应。

```typescript
// 画布背景
;<div data-canvas-element="bg">
  {/* 画布内的节点 */}
  <div data-canvas-element="node">Node</div>

  {/* 第弹出的抽屉（没有这个属性） */}
  <ThirdPartyDrawer />
</div>

// 事件处理
const onPointerDown = (e: React.PointerEvent) => {
  const target = e.target as HTMLElement

  // 只有点击了明确标记为画布元素的东西才执行
  // closest 查找最近的带有该属性的祖先
  if (!target.closest('[data-canvas-element]')) {
    return
  }

  // ...
}
```

### 总结

如果不用 Portal，物理结构就是父子关系，`contains` 无法区分。

1.  **首选**：**策略一（包裹层阻止冒泡）**。这是解决 DOM 事件冒泡最标准的方法。
2.  **备选**：**策略三（`closest` 类名判断）**。当你无法控制 DOM 结构时，这是唯一的救命稻草。
