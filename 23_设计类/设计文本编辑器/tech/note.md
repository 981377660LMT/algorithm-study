https://marijnhaverbeke.nl/blog/codemirror-line-tree.html 使用b树

---

在文本编辑器或相关应用中，为了在大文本上进行高效的插入、删除、查找等编辑操作，人们设计了多种**增量式**（incremental）数据结构，远比传统的数组或链表更灵活高效。本文将系统、详细地介绍以下五种常见的数据结构及其变体：

- **Gap Buffer**
- **Piece Table**
- **PieceTree**
- **Rope**
- **SumTree**

这些数据结构都围绕一个核心目标：**在不频繁整体复制文本的前提下，提供对局部修改（插入、删除）和快速定位的支持**。同时，它们也各自具有不同的适用场景与优缺点。

---

# 1. Gap Buffer

## 1.1 基本概念

**Gap Buffer** 是一种在内存中维护“当前编辑位置附近有一段空闲空间（Gap）”的线性缓冲区。可将其理解为一个数组，在数组中留出一段“空隙”，以便在该空隙处进行插入或删除操作。

典型示意：

```
[ H  e  l  l  o  |    |  W  o  r  l  d ]
                 ^ gap
```

- 左侧存储文本 “Hello”，右侧存储文本 “World”。
- 中间是留空的 GAP。
- 光标（cursor）位于 Gap 的位置。

## 1.2 操作与复杂度

1. **插入**

   - 若在光标处插入字符，而该光标正好位于 Gap 中，那么只需将字符放入 Gap 的首端，并将 Gap 的开始指针后移一位。
   - 复杂度近似为 O(1)。
   - 如果需要在 Gap 之外插入，就要先移动 Gap（把字符向左或向右移动），通常这是 O(n) 的操作（因为可能需要大块内存拷贝）。

2. **删除**

   - 若删除发生在 Gap 附近，只需调整 Gap 的边界即可，类似插入操作。
   - 复杂度近似为 O(1)。
   - 若删除的位置不在 Gap 附近，需要先移动 Gap。

3. **移动光标**

   - 移动光标到任意位置，若不在 Gap，则需要将 Gap “搬运”到该位置（拷贝文字到另一侧）。这是 O(n) 的操作，在最坏情况下需要移动的字符数量与文本长度同阶。

4. **查找 / 随机访问**
   - Gap Buffer 本质上还是一个数组。查找字符时，可以先判断是在 Gap 左侧还是右侧，再进行下标计算。
   - 访问第 i 个字符通常是 O(1) 逻辑访问，但如果需要频繁地跨 Gap 访问、移动光标，可能会有更多数据拷贝开销。

## 1.3 优缺点

- **优点**

  - 实现非常简单；
  - 在“编辑光标附近小范围频繁改动”的场景，性能很高；
  - Emacs 等一些老牌编辑器就是基于 Gap Buffer。

- **缺点**
  - 大文档且需要在不同位置做频繁编辑时，每次光标大跨度移动都要搬运大量数据 (O(n))；
  - 难以在多处同时进行编辑，也不适合在文本中做大量随机插入/删除。

---

# 2. Piece Table

## 2.1 基本概念

**Piece Table** 最早应用于 Bravo 编辑器（世界上第一个 WYSIWYG 文本编辑器之一），后续也被许多编辑器采用。它的核心理念是：**将原始文件和新插入的文本都存放在只追加的缓冲区（buffer）里，并通过表格（piece table）来引用这些文本片段**。

通常维护两个只读缓冲区：

1. **Original buffer**：存放打开文本时的原始内容，只读；
2. **Add buffer**：在用户编辑过程中，所有新增字符依序追加到这里，逻辑上同样只读；
3. **Piece Table**：记录若干条目，每个条目（Piece）包含：
   - 指明该片段来自哪个缓冲区（原始 or 新增）
   - 在该缓冲区的起始偏移
   - 该片段的长度
   - 以及片段在最终文档中的逻辑顺序

例如，打开文档后，Piece Table 只有一行：指向原文件 `[start=0, length=2000]`。当用户插入或删除时，只是“拆分”或“新增”Piece 来描述变化，不会修改原始缓冲区的内容。

## 2.2 操作与复杂度

1. **插入**

   - 将插入文本追加到 Add buffer 的末尾；
   - 在 Piece Table 中适当地“分割”受影响的旧 Piece 并插入一个新 Piece。
   - 由于不需要移动原有文本内容，插入可以在 O(1) 时间内完成（不计索引查找和维护开销）。

2. **删除**

   - 删除操作会在 Piece Table 中“拆分”相关 Piece 并跳过被删除的部分；
   - 依旧不需移动缓冲区内的实际字节，只是修改或者移除 Piece Table 上的一条或几条记录。
   - 复杂度通常在 O(1) ~ O(log n) 之间，取决于底层如何维护和查找 Piece（可能使用数组、链表或平衡树等）。

3. **随机访问 / 定位光标**

   - 需要在 Piece Table 中遍历或用索引结构找到第 i 个逻辑字符所属的 Piece 及在 Piece 的偏移。
   - 若 Piece Table 只是一个简单链表或数组，则最坏情况 O(n)；
   - 若使用平衡树（如红黑树），可在节点上维护子树大小，从而在 O(log n) 时间内找到位置。

4. **查找 / 遍历**
   - 遍历整篇文档，只需按 Piece Table 的顺序逐个 Piece 读出相应的原始/新增数据即可。
   - 适合保存操作（序列化）时，不必重新拷贝整个文档，只要顺序输出原始和新增缓冲区对应内容。

## 2.3 优缺点

- **优点**

  - 大幅减少实际字符移动；
  - 支持多级撤销（Undo）与重做（Redo）较容易；
  - 原文本和新增文本都只追加，管理简单。

- **缺点**
  - Piece Table 的维护需要一个高效的数据结构（数组或链表可能导致在定位光标时速度慢）；
  - 如果文档反复编辑会出现大量小 Piece，可能造成碎片化，Piece Table 变得很大；
  - 在极端场景下进行大量零碎插入，会导致 Piece Table 中维护的条目数量增长。

---

# 3. PieceTree

## 3.1 背景

**PieceTree** 是微软 Visual Studio Code（VSCode）文本编辑器使用的一种数据结构，结合了**Piece Table**的理念和**平衡树**（通常是平衡二叉树或平衡搜索树）数据结构。在开源社区中，也有不少关于其实现细节的讨论。

## 3.2 主要思路

- **分层结构**

  - 依然保留 “Original buffer” + “Add buffer” 来存储文本；
  - 但对 Piece Table 的管理采用**平衡树**(比如平衡二叉搜索树、AVL 树、红黑树等)；
  - 在每个树节点上维护包括 “该Piece的长度、子树总长度” 等统计信息。

- **快速定位**
  - 当用户需要跳转到第 i 个字符时，可以根据根节点存储的子树大小，走左或右分支，最终在 O(log n) 时间内找到所在的 Piece 及其偏移。
  - 插入/删除时，也能在 O(log n) 的时间内定位到受影响的 Piece 并进行拆分/合并。

## 3.3 特点与优势

- 相对于纯粹的 Piece Table + 数组/链表做索引，PieceTree 能**显著提高对随机位置的访问和操作效率**。
- 与 Rope 类似，都可以在平衡树节点上进行局部重组，而不用大范围移动文本本身。
- 在实现上更复杂，但非常适合现代编辑器需要同时处理**大文本文件、频繁随机编辑、多光标操作**等需求。

---

# 4. Rope

## 4.1 基本概念

**Rope**（绳）是一种将文本拆分成许多较小的**字符串块**（通常称作“叶子”），并以**平衡二叉树**的方式组织起来的结构。最早由 Boehm 等人在 1995 年提出，常见于函数式语言与并行环境下的大文本操作。

一个 Rope 的示意：

```
                 [root]
                /      \
          [left-sub]   [right-sub]
            /    \        /    \
         ...    ...     ...    ...
```

- 叶子节点保存一块较短的字符串（如 64~512 字节不等）；
- 内部节点存储子树的总长度、平衡因子等信息；
- 当进行插入、删除或连接操作时，可以在树中做局部拆分或拼接，保持平衡并更新节点统计信息。

## 4.2 核心操作与复杂度

1. **创建**

   - 如果原始文本很大，可以分段创建叶子节点，然后构建平衡树。
   - 复杂度约 O(n)（n 为文本长度），具体依赖分块大小。

2. **插入 / 删除**

   - 先在树中找到插入/删除位置对应的叶子；
   - 对叶子做拆分或合并操作，或新建叶子插入，然后可能进行树的再平衡 (AVL/红黑树等)。
   - 最坏情况 O(log n)。

3. **索引 / 查找第 i 个字符**

   - 从根节点开始，根据左子树的大小判断要去左还是右子树，直到找到对应的叶子和叶内偏移。
   - 复杂度通常 O(log n)。

4. **拼接 (Concatenate)** / **切片 (Split)**
   - 若要将两个 Rope 合并，可以直接构造一个新的根节点，让左指针指向第一个 Rope，右指针指向第二个 Rope，并进行平衡调整。
   - 切片操作同理，通过局部拆分叶子或子树并更新指针。
   - 复杂度 O(log n)。

## 4.3 优缺点

- **优点**

  - 面向**大文本**特别友好；
  - 适合**并发场景**，局部修改不会复制整段文本；
  - 插入、删除、连接、切片等操作都能保持在 O(log n) 左右。

- **缺点**
  - 对于非常小的文件或编辑器，Rope 的平衡树和分段管理反而是一种额外的开销。
  - 实现较为复杂，必须保证树的平衡和叶子块的合理大小，否则性能会退化。
  - 每个叶子需要额外存储指针、树维护信息，如果块过小，会导致存储冗余。

---

# 5. SumTree

## 5.1 基本概念

**SumTree** 并不是一种单独的“文本编辑”数据结构，更像是在树形结构（如平衡搜索树、Segment Tree、Fenwick Tree 变体）上存储“子树字符数的累加和”或其他统计信息的策略。它常与 Rope、PieceTree、Piece Table 的平衡树形式结合使用，用于**快速通过字符偏移定位**到对应节点。

- **节点存储**：
  - `weight` 或 `sum`：表示该节点的子树中包含的字符总数；
  - 左、右子树的指针；
  - 用于平衡树的额外信息（红黑树、AVL 树、B 树等属性）。

## 5.2 典型应用

1. **快速索引第 i 个字符**

   - 从根节点开始，先看左子树的 sum 是否 >= i；
   - 如果是，则递归左子树；否则跳到右子树，并令 i 减去左子树的 sum ；
   - 直到到达叶子找到目标字符。
   - 此流程可在 O(log n) 完成（如果树保持平衡）。

2. **插入 / 删除**
   - 需要在对应节点处更新 sum 值并进行平衡。
   - 当插入 k 个字符时，从插入点所在的节点向上更新 sum 值 += k；删除则相反。
   - 同样可保持在 O(log n) 范围内。

## 5.3 与其他结构的区别

- SumTree 是一个**思想**或**功能模块**，并不与 Rope、Piece Table 对立。相反，它可以嵌入到这些结构中，用于维护子树大小，从而支持**基于字符偏移量的快速查找**。
- 在纯 Piece Table 中使用数组或链表时，获取第 i 个字符通常需要 O(n)；但若在“PieceTree + SumTree”中，每个节点都维护子树大小，定位即可缩减为 O(log n)。
- 另一种思路是使用**Segment Tree**或**Fenwick Tree (BIT)**，但那些结构通常更适合数值区间求和或更新，对文本编辑也可以用，但需要做相应的适配和分块。

---

# 6. 综合比较与应用场景

| 数据结构        | 插入/删除附近性能 | 随机位置插入/删除 | 定位第 i 个字符 | 实现复杂度 | 适用场景                     |
| --------------- | ----------------- | ----------------- | --------------- | ---------- | ---------------------------- |
| **Gap Buffer**  | 高效 (若在 gap)   | 大跨度需移动 O(n) | O(1) 但需搬移   | 简单       | 轻量编辑器、光标附近频繁操作 |
| **Piece Table** | O(1)~O(log n)     | O(1)~O(log n)     | 取决于索引结构  | 中等       | Undo/Redo，稀疏修改          |
| **PieceTree**   | O(log n)          | O(log n)          | O(log n)        | 较复杂     | VSCode 等大型编辑器          |
| **Rope**        | O(log n)          | O(log n)          | O(log n)        | 较复杂     | 大文本、并发场景             |
| **SumTree**     | - (是一种增强)    | - (是一种增强)    | O(log n)        | 中等       | 与其他结构结合维护快速索引   |

- 对**小文件**或**简单编辑器**：

  - **Gap Buffer** 实现简单，光标一般不离太远，性能足够优秀。

- 对**大文件**、**多位置频繁编辑**或**现代编辑器**：

  - **Piece Table** 或 **PieceTree** 或 **Rope** 更具扩展性，典型如 VSCode 的 PieceTree、Sublime Text（Rope 的改进版本）等。
  - 需要快速随机访问、快速插入删除时，倾向于平衡树 + 块存储（PieceTree / Rope） + SumTree。

- **Undo / Redo 需求**：
  - **Piece Table** 自带把原文只读、增量只读的特性，容易记录编辑操作。
  - **Rope** 或 **PieceTree** 也可以利用树的持久化或版本管理做高效撤销。

---

# 7. 结语

以上五种数据结构在“文本编辑”这一主题下各有所长，也可以相互结合：

1. **Gap Buffer**：实现非常直接，适合轻量场景或者在同一片区域编辑为主的流程。
2. **Piece Table**：通过引用（piece）原始缓冲和新增缓冲，避免大规模移动，适合带 Undo/Redo 需求的场景。
3. **PieceTree**：将 Piece Table 置于平衡树结构中，兼顾随机访问效率，是现代编辑器（VSCode）的常用方案。
4. **Rope**：以平衡二叉树组织大量文本块，能够在大文件、高并发编辑、分布式场景中保持优秀的插删查效率。
5. **SumTree**：在平衡树节点维护子树字符数或其他统计信息，支持快速定位第 i 个字符，常与 Rope 或 PieceTree 结合。

具体选择何种结构，需根据**编辑行为**（集中于一个光标 vs 多处同时插入）、**文件规模**（小文件 vs 大文件）、**实现复杂度**、**对Undo/Redo的要求**、**对随机访问的需求**等因素综合考量。实际上，许多主流编辑器在内部都采用了**树形 + 块存储 + 累加索引**的混合策略，以便在各种复杂操作下依然保持高效且稳定的用户体验。
