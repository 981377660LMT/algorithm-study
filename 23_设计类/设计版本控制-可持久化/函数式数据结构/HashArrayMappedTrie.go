// HashArrayMappedTrie
// https://zthinker.com/archives/functional-go-intro-to-hamt
// https://github.com/shanzi/algo-ds/tree/master/hamt
// 节点内部空间的压缩：bitMap 存储节点信息，onesCount表示节点数量
// 压缩 Trie 高度
//
// 查询操作
// 查询操作和在 Trie 上进行查询没有太大的改变，只是因为节点的空间被压缩之后，
// 需要先通过 Bit Map 字段 判断对应的位置是否存在子元素，如果存在，再通过 Pop Count 计算得到子元素所在的实际位置。
// 在获得到子元素之后，鉴于 HAMT 对 Trie 的高度进行了压缩，我们要先判断这个子元素是 Trie 的子节点还是值元素本身。
// 对于 Hash Table，我们将值包装成<Key, Value>这样的一个值节点存放进去。
// 这样取出时就可以先判断 Key 的值是否相同，以此决定是否真的取到了对象。
// 加入操作
// 加入操作类似于查询操作，对于给定的键值对，我们先计算键的 Hash 值，然后从高位开始利用 Hash 值。
// 沿着 Trie 树向下查找，此时存在四种情况：
// 查找到一个位置，这个位置所保存的值对象代表的键和新插入的键相同，则用新插入的值代替原来的值
// 查找到一个子节点，这个子节点再向下目标对象应该所在的位置没有元素，此时只需申请一个新的宽度比当前子节点多1的节点， 将原来子节点上的所有元素连带当前对象一一设置到新的子节点上，维护好元素的顺序和 Bit Map 的值即可
// 查找到一个子节点，这个子节点再向下目标对象所应该在的位置是一个值对象，这时，为这个值对象连带当前对象分配一个宽度为2 的子节点，将原来的值对象和当前对象放置在新的节点中，最后用新的节点在当前子节点中替换掉对应位置
// 查找到一个子节点，这个节点再向下目标对象所应该在的位置是另一个子节点，则在那个子节点上递归进行上述操作
// 删除操作
// 删除操作是加入操作的逆运算，其基本原理也类似。在删除时，现在 Trie 中找到对应的对象，然后依次递归地删除。
// 在从子节点删除一个元素时，我们也一样要分配一个新的子节点，这个子节点的宽度比原来少1。
// 之后将剩余的子元素按照规则放回新的子节点并维护 Bit Map 字段的值。最后用新的子节点替换原来的节点并递归向上进行。
// 一般来讲，在递归时有如下几个情况：
// 在子节点进行删除操作之后，子节点不再包含任何子元素，则删除当前子节点并返回空
// 当前子节点只剩下一个元素，且这个元素为值元素，则应该降低树的高度，直接返回值元素
// 当前子节点只剩下一个元素，且这个元素是子节点，则保留这个子节点，回到上一个节点
package main

func main() {

}

type HashArrayMappedTrie struct {
}
