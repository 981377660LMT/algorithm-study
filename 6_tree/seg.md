### 一、模板类别

​ 数据结构：最长线段射线助手。

### 二、模板功能

#### 1.预处理

1. 数据类型

   模板参数 `typename _Tree` ，表示树的类型。

   构造参数 `_Tree &__tree`​ ，表示树。

2. 时间复杂度

   $O(n)$ 。

3. 备注

   树本质上就是无向无环图。任意找一点作为根，可以确定树的上下方向。

   由于树中没有环，所以任何一个结点的度，就相当于它所连接的连通部分数。

   对于根结点，所有的连通部分都在自己下方。

   对于非根结点，一个连通部分在自己上方，剩余连通部分都在自己下方。

   在预处理后， `m_ray[i]` 存储了 以 `i` 作为一端的线段的最长长度前三名。

   `m_seg[i]` 存储了不经过 `i` 的线段的最长长度前两名。

   `m_downRay[i]` 存储了以 `i` 作为一端的向下的线段的最长长度。

   `m_downSeg[i]` 存储了 `i` 下方的不越过 `i` 的线段的线段最长长度。注意，不越过，但是可以经过。

   `m_upRay[i]` 存储了 以 `i` 作为一端的向上的线段的最长长度。

   `m_upSeg[i]` 存储了 `i` 上方的不越过 `i` 的线段的线段最长长度。注意，不越过，但是可以经过。

   **注意：**此处的前三名、前两名不允许某个连通部分重复占用。比如结点 `i` 有两个邻居，从第一个连通部分可以找到长度为 `10` 的 `ray` ，也可以找到长度为 `9` 的 `ray` ；从第二个联通部分可以找到长度为 `8` 的 `ray` ，那么 `m_ray[i][0]==10` ，`m_ray[i][1]==8` ，`m_ray[i][2]==0` ，也就是没有第三名。

#### 2.查询树中某部分的最长射线线段

1. 数据类型

   输入参数 `uint32_t __i` ，表示树中某结点。

   输入参数 `_Tp __exceptRay` ，表示屏蔽掉的部分所提供的最长 `ray` 。

   输入参数 `_Tp __exceptSeg` ，表示屏蔽掉的部分所提供的最长 `seg` 。要求不经过 `__i` 。

   返回两个值，一个是树中剩余部分从 `__i` 出发的最长 `ray` ，一个是树中剩余部分的最长 `seg` 。

2. 时间复杂度

   $O(1)$ 。

3. 备注

   对于不屏蔽的问题，直接取相应属性即可。

   对于带屏蔽的问题，如果屏蔽的是上方的连通部分，那么要查询的内容也可以直接取相应属性。

   如果屏蔽的是下方的某一连通部分，那么只能调用本函数解决。

#### 3.查询去掉某子树后的最长射线线段

1. 数据类型

   输入参数 `uint32_t __i` ，表示树中某结点。

   输入参数 `uint32_t __exceptSonEdge` ，表示通往被屏蔽掉的子树的边编号。

   返回两个值，一个是树中剩余部分从 `__i` 出发的最长 `ray` ，一个是树中剩余部分的最长 `seg` 。

2. 时间复杂度

   $O(1)$ 。

### 三、模板示例

```c++
#include "IO/FastIO.h"
#include "TREE/SegRayLengthHelper.h"

int main() {
    //一个无权树
    OY::Tree<10> T(5);
    //加边
    T.addEdge(2, 0);
    T.addEdge(1, 3);
    T.addEdge(4, 0);
    T.addEdge(0, 3);
    T.prepare();
    //定根
    T.setRoot(3);
    //预处理
    OY::SegRayLengthSolver sol(T);
    //屏蔽掉以 2 为根的子树，询问最长线段
    auto [ray, seg] = sol.maxRaySeg(0, sol.m_downRay[2] + 1, sol.m_downSeg[2]);
    cout << "longest ray from 0, length = " << ray << endl;
    cout << "longest seg, length = " << seg << endl;
}
```

```
#输出如下
longest ray from 0, length = 2
longest seg, length = 3

```
