**用 js 写持久化线段树/线段树最好用 TyedArray 不要用 class 表示结点 否则容易 MLE**

https://www.acwing.com/solution/content/51456/
https://www.acwing.com/solution/content/72023/

## 可持久化(权值)线段树的思路

使用多个入口结点保存多个不同版本的线段树,可以存下来数据结构的所有历史版本
每一个版本比前一个版本多 logn 级别的数据
实现上, 是在 build 的时候只建立树的骨架而不保存元素, 而对每一个点都做一次 insert,
在插入新点的同时, 只需要修改其中一条链(**关键路径**)的数据，对于不在关键路径上的节点我们就直接复制,即复制旧版本的节点到新的树结点上，复制完后新版本的节点版本号++
由于从 1 个点插到 n 个点, 每次都是二分插入, 时间空间复杂度就都是 nlogn(N 个点离散化之后的范围上限自然还是 N)
线段树 tree 数组要开 `N * 4 + NlogN (N是数组长度，离散化后的值域为0-N-1)`
`树高logN，底端的叶子结点才保存每个元素的真实的 count 个数`

## 可持久化数据结构（Persistent data structure）每次修改都会保留其自身每一个历史版本

https://quant67.com/post/algorithms/ads/persistent/persistent.html
可持久化数据结构 (Persistent data structure) 总是可以保留每一个历史版本，并且支持操作的不可变特性 (immutable)。

- 部分可持久化 (Partially Persistent)
  每个历史版本都可以访问，但只有**最新的版本才可以修改**
  这意味着数据结构的每个版本之间是**线性**的
- 完全可持久化 (Fully Persistent)
  每个历史版本都可以访问和修改(**每次修改都会产生一个新的版本**)
  这意味着数据结构的每个版本之间是**树形**的
- 融合可持久化 (Confluently Persistent)
  每个历史版本都可以访问和修改，且支持通过合并(merge)两个历史版本来创建新版本

## 实际应用

- 字串处理(C++ rope 就是一个持久化的数据结构)
- 版本回溯(持久化结构就是要减少 redo/undo 的花费)
- 函数式编程

## 可持久化的前提：本身的拓扑结构在操纵过程中不变(平衡树就不行)

1. Trie 的持久化
2. 线段树的可持久化(主席树)
   主席树、又称为可持久化线段树，实际上是记录了每一次更新时的版本信息，题型基本上都是结合离散化，最经典的用法是求区间第 K 大/小的数

## 静态问题

- 可持久化线段树(主席树)，不支持修改 **nlogn**
- 树套树(线段树+平衡树)，一般是线段树+set，支持`动态区间查询` **nlognlogn**
- 划分树

持久化(权值)线段树的思路:

1. 离散化到 0-n-1
2. 在`数值`上建立线段树(不是在下标上)，维护每个`数值区间中一共有多少个数`
3. 二分区间 例如[0,mid] 如果左边[0,mid//2]里的数多于 k 个，那么第 k 小数肯定在左边
4. 要求[L,R]里的第 k 小数，需要搜两个版本的线段树，前缀和相减就可以得到这一段有多少个数
   ([0,R]表示只加了 R 个数的情况)
