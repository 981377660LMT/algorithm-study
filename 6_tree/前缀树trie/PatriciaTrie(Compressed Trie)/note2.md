下面是一份对 **Radix Trie（基数树）** 的详细讲解，包括其概念、与普通 Trie 的对比、核心思想、插入搜索删除的过程、时间复杂度以及实际应用场景等。

---

## 1. 基本概念

**Radix Trie**（又称 **Radix Tree**、**压缩 Trie**、或 **Patricia Trie**）是对普通 Trie 进行“压缩”或“合并”的一种改进型数据结构。它在保持 Trie 原有查找效率的同时，大幅减少了树中节点的数量，从而降低内存使用量。

在普通 Trie（前缀树）中，每个字符都对应一个节点，这可能造成：

- **大量中间节点**（尤其在单分支很长的情况下），导致内存浪费；
- **树高度变高**，在极端情况下(如所有字符串都共享长前缀却分支很少)，会出现“链”式结构。

Radix Trie 通过**合并只有单一分支的连续节点**，将多层节点压缩成一个节点存储，从而使得：

- 节点显著减少；
- 查询和插入时，在一个节点上可以一次比较多个字符，而不是只比较一个字符。

因此，Radix Trie 保留了 Trie 关于**前缀匹配**的优势，同时减少了无用的中间节点。

---

## 2. 与普通 Trie 的对比

让我们先回顾一下**普通 Trie** 的特点：

- **普通 Trie**：
  1. 每个节点可能有若干子节点，每条边代表一个字符。
  2. 要查找字符串，会自根节点起，逐字符比对，沿着对应的分支一直走到底；如果能成功匹配完整字符串，表示存在；若中途找不到对应分支，则表示不存在。
  3. 如果某个节点只有一个子节点，但要表示多个字符的连续路径，普通 Trie 需要逐层展开，每层只有一个边，直到最后一个字符。

而**Radix Trie** 会有以下改动：

1. **边（Edge）存储一个“字符串切片”或“字符序列”**，而不是单个字符。

   - 当普通 Trie 在某条分支上只有一个子节点时，Radix Trie 会将连续只能往下走的节点合并到同一个节点中，使用一段字符串来代表“这一段路径”。

2. **减少节点**：

   - 合并原本在普通 Trie 中的“链”式结构，让树更加紧凑。

3. **相同前缀合并**：
   - 插入或搜索时，需要在单条边上进行一次**多字符比对**，找到最长的公共前缀部分做匹配。
   - 如果匹配不完全（或需要拆分），则在该边中间“分裂”出新的节点，实现插入新单词或新分支。

总结地说，**Radix Trie = Trie + 节点压缩**。它在逻辑上仍是前缀匹配树，但底层对节点和边做了合并与拆分处理。

---

## 3. 核心思想与示例

以插入单词为例，假设我们要将字符串集合插入到 **Radix Trie** 中，如：

```
car, cat, dog
```

### 普通 Trie 的情况

- 根节点下有分支 'c' 和 'd'；
- 插入 "car" 后，前缀 "c" -> "a" -> "r" 各占一层节点；
- 插入 "cat" 时，发现前缀 "ca" 已存在，所以共享根 -> c -> a 这一路，仅在 a 节点下再开辟一个 't' 分支；
- 插入 "dog" 则是从根节点开辟另一个分支 'd' -> 'o' -> 'g'。

最终结构中，如果单词更多、前缀重叠少，就会出现相当多节点。

### Radix Trie 的情况

- 对于前缀 "ca" 的那部分，`car` 和 `cat` 会共享一条边，从根节点到一个中间节点的边可以存储字符串 `"ca"`。
- 然后在这个中间节点分出两条边：一条边对应 `"r"`（完成字符串 "car"），另一条边对应 `"t"`（完成字符串 "cat"）。
- 根节点到 "dog" 依旧是另一条边，可以直接存 `"dog"` 这一整段，如果没有更多分支则无需拆分。

所以 Radix Trie 的节点数显著减少。根节点有两条边：`"ca"` 和 `"dog"`。在 `"ca"` 那个节点上再分成两条边，分别是 `"r"` 和 `"t"`。

---

## 4. 主要操作

### 4.1 插入（Insert）

1. **从根节点开始**，获取当前要插入的字符串（key）。
2. **沿着树向下搜索**：
   - 对比当前节点的每条边，找到有“公共前缀”的那一条边。
   - 如果找不到公共前缀，说明这是一个新分支，需要新建边，把 key 当作整条边挂接上。
   - 如果找到公共前缀却无法完全匹配（仅匹配前一部分），则需要**拆分**：
     - 将原边切成公共前缀部分和剩余部分；
     - 中间插入新节点，原边的剩余部分挂在该节点之下；
     - 新插入的 key 也在此新节点下继续比较或直接挂接剩余部分。
   - 如果完全匹配这条边的字符串，还要继续向更深层节点匹配，直到处理完 key 的所有字符，或者在中途需要拆分。
3. **到达最终位置**后，将节点标记为“存在这个 key”，或者存储关联的值（如果是键值对存储）。

### 4.2 查找（Search / Lookup）

1. **从根节点开始**带着要查找的字符串向下匹配。
2. **在每条边上比较**，找到与当前要匹配的前缀一致的边，然后在该边上去掉已匹配的部分，继续往下走。
3. **若途中无法找到匹配的分支**（比如公共前缀不符），则表示该字符串不存在。
4. 如果直到字符串全部匹配完并且节点标记存在该字符串，则查找成功；否则失败。

### 4.3 删除（Delete）

删除也与插入类似，会在边与边之间或节点上进行**查找**：

1. 先搜索定位要删除的字符串，如果找不到则无操作。
2. 找到后，将对应节点取消“有效”标记（若只表示终止，则将标记去掉）。
3. 如果因此导致某个节点下只有一条边，且自身不再是其他 key 的终止节点，则与子节点合并，以保持树的压缩状态。

---

## 5. 时间复杂度

| 操作     | 平均复杂度 | 备注                                                     |
| -------- | ---------- | -------------------------------------------------------- |
| **插入** | O(k)       | k 为字符串长度。多字符比较发生在边上，一次可比对多个字符 |
| **查找** | O(k)       | 同理，Radix Trie 保持与 Trie 相当的搜索性能              |
| **删除** | O(k)       | 先查找再删除                                             |

在最坏情况下，如果绝大多数字符串前缀不共享或只共享很少部分，树高度仍可接近 k，但与普通 Trie 相比，其内存开销通常会显著降低。

---

## 6. 应用场景

- **字符串前缀匹配**：如自动补全、搜索提示，Radix Trie 能快速定位和跳转。
- **路由表 / IP 地址前缀匹配**：在网络领域（如 BGP、路由器），经常使用 Patricia Trie（Radix Trie 的一种变体）来存储和查找 IP 前缀。
- **域名解析**：DNS 中对域名进行前缀/后缀匹配的场景可使用压缩 Trie。
- **大规模字符串索引**：需要高效检索的情况下，Radix Trie 提供了紧凑的存储与较快的查询性能。

---

## 7. 总结

1. **Radix Trie = Trie + 压缩合并节点**：利用将连续单分支路径压缩为一个节点的技术，既保留了 Trie 的前缀匹配性质，又降低了树中节点数量。
2. **操作流程**：插入、搜索、删除时，都需要在每条边上做多字符比较、可能分裂或合并边，来维护树的紧凑性。
3. **优势**：
   - 在保持（平均）O(k) 时间复杂度的前提下，明显降低节点数量，减少内存开销。
   - 适合**高效前缀检索**的应用场景，尤其对于大量字符串或特殊前缀数据（如路由表）非常有用。
4. **劣势**：
   - 相比普通 Trie，Radix Trie 在插入/删除时需要处理**分裂/合并边**的逻辑，代码实现更复杂。
   - 在一些极端场景（前缀重叠非常少）中，节省内存的效果可能并不明显。

Radix Trie 在实践中非常常见（尤其变体 Patricia Trie 广泛应用于网络路由表），它将普通 Trie 的优势（前缀快速匹配）和“压缩”技巧相结合，是一类高效的字符串检索数据结构。
