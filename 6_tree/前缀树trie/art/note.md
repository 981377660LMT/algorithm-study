https://zhuanlan.zhihu.com/p/271739790
ART 的全称是 Adaptive Radix Tree，中文是自适应基数树，实际上就是基数树的升级版。

https://github.com/plar/go-adaptive-radix-tree

---

Adaptive Radix Tree（自适应基数树，简称 ART）是一种高效的有序键值存储数据结构，广泛应用于数据库索引、内存数据库、键值存储系统等领域。它结合了基数树（Radix Tree）和自适应节点大小的思想，旨在优化内存使用和查找性能。以下将详细介绍 ART 的定义、特点、优势及其应用与实现方法。

## 一、什么是 Adaptive Radix Tree (ART)?

Adaptive Radix Tree 是一种基于前缀共享的有序树形数据结构，用于高效存储和检索键值对。
与传统的基数树相比，`ART 引入了自适应节点大小的概念，根据节点的子节点数量动态调整节点的结构，以提高空间利用率和查找效率。`

### 基本结构

ART 由多个节点组成，每个节点可以存储一定数量的子节点。根据子节点的数量，ART 的节点会动态调整为不同的类型，以优化性能：

1. **Node4**：最多可有 4 个子节点，适用于节点子数量较少的情况。
2. **Node16**：最多可有 16 个子节点。
3. **Node48**：最多可有 48 个子节点，使用一个索引数组来加快查找。
4. **Node256**：最多可有 256 个子节点，使用一个直接索引数组。

这种自适应的设计使得 ART 能够在不同情况下优化内存使用和查找速度。

## 二、为什么使用 Adaptive Radix Tree？

### 1. 高效的查找性能

ART 通过压缩前缀和动态调整节点类型，减少了查找路径的长度和每个节点的查找时间。尤其在高键密度的场景下，ART 的查找性能优于传统的基数树和 B 树等数据结构。

### 2. 优化的内存使用

自适应节点结构使得 ART 能够根据实际需求调整节点的大小，避免了固定大小节点带来的内存浪费。特别是在子节点数量较少的情况下，使用 Node4 和 Node16 节点能够显著节省内存。

### 3. 有序性支持

ART 作为一种有序数据结构，支持高效的范围查询和有序遍历，这在数据库索引和数据库系统中尤为重要。

### 4. 动态插入和删除

ART 支持高效的动态插入和删除操作，能够在运行时灵活调整树结构，适应数据的动态变化。

## 三、ART 的主要特点

1. **自适应节点大小**：根据子节点数量动态调整节点类型（Node4, Node16, Node48, Node256），优化内存和查找效率。
2. **前缀压缩**：通过前缀共享，减少树的高度，提升查找性能。
3. **有序性**：支持有序遍历和范围查询，适用于需要有序数据访问的场景。
4. **高缓存友好性**：节点结构设计紧凑，提升了缓存命中率，进一步加快查找速度。
5. **支持高并发**：在并发环境下，ART 可以通过细粒度锁或无锁机制实现高效的并发访问。

## 四、ART 的应用场景

1. **数据库索引**：作为数据库系统中的索引结构，提供高效的查找和范围查询能力。
2. **内存数据库**：在内存中存储大量数据时，ART 的高效性和低内存开销非常适用。
3. **键值存储系统**：如 Redis、NoSQL 数据库等，作为核心数据结构，支持快速的键值访问。
4. **网络路由表**：在网络设备中，用于存储和查找路由信息，ART 的高性能查找能力适合高速网络需求。

## 五、如何实现和使用 ART？

实现 ART 涉及多个方面，包括节点结构设计、动态节点调整、前缀压缩等。以下是实现 ART 的基本步骤和要点：

### 1. 节点结构设计

根据子节点数量，定义不同类型的节点（Node4, Node16, Node48, Node256）。每种节点类型有不同的存储方式：

- **Node4**：使用两个数组分别存储子节点的分支字符和对应的子节点指针。
- **Node16**：类似于 Node4，但支持最多 16 个子节点。
- **Node48**：使用一个 256 大小的索引数组加上子节点数组，快速定位子节点。
- **Node256**：使用一个 256 大小的直接索引数组，每个字符对应一个子节点指针。

### 2. 前缀压缩

在树的每个节点，存储一个前缀字段，用于压缩键的公共前缀，减少树的高度。查找时，需要匹配节点存储的前缀，再继续向下查找。

### 3. 动态节点调整

在插入或删除操作时，根据节点的子节点数量动态调整节点类型。例如，当 Node4 的子节点超过 4 个时，升级为 Node16；当子节点数量减少时，降级为更小的节点类型。

### 4. 查找操作

查找一个键时，从根节点开始，逐层匹配节点的前缀和分支字符，逐步向下查找，直到找到目标键或确定不存在。

### 5. 插入和删除操作

插入时，找到合适的节点位置，插入新的子节点，必要时调整节点类型。删除时，移除目标子节点，必要时调整节点类型。

### 6. 并发支持

在多线程环境下，需考虑线程安全性。可通过锁机制（如细粒度锁、读写锁）或无锁数据结构实现并发访问。

### 示例代码

以下是一个简化的 ART Node4 节点结构示例（伪代码）：

```c
typedef struct {
    uint8_t num_children;
    uint8_t keys[4];
    Node* children[4];
} Node4;

Node4* create_node4() {
    Node4* node = malloc(sizeof(Node4));
    node->num_children = 0;
    return node;
}

void insert_node4(Node4* node, uint8_t key, Node* child) {
    int pos = 0;
    while (pos < node->num_children && node->keys[pos] < key) pos++;
    for (int i = node->num_children; i > pos; i--) {
        node->keys[i] = node->keys[i-1];
        node->children[i] = node->children[i-1];
    }
    node->keys[pos] = key;
    node->children[pos] = child;
    node->num_children++;
}
```

这个示例展示了如何在 Node4 节点中插入一个子节点。实际实现中，还需包含查找、删除、节点升级/降级等功能。

## 六、总结

Adaptive Radix Tree 通过自适应调整节点大小和前缀压缩，提供了高效的查找性能和优化的内存使用，广泛应用于数据库索引、内存数据库和键值存储系统等领域。其动态调整和灵活性使其在处理大规模有序数据时表现出色。实现 ART 需要精心设计节点结构和调整机制，但其带来的性能和效率提升通常是值得的。

如果您打算在项目中使用 ART，可以参考已有的开源实现，如 [ART by Nick Johnson](https://github.com/art-project/art) 或者数据库系统中的实现，并根据具体需求进行优化和扩展。
