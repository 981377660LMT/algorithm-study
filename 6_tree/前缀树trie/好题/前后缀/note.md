1. **批量查询 s 是否为 t 的前后缀：**
   把字符串 s 视作一个 pair 列表：
   [(s[0],s[n−1]),(s[1],s[n−2]),(s[2],s[n−3]),⋯,(s[n−1],s[0])]
   只要这个 pair 列表是另一个字符串 t 的 pair 列表的前缀，那么 s 就是 t 的前后缀。

2. **批量查询字典中是否包含具有前缀 s 且具有后缀 t 的单词**
   1. 单词数量不多，但是单个单词长度长：
      维护两个 trie，一个存储所有单词的前缀，一个存储所有单词的后缀。
      插入时将 index 保存到节点数组中，最后求出两个 index 数组的最小公共元素即可(双指针比较即可).
      单词查询最坏时间复杂度为 O(n)。
   2. 单词数量多，但是单个单词长度不长：
      插入、查询时带上后缀特殊处理
      ```
      '#apple', 'e#apple', 'le#apple', 'ple#apple', 'pple#apple', 'apple#apple'。
      然后对于 prefix = "ap", suffix = "le" 这样的查询，
      我们可以通过查询单词查找树找到 le#ap。
      ```
   3. 单词数量、单个单词长度都很大：
      根据长度设定阈值，哈希+分治
      https://codeforces.com/problemsets/acmsguru/problem/99999/505
