# 双数组trie

## trie等词典数据结构还有哪些，最好的是哪一个？

1. [什么是双数组 Trie（Double-Array Trie）](#sec1)
2. [双数组 Trie 的内部结构](#sec2)
3. [双数组 Trie 的构建与查询流程](#sec3)
4. [双数组 Trie 的优缺点](#sec4)
5. [其他常见的 Trie / 词典数据结构](#sec5)
6. [在实际工程中该怎么选？](#sec6)

---

<a id="sec1"></a>

## 1. 什么是双数组 Trie（Double-Array Trie）

**Trie**（也叫 **Prefix Tree**，前缀树）是一种常见的树形数据结构，用于高效地表示和查询一组字符串（或“单词”）。Trie 的核心思想是：

- 将字符串的公共前缀只存储一次；
- 从根节点到叶节点的一条路径，代表一个字符串。

但是，**传统的树形 Trie** 往往需要大量的指针或哈希结构来链接“子节点”。当字符串集合和字符集很大时，指针式的 Trie 可能浪费内存。

**双数组 Trie（Double-Array Trie）**（又称 **DART** 或 **DAWG-based** 的某种实现之一）是由 Aoe 等人在 1989 年提出的，用 **两个并行的一维数组**（通常命名为 `base[]` 和 `check[]`）来紧凑地表示一棵 Trie。它具有以下特点：

- 不再显式存储指针或链表结构；
- 利用整型数组模拟树形结构；
- 在构造完成后，对某些操作（查询或键值对检索）可以实现**O(m)** 的查询时间（m 为查询串长度），且具有良好的**空间压缩**效果。

简而言之：

- **Double-Array Trie** 依然是一棵 Trie，但节点都放在数组下标里，每个节点对应一个下标 idx；
- 用 `base[idx]`、`check[idx]` 来表示“从节点 idx 出发”的**子节点所在位置**以及**父节点是谁**，从而在一个或两个数组里实现紧凑存储。

---

<a id="sec2"></a>

## 2. 双数组 Trie 的内部结构

### 2.1 两个关键数组

1. **`base[]`**

   - `base[idx]` 是一个整数，表示节点 `idx` 的子节点在数组中的“基地址（base）”。
   - 当我们要找“节点 `idx` 在字符 `c` 下的子节点”时，一般做：  
     \[
     \text{childIndex} = \text{base}[idx] + (\text{code of }c)
     \]
   - 其中 “\(\text{code of }c\)” 是将字符 `c` 映射为一个整数（常见做法是字符的 ASCII/Unicode 值减去某个偏移等）。

2. **`check[]`**
   - `check[childIndex]` 也存一个整数，表示**childIndex 的父节点**在数组里是哪个下标。
   - 如果 `check[childIndex] = idx`，才意味着 “节点 `childIndex` 的父节点，确实是节点 `idx`”。
   - 如果 `check[childIndex]` ≠ `idx`，表示这里并不是节点 `idx` 下的子节点（可能是别人的子节点，或者空位）。

### 2.2 一段示意

假设节点下标 5 对应某个 Trie 节点，`base[5] = 100`。要查它的字符 `c` 子节点，假设 `c` 的“编号”为 3（比如 `'c' - 'a' = 2`、`'d' - 'a' = 3` 等），则“潜在子节点”下标是 `100 + 3 = 103`。

- 接着我们看 `check[103]`：
  - 如果 `check[103] == 5`，说明“103” 确实是 5 节点在字符 `c` 下的子节点；
  - 如果 `check[103] != 5`，说明在这个位置，要么是空，要么是属于别的父节点。

通过这样**一对** `base[]` + `check[]`，就把树形的父子关系**编码**进数组下标中，不需要指针或哈希映射。

### 2.3 存储其他信息

- 通常还需要一些辅助结构或方法来表示：
  1. 哪些节点是“终止节点”（匹配一个完整字符串）；
  2. 节点存储的值（若需要词典功能）等等。
- 一些实现会在 `base[idx]` 或 `check[idx]` 上做特殊标记，比如 `base[idx] < 0` 表示这是一个终止节点，也有人在单独的数组/位图中记录终止信息。

---

<a id="sec3"></a>

## 3. 双数组 Trie 的构建与查询流程

### 3.1 构建（简要介绍）

1. **插入字符串**：从根节点（下标 0）开始，每次读一个字符 `c`，计算 “`base[curr] + code(c)`” 作为子节点下标 `childIndex`，如果：
   - `check[childIndex] == curr`，说明已经有这个子节点（或冲突，需要重新分配 base），就往下走；
   - 否则，就说明需要在这个位置建新的子节点。
     - 如果 `childIndex` 已被别人占用（`check[childIndex] != -1 && != curr`），就要**“冲突解决”**：移动某些节点到其它空闲区，以免产生冲突——这也是双数组 Trie 构建中最复杂的环节。
     - 一些算法会通过“寻找下一段空区块”或“开辟新的 base 值”等方式来把冲突节点挪走。
2. **记录终止节点**：当插入一个字符串完毕，就把该节点标记为“终止”，有的实现是 `base[idx]` 设为负数等方式。

> 正因为要处理冲突，最原始的双数组 Trie 构建算法比较复杂，常有多种实现变体（如 DARTS、DARTS-Lite 等）以提升构建速度。

### 3.2 查询

给定要查询的字符串 `S`：

1. 从根节点 `0` 开始，令 `curr = 0`；
2. 依次读取字符 `c`，计算 `childIndex = base[curr] + code(c)`；
3. 如果 `check[childIndex] == curr`，则 `curr = childIndex`；否则说明查找失败，字符串不在 Trie 中；
4. 读到字符串结尾，如果 `curr` 标记为“终止节点”，查询成功；否则失败或部分匹配。

这样一个**字符一个字符**地走下来，每步只要做一次加法和一次数组访问，复杂度**O(m)**（m 为字符串长度）。

---

<a id="sec4"></a>

## 4. 双数组 Trie 的优缺点

**优点：**

1. **紧凑内存**：和普通指针 Trie 相比，大幅减少“子节点指针”的存储开销；
2. **查询速度快**：对每个字符只做“加法 + 下标访问 + 比较”，可以高速匹配（在 CPU Cache 上也较友好）；
3. **静态构造后**可以得到非常好的空间和查询性能，适合 **“一次构造，多次查询”** 的场景（如词典、词法分析器、拼写检查工具等）。

**缺点：**

1. **构建过程复杂**：要处理冲突，找空闲区块，需要较多的技巧；构建时间比普通 Trie 更耗时，代码实现也更复杂；
2. **动态更新困难**：如果频繁增删，会导致大量节点重排、移动，性能很差；因此多见于**静态字典**场景；
3. **字符编码需离散映射**：对字符集大的场景，可能浪费空间或需要做稀疏存储策略。

---

<a id="sec5"></a>

## 5. 其他常见的 Trie / 词典数据结构

除了双数组 Trie，还有很多种**索引或词典**数据结构，常见的包括：

1. **普通指针 Trie**

   - 每个节点用数组或 map 保存所有子节点引用，构造简单，但可能浪费指针/哈希空间；
   - 适合字符集不大的情况（例如仅 [a-z]），且易于**动态插入**。

2. **压缩 Trie（Radix Tree / Patricia Trie）**

   - 把中间只有单一分支的节点“压缩”成一条边，从而减少深度；
   - 适合保存大量拥有长公共前缀的字符串，可以大幅节省节点数量。

3. **DAWG / Directed Acyclic Word Graph**

   - 可以看作更进一步的“后缀合并”压缩，将所有相同后缀合并为一个共享的子图；
   - 是存储一个**无重复**大规模单词集合的最小有穷自动机 (Minimized DFA)，可以极大节省空间；
   - 但也只适用于**静态**场景，动态插入很麻烦。

4. **B-Tree / Ternary Search Tree / Sorted Array + Binary Search**

   - 不同的关键词可能使用不同索引结构，比如 B-Tree 适用于磁盘索引、Ternary Search Tree 适合内存中使用字符三分搜索等；
   - 若只是**查询**，也可以将所有字符串排序后用二分搜索来查是否存在，这对于纯在/不在判断也很快，且构造容易。

5. **Trie 的其它紧凑实现**
   - **Double-Array Trie** 是一种，
   - **Single Array + Offset**（如某些 “packed trie”）也是一种，
   - 或者对 Trie 做“位图压缩”或“succinct trie”以省内存等。

---

<a id="sec6"></a>

## 6. 在实际工程中该怎么选？

1. **是否需要动态插入/删除？**
   - 如果需要频繁插入/删除，**双数组 Trie** 并不适合，因为更新操作会引发大量重排；**普通指针 Trie** 或 **Radix Tree** 会更方便。
2. **是否是大规模静态词典？**
   - 若是一次性构造的大规模字典（词库、词法分析、拼写纠正），然后仅做查询，**双数组 Trie** 或 **DAWG** 非常好：空间效率高，查询速度快。
3. **字符集大小**
   - 若字符集很小（如仅 `[a-z]`），普通 Trie 或许也还行；若字符集大（中文、Unicode），则在双数组 Trie 里要先做映射，否则会浪费很多空间。
4. **能否容忍额外构建开销？**
   - 双数组 Trie 的构建相对复杂，可能耗时更多，但**静态**查询性能（和内存占用）通常是它的最大优势。
5. **对空间的极致要求？**
   - **DAWG**（最小化有穷自动机）可能是最紧凑的方式之一，但一般只支持“是否存在该字符串？”的匹配（可扩展做简单的 value 存储，但更复杂），且更新不便。

**没有绝对“最好”** 的词典数据结构，只有**最合适**。简单总结：

- 小规模、动态的：**普通 Trie** 或 **基于 map 的 Trie**，实现简单直观；
- 大规模、静态的：**双数组 Trie** 或 **DAWG**（最小化自动机）更省空间、查得快；
- 若只做“存在性判断”且字符串集合非常庞大：考虑 **DAWG** 或 **Bloom Filter**（但后者有一定概率误判）。

---

## 总结

- **双数组 Trie**（Double-Array Trie）是利用 `base[]` 和 `check[]` 两个数组来紧凑表示一棵 Trie，查询速度快、内存紧凑，对大规模静态字典特别有用。
- 构建算法较复杂，不适合频繁动态更新。
- 在工业级场景，如字典、词法分析器、拼写纠正器中大量使用。
- 除了双数组 Trie，还有普通指针 Trie、压缩 Trie（Radix Tree / Patricia）、DAWG、Succinct Trie 等多种形态。
- **最好的**结构要根据**使用场景**来决定：
  - 需要动态更新？需要最紧凑空间？需要快速批量插入或只读查询？字符集大小如何？结合这些维度进行综合选择。
