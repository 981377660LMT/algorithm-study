# 两种类型

- 静态，配合 dfs；动态，配合 bit：
  预处理 distToRoot 数组，dfs 出每个点到根结点的值
  树链上维护阿贝尔群
  `RangeAdd，pointGet`，链上加单点求职参考树状数组的差分 api

  **点的修改**:u++,v++,lca--,fa[lca]--
  **边的修改**:u++,v++,lca-=2

---

https://www.luogu.com.cn/blog/LawrenceSivan/shu-shang-ci-fen-zong-jie

点差分：https://www.luogu.com.cn/problem/P3128
边差分：https://www.luogu.com.cn/problem/P2680

---

https://zhuanlan.zhihu.com/p/30677133

---

# 树链求并。

按照 dfn 排序后，对每个 i，将 ui 到根节点的链上点+1，将 lca(u[i],u[i+1])到根节点的链上点-1。
现在问题转化为了：" 链上加 " & " 单点求值 "。
可以使用树上差分将问题转化为：" 单点加 " & " 子树求和 "。

树上差分解决问题类型

---

**一个端点为根节点**的路径查询/修改问题可以简化：

- 是否可以用 dfs 一遍求出所有查询答案?
  滴滴笔试 t2：对每个结点，求出到父亲的链上权值的前驱.
  因为一个端点是根节点，因此 dfs 一遍，维护 set 即可求出答案.
- 查询的一个端点是根时，单点修改链求和 => 子树修改单点查询
  修改的一个端点是根时，链加，单点查询 => 单点加，子树求和
  如果不满足一个端点是根的条件，可以考虑使用树上差分，转化为三个到根链的求和/修改.
  **只要包含一个单点操作，一个链操作，均可以将链操作转化为子树操作，即可将时间复杂度更大的树剖 BIT 换成普通 BIT。**
