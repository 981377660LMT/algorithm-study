写线段树的话，推荐使用 `ts+数组实现(节点的写法很容易MLE)+考虑大数`

<!-- 参考 4_set\有序集合\区间合并的三种题 -->

五个方法:

```py
def build(self, rt: int, left: int, right: int) -> None:
初始化Node准备初始状态的query、要pushUp

def update(self, rt: int, left: int, right: int, target: str) -> None:
要pushDown、pushUp，到了最细粒度的结点更新(也实际的原数组)后打上懒标记

def query(self, rt: int, left: int, right: int) -> int:
要pushDown，到了最细粒度的结点后返回节点值

def pushUp(self, rt: int) -> None:
用子节点更新父节点状态

def pushDown(self, rt: int) -> None:
传递懒标记并更新左右结点
```

`如果没有区间修改，没有必要用懒标记`
`如果改一次就查一次，没有必要用懒标记`
`如果只有单点查询，没有必要用pushUp`

不同的线段树一般是 pushDown 和 pushUp 不同，需要想清楚`怎么用左右区间更新整个区间、整个区间更新左右区间`

`线段树是工具，真正需要关心的是“维护什么值，怎么维护”，而不是模板什么的`

https://www.desgard.com/algo/docs/part3/ch02/3-segment-tree-range/

只要是区间查询、区间操作问题中，并且区间内有确定运算结果场景下，都可以通过线段树来优化查询、更新的复杂度，例如：`区间求 GCD（最大公约数）、区间求异或结果等等`

1. 在向上更新 push_up 的时候，重新制定规则 - 父结点是两个子节点的大值；
2. 在查询 query 的时候，将结果取递归搜索的大值；

|                    | 使用数组实现 | 线段树  |
| ------------------ | ------------ | ------- |
| 染色操作(更新区间) | O(n)         | O(logn) |
| 查询操作(查询区间) | O(n)         | O(logn) |

**有更新的区间查询问题**
2017 年到现在消费最少的用户?
某个太空区间中天体总量?
给出一份服务器一天的 log 文件，包含用户 id，登录时间，登出时间，求`当天服务器最大在线人数是多少`(如果文件发生变动 => 用 max 的线段树；如果文件不会发生变动 => 如果只查一次，用差分数组加一次遍历；如果查区间多次，用 st 表)

规定:左孩子少一些
平衡二叉但不是完全二叉，但是可以**当成满二叉树处理**
堆和线段树都是**平衡二叉树**

n 个元素的区间，数组表示需要多少节点？
需要约 **4n** 的静态空间

线段树主要用于**会更新的区域**

创建线段树=>查询线段树=>更新线段树

因为根节点的值依赖于子节点，所以**后序遍历递归**

线段树其实最重要的是“两操作，一思想”。两操作中，包括 Push Up 和 Push Down 两个操作，一个思想是 Lazy 延迟更新思想

Segmentation fault
存储器区段错误

`单点更新不需要懒标记，区间更新需要懒标记`
