有漏洞的哈希函数
https://leetcode.cn/problems/delete-duplicate-folders-in-system/solutions/904603/he-ji-yi-xie-you-lou-dong-de-ha-xi-han-s-nylg/

## 1. 问题背景

树哈希常用于判断两棵树结构是否相同（同构），比如文件夹结构、表达式树等。  
理想的哈希函数应该让不同的树结构几乎不可能哈希到同一个值（极小的冲突概率），而且不能被“有心人”通过构造特定数据轻易卡掉。

---

## 2. 常见错误哈希函数及其漏洞

### 错误1：线性加和型

**形式：**

```
h(x) = M * (h(y1) + h(y2) + ... + h(yd)) + h'(s(x)) (mod P)
```

- `x` 是当前节点，`y1...yd` 是子节点，`s(x)` 是节点名，`h'` 是字符串哈希。

**漏洞：**

- 只要对子节点的哈希值做“等量正负抵消”，整体哈希值不变。
- 比如一个子节点哈希+1，另一个-1，结果一样。
- 这就容易被构造出不同结构但哈希值相同的树。

**反例：**

- `["a", "b"]` 和 `["b", "a"]`，只要哈希值能互换抵消。

---

### 错误2：加权线性型

**形式：**

```
h(x) = 1 + M * sum(h(yi) * h'(s(yi))) (mod P)
```

- 看起来更复杂，但本质还是线性组合。

**漏洞：**

- 只要把所有的 `h'(s(yi))` 看成变量，还是可以通过多项式变换凑出相同的哈希值。
- 依然容易被构造反例。

---

### 错误3：Rabin-Karp 类型（递推多项式）

**形式：**

```
hi(x) = (hi-1(x) * M + h(yi) * M + h'(s(yi))) mod P
h(x) = hd(x)
```

- 类似字符串哈希的递推。

**漏洞：**

- 如果 `h'(s)` 很简单（比如线性），可以通过调整某些子节点的哈希值，让不同结构的树哈希值相同。
- 多个节点共享同一“位权”，容易被卡。

---

### 错误4：多项式嵌套型

**形式：**

```
hi(x) = (hi-1(x) * M^2 + h(yi) * M + h'(s(yi))) mod P
```

- 进一步嵌套多项式。

**漏洞：**

- 依然可以通过变量替换、节点交换等方式，构造出哈希冲突。

---

### 错误5：加常数型

**形式：**

```
h(x) = (hd(x) * M + B) mod P
```

- 在尾部加常数B。

**漏洞：**

- 只要B不是每个节点唯一的，依然可以被卡。

---

## 3. 为什么这些哈希函数容易被卡？

- **线性结构**：只要哈希表达式是线性的（加法、乘法），就容易被“抵消”或“变量替换”。
- **多项式结构**：多项式的变量可以通过构造不同的树结构，凑出相同的多项式值。
- **节点顺序无关**：如果哈希函数对儿子节点的顺序不敏感（比如加法），就容易被“换顺序”卡掉。
- **节点权重不唯一**：如果每个节点的权重（比如M的幂次）不是唯一的，也容易被卡。

---

## 4. 如何改进？

### 1. 让每个节点的权重唯一

- 比如用 `M^size(yi)`，其中 `size(yi)` 是子树大小，这样每个节点的权重都不同，难以抵消。

### 2. 递归嵌套哈希

- 比如 `h(x) = hash( sort([h(yi) for yi in children]) + s(x) )`
- 先对子节点哈希排序，再整体哈希，保证结构唯一性。

### 3. 多模数、多哈希函数

- 并行用多个大质数和不同哈希函数，进一步降低冲突概率。

### 4. 加入节点顺序

- 如果树是有序的，可以把顺序也编码进哈希。

---

## 5. 总结

- 线性、简单多项式型哈希函数容易被构造反例卡掉，不能保证树结构的唯一性。
- 正确的树哈希应让每个节点的权重唯一、结构敏感、难以抵消。
- 常用的安全做法是递归嵌套哈希+排序+多模数。

---

### 参考代码（安全树哈希示例）

```python
def tree_hash(node):
    # node: (name, [children])
    name, children = node
    child_hashes = [tree_hash(child) for child in children]
    child_hashes.sort()  # 无序树需要排序
    s = name + '(' + ''.join(child_hashes) + ')'
    return str(hash(s))
```
