https://taodaling.github.io/blog/2019/09/10/%E6%A0%91%E4%B8%8A%E7%AE%97%E6%B3%95/

# 括号序列/dfs 序

- 平衡树维护括号序

我们可以把一颗大小为 n 的树唯一的转换为一个长度为 2n 的括号序列，具体做法是对树进行遍历，进入某个顶点的时候，在括号序列尾部插入一个左括号，离开某个顶点的时候插入一个右括号。每个顶点对应一对匹配的左右括号。

同理一颗合法的括号序列（同时最左边的左括号和最右边的右括号匹配）也唯一对应一颗树。
括号序列的好处是我们可以**把树作为字符串进行操作，而对于字符串我们可以将其丢到平衡树上进行加速**，这样就可以实现 O(log2n)级别的字符串各种骚操作，如果愿意舍弃一些内存，还能支持持久化。

来看看括号序列有哪些好，括号序列的表示方式，可以允许我们 O(log2n)时间复杂度下完成下面所有操作：

- **子树的删除**：我们可以删除一颗子树，对应的就是删除一段括号序列。
- **子树的插入**：类似于删除，只不过变成插入一段括号序列。
- 查找 k 级祖先：考虑顶点 v，要找它的深度为 h 的祖先，可以去二分找 v 右括号后第一个深度小于等于 h 的顶点，由于是在平衡树上二分，所以时间复杂度为 O(log2n)。
- 查询 lca：对于给定顶点 u,v，如果二者为根的子树对应的括号子串有相交，那么较大的为 lca。否则二者不相交，记 u 的括号对出现在前，那么在 u 的右括号到 v 的左括号之- 间的深度最小的顶点的父亲，就是它们的 lca。找父亲，可以于用查找 k 级祖先提到的方法。
- 子树修改查询：对应的就是一段区间的修改查询。
- 查询两点距离：维护每个顶点的深度，查找 lca 后用距离公式计算。
- 查找 dfs 序最大/小的深度为 k 的顶点：这个实际上对应的就是查找最靠右深度大于等于 k/最靠左深度大于等于 k 的顶点。直接在平衡树上进行二分即可。

  但是这样维护括号序列是不能支持换根的，要换根需要用到 euler tour tree。
  https://codeforces.com/contest/414/problem/E

---

有的题目是`后序dfs序`
[3327. 判断 DFS 字符串是否是回文串](https://leetcode.cn/problems/check-if-dfs-strings-are-palindromes/description/)
