## 动态点分治解决具有带点权/边权修改 的树上路径信息统计问题

具体的说，经常用于处理没有明显的子树边界的问题，比如：相距最远的两个黑点、距离一个点距离<=k 的点权和...这些问题没有子树的限制，是面向整棵树的。
https://www.luogu.com.cn/blog/i207M/dian-fen-shu-xue-xi-bi-ji
https://www.luogu.com.cn/problem/solution/P6329

有的问题我们不是非常关心树的形态特点，比如**路径问题，联通块问题，寻找关键点**问题等等，以路径问题为例，我们不一定非得查到 p,q 的 LCA 才可以处理 p,q 的路径信
息，相反，我们可以随便从这个路径上寻找一个分割点，然后分别处理 p,q 到分割点的路径信息，只要我们可以快速的处理 p 到 t 和 q 到 t 的信息，我们就可以处理 p 到 q 的信息。

`点分树`恰好满足这种性质:
https://atcoder.jp/contests/abc291/tasks/abc291_h

- 点分树上(u,v)两点的 lca 一定在原树中(u,v)的路径上
  即 dist(x,y) = dist(x,t) + dist(t,y)。
  `原树中的路径都能以他们两个端点在点分树中的 lca 为终点，分解为两条路径。`
  对每个固定的 u，不断上跳到祖先结点(可能的 LCA)，就可以和祖先子树中另一个 v 配对形成一条路径
- 原图中除开根节点的所有顶点 v，在点分树中都满足子树大小不超过父亲子树大小的一半。
  他的高度为 logn,因此我们可以使用各种各样在一般树论里过不去的暴力做法，比如利用这棵树来跑一些类似“`从询问点出发，不断跳 fa`”的暴力，来解决一些树上的多次询问/修改问题。对某个结点进行修改的话，影响的是他到根的一段 log 长的路径。

## 一个比较常见的套路是这样的：

1. 求出每个点在点分树上的父节点
2. 对于每个点，开一个数据结构 S1 存储点分树子树的贡献(以点 u 为根的子树与 u 的信息)，再开一个数据结构 S 2 存储点分树父亲的贡献(以点 u 为根的子树与 fa[u]的信息)，用来容斥求出`在 fa[u]的子树中且不在 u 的子树中的信息`
3. 对 x 进行修改时，从 x 开始不断跳点分树的父亲一直到根，每次对经过的节点的 S1,
   S2 修改它的贡献，时空复杂度为`点分树高 × 节点上的子数据结构单次修改复杂度`。
4. 对 x 进行查询时，从 x 开始不断跳点分树的父亲一直到根，每次把 S 1 的贡献添加进答案，把 S 2 的贡献从答案刨去
5. 初始化可视为直接进行 n 次修改
