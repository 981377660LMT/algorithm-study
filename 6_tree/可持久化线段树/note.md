**用 js 写持久化线段树/线段树最好用 TyedArray 不要用 class 表示结点 否则容易 MLE**

https://www.acwing.com/solution/content/51456/
https://www.acwing.com/solution/content/72023/

## 解决的问题

使用多个入口指针保存多个不同版本的线段树
可以存下来数据结构的所有历史版本
类似 git 只记录 diff，每一个版本比前一个版本多 logn 级别的数据
类似 GitHub, 每个版本包含当前版本和之前的所有内容: 每新增一个点都建一颗新树,
复制前一棵树并插入新元素所造成的修改.
实现上, 是在 build 的时候只建立树的骨架而不保存元素, 而对每一个点都做一次 insert,
在插入新点的同时, 复制上一棵树, 再插入新点
由于从 1 个点插到 n 个点, 每次都是二分插入, 时间空间复杂度就都是 nlogn(N 个点离散化之后的范围上限自然还是 N)
线段树 tree 数组要开 `N * 4 + NlogN (N是数组长度，离散化后的值域为0-N-1)`
`树高logN，底端的叶子结点才保存每个元素的真实的 count 个数`

## 可持久化数据结构（Persistent data structure）每次修改都会保留其自身每一个历史版本

- 部分可持久化¶
  每个历史版本都可以访问，但只有最新的版本才可以修改

- 完全可持久化¶
  每个历史版本都可以访问和修改

- 融合可持久化¶
  每个历史版本都可以访问和修改，且支持通过合并两个历史版本来创建新版本

## 可持久化的前提：本身的拓扑结构在操纵过程中不变(平衡树就不行)

1. Trie 的持久化
2. 线段树的可持久化(主席树)
   主席树、又称为可持久化线段树，实际上是记录了每一次更新时的版本信息，题型基本上都是结合离散化，最经典的用法是求区间第 K 大/小的数

## 静态问题

- 可持久化线段树(主席树)，不支持修改 **nlogn**
- 树套树(线段树+平衡树)，一般是线段树+set，支持`动态区间查询` **nlognlogn**
- 划分树

持久化(权值)线段树的思路:

1. 离散化到 0-n-1
2. 在`数值`上建立线段树(不是在下标上)，维护每个`数值区间`中一共有多少个数
3. 二分区间 例如[0,mid] 如果左边[0,mid//2]里的数多于 k 个，那么第 k 小数肯定在左边
4. 要求[L,R]里的第 k 小数，需要搜两个版本的线段树，前缀和相减就可以得到这一段有多少个数
   ([0,R]表示只加了 R 个数的情况)
