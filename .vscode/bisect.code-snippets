{
  // Place your js-algorithm 工作区 snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and
  // description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope
  // is left empty or omitted, the snippet gets applied to all languages. The prefix is what is
  // used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
  // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders.
  // Placeholders with the same ids are connected.
  // Example:
  "最左二分": {
    "scope": "python",
    "prefix": "bisect1",
    "body": [
      "def check(mid: int) -> bool:",
      "  res = 0",
      "  for num in nums:",
      "    res += num // mid",
      "  return res >= k",
      "",
      "left, right = 0, int(1e18)",
      "ok = False",
      "while left <= right:",
      "  mid = (left + right) // 2",
      "  if check(mid):",
      "    right = mid - 1",
      "    ok = True",
      "  else:",
      "    left = mid + 1",
      "return left"
    ],
    "description": "最左二分"
  },
  "最右二分": {
    "scope": "python",
    "prefix": "bisect2",
    "body": [
      "def check(mid: int) -> bool:",
      "  res = 0",
      "  for num in nums:",
      "    res += num // mid",
      "  return res >= k",
      "",
      "left, right = 1, int(1e18)",
      "ok = False",
      "while left <= right:",
      "  mid = (left + right) // 2",
      "  if check(mid):",
      "    left = mid + 1",
      "    ok = True",
      "  else:",
      "    right = mid - 1",
      "return right"
    ],
    "description": "最右二分"
  },
  "reArrange-py": {
    "scope": "python",
    "prefix": "rearrange",
    "body": [
      "def rearrange(A, order: List[int]):",
      "  '''将数组按照order里的顺序重新排序.'''",
      "  res = [None] * len(A)",
      "  for i in range(len(order)):",
      "    res[i] = A[order[i]]",
      "  return res"
    ],
    "description": "将数组按照order里的顺序重新排序."
  },
  "第k小的数,k从1开始": {
    "scope": "python",
    "prefix": "bisectKth",
    "body": [
      "def countNGT(mid: int) -> int:",
      "  '''有多少个不超过mid的候选'''",
      "  res = 0",
      "  return res",
      "",
      "left, right = 0, int(1e18)",
      "while left <= right:",
      "  mid = (left + right) // 2",
      "  if countNGT(mid) < k:",
      "    left = mid + 1",
      "  else:",
      "    right = mid - 1",
      "return left"
    ],
    "description": "二分查找第k小的数,k从1开始"
  },
  "遍历子集": {
    "scope": "typescript,typescriptreact",
    "prefix": ["subset", "enumerateSubset", "枚举子集", "子集"],
    "body": [
      "/**",
      " * 遍历子集.",
      " * @param copy 是否复制子集.",
      " * @complexity O(2^n), 2^27(1.3e8) => 1.1s.",
      " */",
      "function enumerateSubset<T>(",
      "  nums: ArrayLike<T>,",
      "  callback: (subset: T[]) => void,",
      "  copy = false",
      "): void {",
      "  const n = nums.length",
      "  dfs(0, [])",
      "  function dfs(index: number, path: T[]) {",
      "    if (index === n) {",
      "      callback(copy ? path.slice() : path)",
      "      return",
      "    }",
      "    dfs(index + 1, path)",
      "    path.push(nums[index])",
      "    dfs(index + 1, path)",
      "    path.pop()",
      "  }",
      "}"
    ],
    "description": "遍历子集"
  },

  "前后缀分解-py": {
    "scope": "python",
    "prefix": "makeDp",
    "body": [
      "def makeDp(arr: List[int]) -> List[int]:",
      "\t\tn = len(arr)",
      "\t\tdp = [0] * (n + 1)",
      "\t\tfor i in range(1, n + 1):",
      "\t\t\t\tcur = arr[i - 1]",
      "\t\t\t\t#",
      "\t\treturn dp",
      "",
      "dp1, dp2 = makeDp(${1:nums}), makeDp(${1:nums}[::-1])[::-1]",
      "res = 0",
      "for i in range(len(${1:nums})):",
      "\t\tres += dp1[i] * dp2[i]\t# [0,i) [i,n)"
    ],
    "description": "前后缀分解,适用于dp逻辑复杂的情况"
  },
  "前后缀分解-ts": {
    "scope": "typescript,typescriptreact",
    "prefix": "makeDp",
    "body": [
      "\tconst makeDp = (arr: number[]): number[] => {",
      "\t\tconst m = arr.length",
      "\t\tconst dp: number[] = Array(m + 1).fill(0)",
      "\t\tfor (let i = 1; i <= m; i++) {",
      "\t\t\tconst cur = arr[i - 1]",
      "\t\t\t// ...",
      "\t\t}",
      "\t\treturn dp",
      "\t}",
      "",
      "\tconst dp1 = makeDp(${1:nums})",
      "\tconst dp2 = makeDp(${1:nums}.slice().reverse()).reverse()",
      "\tlet res = 0",
      "\tfor (let i = 0; i < ${1:nums}.length; i++) {",
      "\t\tres += dp1[i] * dp2[i] // [0,i) x [i,n)",
      "\t}",
      "\treturn res"
    ],
    "description": "前后缀分解"
  },
  "前后缀分解-go": {
    "scope": "go,golang",
    "prefix": "makeDp",
    "body": [
      "\tmakeDp := func(arr []int) []int {",
      "\t\tm := len(arr)",
      "\t\tdp := make([]int, m+1)",
      "\t\tfor i := 1; i <= m; i++ {",
      "\t\t\tcur := arr[i-1]",
      "\t\t\t// ...",
      "\t\t}",
      "\t\treturn dp",
      "\t}",
      "",
      "\tdp1 := makeDp(${1:nums})",
      "\tdp2 := func() []int {",
      "\t\ttmp := append(${1:nums}[:0:0], ${1:nums}...)",
      "\t\tfor i, j := 0, len(tmp)-1; i < j; i, j = i+1, j-1 {",
      "\t\t\ttmp[i], tmp[j] = tmp[j], tmp[i]",
      "\t\t}",
      "\t\tres := makeDp(tmp)",
      "\t\tfor i, j := 0, len(res)-1; i < j; i, j = i+1, j-1 {",
      "\t\t\tres[i], res[j] = res[j], res[i]",
      "\t\t}",
      "\t\treturn res",
      "\t}()",
      "",
      "\tres := 0",
      "\tfor i := 0; i < len(${1:nums}); i++ {",
      "\t\tres += dp1[i] * dp2[i] // [0,i) x [i,n)",
      "\t}"
    ],
    "description": "前后缀分解"
  },
  "记忆化dfsIndexRemain": {
    "scope": "python",
    "prefix": "dfsIndexRemain",
    "body": [
      "@lru_cache(None)",
      "def dfs(index: int, remain: int) -> int:",
      "  if remain < 0:",
      "    return 0",
      "  if index == n:",
      "    return 1 if remain == 0 else 0",
      "",
      "  res = 0",
      "  return res",
      "",
      "res = dfs(0, k)",
      "dfs.cache_clear()",
      "return res"
    ],
    "description": "将区间[0,n)分成 k 组的最小代价"
  },
  // !dp[k][j]=min(dp[k-1][i]+f(i,j)) (0<=i<j<=n)
  "dp数组dfsIndexRemain2": {
    "scope": "python",
    "prefix": "dfsIndexRemain",
    "body": [
      " # !dp[k][j]=min(dp[k-1][i]+f(i,j)) (0<=i<j<=n)",
      " # !f(i,j): 左闭右开区间[i,j)的代价(0<=i<j<=n)",
      " dp = [0] + [f(0, j) for j in range(1, n + 1)]  # 分成1组时的代价",
      " for _ in range(2, k + 1):",
      "     ndp = [INF] * (n + 1)",
      "     for j in range(1, n + 1):",
      "         for i in range(j):",
      "             ndp[j] = min(ndp[j], dp[i] + f(i, j))",
      "     dp = ndp",
      " return dp[n]"
    ],
    "description": "将区间[0,n)分成 k 组的最小代价"
  },
  "将区间[0,n)分成k组的最小代价": {
    "scope": "go",
    "prefix": "dfsIndexRemain",
    "body": [
      "const INF int = 1e18",
      "// !f(i,j): 左闭右开区间[i,j)的代价(0<=i<j<=n)",
      "func offlineDpMin(k, n int, f func(i, j int) int) int {",
      " dp := make([]int, n+1)",
      " for j := 1; j <= n; j++ {",
      "  dp[j] = f(0, j)",
      " }",
      " for k_ := 2; k_ <= k; k_++ {",
      "  ndp := make([]int, n+1)",
      "  for i := 0; i <= n; i++ {",
      "   ndp[i] = INF",
      "  }",
      "  for j := 1; j <= n; j++ {",
      "   for i := 0; i < j; i++ {",
      "    cand := dp[i] + f(i, j)",
      "    if cand < ndp[j] {",
      "     ndp[j] = cand",
      "    }",
      "   }",
      "  }",
      "  dp = ndp",
      " }",
      " return dp[n]",
      "}",
      "",
      "// !f(i,j): 左闭右开区间[i,j)的代价(0<=i<j<=n)",
      "func offlineDpMax(k, n int, f func(i, j int) int) int {",
      " dp := make([]int, n+1)",
      " for j := 1; j <= n; j++ {",
      "  dp[j] = f(0, j)",
      " }",
      " for k_ := 2; k_ <= k; k_++ {",
      "  ndp := make([]int, n+1)",
      "  for i := 0; i <= n; i++ {",
      "   ndp[i] = -INF",
      "  }",
      "  for j := 1; j <= n; j++ {",
      "   for i := 0; i < j; i++ {",
      "    cand := dp[i] + f(i, j)",
      "    if cand > ndp[j] {",
      "     ndp[j] = cand",
      "    }",
      "   }",
      "  }",
      "  dp = ndp",
      " }",
      " return dp[n]",
      "}"
    ],
    "description": "将区间[0,n)分成k组的最小代价"
  },
  "记忆化dfsIndex": {
    "scope": "python",
    "prefix": "dfsIndex",
    "body": [
      "@lru_cache(None)",
      "def dfs(index: int) -> int:",
      "    if index == n:",
      "        return 0",
      "",
      "    res = INF",
      "    curSum = 0",
      "    for i in range(index, len(nums)):",
      "        ...",
      "        cand = dfs(i + 1) + curSum",
      "        res = cand if cand < res else res",
      "    return res",
      "",
      "",
      "n = len(nums)",
      "res = dfs(0)",
      "dfs.cache_clear()",
      "return res"
    ],
    "description": "将区间[0,n)分成任意组的最小代价"
  },
  "dfs记录路径": {
    "scope": "python",
    "prefix": "dfsPath",
    "body": [
      "def dfs(cur: int) -> None:",
      "  nonlocal res",
      "  if visited[cur]:",
      "    return",
      "  visited[cur] = True",
      "  path.append(cur)",
      "  res += 1",
      "  for next in adjList[cur]:",
      "   dfs(next)",
      "  visited[cur] = False",
      "  path.pop()",
      "",
      "path = []",
      "visited = [False] * n",
      "res = 0",
      "dfs(start)"
    ]
  },
  "dfs回溯-py": {
    "scope": "python",
    "prefix": "dfsBacktrack",
    "body": [
      "from collections import defaultdict",
      "from typing import DefaultDict, List",
      "",
      "def dfsBt(pos: int, path: List[int], counter: DefaultDict[int,int]) -> None:",
      "  if pos == n:",
      "    nonlocal res",
      "    res += 1",
      "    return",
      "  dfsBt(pos + 1, path, counter)",
      "  cur = nums[pos]",
      "  if counter[cur - k] == 0 and counter[cur + k] == 0:",
      "    counter[cur] += 1",
      "    path.append(cur)",
      "    dfsBt(pos + 1, path, counter)",
      "    counter[cur] -= 1",
      "    path.pop()",
      "",
      "n = len(nums)",
      "res = 0",
      "dfsBt(0, [], defaultdict(int))"
    ],
    "description": "dfs回溯"
  },
  "dfs回溯-ts": {
    "scope": "ts,typescript,typescriptreact",
    "prefix": "dfsBacktrack",
    "body": [
      "const n = nums.length",
      "let res = 0",
      "dfsBt(0, [], new Map<number, number>())",
      "return res",
      "function dfsBt(pos: number, path: number[], counter: Map<number, number>): void {",
      "  if (pos === n) {",
      "    res++",
      "    return",
      "  }",
      "  dfsBt(pos + 1, path, counter)",
      "  const cur = nums[pos]",
      "  if ((counter.get(cur - k) || 0) === 0 && (counter.get(cur + k) || 0) === 0) {",
      "    path.push(cur)",
      "    counter.set(cur, (counter.get(cur) || 0) + 1)",
      "    dfsBt(pos + 1, path, counter)",
      "    path.pop()",
      "    counter.set(cur, (counter.get(cur) || 0) - 1)",
      "  }",
      "}"
    ],
    "description": "dfs回溯"
  },
  "子序列匹配": {
    "scope": "python",
    "prefix": "isSubsequence",
    "body": [
      "from typing import Sequence, Any",
      "def isSubsequence(longer: Sequence[Any], shorter: Sequence[Any]) -> bool:",
      "    '''判断shorter是否是longer的子序列'''",
      "    if len(shorter) > len(longer):",
      "        return False",
      "    if len(shorter) == 0:",
      "        return True",
      "    i, j = 0, 0",
      "    while i < len(longer) and j < len(shorter):",
      "        if longer[i] == shorter[j]:",
      "            j += 1",
      "            if j == len(shorter):",
      "              return True",
      "        i += 1",
      "    return False"
    ]
  },
  "二叉树转无向图": {
    "scope": "python",
    "prefix": "treeToGraph1",
    "body": [
      "from typing import List, Optional, Tuple",
      "",
      "class TreeNode:",
      "    def __init__(self, val=0, left=None, right=None):",
      "        self.val = val",
      "        self.left = left",
      "        self.right = right",
      "",
      "def treeToGraph1(",
      "    root: Optional[\"TreeNode\"],",
      ") -> Tuple[List[List[int]], List[Tuple[int, int]], List[int]]:",
      "    \"\"\"二叉树转无向图,返回邻接表,边列表,结点值列表\"\"\"",
      "    def dfs(root: Optional[\"TreeNode\"]) -> int:",
      "        if not root:",
      "            return -1",
      "        nonlocal globalId",
      "        values.append(root.val)",
      "        curId = globalId",
      "        globalId += 1",
      "        if root.left:",
      "            childId = dfs(root.left)",
      "            edges.append((curId, childId))",
      "        if root.right:",
      "            childId = dfs(root.right)",
      "            edges.append((curId, childId))",
      "        return curId",
      "",
      "    globalId = 0  # 0 - n-1",
      "    edges = []",
      "    values = []",
      "    dfs(root)",
      "",
      "    n = len(values)",
      "    adjList = [[] for _ in range(n)]",
      "    for u, v in edges:",
      "        adjList[u].append(v)",
      "        adjList[v].append(u)",
      "    return adjList, edges, values"
    ],
    "description": "二叉树转无向图"
  },
  "n叉树转无向图": {
    "scope": "python",
    "prefix": "treeToGraph2",
    "body": [
      "from typing import List, Optional, Tuple",
      "",
      "class Node:",
      "    def __init__(self, val=None, children=None):",
      "        self.val = val",
      "        self.children = children if children is not None else []",
      "",
      "def treeToGraph2(",
      "    root: Optional[\"Node\"],",
      ") -> Tuple[List[List[int]], List[Tuple[int, int]], List[int]]:",
      "    \"\"\"n叉树转无向图,返回邻接表,边列表,结点值列表\"\"\"",
      "    def build(root: Optional[\"Node\"]) -> int:",
      "        if not root:",
      "            return -1",
      "        nonlocal globalId",
      "        values.append(root.val)",
      "        curId = globalId",
      "        globalId += 1",
      "        for next in root.children:",
      "            nextId = build(next)",
      "            edges.append((curId, nextId))",
      "        return curId",
      "",
      "    globalId = 0  # 0 - n-1",
      "    edges = []",
      "    values = []",
      "    build(root)",
      "",
      "    n = len(values)",
      "    adjList = [[] for _ in range(n)]",
      "    for u, v in edges:",
      "        adjList[u].append(v)",
      "        adjList[v].append(u)",
      "    return adjList, edges, values"
    ]
  },
  "unique": {
    "scope": "go,golang",
    "prefix": "unique",
    "body": [
      "// Sorts the slice, removes duplicates, and clips the slice.",
      "//",
      "// T: cmp.Ordered",
      "//",
      "//\tallX := []int{3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5}",
      "//\tUnique(&allX)",
      "//\tsize := len(allX) // 7",
      "//\tnewX := sort.SearchInts(allX, 5) // 4",
      "func Unique[T int | int32 | uint | uint32](nums *[]T) {",
      "\tslices.Sort(*nums)",
      "\t*nums = slices.Compact(*nums)",
      "\t*nums = slices.Clip(*nums)",
      "}"
    ],
    "description": "unique"
  },
  "go-记忆化dfs": {
    "scope": "go,golang",
    "prefix": ["dfs", "memo"],
    "body": [
      "\tmemo := make([]int, $1)",
      "\tfor i := range memo {",
      "\t\tmemo[i] = -1",
      "\t}",
      "\thash := func(index, arg1 int) int {",
      "\t\treturn ${2:0}",
      "\t}",
      "",
      "\tvar dfs func(index, arg1 int) int",
      "\tdfs = func(index, arg1 int) int {",
      "\t\tif index == n {",
      "\t\t\treturn ${3:0}",
      "\t\t}",
      "\t\thash_ := hash(index, arg1)",
      "\t\tif memo[hash_] != -1 {",
      "\t\t\treturn memo[hash_]",
      "\t\t}",
      "",
      "\t\tres := 0",
      "",
      "\t\t// $4",
      "",
      "\t\tmemo[hash_] = res",
      "\t\treturn res",
      "\t}",
      "\tres := dfs(0, 0)"
    ],
    "description": "记忆化dfs"
  },
  "go-记忆化dfs2": {
    "scope": "go,golang",
    "prefix": "dfsIndexVisited",
    "body": [
      "memo := [20][1 << 20]int{}",
      "for i := 0; i < 20; i++ {",
      " for j := 0; j < (1 << 20); j++ {",
      "   memo[i][j] = -1",
      " }",
      "}",
      "var dfs func(index int, visited int) int",
      "dfs = func(index int, visited int) int {",
      " if visited == (1<<len(need))-1 {",
      " return 0",
      " }",
      " if memo[index][visited] != -1 {",
      " return memo[index][visited]",
      " }",
      " res := INF",
      " for next := 0; next < len(need); next++ {",
      " if visited&(1<<next) == 0 {",
      " res = min(res, dist[index][next]+dfs(next, visited|(1<<next)))",
      " }",
      " }",
      " memo[index][visited] = res",
      " return res",
      "}"
    ],
    "description": "记忆化dfs2"
  },
  "go-dfsIndexVisited2": {
    "scope": "go,golang",
    "prefix": "dfsIndexVisited2",
    "body": [
      "\tconst INF int = 1e18",
      "\tn := len(nums)",
      "",
      "\tmemo := make([]int, n*(1<<n))",
      "\tfor i := range memo {",
      "\t\tmemo[i] = -1",
      "\t}",
      "\thash := func(index, visited int) int {",
      "\t\treturn index*(1<<n) + visited",
      "\t}",
      "",
      "\tvar dfs func(index int, visited int) int",
      "\tdfs = func(index int, visited int) int {",
      "\t\tif index == n {",
      "\t\t\treturn 0",
      "\t\t}",
      "\t\thash_ := hash(index, visited)",
      "\t\tif memo[hash_] != -1 {",
      "\t\t\treturn memo[hash_]",
      "\t\t}",
      "\t\tres := INF",
      "\t\tfor next := 0; next < n; next++ {",
      "\t\t\tif visited&(1<<next) == 0 {",
      "\t\t\t\tres = min(res, dfs(index+1, visited|(1<<next))+1)",
      "\t\t\t}",
      "\t\t}",
      "\t\tmemo[hash_] = res",
      "\t\treturn res",
      "\t}"
    ],
    "description": "dfsIndexVisited2"
  },
  "go-dfsVisited": {
    "scope": "go,golang",
    "prefix": "dfsVisited",
    "body": [
      "\tconst INF int = 1e18",
      "\tn := len(nums)",
      "\tmask := 1<<n - 1",
      "",
      "\tmemo := make([]int, 1<<n)",
      "\tfor i := range memo {",
      "\t\tmemo[i] = -1",
      "\t}",
      "\thash := func(visited int) int {",
      "\t\treturn visited",
      "\t}",
      "",
      "\tvar dfs func(visited int) int",
      "\tdfs = func(visited int) int {",
      "\t\tif visited == mask {",
      "\t\t\treturn 0",
      "\t\t}",
      "\t\thash_ := hash(visited)",
      "\t\tif memo[hash_] != -1 {",
      "\t\t\treturn memo[hash_]",
      "\t\t}",
      "\t\tres := INF",
      "\t\tfor next := 0; next < n; next++ {",
      "\t\t\tif visited&(1<<next) == 0 {",
      "\t\t\t\tres = min(res, dfs(visited|(1<<next))+1)",
      "\t\t\t}",
      "\t\t}",
      "\t\tmemo[hash_] = res",
      "\t\treturn res",
      "\t}"
    ],
    "description": "dfsVisited"
  },
  "go-minMax": {
    "scope": "go,golang",
    "prefix": ["min", "max"],
    "body": [
      "$1",
      "func min(a, b int) int {",
      "\tif a < b {",
      "\t\treturn a",
      "\t}",
      "\treturn b",
      "}",
      "",
      "func max(a, b int) int {",
      "\tif a > b {",
      "\t\treturn a",
      "\t}",
      "\treturn b",
      "}",
      "",
      "func min32(a, b int32) int32 {",
      "\tif a < b {",
      "\t\treturn a",
      "\t}",
      "\treturn b",
      "}",
      "",
      "func max32(a, b int32) int32 {",
      "\tif a > b {",
      "\t\treturn a",
      "\t}",
      "\treturn b",
      "}",
      "",
      "func mins(nums ...int) int {",
      "\tres := nums[0]",
      "\tfor _, num := range nums {",
      "\t\tif num < res {",
      "\t\t\tres = num",
      "\t\t}",
      "\t}",
      "\treturn res",
      "}",
      "",
      "func maxs(nums ...int) int {",
      "\tres := nums[0]",
      "\tfor _, num := range nums {",
      "\t\tif num > res {",
      "\t\t\tres = num",
      "\t\t}",
      "\t}",
      "\treturn res",
      "}"
    ],
    "description": "minMax"
  },

  "python-minmax": {
    "scope": "python",
    "prefix": "minmax",
    "body": [
      "def max(x, y):",
      "    if x > y:",
      "        return x",
      "    return y",
      "",
      "def min(x, y):",
      "    if x < y:",
      "        return x",
      "    return y",
      "",
      "def maxs(seq):",
      "    res = seq[0]",
      "    for i in range(1, len(seq)):",
      "        if seq[i] > res:",
      "            res = seq[i]",
      "    return res",
      "",
      "def mins(seq):",
      "    res = seq[0]",
      "    for i in range(1, len(seq)):",
      "        if seq[i] < res:",
      "            res = seq[i]",
      "    return res"
    ],
    "description": "python手写minmax"
  },

  "状压dp": {
    "scope": "python",
    "prefix": "dfsIndexVisited",
    "body": [
      "@lru_cache(None)",
      "def dfs(index: int, visited: int) -> int:",
      "    if index == n:",
      "        return 1",
      "    res = 0",
      "    for next in range(n):",
      "        if visited & (1 << next):",
      "            continue",
      "        if check():",
      "            res += dfs(index + 1, visited | 1 << next)",
      "    return res",
      "",
      "",
      "res = dfs(0, 0)",
      "dfs.cache_clear()",
      "return res"
    ],
    "description": "状压dp"
  },
  "dfsVisited": {
    "scope": "python",
    "prefix": ["dfsVisited", "dfsIndexVisited2"],
    "body": [
      "\t\tn = len(nums)",
      "\t\tmask = (1 << n) - 1",
      "",
      "\t\t@lru_cache(None)",
      "\t\tdef dfs(visited: int) -> int:",
      "\t\t\t\tif visited == mask:",
      "\t\t\t\t\t\treturn 0",
      "\t\t\t\tres = INF",
      "\t\t\t\tfor i in range(n):",
      "\t\t\t\t\t\tif (visited >> i) & 1:",
      "\t\t\t\t\t\t\t\tcontinue",
      "\t\t\t\t\t\tres = min2(res, dfs(visited | (1 << i)) + nums[i])",
      "",
      "\t\t\t\treturn res",
      "",
      "\t\tres = dfs(0)",
      "\t\tdfs.cache_clear()",
      "\t\treturn res"
    ],
    "description": "dfsVisited"
  },
  "dp": {
    "scope": "python",
    "prefix": "dpIndexRemain",
    "body": [
      "# dp[count][index]表示前index个字符分成count个子串的方案数",
      "dp = [[0] * (n + 1) for _ in range(k + 1)]",
      "dp[0][0] = 1",
      "",
      "for c in range(1, k + 1):  # 分c组",
      "  dpSum = [0] * (n + 1)",
      "  for i in range(1, n + 1):  # 前i个数字",
      "    dpSum[i] = dpSum[i - 1] + (dp[c - 1][i - 1])",
      "    dpSum[i] %= MOD",
      "  for i in range(1, n + 1):",
      "    dp[c][i] = dpSum[max(0, i - minLength + 1)]  # i-length+1 个数的和",
      "",
      "return dp[k][n]"
    ],
    "description": "dp[count][index]表示前index个字符分成count个子串的方案数"
  },
  "求组合数": {
    "scope": "python",
    "prefix": ["comb", "enumeration", "Enumeration"],
    "body": [
      "class Enumeration:",
      "    __slots__ = (\"_fac\", \"_ifac\", \"_inv\", \"_mod\")",
      "    def __init__(self, size: int, mod: int) -> None:",
      "        self._mod = mod",
      "        self._fac = [1]",
      "        self._ifac = [1]",
      "        self._inv = [1]",
      "        self._expand(size)",
      "    def fac(self, k: int) -> int:",
      "        self._expand(k)",
      "        return self._fac[k]",
      "    def ifac(self, k: int) -> int:",
      "        self._expand(k)",
      "        return self._ifac[k]",
      "    def inv(self, k: int) -> int:",
      "        '''模逆元'''",
      "        self._expand(k)",
      "        return self._inv[k]",
      "    def C(self, n: int, k: int) -> int:",
      "        if n < 0 or k < 0 or n < k:",
      "            return 0",
      "        mod = self._mod",
      "        return self.fac(n) * self.ifac(k) % mod * self.ifac(n - k) % mod",
      "    def P(self, n: int, k: int) -> int:",
      "        if n < 0 or k < 0 or n < k:",
      "            return 0",
      "        mod = self._mod",
      "        return self.fac(n) * self.ifac(n - k) % mod",
      "    def H(self, n: int, k: int) -> int:",
      "        '''可重复选取元素的组合数'''",
      "        if n == 0:",
      "            return 1 if k == 0 else 0",
      "        return self.C(n + k - 1, k)",
      "    def put(self, n: int, k: int) -> int:",
      "        '''n个相同的球放入k个不同的盒子(盒子可放任意个球)的方案数.'''",
      "        return self.C(n + k - 1, n)",
      "    def catalan(self, n: int) -> int:",
      "        '''卡特兰数'''",
      "        return self.C(2 * n, n) * self.inv(n + 1) % self._mod",
      "    def _expand(self, size: int) -> None:",
      "        size = min(size, self._mod - 1)",
      "        if len(self._fac) < size + 1:",
      "            mod = self._mod",
      "            preSize = len(self._fac)",
      "            diff = size + 1 - preSize",
      "            self._fac += [1] * diff",
      "            self._ifac += [1] * diff",
      "            self._inv += [1] * diff",
      "            for i in range(preSize, size + 1):",
      "                self._fac[i] = self._fac[i - 1] * i % mod",
      "            self._ifac[size] = pow(self._fac[size], mod - 2, mod)  # !modInv",
      "            for i in range(size - 1, preSize - 1, -1):",
      "                self._ifac[i] = self._ifac[i + 1] * (i + 1) % mod",
      "            for i in range(preSize, size + 1):",
      "                self._inv[i] = self._ifac[i] * self._fac[i - 1] % mod"
    ],
    "description": "求组合数"
  },
  "golang求组合数": {
    "scope": "go,golang",
    "prefix": ["comb", "enumeration", "Enumeration"],
    "body": [
      "var E *Enumeration",
      "func init() {",
      "  const SIZE int = 1e6 + 10",
      "  const MOD int = 1e9 + 7",
      "  E = NewEnumeration(SIZE, MOD)",
      "}",
      "type Enumeration struct {",
      "  fac, ifac, inv []int",
      "  mod            int",
      "}",
      "// 模数为质数时的组合数计算.",
      "func NewEnumeration(initSize, mod int) *Enumeration {",
      "  res := &Enumeration{",
      "    fac:  make([]int, 1, initSize+1),",
      "    ifac: make([]int, 1, initSize+1),",
      "    inv:  make([]int, 1, initSize+1),",
      "    mod:  mod,",
      "  }",
      "  res.fac[0] = 1",
      "  res.ifac[0] = 1",
      "  res.inv[0] = 1",
      "  res.expand(initSize)",
      "  return res",
      "}",
      "// 阶乘.",
      "func (e *Enumeration) Fac(k int) int {",
      "  e.expand(k)",
      "  return e.fac[k]",
      "}",
      "// 阶乘逆元.",
      "func (e *Enumeration) Ifac(k int) int {",
      "  e.expand(k)",
      "  return e.ifac[k]",
      "}",
      "// 模逆元.",
      "func (e *Enumeration) Inv(k int) int {",
      "  e.expand(k)",
      "  return e.inv[k]",
      "}",
      "// 组合数.",
      "func (e *Enumeration) C(n, k int) int {",
      "  if n < 0 || k < 0 || n < k {",
      "    return 0",
      "  }",
      "  return e.Fac(n) * e.Ifac(k) % e.mod * e.Ifac(n-k) % e.mod",
      "}",
      "// 排列数.",
      "func (e *Enumeration) P(n, k int) int {",
      "  if n < 0 || k < 0 || n < k {",
      "    return 0",
      "  }",
      "  return e.Fac(n) * e.Ifac(n-k) % e.mod",
      "}",
      "// 可重复选取元素的组合数.",
      "func (e *Enumeration) H(n, k int) int {",
      "  if n == 0 {",
      "    if k == 0 {",
      "      return 1",
      "    }",
      "    return 0",
      "  }",
      "  return e.C(n+k-1, k)",
      "}",
      "// n个相同的球放入k个不同的盒子(盒子可放任意个球)的方案数.",
      "func (e *Enumeration) Put(n, k int) int {",
      "  return e.C(n+k-1, n)",
      "}",
      "// 卡特兰数.",
      "func (e *Enumeration) Catalan(n int) int {",
      "  return e.C(2*n, n) * e.Inv(n+1) % e.mod",
      "}",
      "func (e *Enumeration) expand(size int) {",
      "  if upper := e.mod - 1; size > upper {",
      "    size = upper",
      "  }",
      "  if len(e.fac) < size+1 {",
      "    mod := e.mod",
      "    preSize := len(e.fac)",
      "    diff := size + 1 - preSize",
      "    e.fac = append(e.fac, make([]int, diff)...)",
      "    e.ifac = append(e.ifac, make([]int, diff)...)",
      "    e.inv = append(e.inv, make([]int, diff)...)",
      "    for i := preSize; i < size+1; i++ {",
      "      e.fac[i] = e.fac[i-1] * i % mod",
      "    }",
      "    e.ifac[size] = Pow(e.fac[size], mod-2, mod)  // !modInv",
      "    for i := size - 1; i >= preSize; i-- {",
      "      e.ifac[i] = e.ifac[i+1] * (i+1) % mod",
      "    }",
      "    for i := preSize; i < size+1; i++ {",
      "      e.inv[i] = e.ifac[i] * e.fac[i-1] % mod",
      "    }",
      "  }",
      "}",
      "func Pow(base, exp, mod int) int {",
      "  base %= mod",
      "  res := 1",
      "  for ; exp > 0; exp >>= 1 {",
      "    if exp&1 == 1 {",
      "      res = res * base % mod",
      "    }",
      "    base = base * base % mod",
      "  }",
      "  return res"
    ],
    "description": "golang求组合数"
  },
  "groupby": {
    "scope": "python",
    "prefix": "groupby",
    "body": ["groups = [(char, len(list(group))) for char, group in groupby($0)]"],
    "description": "groupby分组"
  },
  "preSum": {
    "scope": "python",
    "prefix": "preSum",
    "body": ["preSum = [0] + list(accumulate($1nums))"],
    "description": "preSum前缀和"
  },
  "preSum记录前缀和个数": {
    "scope": "python",
    "prefix": "preSum",
    "body": [
      "if k == 0: # 注意有时需要特判和为0",
      "    ...",
      "preSum = defaultdict(int, {0: 1})  # 如果记录索引就是{0: -1}",
      "res, curSum = 0, 0",
      "for i, num in enumerate(nums):",
      "    curSum += num",
      "    if curSum - k in preSum:",
      "        res += preSum[curSum - k]",
      "    preSum[curSum] += 1",
      "return res"
    ],
    "description": "preSum记录前缀和个数,子数组不能为空,空需要特判"
  },
  "preMin": {
    "scope": "python",
    "prefix": "preMin",
    "body": [
      "preMin = [-INF] + $1nums[:]",
      "for i in range(1, len(preMin)):",
      "    if preMin[i] > preMin[i - 1]:",
      "        preMin[i] = preMin[i - 1]"
    ],
    "description": "前缀最小值"
  },
  "preMax": {
    "scope": "python",
    "prefix": "preMax",
    "body": [
      "preMax = [-INF] + $1nums[:]",
      "for i in range(1, len(preMax)):",
      "    if preMax[i] < preMax[i - 1]:",
      "        preMax[i] = preMax[i - 1]"
    ],
    "description": "前缀最大值"
  },
  "sufSum": {
    "scope": "python",
    "prefix": "sufSum",
    "body": ["sufSum = ([0] + list(accumulate($1nums[::-1])))[::-1]"],
    "description": "sufSum后缀和"
  },
  "sufMin": {
    "scope": "python",
    "prefix": "sufMin",
    "body": [
      "sufMin = $1nums[:] + [INF]",
      "for i in range(len(sufMin) - 2, -1, -1):",
      "    if sufMin[i] > sufMin[i + 1]:",
      "        sufMin[i] = sufMin[i + 1]"
    ],
    "description": "后缀最小值"
  },
  "sufMax": {
    "scope": "python",
    "prefix": "sufMax",
    "body": [
      "sufMax = $1nums[:] + [-INF]",
      "for i in range(len(sufMax) - 2, -1, -1):",
      "    if sufMax[i] < sufMax[i + 1]:",
      "        sufMax[i] = sufMax[i + 1]"
    ],
    "description": "后缀最大值"
  },
  "readline": {
    "scope": "python",
    "prefix": "stdin",
    "body": [
      "import sys",
      "",
      "sys.setrecursionlimit(int(1e6))",
      // AtCoderの入力データでは通常、末尾にも改行が入ります
      "input = lambda: sys.stdin.readline().rstrip('\\r\\n')",
      "MOD = 998244353",
      "INF = int(4e18)",
      "",
      "if __name__ == '__main__':",
      "    $1",
      ""
      // 不要把逻辑放在main函数中执行,这会在pypy3中变慢
      // "def main() -> None:",
      // "    $1",
      // "",
      // "",
      // "if __name__ == '__main__':",
      // "    if os.environ.get('USERNAME', ' ') == 'caomeinaixi':",
      // "        while True:",
      // "            main()",
      // "    else:",
      // "        main()"
    ],
    "description": "更快的读入"
  },
  "topoSort": {
    "scope": "python",
    "prefix": "topoSort",
    "body": [
      "from typing import List",
      "from collections import deque",
      "",

      "def hasCycle(n: int, adjList: List[List[int]], directed=True) -> bool:",
      "\t\t\"\"\"拓扑排序判环.\"\"\"",
      "\t\tif directed:",
      "\t\t\t\tdeg = [0] * n",
      "\t\t\t\tfor i in range(n):",
      "\t\t\t\t\t\tfor j in adjList[i]:",
      "\t\t\t\t\t\t\t\tdeg[j] += 1",
      "\t\telse:",
      "\t\t\t\tdeg = [len(adj) for adj in adjList]",
      "",
      "\t\tstartDeg = 0 if directed else 1",
      "\t\tqueue = deque([v for v in range(n) if deg[v] == startDeg])",
      "\t\tcount = 0",
      "\t\twhile queue:",
      "\t\t\t\tcur = queue.popleft()",
      "\t\t\t\tcount += 1",
      "\t\t\t\tfor next in adjList[cur]:",
      "\t\t\t\t\t\tdeg[next] -= 1",
      "\t\t\t\t\t\tif deg[next] == startDeg:",
      "\t\t\t\t\t\t\t\tqueue.append(next)",
      "\t\treturn count < n",
      "",
      "",
      "def topoSort(n: int, adjList: List[List[int]], directed=True) -> Tuple[List[int], bool]:",
      "\t\t\"\"\"求图的拓扑排序.\"\"\"",
      "\t\tif directed:",
      "\t\t\t\tdeg = [0] * n",
      "\t\t\t\tfor i in range(n):",
      "\t\t\t\t\t\tfor j in adjList[i]:",
      "\t\t\t\t\t\t\t\tdeg[j] += 1",
      "\t\telse:",
      "\t\t\t\tdeg = [len(adj) for adj in adjList]",
      "",
      "\t\tstartDeg = 0 if directed else 1",
      "\t\tqueue = deque([v for v in range(n) if deg[v] == startDeg])",
      "\t\tres = []",
      "\t\twhile queue:",
      "\t\t\t\tcur = queue.popleft()",
      "\t\t\t\tres.append(cur)",
      "\t\t\t\tfor next in adjList[cur]:",
      "\t\t\t\t\t\tdeg[next] -= 1",
      "\t\t\t\t\t\tif deg[next] == startDeg:",
      "\t\t\t\t\t\t\t\tqueue.append(next)",
      "",
      "\t\tif len(res) != n:",
      "\t\t\t\treturn [], False",
      "\t\treturn res, True"
    ],
    "description": "拓扑排序"
  },

  "dfs序": {
    "scope": "python",
    "prefix": "dfs序",
    "body": [
      "def dfs(cur: int, pre: int) -> None:",
      "    nonlocal dfsId",
      "    ins[cur] = dfsId",
      "    for next in adjList[cur]:",
      "        if next != pre:",
      "            depth[next] = depth[cur] + 1",
      "            dfs(next, cur)",
      "    outs[cur] = dfsId",
      "    dfsId += 1",
      "",
      "ins, outs, dfsId = [0] * (n + 10), [0] * (n + 10), 1",
      "depth = [0] * (n + 10)",
      "dfs(0, -1)",
      "",
      "newNums = [0] * n",
      "for i in range(n):",
      "    id = outs[i] - 1",
      "    newNums[id] = nums[i]",
      "for i in range(len(queries)):",
      "    queryRoot = queries[i]",
      "    left = ins[queryRoot]",
      "    right = outs[queryRoot]"
    ],
    "description": "dfs序"
  },
  "dfs序-new": {
    "scope": "python",
    "prefix": ["dfs序-new", "dfsOrder"],
    "body": [
      "lid, rid = [0] * n, [0] * n",
      "dfn = 0",
      "",
      "",
      "def dfs(cur: int, pre: int) -> None:",
      "\t\tnonlocal dfn",
      "\t\tlid[cur] = dfn",
      "\t\tdfn += 1",
      "\t\tfor next_ in tree[cur]:",
      "\t\t\t\tif next_ != pre:",
      "\t\t\t\t\t\tdfs(next_, cur)",
      "\t\trid[cur] = dfn",
      "",
      "",
      "dfs(0, -1)",
      "# data[lid[i]] = values[i]"
    ],
    "description": "dfs序-new"
  },
  "golangdfs序": {
    "scope": "go,golang",
    "prefix": "dfs序",
    "body": [
      "ins, outs, dfsId := make([]int, n+5), make([]int, n+5), 1",
      "depth := make([]int, n+5)",
      "var dfsOrder func(cur, pre int)",
      "dfsOrder = func(cur, pre int) {",
      "  ins[cur] = dfsId",
      "  for _, next := range adjList[cur] {",
      "    if next != pre {",
      "      depth[next] = depth[cur] + 1",
      "      dfsOrder(next, cur)",
      "    }",
      "  }",
      "  outs[cur] = dfsId",
      "  dfsId += 1",
      "}",
      "dfsOrder(0, -1)",
      "newNums := make([]int, n)",
      "for i := 0; i < n; i++ {",
      "  id := outs[i] - 1",
      "  newNums[id] = nums[i]",
      "}"
    ],
    "description": "golang dfs序"
  },
  "golang-dfs序-new": {
    "scope": "go,golang",
    "prefix": "dfs序-new",
    "body": [
      "\tlid, rid := make([]int, n), make([]int, n)",
      "\tdfn := 0",
      "\tvar dfs func(cur, pre int)",
      "\tdfs = func(cur, pre int) {",
      "\t\tlid[cur] = dfn",
      "\t\tdfn++",
      "\t\tfor _, next := range tree[cur] {",
      "\t\t\tif next != pre {",
      "\t\t\t\tdfs(next, cur)",
      "\t\t\t}",
      "\t\t}",
      "\t\trid[cur] = dfn",
      "\t}",
      "\tdfs(0, -1)",
      "\t// data[lid[i]] = values[i]"
    ],
    "description": "golang-dfs序-new"
  },
  "预处理每个点上下左右连续1的长度": {
    "scope": "python",
    "prefix": "updownleftright",
    "body": [
      "up = [[0] * COL for _ in range(ROW)]",
      "down = [[0] * COL for _ in range(ROW)]",
      "left = [[0] * COL for _ in range(ROW)]",
      "right = [[0] * COL for _ in range(ROW)]",
      "for r in range(ROW):",
      "    for c in range(COL):",
      "        if (r, c) not in bad:",
      "            up[r][c] = up[r - 1][c] + 1 if r else 1",
      "            left[r][c] = left[r][c - 1] + 1 if c else 1",
      "        if (ROW - 1 - r, COL - 1 - c) not in bad:",
      "            down[ROW - 1 - r][COL - 1 - c] = down[ROW - r][COL - 1 - c] + 1 if r else 1",
      "            right[ROW - 1 - r][COL - 1 - c] = right[ROW - 1 - r][COL - c] + 1 if c else 1"
    ],
    "description": "预处理每个点上下左右连续1的长度"
  },
  "treeDp": {
    "scope": "python",
    "prefix": "treeDp",
    "body": [
      "def dfs(cur: int, pre: int) -> int:",
      "    subCount = 1",
      "    for next in adjList[cur]:",
      "        if next == pre:",
      "            continue",
      "        subCount += dfs(next, cur)",
      "        # 处理当前子树的值",
      "    # 回溯，向上返回所有子树的结果",
      "    return subCount",
      "",
      "adjList = [[] for _ in range(n)]",
      "for u, v in edges:",
      "    adjList[u].append(v)",
      "    adjList[v].append(u)",
      "",
      "dfs(0, -1)"
    ],
    "description": "treeDp"
  },
  "treeDfs": {
    "scope": "python",
    "prefix": "treeDfs",
    "body": [
      "\t\t\t\t@lru_cache(None)",
      "\t\t\t\tdef dfs(cur: int, pre: int, ok: bool) -> int:",
      "\t\t\t\t\t\tif len(adjList[cur]) == 1 and pre != -1:\t# 叶子节点",
      "\t\t\t\t\t\t\t\treturn 0",
      "",
      "\t\t\t\t\t\tnexts = [next_ for next_ in adjList[cur] if next_ != pre]",
      "\t\t\t\t\t\tif ok:",
      "\t\t\t\t\t\t\t\t...",
      "",
      "\t\t\t\t\t\tres1 = 0",
      "\t\t\t\t\t\tres2 = 0",
      "\t\t\t\t\t\treturn max(res1, res2)",
      "",
      "\t\t\t\tn = len(values)",
      "\t\t\t\tadjList = [[] for _ in range(n)]",
      "\t\t\t\tfor u, v in edges:",
      "\t\t\t\t\t\tadjList[u].append(v)",
      "\t\t\t\t\t\tadjList[v].append(u)",
      "",
      "\t\t\t\tres = dfs(0, -1, False)",
      "\t\t\t\tdfs.cache_clear()",
      "\t\t\t\treturn res"
    ],
    "description": "treeDfs"
  },
  "Graph Type": {
    "scope": "python",
    "prefix": "Graph",
    "body": [
      "from typing import Iterable, Mapping, Sequence, TypeVar, Union",
      "",
      "T = TypeVar('T')",
      "AdjList = Sequence[Iterable[T]]",
      "AdjMap = Mapping[T, Iterable[T]]",
      "Graph = Union[AdjList[T], AdjMap[T]]"
    ],
    "description": "Graph Type"
  },
  "Weighted Graph Type": {
    "scope": "python",
    "prefix": "Graph Weighted",
    "body": [
      "from typing import Iterable, List, Mapping, Sequence, Tuple, TypeVar, Union",
      "",
      "T = TypeVar('T')",
      "ListWG = Sequence[Iterable[Tuple[T, int]]]",
      "DictWG = Mapping[T, Iterable[Tuple[T, int]]]",
      "WG = Union[ListWG[T], DictWG[T]]"
    ],
    "description": "Weighted Graph Type"
  },
  "邻接表adjList": {
    "scope": "python",
    "prefix": "adjList",
    "body": ["adjList = [[] for _ in range(n)]"],
    "description": "邻接表adjList"
  },
  "邻接表adjList-ts": {
    "scope": "typescript",
    "prefix": "adjList",
    "body": ["const adjList: number[][] = Array(n)", "for (let i = 0; i < n; i++) adjList[i] = []"],
    "description": "邻接表adjList"
  },
  "邻接表adjMap": {
    "scope": "python",
    "prefix": "adjMap",
    "body": ["adjMap = defaultdict(lambda: defaultdict(lambda: INF))"],
    "description": "邻接表adjMap"
  },
  "定长滑窗": {
    "scope": "python",
    "prefix": "window1",
    "body": [
      "n = len(nums)",
      "res, curSum = INF, 0",
      "for right in range(n):",
      "    curSum += nums[right]",
      "    if right >= k:",
      "        curSum -= nums[right - k]",
      "    if right >= k - 1:",
      "        res = min(res, curSum)",
      "return res"
    ],
    "description": "定长滑窗"
  },
  "定长滑窗-ts": {
    "scope": "typescript",
    "prefix": "window1",
    "body": [
      "let res = INF",
      "let curSum = 0",
      "for (let right = 0; right < n; right++) {",
      "    curSum += nums[right]",
      "    if (right >= k) {",
      "        curSum -= nums[right - k]",
      "    }",
      "    if (right >= k - 1) {",
      "        res = Math.min(res, curSum)",
      "    }",
      "}",
      "return res"
    ],
    "description": "定长滑窗"
  },
  "定长滑窗-go": {
    "scope": "go",
    "prefix": "window1",
    "body": [
      "\tn := len(nums)",
      "\tres, curSum := INF, 0",
      "\tfor right := 0; right < n; right++ {",
      "\t\tcurSum += nums[right]",
      "\t\tif right >= k {",
      "\t\t\tcurSum -= nums[right-k]",
      "\t\t}",
      "\t\tif right >= k-1 {",
      "\t\t\tres = min(res, curSum)",
      "\t\t}",
      "\t}"
    ],
    "description": "定长滑窗"
  },
  "不定长滑窗": {
    "scope": "python",
    "prefix": "window2",
    "body": [
      "res, left, n = 0, 0, len(nums)",
      "curSum = 0",
      "for right in range(n):",
      "    curSum += nums[right]",
      "    while left <= right and $1:",
      "        curSum -= nums[left]",
      "        left += 1",
      "    res = max(res, right - left + 1)",
      "return res"
    ],
    "description": "不定长滑窗"
  },
  "不定长滑窗-ts": {
    "scope": "typescript",
    "prefix": "window2",
    "body": [
      "let res = 0",
      "let left = 0",
      "let curSum = 0",
      "for (let right = 0; right < n; right++) {",
      "    curSum += arr[right]",
      "    while (left <= right && curSum > target) {",
      "        curSum -= arr[left]",
      "        left++",
      "    }",
      "    res += right - left + 1",
      "}",
      "return res"
    ],
    "description": "不定长滑窗"
  },
  "不定长滑窗-go": {
    "scope": "go",
    "prefix": "window2",
    "body": [
      "\tres, left, n := 0, 0, len(nums)",
      "\tcurSum := 0",
      "\tfor right := 0; right < n; right++ {",
      "\t\tcurSum += nums[right]",
      "\t\tfor left <= right && $1 {",
      "\t\t\tcurSum -= nums[left]",
      "\t\t\tleft++",
      "\t\t}",
      "\t\tres = max(res, right-left+1)",
      "\t}"
    ],
    "description": "不定长滑窗"
  },
  "前后缀滑窗": {
    "scope": "python",
    "prefix": "window3",
    "body": [
      "first = [INF] * (n + 1)  # 每个前缀长度对应的右边界",
      "right = 0",
      "for left, v in enumerate(pre):",
      "    while right < len(suf) and suf[right]$1:",
      "        right += 1",
      "    if right < len(suf) and suf[right]$2:",
      "        first[left] = right",
      "for left in range(len(first)):",
      "           ...                 "
    ],
    "description": [
      "前后缀滑窗",
      "枚举前缀长度left,求出第一个满足条件的后缀位置right(pre长度为n+1)",
      "不存在时为INF"
    ]
  },
  "dijkstra求最短路Map": {
    "scope": "python",
    "prefix": "dijkstraMap",
    "body": [
      "from typing import List, Mapping",
      "from collections import defaultdict",
      "from heapq import heappop, heappush",
      "",
      "def dijkstra(n: int, adjMap: Mapping[int, Mapping[int, int]], start: int) -> List[int]:",
      "    dist = [INF] * n",
      "    dist[start] = 0",
      "    pq = [(0, start)]",
      "",
      "    while pq:",
      "        curDist, cur = heappop(pq)",
      "        if dist[cur] < curDist:",
      "            continue",
      "        for next in adjMap[cur]:",
      "            cand = dist[cur] + adjMap[cur][next]",
      "            if cand < dist[next]:",
      "                dist[next] = cand",
      "                heappush(pq, (dist[next], next))",
      "    return dist",
      "adjMap = defaultdict(lambda: defaultdict(lambda: INF))",
      "for u, v, w in edges:",
      "    adjMap[u][v] = min(adjMap[u][v], w)",
      "    adjMap[v][u] = min(adjMap[v][u], w)",
      "",
      ""
    ],
    "description": "dijkstra求最短路"
  },
  "dijkstra求最短路List": {
    "scope": "python",
    "prefix": "dijkstraList",
    "body": [
      //   from typing import List, Sequence, Tuple
      // from heapq import heappop, heappush
      // def dijkstra(n: int, adjList: Sequence[Sequence[Tuple[int, int]]], start: int) -> List[int]:
      //     dist = [INF] * n
      //     dist[start] = 0
      //     pq = [(0, start)]
      //     while pq:
      //         curDist, cur = heappop(pq)
      //         if dist[cur] < curDist:
      //             continue
      //         for next, weight in adjList[cur]:
      //             cand = dist[cur] + weight
      //             if cand < dist[next]:
      //                 dist[next] = cand
      //                 heappush(pq, (dist[next], next))
      //     return dist
      "from typing import List, Sequence, Tuple",
      "from heapq import heappop, heappush",
      "",
      "def dijkstra(n: int, adjList: Sequence[Sequence[Tuple[int, int]]], start: int) -> List[int]:",
      "    dist = [INF] * n",
      "    dist[start] = 0",
      "    pq = [(0, start)]",
      "",
      "    while pq:",
      "        curDist, cur = heappop(pq)",
      "        if dist[cur] < curDist:",
      "            continue",
      "        for next, weight in adjList[cur]:",
      "            cand = dist[cur] + weight",
      "            if cand < dist[next]:",
      "                dist[next] = cand",
      "                heappush(pq, (dist[next], next))",
      "    return dist",
      "",
      "adjList = [[] for _ in range(n)]",
      "for u, v, w in edges:",
      "    adjList[u].append((v, w))",
      "    adjList[v].append((u, w))",
      ""
    ],
    "description": "dijkstra求最短路"
  },
  "bfs求最短路": {
    "scope": "python",
    "prefix": "bfs",
    "body": [
      "from collections import deque",
      "",
      "",
      "def bfs(start: int, adjList: List[List[int]]) -> List[int]:",
      "    n = len(adjList)",
      "    dist = [INF] * n",
      "    dist[start] = 0",
      "    queue = deque([start])",
      "    while queue:",
      "        cur = queue.popleft()",
      "        for next in adjList[cur]:",
      "            cand = dist[cur] + 1",
      "            if cand < dist[next]:",
      "                dist[next] = cand",
      "                queue.append(next)",
      "    return dist"
    ],
    "description": "bfs求最短路"
  },
  "bfs求某层的结点": {
    "scope": "python",
    "prefix": "bfsDepth",
    "body": [
      "from collections import deque",
      "from typing import List",
      "",
      "def bfsDepth(adjList: List[List[int]], start: int, dist: int) -> List[int]:",
      "    '''返回距离start为dist的结点'''",
      "    if dist < 0:",
      "        return []",
      "    if dist == 0:",
      "        return [start]",
      "    queue = deque([start])",
      "    visited = set([start])",
      "    todo = dist",
      "    while queue and todo > 0:",
      "        len_ = len(queue)",
      "        for _ in range(len_):",
      "            cur = queue.popleft()",
      "            for next in adjList[cur]:",
      "                if next not in visited:",
      "                    visited.add(next)",
      "                    queue.append(next)",
      "        todo -= 1",
      "    return list(queue)"
    ],
    "description": "bfs求某层的结点"
  },

  "并查集数组": {
    "scope": "python",
    "prefix": ["UnionFindArray", "并查集数组"],
    "body": [
      "class UnionFindArray:",
      "\t\t\"\"\"元素是0-n-1的并查集写法,不支持动态添加",
      "",
      "\t\t初始化的连通分量个数 为 n",
      "\t\t\"\"\"",
      "",
      "\t\t__slots__ = (\"n\", \"part\", \"_parent\", \"_rank\")",
      "",
      "\t\tdef __init__(self, n: int):",
      "\t\t\t\tself.n = n",
      "\t\t\t\tself.part = n",
      "\t\t\t\tself._parent = list(range(n))",
      "\t\t\t\tself._rank = [1] * n",
      "",
      "\t\tdef find(self, x: int) -> int:",
      "\t\t\t\twhile self._parent[x] != x:",
      "\t\t\t\t\t\tself._parent[x] = self._parent[self._parent[x]]",
      "\t\t\t\t\t\tx = self._parent[x]",
      "\t\t\t\treturn x",
      "",
      "\t\tdef union(self, x: int, y: int) -> bool:",
      "\t\t\t\t\"\"\"按秩合并.\"\"\"",
      "\t\t\t\trootX = self.find(x)",
      "\t\t\t\trootY = self.find(y)",
      "\t\t\t\tif rootX == rootY:",
      "\t\t\t\t\t\treturn False",
      "\t\t\t\tif self._rank[rootX] > self._rank[rootY]:",
      "\t\t\t\t\t\trootX, rootY = rootY, rootX",
      "\t\t\t\tself._parent[rootX] = rootY",
      "\t\t\t\tself._rank[rootY] += self._rank[rootX]",
      "\t\t\t\tself.part -= 1",
      "\t\t\t\treturn True",
      "",
      "\t\tdef unionTo(self, child: int, parent: int) -> bool:",
      "\t\t\t\t\"\"\"定向合并.将child的父节点设置为parent.\"\"\"",
      "\t\t\t\trootX = self.find(child)",
      "\t\t\t\trootY = self.find(parent)",
      "\t\t\t\tif rootX == rootY:",
      "\t\t\t\t\t\treturn False",
      "\t\t\t\tself._parent[rootX] = rootY",
      "\t\t\t\tself._rank[rootY] += self._rank[rootX]",
      "\t\t\t\tself.part -= 1",
      "\t\t\t\treturn True",
      "",
      "\t\tdef unionWithCallback(self, x: int, y: int, f: Callable[[int, int], None]) -> bool:",
      "\t\t\t\t\"\"\"",
      "\t\t\t\tf: 合并后的回调函数, 入参为 (big, small)",
      "\t\t\t\t\"\"\"",
      "\t\t\t\trootX = self.find(x)",
      "\t\t\t\trootY = self.find(y)",
      "\t\t\t\tif rootX == rootY:",
      "\t\t\t\t\t\treturn False",
      "\t\t\t\tif self._rank[rootX] > self._rank[rootY]:",
      "\t\t\t\t\t\trootX, rootY = rootY, rootX",
      "\t\t\t\tself._parent[rootX] = rootY",
      "\t\t\t\tself._rank[rootY] += self._rank[rootX]",
      "\t\t\t\tself.part -= 1",
      "\t\t\t\tf(rootY, rootX)",
      "\t\t\t\treturn True",
      "",
      "\t\tdef isConnected(self, x: int, y: int) -> bool:",
      "\t\t\t\treturn self.find(x) == self.find(y)",
      "",
      "\t\tdef getGroups(self) -> DefaultDict[int, List[int]]:",
      "\t\t\t\tgroups = defaultdict(list)",
      "\t\t\t\tfor key in range(self.n):",
      "\t\t\t\t\t\troot = self.find(key)",
      "\t\t\t\t\t\tgroups[root].append(key)",
      "\t\t\t\treturn groups",
      "",
      "\t\tdef getRoots(self) -> List[int]:",
      "\t\t\t\treturn list(set(self.find(key) for key in self._parent))",
      "",
      "\t\tdef getSize(self, x: int) -> int:",
      "\t\t\t\treturn self._rank[self.find(x)]",
      "",
      "\t\tdef __repr__(self) -> str:",
      "\t\t\t\treturn \"\\n\".join(f\"{root}: {member}\" for root, member in self.getGroups().items())",
      "",
      "\t\tdef __len__(self) -> int:",
      "\t\t\t\treturn self.part",
      ""
    ],
    "description": "并查集数组"
  },
  "通用的并查集": {
    "scope": "python",
    "prefix": ["UnionFindMap", "并查集"],
    "body": [
      "from collections import defaultdict",
      "from typing import DefaultDict, Generic, Hashable, Iterable, List, Optional, TypeVar",
      "",
      "",
      "T = TypeVar('T', bound=Hashable)",
      "",
      "",
      "class UnionFindMap(Generic[T]):",
      "    '''当元素不是数组index时(例如字符串),更加通用的并查集写法,支持动态添加'''",
      "",
      "    __slots__ = ('part', '_parent', '_rank')",
      "",
      "    def __init__(self, iterable: Optional[Iterable[T]] = None):",
      "        self.part = 0",
      "        self._parent = dict()",
      "        self._rank = dict()",
      "        for item in iterable or []:",
      "            self.add(item)",
      "",
      "    def union(self, key1: T, key2: T) -> bool:",
      "        '''rank一样时 默认key2作为key1的父节点'''",
      "        root1 = self.find(key1)",
      "        root2 = self.find(key2)",
      "        if root1 == root2:",
      "            return False",
      "        if self._rank[root1] > self._rank[root2]:",
      "            root1, root2 = root2, root1",
      "        self._parent[root1] = root2",
      "        self._rank[root2] += self._rank[root1]",
      "        self.part -= 1",
      "        return True",
      "",
      "    def find(self, key: T) -> T:",
      "        if key not in self._parent:",
      "            self.add(key)",
      "            return key",
      "",
      "        while self._parent.get(key, key) != key:",
      "            self._parent[key] = self._parent[self._parent[key]]",
      "            key = self._parent[key]",
      "        return key",
      "",
      "    def isConnected(self, key1: T, key2: T) -> bool:",
      "        return self.find(key1) == self.find(key2)",
      "",
      "    def getRoots(self) -> List[T]:",
      "        return list(set(self.find(key) for key in self._parent))",
      "",
      "    def getGroups(self) -> DefaultDict[T, List[T]]:",
      "        groups = defaultdict(list)",
      "        for key in self._parent:",
      "            root = self.find(key)",
      "            groups[root].append(key)",
      "        return groups",
      "",
      "    def add(self, key: T) -> bool:",
      "        if key in self._parent:",
      "            return False",
      "        self._parent[key] = key",
      "        self._rank[key] = 1",
      "        self.part += 1",
      "        return True",
      "",
      "    def __repr__(self) -> str:",
      "        return '\\n'.join(f'{root}: {member}' for root, member in self.getGroups().items())",
      "",
      "    def __len__(self) -> int:",
      "        return self.part",
      "",
      "    def __contains__(self, key: T) -> bool:",
      "        return key in self._parent",
      "",
      "",
      "class UnionFindArray:",
      "    '''元素是0-n-1的并查集写法,不支持动态添加",
      "",
      "    初始化的连通分量个数 为 n",
      "    '''",
      "",
      "    __slots__ = ('n', 'part', '_parent', '_rank')",
      "",
      "    def __init__(self, n: int):",
      "        self.n = n",
      "        self.part = n",
      "        self._parent = list(range(n))",
      "        self._rank = [1] * n",
      "",
      "    def find(self, x: int) -> int:",
      "        while self._parent[x] != x:",
      "            self._parent[x] = self._parent[self._parent[x]]",
      "            x = self._parent[x]",
      "        return x",
      "",
      "    def union(self, x: int, y: int) -> bool:",
      "        '''rank一样时 默认key2作为key1的父节点'''",
      "        rootX = self.find(x)",
      "        rootY = self.find(y)",
      "        if rootX == rootY:",
      "            return False",
      "        if self._rank[rootX] > self._rank[rootY]:",
      "            rootX, rootY = rootY, rootX",
      "        self._parent[rootX] = rootY",
      "        self._rank[rootY] += self._rank[rootX]",
      "        self.part -= 1",
      "        return True",
      "",
      "    def isConnected(self, x: int, y: int) -> bool:",
      "        return self.find(x) == self.find(y)",
      "",
      "    def getGroups(self) -> DefaultDict[int, List[int]]:",
      "        groups = defaultdict(list)",
      "        for key in range(self.n):",
      "            root = self.find(key)",
      "            groups[root].append(key)",
      "        return groups",
      "",
      "    def getRoots(self) -> List[int]:",
      "        return list(set(self.find(key) for key in self._parent))",
      "",
      "    def __repr__(self) -> str:",
      "        return '\\n'.join(f'{root}: {member}' for root, member in self.getGroups().items())",
      "",
      "    def __len__(self) -> int:",
      "        return self.part",
      "",
      "",
      "class UnionFindMap2(Generic[T]):",
      "    '''不自动合并 需要手动add添加元素'''",
      "",
      "    __slots__ = ('part', '_parent', '_rank')",
      "",
      "    def __init__(self, iterable: Optional[Iterable[T]] = None):",
      "        self.part = 0",
      "        self._parent = dict()",
      "        self._rank = defaultdict(lambda: 1)",
      "        for item in iterable or []:",
      "            self.add(item)",
      "",
      "    def add(self, key: T) -> 'UnionFindMap2[T]':",
      "        if key in self._parent:",
      "            return self",
      "        self._parent[key] = key",
      "        self._rank[key] = 1",
      "        self.part += 1",
      "        return self",
      "",
      "    def union(self, key1: T, key2: T) -> bool:",
      "        '''rank一样时 默认key2作为key1的父节点'''",
      "        root1 = self.find(key1)",
      "        root2 = self.find(key2)",
      "        if root1 == root2 or root1 not in self._parent or root2 not in self._parent:",
      "            return False",
      "        if self._rank[root1] > self._rank[root2]:",
      "            root1, root2 = root2, root1",
      "        self._parent[root1] = root2",
      "        self._rank[root2] += self._rank[root1]",
      "        self.part -= 1",
      "        return True",
      "",
      "    def find(self, key: T) -> T:",
      "        '''此处不自动add'''",
      "        if key not in self._parent:",
      "            return key",
      "",
      "        if key != self._parent[key]:",
      "            root = self.find(self._parent[key])",
      "            self._parent[key] = root",
      "        return self._parent[key]",
      "",
      "    def isConnected(self, key1: T, key2: T) -> bool:",
      "        if key1 not in self._parent or key2 not in self._parent:",
      "            return False",
      "        return self.find(key1) == self.find(key2)",
      "",
      "    def getRoots(self) -> List[T]:",
      "        return list(set(self.find(key) for key in self._parent))",
      "",
      "    def getGroups(self) -> DefaultDict[T, List[T]]:",
      "        groups = defaultdict(list)",
      "        for key in self._parent:",
      "            root = self.find(key)",
      "            groups[root].append(key)",
      "        return groups",
      "",
      "    def __repr__(self) -> str:",
      "        return '\\n'.join(f'{root}: {member}' for root, member in self.getGroups().items())",
      "",
      "    def __len__(self) -> int:",
      "        return self.part",
      "",
      "    def __contains__(self, key: T) -> bool:",
      "        return key in self._parent",
      "",
      "",
      "class UnionFindGraph:",
      "    '''并查集维护无向图每个连通块的边数和顶点数'''",
      "",
      "    __slots__ = ('n', 'part', '_parent', 'vertex', 'edge')",
      "",
      "    def __init__(self, n: int):",
      "        self.n = n",
      "        self.part = n",
      "        self._parent = list(range(n))",
      "        self.vertex = [1] * n  # 每个联通块的顶点数",
      "        self.edge = [0] * n  # 每个联通块的边数",
      "",
      "    def find(self, x: int) -> int:",
      "        while x != self._parent[x]:",
      "            self._parent[x] = self._parent[self._parent[x]]",
      "            x = self._parent[x]",
      "        return x",
      "",
      "    def union(self, x: int, y: int) -> bool:",
      "        rootX = self.find(x)",
      "        rootY = self.find(y)",
      "        if rootX == rootY:",
      "            self.edge[rootX] += 1  # 两个顶点已经在同一个连通块了,这个连通块的边数+1",
      "            return False",
      "        if self.vertex[rootX] > self.vertex[rootY]:",
      "            rootX, rootY = rootY, rootX",
      "        self._parent[rootX] = rootY",
      "        self.vertex[rootY] += self.vertex[rootX]",
      "        self.edge[rootY] += self.edge[rootX] + 1",
      "        self.part -= 1",
      "        return True",
      "",
      "    def isConnected(self, x: int, y: int) -> bool:",
      "        return self.find(x) == self.find(y)",
      "",
      "    def getGroups(self) -> DefaultDict[int, List[int]]:",
      "        groups = defaultdict(list)",
      "        for key in range(self.n):",
      "            root = self.find(key)",
      "            groups[root].append(key)",
      "        return groups",
      "",
      "    def getRoots(self) -> List[int]:",
      "        return list(set(self.find(i) for i in range(self.n)))",
      "",
      "    def __repr__(self) -> str:",
      "        return '\\n'.join(f'{root}: {member}' for root, member in self.getGroups().items())",
      "",
      "    def __len__(self) -> int:",
      "        return self.part"
    ],
    "description": "通用的并查集"
  },
  "SortedList计数": {
    "scope": "python",
    "prefix": ["BITSortedList", "SortedList计数"],
    "body": [
      "from sortedcontainers import SortedList",
      "",
      "def queryRange(left: int, right: int) -> int:",
      "    '''求[left, right]闭区间内的元素个数'''",
      "    if left > right:",
      "        return 0",
      "    return sl.bisect_right(right) - sl.bisect_left(left)",
      "",
      "def query(right: int) -> int:",
      "    '''求(-∞,right]区间内的元素个数'''",
      "    return sl.bisect_right(right)",
      "",
      "sl = SortedList()"
    ],
    "description": "SortedList区间计数"
  },
  "python的BITArray": {
    "scope": "python",
    "prefix": "BITArray",
    "body": [
      "from typing import List, Sequence, Union",
      "",
      "class BITArray:",
      "    '''Point Add Range Sum, 0-indexed.'''",
      "",
      "    @staticmethod",
      "    def _build(sequence: Sequence[int]) -> List[int]:",
      "        tree = [0] * (len(sequence) + 1)",
      "        for i in range(1, len(tree)):",
      "            tree[i] += sequence[i - 1]",
      "            parent = i + (i & -i)",
      "            if parent < len(tree):",
      "                tree[parent] += tree[i]",
      "        return tree",
      "",
      "    __slots__ = ('_n', '_tree')",
      "",
      "    def __init__(self, lenOrSequence: Union[int, Sequence[int]]):",
      "        if isinstance(lenOrSequence, int):",
      "            self._n = lenOrSequence",
      "            self._tree = [0] * (lenOrSequence + 1)",
      "        else:",
      "            self._n = len(lenOrSequence)",
      "            self._tree = self._build(lenOrSequence)",
      "",
      "    def add(self, index: int, delta: int) -> None:",
      "        index += 1",
      "        while index <= self._n:",
      "            self._tree[index] += delta",
      "            index += index & -index",
      "",
      "    def query(self, right: int) -> int:",
      "        '''Query sum of [0, right).'''",
      "        if right > self._n:",
      "            right = self._n",
      "        res = 0",
      "        while right > 0:",
      "            res += self._tree[right]",
      "            right -= right & -right",
      "        return res",
      "",
      "    def queryRange(self, left: int, right: int) -> int:",
      "        '''Query sum of [left, right).'''",
      "        return self.query(right) - self.query(left)",
      "",
      "    def __len__(self) -> int:",
      "        return self._n",
      "",
      "    def __repr__(self) -> str:",
      "        nums = []",
      "        for i in range(1, self._n + 1):",
      "            nums.append(self.queryRange(i, i + 1))",
      "        return f'BITArray({nums})'"
    ],
    "description": "python的BITArray"
  },

  "ts的BITArray": {
    "scope": "typescript,typescriptreact",
    "prefix": "BITArray",
    "body": [
      "/**",
      " * Point add range sum, 0-indexed.",
      " */",
      "class BITArray {",
      "\t/**",
      "\t * Build a tree from an array-like object using dp.",
      "\t * O(n) time.",
      "\t */",
      "\tprivate static _buildTree(arr: ArrayLike<number>): Float64Array {",
      "\t\tconst tree = new Float64Array(arr.length + 1)",
      "\t\tfor (let i = 1; i < tree.length; i++) {",
      "\t\t\ttree[i] += arr[i - 1]",
      "\t\t\tconst parent = i + (i & -i)",
      "\t\t\tif (parent < tree.length) tree[parent] += tree[i]",
      "\t\t}",
      "\t\treturn tree",
      "\t}",
      "",
      "\treadonly length: number",
      "\tprivate readonly _tree: Float64Array",
      "",
      "\t/**",
      "\t * 指定长度或者从类数组建立树状数组.",
      "\t *",
      "\t * @warning",
      "\t * !如果需要使用`值域树状数组`，需要在构造函数中传入`长度n(值域1-n)`而不是类数组.",
      "\t */",
      "\tconstructor(lengthOrArrayLike: number | ArrayLike<number>) {",
      "\t\tif (typeof lengthOrArrayLike === 'number') {",
      "\t\t\tthis.length = lengthOrArrayLike",
      "\t\t\tthis._tree = new Float64Array(lengthOrArrayLike + 1)",
      "\t\t} else {",
      "\t\t\tthis.length = lengthOrArrayLike.length",
      "\t\t\tthis._tree = BITArray._buildTree(lengthOrArrayLike)",
      "\t\t}",
      "\t}",
      "",
      "\t/**",
      "\t * Add delta to the element at index.",
      "\t * @param index 0 <= index < {@link length}",
      "\t */",
      "\tadd(index: number, delta: number): void {",
      "\t\tindex++",
      "\t\tfor (let i = index; i <= this.length; i += i & -i) {",
      "\t\t\tthis._tree[i] += delta",
      "\t\t}",
      "\t}",
      "",
      "\t/**",
      "\t * Query the sum of [0, end).",
      "\t */",
      "\tquery(end: number): number {",
      "\t\tif (end > this.length) end = this.length",
      "\t\tlet res = 0",
      "\t\tfor (let i = end; i > 0; i &= i - 1) {",
      "\t\t\tres += this._tree[i]",
      "\t\t}",
      "\t\treturn res",
      "\t}",
      "",
      "\t/**",
      "\t * Query the sum of [start, end).",
      "\t */",
      "\tqueryRange(start: number, end: number): number {",
      "\t\treturn this.query(end) - this.query(start)",
      "\t}",
      "",
      "\ttoString(): string {",
      "\t\tconst sb: string[] = []",
      "\t\tsb.push('BITArray: [')",
      "\t\tfor (let i = 1; i < this._tree.length; i++) {",
      "\t\t\tsb.push(String(this.queryRange(i, i + 1)))",
      "\t\t\tif (i < this._tree.length - 1) sb.push(', ')",
      "\t\t}",
      "\t\tsb.push(']')",
      "\t\treturn sb.join('')",
      "\t}",
      "}"
    ],
    "description": "ts的BITArray"
  },
  "树状数组单点修改区间查询": {
    "scope": "python",
    "prefix": "BIT1",
    "body": [
      "class BIT1:",
      "    '''单点修改'''",
      "",
      "    __slots__ = 'size', 'bit', 'tree'",
      "",
      "    def __init__(self, n: int):",
      "        self.size = n + 5",
      "        self.bit = n.bit_length()",
      "        self.tree = dict()",
      "",
      "    def add(self, index: int, delta: int) -> None:",
      "        index += 1",
      "        while index <= self.size:",
      "            self.tree[index] = self.tree.get(index, 0) + delta",
      "            index += index & -index",
      "",
      "    def query(self, right: int) -> int:",
      "        '''Query sum of [0, right).'''",
      "        if right > self.size:",
      "            right = self.size",
      "        res = 0",
      "        while right > 0:",
      "            res += self.tree.get(right, 0)",
      "            right -= right & -right",
      "        return res",
      "",
      "    def queryRange(self, left: int, right: int) -> int:",
      "        '''Query sum of [left, right).'''",
      "        return self.query(right) - self.query(left)",
      "",
      "    def bisectLeft(self, k: int) -> int:",
      "        '''返回第一个前缀和大于等于k的位置pos",
      "        0 <= pos <= self.size'''",
      "        curSum, pos = 0, 0",
      "        for i in range(self.bit, -1, -1):",
      "            nextPos = pos + (1 << i)",
      "            if nextPos <= self.size and curSum + self.tree.get(nextPos, 0) < k:",
      "                pos = nextPos",
      "                curSum += self.tree.get(pos, 0)",
      "        return pos",
      "",
      "    def bisectRight(self, k: int) -> int:",
      "        '''返回第一个前缀和大于k的位置pos",
      "        0 <= pos <= self.size'''",
      "        curSum, pos = 0, 0",
      "        for i in range(self.bit, -1, -1):",
      "            nextPos = pos + (1 << i)",
      "            if nextPos <= self.size and curSum + self.tree.get(nextPos, 0) <= k:",
      "                pos = nextPos",
      "                curSum += self.tree.get(pos, 0)",
      "        return pos",
      "",
      "    def __repr__(self) -> str:",
      "        arr = []",
      "        for i in range(self.size):",
      "            arr.append(self.queryRange(i, i + 1))",
      "        return str(arr)",
      "",
      "    def __len__(self) -> int:",
      "        return self.size"
    ],
    "description": "树状数组单点修改区间查询"
  },
  "树状数组区间修改区间查询": {
    "scope": "python",
    "prefix": "BIT2",
    "body": [
      "class BIT2:",
      "    '''范围修改,0-indexed'''",
      "    __slots__ = 'size', '_tree1', '_tree2'",
      "",
      "    def __init__(self, n: int):",
      "        self.size = n + 5",
      "        self._tree1 = dict()",
      "        self._tree2 = dict()",
      "",
      "    def add(self, left: int, right: int, delta: int) -> None:",
      "        '''区间[left, right)加delta.'''",
      "        right -= 1",
      "        self._add(left, delta)",
      "        self._add(right + 1, -delta)",
      "",
      "    def query(self, left: int, right: int) -> int:",
      "        '''区间[left, right)的和.'''",
      "        right -= 1",
      "        return self._query(right) - self._query(left - 1)",
      "",
      "    def _add(self, index: int, delta: int) -> None:",
      "        index += 1",
      "        rawIndex = index",
      "        while index <= self.size:",
      "            self._tree1[index] = self._tree1.get(index, 0) + delta",
      "            self._tree2[index] = self._tree2.get(index, 0) + (rawIndex - 1) * delta",
      "            index += index & -index",
      "",
      "    def _query(self, index: int) -> int:",
      "        index += 1",
      "        if index > self.size:",
      "            index = self.size",
      "        rawIndex = index",
      "        res = 0",
      "        while index > 0:",
      "            res += rawIndex * self._tree1.get(index, 0) - self._tree2.get(index, 0)",
      "            index &= index - 1",
      "        return res",
      "",
      "    def __repr__(self) -> str:",
      "        arr = []",
      "        for i in range(self.size):",
      "            arr.append(self.query(i, i + 1))",
      "        return str(arr)",
      "",
      "    def __len__(self) -> int:",
      "        return self.size"
    ],
    "description": "树状数组区间修改区间查询"
  },
  "埃氏筛-py": {
    "scope": "python",
    "prefix": ["埃氏筛", "EratosthenesSieve", "筛法"],
    "body": [
      "from collections import Counter",
      "from typing import List",
      "",
      "",
      "class EratosthenesSieve:",
      "    '''埃氏筛'''",
      "",
      "    __slots__ = '_minPrime'  # 每个数的最小质因数",
      "",
      "    def __init__(self, maxN: int):",
      "        '''预处理 O(nloglogn)'''",
      "        minPrime = list(range(maxN + 1))",
      "        upper = int(maxN**0.5) + 1",
      "        for i in range(2, upper):",
      "            if minPrime[i] < i:",
      "                continue",
      "            for j in range(i * i, maxN + 1, i):",
      "                if minPrime[j] == j:",
      "                    minPrime[j] = i",
      "        self._minPrime = minPrime",
      "",
      "    def isPrime(self, n: int) -> bool:",
      "        if n < 2:",
      "            return False",
      "        return self._minPrime[n] == n",
      "",
      "    def getPrimeFactors(self, n: int) -> 'Counter[int]':",
      "        '''求n的质因数分解 O(logn)'''",
      "        res, f = Counter(), self._minPrime",
      "        while n > 1:",
      "            m = f[n]",
      "            res[m] += 1",
      "            n //= m",
      "        return res",
      "",
      "    def getPrimes(self) -> List[int]:",
      "        return [x for i, x in enumerate(self._minPrime) if i >= 2 and i == x]"
    ],
    "description": "埃氏筛"
  },
  "埃氏筛-ts": {
    "scope": "typescript",
    "prefix": ["埃氏筛", "EratosthenesSieve", "筛法"],
    "body": [
      "/**",
      " * 埃氏筛.",
      " */",
      "class EratosthenesSieve {",
      "  /**",
      "   * 每个数的最小质因子.",
      "   */",
      "  private readonly minPrime: Uint32Array",
      "  private readonly _max: number",
      "  constructor(max: number) {",
      "    const minPrime = new Uint32Array(max + 1)",
      "    for (let i = 0; i <= max; i++) minPrime[i] = i",
      "    const upper = ~~Math.sqrt(max)",
      "    for (let i = 2; i <= upper; i++) {",
      "      if (minPrime[i] < i) continue",
      "      for (let j = i * i; j <= max; j += i) {",
      "        if (minPrime[j] === j) minPrime[j] = i",
      "      }",
      "    }",
      "    this.minPrime = minPrime",
      "    this._max = max",
      "  }",
      "  isPrime(n: number): boolean {",
      "    return n >= 2 && this.minPrime[n] === n",
      "  }",
      "  getPrimeFactors(n: number): ReadonlyMap<number, number> {",
      "    const f = this.minPrime",
      "    const res = new Map<number, number>()",
      "    while (n > 1) {",
      "      const p = f[n]",
      "      res.set(p, (res.get(p) || 0) + 1)",
      "      n /= p",
      "    }",
      "    return res",
      "  }",
      "  getPrimes(n = this._max): readonly number[] {",
      "    const res: number[] = []",
      "    for (let i = 2; i <= n; i++) {",
      "      if (i === this.minPrime[i]) res.push(i)",
      "    }",
      "    return res",
      "  }",
      "}"
    ],
    "description": "埃氏筛"
  },
  "链表转换": {
    "scope": "python",
    "prefix": "linkedListToArray",
    "body": [
      "class ListNode:",
      "    def __init__(self, val=0, next=None):",
      "        self.val = val",
      "        self.next = next",
      "",
      "",
      "def arrayToLinkedList(nums):",
      "    dummy = ListNode(0)",
      "    p = dummy",
      "    for num in nums:",
      "        p.next = ListNode(num)",
      "        p = p.next",
      "    return dummy.next",
      "",
      "",
      "def linkedListToArray(head):",
      "    nums = []",
      "    p = head",
      "    while p:",
      "        nums.append(p.val)",
      "        p = p.next",
      "    return nums"
    ],
    "description": "链表转数组/数组转链表"
  },
  "等差数列求和": {
    "scope": "python",
    "prefix": ["等差数列求和", "arithmeticSum", "dengchashulie"],
    "body": [
      "def arithmeticSum1(first: int, last: int, diff: int) -> int:",
      "    '''等差数列求和 first:首项 last:末项 diff:公差'''",
      "    item = (last - first) // diff + 1",
      "    return item * (first + last) // 2",
      "",
      "def arithmeticSum2(first: int, diff: int, item: int) -> int:",
      "    '''等差数列求和 first:首项 diff:公差 item:项数'''",
      "    last = first + (item - 1) * diff",
      "    return item * (first + last) // 2"
    ],
    "description": "等差数列求和"
  },
  "tsInput": {
    "scope": "typescript,typescriptreact",
    "prefix": "useInput",
    "body": [
      "import * as fs from 'fs'",
      "import { resolve } from 'path'",
      "",
      "function useInput(path?: string) {",
      "  let data: string",
      "  if (path) {",
      "    data = fs.readFileSync(resolve(__dirname, path), 'utf8')",
      "  } else {",
      "    data = fs.readFileSync(process.stdin.fd, 'utf8')",
      "  }",
      "",
      "  const lines = data.split(/\\r\\n|\\r|\\n/)",
      "  let lineId = 0",
      "  const input = (): string => lines[lineId++]",
      "",
      "  return {",
      "    input",
      "  }",
      "}"
    ],
    "description": "tsInput"
  },
  "bisect1": {
    "scope": "typescript,typescriptreact",
    "prefix": "bisect1",
    "body": [
      "let left = 0",
      "let right = 2e15",
      "let ok = false",
      "while (left <= right) {",
      "  const mid = Math.floor((left + right) / 2)",
      "  if (check(mid)) {",
      "    right = mid - 1",
      "    ok = true",
      "  } else {",
      "    left = mid + 1",
      "  }",
      "}",
      "",
      "return left",
      "",
      "function check(mid: number): boolean {",
      "  return true",
      "}"
    ],
    "description": "最右二分"
  },
  "bisect1-golang": {
    "scope": "go,golang",
    "prefix": "bisect1",
    "body": [
      "check := func(mid int) bool {",
      "  return true",
      "}",
      "left, right := 0, int(1e18)",
      "for left <= right {",
      "  mid := (left + right) / 2",
      "  if check(mid) {",
      "    right = mid - 1",
      "  } else {",
      "    left = mid + 1",
      "  }",
      "}",
      "return left"
    ],
    "description": "最左二分"
  },
  "bisect2-golang": {
    "scope": "go,golang",
    "prefix": "bisect2",
    "body": [
      "check := func(mid int) bool {",
      "  return true",
      "}",
      "left, right := 1, int(1e18)",
      "for left <= right {",
      "  mid := (left + right) / 2",
      "  if check(mid) {",
      "    left = mid + 1",
      "  } else {",
      "    right = mid - 1",
      "  }",
      "}",
      "return right"
    ],
    "description": "最右二分"
  },
  "bisect2": {
    "scope": "typescript,typescriptreact",
    "prefix": "bisect2",
    "body": [
      "let left = 1",
      "let right = 2e15",
      "let ok = false",
      "while (left <= right) {",
      "  const mid = Math.floor((left + right) / 2)",
      "  if (check(mid)) {",
      "    left = mid + 1",
      "    ok = true",
      "  } else {",
      "    right = mid - 1",
      "  }",
      "}",
      "",
      "return right",
      "",
      "function check(mid: number): boolean {",
      "  return true",
      "}"
    ],
    "description": "最右二分"
  },
  "bisectKth": {
    "scope": "typescript,typescriptreact",
    "prefix": "bisectKth",
    "body": [
      "let left = 0",
      "let right = 4e15",
      "while (left <= right) {",
      "  const mid = (left + right) >> 1",
      "  if (countNGT(mid) < k) {",
      "    left = mid + 1",
      "  } else {",
      "    right = mid - 1",
      "  }",
      "}",
      "return left",
      "",
      "// 不超过mid的答案个数",
      "function countNGT(mid: number): number {",
      "  return 0",
      "}"
    ],
    "description": "二分答案查找第k小,k从1开始"
  },
  "bisectKth-go": {
    "scope": "go,golang",
    "prefix": "bisectKth",
    "body": [
      "// 不超过mid的答案个数",
      "countNGT := func(mid int) int {",
      "  return 0",
      "}",
      "left, right := 0, int(1e18)",
      "for left <= right {",
      "  mid := (left + right) / 2",
      "  if countNGT(mid) < k {",
      "    left = mid + 1",
      "  } else {",
      "    right = mid - 1",
      "  }",
      "}",
      "return left"
    ],
    "description": "二分答案查找第k小,k从1开始"
  },
  "生成大数组测试用例": {
    "scope": "typescript,typescriptreact",
    "prefix": ["bigArray"],
    "body": [
      "const getBig = (len = 1e5): number[] => {",
      "  const big = Array(len)",
      "  for (let i = 0; i < len; i++) {",
      "    big[i] = ~~(Math.random() * 2e9) - 1e9",
      "  }",
      "  return big",
      "}"
    ],
    "description": "生成大数组测试用例"
  },
  "dfsOrder": {
    "scope": "typescript,typescriptreact",
    "prefix": "dfsOrder",
    "body": [
      "const ins = new Uint32Array(n + 10) // 子树中最小的结点序号,const left = ins[removeRoot]",
      "const outs = new Uint32Array(n + 10) // 子树中最大的结点序号,即自己的id,const right = outs[removeRoot]",
      "const depth = new Uint32Array(n + 10) // 深度 根节点深度为0",
      "let dfsId = 1",
      "dfsOrder(root, -1, 0)",
      "",
      "for (let i = 0; i < queries.length; i++) {",
      "  const queryRoot = queries[i]",
      "  const left = ins[queryRoot]",
      "  const right = outs[queryRoot]",
      "}",
      "",
      "function dfsOrder(cur: number, pre: number, dep: number): void {",
      "  ins[cur] = dfsId",
      "  for (let i = 0; i < tree[cur].length; i++) {",
      "    const next = tree[cur][i]",
      "    if (next === pre) continue",
      "    dfsOrder(next, cur, dep + 1)",
      "  }",
      "  outs[cur] = dfsId",
      "  depth[dfsId] = dep",
      "  dfsId++",
      "}"
    ],
    "description": "树的dfs序"
  },
  "dfsOrder-new": {
    "scope": "typescript,typescriptreact",
    "prefix": "dfsOrder-new",
    "body": [
      "const lid = new Uint32Array(n)",
      "const rid = new Uint32Array(n)",
      "let dfn = 0",
      "const dfs = (cur: number, pre: number): void => {",
      "\tlid[cur] = dfn",
      "\tdfn++",
      "\ttree[cur].forEach(next_ => {",
      "\t\tif (next_ !== pre) {",
      "\t\t\tdfs(next_, cur)",
      "\t\t}",
      "\t})",
      "\trid[cur] = dfn",
      "}",
      "dfs(0, -1)",
      "",
      "\t// data[lid[i]] = values[i]"
    ],
    "description": "dfs序"
  },
  "input": {
    "scope": "go,golang",
    "prefix": "input",
    "body": [
      // "const INF int = int(1e18)",
      // "const MOD int = 998244353",
      // "",
      "in := bufio.NewReader(os.Stdin)",
      "out := bufio.NewWriter(os.Stdout)",
      "defer out.Flush()",
      "",
      "var n int",
      "fmt.Fscan(in, &n)"
    ],
    "description": "golang input"
  },
  "go-bisectLeft": {
    "scope": "go,golang",
    "prefix": "bisectLeft",
    "body": [
      "func bisectLeft(nums []int, target int) int {",
      "  left, right := 0, len(nums) - 1",
      "  for left <= right {",
      "    mid := (left + right) >> 1",
      "    if nums[mid] < target {",
      "      left = mid + 1",
      "    } else {",
      "      right = mid - 1",
      "    }",
      "  }",
      "  return left",
      "}"
    ],
    "description": "bisectLeft"
  },
  "go-bisectRight": {
    "scope": "go,golang",
    "prefix": "bisectRight",
    "body": [
      "func bisectRight(nums []int, target int) int {",
      "  left, right := 0, len(nums) - 1",
      "  for left <= right {",
      "    mid := (left + right) >> 1",
      "    if nums[mid] <= target {",
      "      left = mid + 1",
      "    } else {",
      "      right = mid - 1",
      "    }",
      "  }",
      "  return left",
      "}"
    ],
    "description": "bisectRight"
  },

  "golang快速幂1": {
    "scope": "go,golang",
    "prefix": "pow",
    "body": [
      "func Pow(base, exp, mod int) int {",
      "  base %= mod",
      "  res := 1 % mod",
      "  for ; exp > 0; exp >>= 1 {",
      "    if exp&1 == 1 {",
      "      res = res * base % mod",
      "    }",
      "    base = base * base % mod",
      "  }",
      "  return res",
      "}"
    ],
    "description": "golang快速幂1"
  },
  "golang快速幂2": {
    "scope": "go,golang",
    "prefix": ["pow", "exgcd", "modInv"],
    "body": [
      "func Pow(base, exp, mod int) int {",
      "  if exp == -1 {",
      "    return modInv(base, mod)",
      "  }",
      "",
      "  base %= mod",
      "  res := 1 % mod",
      "  for ; exp > 0; exp >>= 1 {",
      "    if exp&1 == 1 {",
      "      res = res * base % mod",
      "    }",
      "    base = base * base % mod",
      "  }",
      "  return res",
      "}",
      "",
      "func exgcd(a, b int) (gcd, x, y int) {",
      "  if b == 0 {",
      "    return a, 1, 0",
      "  }",
      "  gcd, y, x = exgcd(b, a%b)",
      "  y -= a / b * x",
      "  return",
      "}",
      "",
      "// 注意模为1时不存在逆元",
      "func modInv(a, mod int) int {",
      "  gcd, x, _ := exgcd(a, mod)",
      "  if gcd != 1 {",
      "    panic(fmt.Sprintf(\"no inverse element for %d\", a))",
      "  }",
      "  return (x%mod + mod) % mod",
      "}"
    ],
    "description": "golang快速幂2"
  },
  "golang ModInt": {
    "scope": "go,golang",
    "prefix": ["modint", "ModInt"],
    "body": [
      "const MOD = 998244353",
      "type ModInt int64",
      "func (m ModInt) Add(x ModInt) ModInt {",
      " return (m + x).mod()",
      "}",
      "func (m *ModInt) IAdd(x ModInt) {",
      " *m = m.Add(x)",
      "}",
      "func (m ModInt) Sub(x ModInt) ModInt {",
      " return (m - x).mod()",
      "}",
      "func (m *ModInt) ISub(x ModInt) {",
      " *m = m.Sub(x)",
      "}",
      "func (m ModInt) Mul(x ModInt) ModInt {",
      " return (m * x).mod()",
      "}",
      "func (m *ModInt) IMul(x ModInt) {",
      " *m = m.Mul(x)",
      "}",
      "func (m ModInt) Div(x ModInt) ModInt {",
      " return m.Mul(x.Inv())",
      "}",
      "func (m *ModInt) IDiv(x ModInt) {",
      " *m = m.Div(x)",
      "}",
      "func (m ModInt) Pow(n ModInt) ModInt {",
      " m = m.mod()",
      " p := ModInt(1)",
      " for n > 0 {",
      " if n&1 == 1 {",
      " p.IMul(m)",
      " }",
      " m.IMul(m)",
      " n >>= 1",
      " }",
      " return p",
      "}",
      "func (m ModInt) Inv() ModInt {",
      " return m.Pow(ModInt(0).Sub(2))",
      "}",
      "func (m ModInt) mod() ModInt {",
      " m %= MOD",
      " if m < 0 {",
      " m += MOD",
      " }",
      " return m",
      "}"
    ],
    "description": "golang ModInt"
  },
  "golang快读": {
    "scope": "go,golang",
    "prefix": ["io", "input"],
    "body": [
      "package main",
      "import (",
      "  \"bufio\"",
      "  \"fmt\"",
      "  stdio \"io\"",
      "  \"os\"",
      "  \"strconv\"",
      ")",
      "// from https://atcoder.jp/users/ccppjsrb",
      "var io *Iost",
      "type Iost struct {",
      "  Scanner *bufio.Scanner",
      "  Writer  *bufio.Writer",
      "}",
      "func NewIost(fp stdio.Reader, wfp stdio.Writer) *Iost {",
      "  const BufSize = 2000005",
      "  scanner := bufio.NewScanner(fp)",
      "  scanner.Split(bufio.ScanWords)",
      "  scanner.Buffer(make([]byte, BufSize), BufSize)",
      "  return &Iost{Scanner: scanner, Writer: bufio.NewWriter(wfp)}",
      "}",
      "func (io *Iost) Text() string {",
      "  if !io.Scanner.Scan() {",
      "    panic(\"scan failed\")",
      "  }",
      "  return io.Scanner.Text()",
      "}",
      "func (io *Iost) Atoi(s string) int                 { x, _ := strconv.Atoi(s); return x }",
      "func (io *Iost) Atoi64(s string) int64             { x, _ := strconv.ParseInt(s, 10, 64); return x }",
      "func (io *Iost) Atof64(s string) float64           { x, _ := strconv.ParseFloat(s, 64); return x }",
      "func (io *Iost) NextInt() int                      { return io.Atoi(io.Text()) }",
      "func (io *Iost) NextInt64() int64                  { return io.Atoi64(io.Text()) }",
      "func (io *Iost) NextFloat64() float64              { return io.Atof64(io.Text()) }",
      "func (io *Iost) Print(x ...interface{})            { fmt.Fprint(io.Writer, x...) }",
      "func (io *Iost) Printf(s string, x ...interface{}) { fmt.Fprintf(io.Writer, s, x...) }",
      "func (io *Iost) Println(x ...interface{})          { fmt.Fprintln(io.Writer, x...) }",
      "  ",
      "func main() {",
      "  in := os.Stdin",
      "  out := os.Stdout",
      "  io = NewIost(in, out)",
      "  defer func() {",
      "    io.Writer.Flush()",
      "  }()",
      "  ",
      "  ",
      " }"
    ],
    "description": "golang快读"
  },
  "golang线段树单点修改区间查询": {
    "scope": "go,golang",
    "prefix": ["seg"],
    "body": [
      "const INF int = 1e18",
      "// PointSetRangeMin",
      "$1",
      "type E = int",
      "func (*SegmentTree) e() E        { return INF }",
      "func (*SegmentTree) op(a, b E) E { return min(a, b) }",
      "func min(a, b int) int {",
      " if a < b {",
      "  return a",
      " }",
      " return b",
      "}",
      "func max(a, b int) int {",
      " if a > b {",
      "  return a",
      " }",
      " return b",
      "}",
      "type SegmentTree struct {",
      " n, size int",
      " seg     []E",
      "}",
      "func NewSegmentTree(n int, f func(int) E) *SegmentTree {",
      "\tres := &SegmentTree{}",
      "\tsize := 1",
      "\tfor size < n {",
      "\t\tsize <<= 1",
      "\t}",
      "\tseg := make([]E, size<<1)",
      "\tfor i := range seg {",
      "\t\tseg[i] = res.e()",
      "\t}",
      "\tfor i := 0; i < n; i++ {",
      "\t\tseg[i+size] = f(i)",
      "\t}",
      "\tfor i := size - 1; i > 0; i-- {",
      "\t\tseg[i] = res.op(seg[i<<1], seg[i<<1|1])",
      "\t}",
      "\tres.n = n",
      "\tres.size = size",
      "\tres.seg = seg",
      "\treturn res",
      "}",
      "func NewSegmentTreeFrom(leaves []E) *SegmentTree {",
      " res := &SegmentTree{}",
      " n := len(leaves)",
      " size := 1",
      " for size < n {",
      "  size <<= 1",
      " }",
      " seg := make([]E, size<<1)",
      " for i:= range seg {",
      "  seg[i] = res.e()",
      " }",
      " for i := 0; i < n; i++ {",
      "  seg[i+size] = leaves[i]",
      " }",
      " for i := size - 1; i > 0; i-- {",
      "  seg[i] = res.op(seg[i<<1], seg[i<<1|1])",
      " }",
      " res.n = n",
      " res.size = size",
      " res.seg = seg",
      " return res",
      "}",
      "func (st *SegmentTree) Get(index int) E {",
      " if index < 0 || index >= st.n {",
      "  return st.e()",
      " }",
      " return st.seg[index+st.size]",
      "}",
      "func (st *SegmentTree) Set(index int, value E) {",
      " if index < 0 || index >= st.n {",
      "  return",
      " }",
      " index += st.size",
      " st.seg[index] = value",
      " for index >>= 1; index > 0; index >>= 1 {",
      "  st.seg[index] = st.op(st.seg[index<<1], st.seg[index<<1|1])",
      " }",
      "}",
      "func (st *SegmentTree) Update(index int, value E) {",
      " if index < 0 || index >= st.n {",
      "  return",
      " }",
      " index += st.size",
      " st.seg[index] = st.op(st.seg[index], value)",
      " for index >>= 1; index > 0; index >>= 1 {",
      "  st.seg[index] = st.op(st.seg[index<<1], st.seg[index<<1|1])",
      " }",
      "}",
      "// [start, end)",
      "func (st *SegmentTree) Query(start, end int) E {",
      " if start < 0 {",
      "  start = 0",
      " }",
      " if end > st.n {",
      "  end = st.n",
      " }",
      " if start >= end {",
      "  return st.e()",
      " }",
      " leftRes, rightRes := st.e(), st.e()",
      " start += st.size",
      " end += st.size",
      " for start < end {",
      "  if start&1 == 1 {",
      "   leftRes = st.op(leftRes, st.seg[start])",
      "   start++",
      "  }",
      "  if end&1 == 1 {",
      "   end--",
      "   rightRes = st.op(st.seg[end], rightRes)",
      "  }",
      "  start >>= 1",
      "  end >>= 1",
      " }",
      " return st.op(leftRes, rightRes)",
      "}",
      "func (st *SegmentTree) QueryAll() E { return st.seg[1] }",
      "func (st *SegmentTree) GetAll() []E {",
      " res := make([]E, st.n)",
      " copy(res, st.seg[st.size:st.size+st.n])",
      " return res",
      "}",
      "// 二分查询最大的 right 使得切片 [left:right] 内的值满足 predicate",
      "func (st *SegmentTree) MaxRight(left int, predicate func(E) bool) int {",
      " if left == st.n {",
      "  return st.n",
      " }",
      " left += st.size",
      " res := st.e()",
      " for {",
      "  for left&1 == 0 {",
      "   left >>= 1",
      "  }",
      "  if !predicate(st.op(res, st.seg[left])) {",
      "   for left < st.size {",
      "    left <<= 1",
      "    if tmp := st.op(res, st.seg[left]); predicate(tmp) {",
      "     res = tmp",
      "     left++",
      "    }",
      "   }",
      "   return left - st.size",
      "  }",
      "  res = st.op(res, st.seg[left])",
      "  left++",
      "  if (left & -left) == left {",
      "   break",
      "  }",
      " }",
      " return st.n",
      "}",
      "// 二分查询最小的 left 使得切片 [left:right] 内的值满足 predicate",
      "func (st *SegmentTree) MinLeft(right int, predicate func(E) bool) int {",
      " if right == 0 {",
      "  return 0",
      " }",
      " right += st.size",
      " res := st.e()",
      " for {",
      "  right--",
      "  for right > 1 && right&1 == 1 {",
      "   right >>= 1",
      "  }",
      "  if !predicate(st.op(st.seg[right], res)) {",
      "   for right < st.size {",
      "    right = right<<1 | 1",
      "    if tmp := st.op(st.seg[right], res); predicate(tmp) {",
      "     res = tmp",
      "     right--",
      "    }",
      "   }",
      "   return right + 1 - st.size",
      "  }",
      "  res = st.op(st.seg[right], res)",
      "  if right&-right == right {",
      "    break",
      "  }",
      " }",
      " return 0",
      "}"
    ],
    "description": "golang线段树单点修改区间查询"
  },
  "golang线段树单点修改区间查询-32": {
    "scope": "go,golang",
    "prefix": ["seg32"],
    "body": [
      "",
      "const INF32 int32 = 1 << 30",
      "",
      "// PointSetRangeMin",
      "",
      "$1",
      "type E = int32",
      "",
      "func (*SegmentTree) e() E\t\t\t\t{ return INF32 }",
      "func (*SegmentTree) op(a, b E) E { return min32(a, b) }",
      "func min32(a, b int32) int32 {",
      "\tif a < b {",
      "\t\treturn a",
      "\t}",
      "\treturn b",
      "}",
      "func max32(a, b int32) int32 {",
      "\tif a > b {",
      "\t\treturn a",
      "\t}",
      "\treturn b",
      "}",
      "",
      "type SegmentTree struct {",
      "\tn, size int32",
      "\tseg\t\t []E",
      "}",
      "",
      "func NewSegmentTree(n int32, f func(int32) E) *SegmentTree {",
      "\tres := &SegmentTree{}",
      "\tsize := int32(1)",
      "\tfor size < n {",
      "\t\tsize <<= 1",
      "\t}",
      "\tseg := make([]E, size<<1)",
      "\tfor i := range seg {",
      "\t\tseg[i] = res.e()",
      "\t}",
      "\tfor i := int32(0); i < n; i++ {",
      "\t\tseg[i+size] = f(i)",
      "\t}",
      "\tfor i := size - 1; i > 0; i-- {",
      "\t\tseg[i] = res.op(seg[i<<1], seg[i<<1|1])",
      "\t}",
      "\tres.n = n",
      "\tres.size = size",
      "\tres.seg = seg",
      "\treturn res",
      "}",
      "func NewSegmentTreeFrom(leaves []E) *SegmentTree {",
      "\tres := &SegmentTree{}",
      "\tn := int32(len(leaves))",
      "\tsize := int32(1)",
      "\tfor size < n {",
      "\t\tsize <<= 1",
      "\t}",
      "\tseg := make([]E, size<<1)",
      "\tfor i := range seg {",
      "\t\tseg[i] = res.e()",
      "\t}",
      "\tfor i := int32(0); i < n; i++ {",
      "\t\tseg[i+size] = leaves[i]",
      "\t}",
      "\tfor i := size - 1; i > 0; i-- {",
      "\t\tseg[i] = res.op(seg[i<<1], seg[i<<1|1])",
      "\t}",
      "\tres.n = n",
      "\tres.size = size",
      "\tres.seg = seg",
      "\treturn res",
      "}",
      "func (st *SegmentTree) Get(index int32) E {",
      "\tif index < 0 || index >= st.n {",
      "\t\treturn st.e()",
      "\t}",
      "\treturn st.seg[index+st.size]",
      "}",
      "func (st *SegmentTree) Set(index int32, value E) {",
      "\tif index < 0 || index >= st.n {",
      "\t\treturn",
      "\t}",
      "\tindex += st.size",
      "\tst.seg[index] = value",
      "\tfor index >>= 1; index > 0; index >>= 1 {",
      "\t\tst.seg[index] = st.op(st.seg[index<<1], st.seg[index<<1|1])",
      "\t}",
      "}",
      "func (st *SegmentTree) Update(index int32, value E) {",
      "\tif index < 0 || index >= st.n {",
      "\t\treturn",
      "\t}",
      "\tindex += st.size",
      "\tst.seg[index] = st.op(st.seg[index], value)",
      "\tfor index >>= 1; index > 0; index >>= 1 {",
      "\t\tst.seg[index] = st.op(st.seg[index<<1], st.seg[index<<1|1])",
      "\t}",
      "}",
      "",
      "// [start, end)",
      "func (st *SegmentTree) Query(start, end int32) E {",
      "\tif start < 0 {",
      "\t\tstart = 0",
      "\t}",
      "\tif end > st.n {",
      "\t\tend = st.n",
      "\t}",
      "\tif start >= end {",
      "\t\treturn st.e()",
      "\t}",
      "\tleftRes, rightRes := st.e(), st.e()",
      "\tstart += st.size",
      "\tend += st.size",
      "\tfor start < end {",
      "\t\tif start&1 == 1 {",
      "\t\t\tleftRes = st.op(leftRes, st.seg[start])",
      "\t\t\tstart++",
      "\t\t}",
      "\t\tif end&1 == 1 {",
      "\t\t\tend--",
      "\t\t\trightRes = st.op(st.seg[end], rightRes)",
      "\t\t}",
      "\t\tstart >>= 1",
      "\t\tend >>= 1",
      "\t}",
      "\treturn st.op(leftRes, rightRes)",
      "}",
      "func (st *SegmentTree) QueryAll() E { return st.seg[1] }",
      "func (st *SegmentTree) GetAll() []E {",
      "\tres := make([]E, st.n)",
      "\tcopy(res, st.seg[st.size:st.size+st.n])",
      "\treturn res",
      "}",
      "",
      "// 二分查询最大的 right 使得切片 [left:right] 内的值满足 predicate",
      "func (st *SegmentTree) MaxRight(left int32, predicate func(E) bool) int32 {",
      "\tif left == st.n {",
      "\t\treturn st.n",
      "\t}",
      "\tleft += st.size",
      "\tres := st.e()",
      "\tfor {",
      "\t\tfor left&1 == 0 {",
      "\t\t\tleft >>= 1",
      "\t\t}",
      "\t\tif !predicate(st.op(res, st.seg[left])) {",
      "\t\t\tfor left < st.size {",
      "\t\t\t\tleft <<= 1",
      "\t\t\t\tif tmp := st.op(res, st.seg[left]); predicate(tmp) {",
      "\t\t\t\t\tres = tmp",
      "\t\t\t\t\tleft++",
      "\t\t\t\t}",
      "\t\t\t}",
      "\t\t\treturn left - st.size",
      "\t\t}",
      "\t\tres = st.op(res, st.seg[left])",
      "\t\tleft++",
      "\t\tif (left & -left) == left {",
      "\t\t\tbreak",
      "\t\t}",
      "\t}",
      "\treturn st.n",
      "}",
      "",
      "// 二分查询最小的 left 使得切片 [left:right] 内的值满足 predicate",
      "func (st *SegmentTree) MinLeft(right int32, predicate func(E) bool) int32 {",
      "\tif right == 0 {",
      "\t\treturn 0",
      "\t}",
      "\tright += st.size",
      "\tres := st.e()",
      "\tfor {",
      "\t\tright--",
      "\t\tfor right > 1 && right&1 == 1 {",
      "\t\t\tright >>= 1",
      "\t\t}",
      "\t\tif !predicate(st.op(st.seg[right], res)) {",
      "\t\t\tfor right < st.size {",
      "\t\t\t\tright = right<<1 | 1",
      "\t\t\t\tif tmp := st.op(st.seg[right], res); predicate(tmp) {",
      "\t\t\t\t\tres = tmp",
      "\t\t\t\t\tright--",
      "\t\t\t\t}",
      "\t\t\t}",
      "\t\t\treturn right + 1 - st.size",
      "\t\t}",
      "\t\tres = st.op(st.seg[right], res)",
      "\t\tif right&-right == right {",
      "\t\t\tbreak",
      "\t\t}",
      "\t}",
      "\treturn 0",
      "}",
      ""
    ],
    "description": "seg32"
  },
  "golang线段树区间修改单点查询": {
    "scope": "go,golang",
    "prefix": ["segDual"],

    "body": [
      "",
      "// RangeAssignPointGet",
      "",
      "type Id = int",
      "",
      "$1",
      "const COMMUTATIVE = false",
      "",
      "func (*SegmentTreeDual) id() Id\t\t\t\t\t\t\t\t { return 0 }",
      "func (*SegmentTreeDual) composition(f, g Id) Id { return f }",
      "",
      "type SegmentTreeDual struct {",
      "\tn\t\t\t\t\t\tint",
      "\tsize, height int",
      "\tlazy\t\t\t\t []Id",
      "\tunit\t\t\t\t Id",
      "}",
      "",
      "func NewSegmentTreeDual(n int) *SegmentTreeDual {",
      "\tres := &SegmentTreeDual{}",
      "\tsize := 1",
      "\theight := 0",
      "\tfor size < n {",
      "\t\tsize <<= 1",
      "\t\theight++",
      "\t}",
      "\tlazy := make([]Id, 2*size)",
      "\tunit := res.id()",
      "\tfor i := 0; i < 2*size; i++ {",
      "\t\tlazy[i] = unit",
      "\t}",
      "\tres.n = n",
      "\tres.size = size",
      "\tres.height = height",
      "\tres.lazy = lazy",
      "\tres.unit = unit",
      "\treturn res",
      "}",
      "func (seg *SegmentTreeDual) Get(index int) Id {",
      "\tindex += seg.size",
      "\tfor i := seg.height; i > 0; i-- {",
      "\t\tseg.propagate(index >> i)",
      "\t}",
      "\treturn seg.lazy[index]",
      "}",
      "func (seg *SegmentTreeDual) Set(index int, value Id) {",
      "\tindex += seg.size",
      "\tfor i := seg.height; i > 0; i-- {",
      "\t\tseg.propagate(index >> i)",
      "\t}",
      "\tseg.lazy[index] = value",
      "}",
      "func (seg *SegmentTreeDual) GetAll() []Id {",
      "\tfor i := 0; i < seg.size; i++ {",
      "\t\tseg.propagate(i)",
      "\t}",
      "\tres := make([]Id, seg.n)",
      "\tcopy(res, seg.lazy[seg.size:seg.size+seg.n])",
      "\treturn res",
      "}",
      "func (seg *SegmentTreeDual) Update(left, right int, value Id) {",
      "\tif left < 0 {",
      "\t\tleft = 0",
      "\t}",
      "\tif right > seg.n {",
      "\t\tright = seg.n",
      "\t}",
      "\tif left >= right {",
      "\t\treturn",
      "\t}",
      "\tleft += seg.size",
      "\tright += seg.size",
      "\tif !COMMUTATIVE {",
      "\t\tfor i := seg.height; i > 0; i-- {",
      "\t\t\tif (left>>i)<<i != left {",
      "\t\t\t\tseg.propagate(left >> i)",
      "\t\t\t}",
      "\t\t\tif (right>>i)<<i != right {",
      "\t\t\t\tseg.propagate((right - 1) >> i)",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "\tfor left < right {",
      "\t\tif left&1 > 0 {",
      "\t\t\tseg.lazy[left] = seg.composition(value, seg.lazy[left])",
      "\t\t\tleft++",
      "\t\t}",
      "\t\tif right&1 > 0 {",
      "\t\t\tright--",
      "\t\t\tseg.lazy[right] = seg.composition(value, seg.lazy[right])",
      "\t\t}",
      "\t\tleft >>= 1",
      "\t\tright >>= 1",
      "\t}",
      "}",
      "func (seg *SegmentTreeDual) propagate(k int) {",
      "\tif seg.lazy[k] != seg.unit {",
      "\t\tseg.lazy[k<<1] = seg.composition(seg.lazy[k], seg.lazy[k<<1])",
      "\t\tseg.lazy[k<<1|1] = seg.composition(seg.lazy[k], seg.lazy[k<<1|1])",
      "\t\tseg.lazy[k] = seg.unit",
      "\t}",
      "}",
      "func (st *SegmentTreeDual) String() string {",
      "\tvar buf bytes.Buffer",
      "\tbuf.WriteByte('[')",
      "\tfor i := 0; i < st.n; i++ {",
      "\t\tif i > 0 {",
      "\t\t\tbuf.WriteByte(' ')",
      "\t\t}",
      "\t\tbuf.WriteString(fmt.Sprint(st.Get(i)))",
      "\t}",
      "\tbuf.WriteByte(']')",
      "\treturn buf.String()",
      "}"
    ],
    "description": "golang线段树区间修改单点查询"
  },

  "golang线段树区间修改单点查询-2": {
    "scope": "go,golang",
    "prefix": ["segDual32"],
    "body": [
      "",
      "// RangeAssignPointGet",
      "",
      "$1",
      "type Id = int",
      "",
      "const COMMUTATIVE = false",
      "",
      "func (*SegmentTreeDual32) id() Id\t\t\t\t\t\t\t\t { return 0 }",
      "func (*SegmentTreeDual32) composition(f, g Id) Id { return f }",
      "",
      "type SegmentTreeDual32 struct {",
      "\tn\t\t\t\t\t\tint32",
      "\tsize, height int32",
      "\tlazy\t\t\t\t []Id",
      "\tunit\t\t\t\t Id",
      "}",
      "",
      "func NewSegmentTreeDual32(n int32) *SegmentTreeDual32 {",
      "\tres := &SegmentTreeDual32{}",
      "\tsize := int32(1)",
      "\theight := int32(0)",
      "\tfor size < n {",
      "\t\tsize <<= 1",
      "\t\theight++",
      "\t}",
      "\tlazy := make([]Id, 2*size)",
      "\tunit := res.id()",
      "\tfor i := int32(0); i < 2*size; i++ {",
      "\t\tlazy[i] = unit",
      "\t}",
      "\tres.n = n",
      "\tres.size = size",
      "\tres.height = height",
      "\tres.lazy = lazy",
      "\tres.unit = unit",
      "\treturn res",
      "}",
      "func (seg *SegmentTreeDual32) Get(index int32) Id {",
      "\tindex += seg.size",
      "\tfor i := seg.height; i > 0; i-- {",
      "\t\tseg.propagate(index >> i)",
      "\t}",
      "\treturn seg.lazy[index]",
      "}",
      "func (seg *SegmentTreeDual32) Set(index int32, value Id) {",
      "\tindex += seg.size",
      "\tfor i := seg.height; i > 0; i-- {",
      "\t\tseg.propagate(index >> i)",
      "\t}",
      "\tseg.lazy[index] = value",
      "}",
      "func (seg *SegmentTreeDual32) GetAll() []Id {",
      "\tfor i := int32(0); i < seg.size; i++ {",
      "\t\tseg.propagate(i)",
      "\t}",
      "\tres := make([]Id, seg.n)",
      "\tcopy(res, seg.lazy[seg.size:seg.size+seg.n])",
      "\treturn res",
      "}",
      "func (seg *SegmentTreeDual32) Update(left, right int32, value Id) {",
      "\tif left < 0 {",
      "\t\tleft = 0",
      "\t}",
      "\tif right > seg.n {",
      "\t\tright = seg.n",
      "\t}",
      "\tif left >= right {",
      "\t\treturn",
      "\t}",
      "\tleft += seg.size",
      "\tright += seg.size",
      "\tif !COMMUTATIVE {",
      "\t\tfor i := seg.height; i > 0; i-- {",
      "\t\t\tif (left>>i)<<i != left {",
      "\t\t\t\tseg.propagate(left >> i)",
      "\t\t\t}",
      "\t\t\tif (right>>i)<<i != right {",
      "\t\t\t\tseg.propagate((right - 1) >> i)",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "\tfor left < right {",
      "\t\tif left&1 > 0 {",
      "\t\t\tseg.lazy[left] = seg.composition(value, seg.lazy[left])",
      "\t\t\tleft++",
      "\t\t}",
      "\t\tif right&1 > 0 {",
      "\t\t\tright--",
      "\t\t\tseg.lazy[right] = seg.composition(value, seg.lazy[right])",
      "\t\t}",
      "\t\tleft >>= 1",
      "\t\tright >>= 1",
      "\t}",
      "}",
      "func (seg *SegmentTreeDual32) propagate(k int32) {",
      "\tif seg.lazy[k] != seg.unit {",
      "\t\tseg.lazy[k<<1] = seg.composition(seg.lazy[k], seg.lazy[k<<1])",
      "\t\tseg.lazy[k<<1|1] = seg.composition(seg.lazy[k], seg.lazy[k<<1|1])",
      "\t\tseg.lazy[k] = seg.unit",
      "\t}",
      "}",
      "func (st *SegmentTreeDual32) String() string {",
      "\tvar buf bytes.Buffer",
      "\tbuf.WriteByte('[')",
      "\tfor i := int32(0); i < st.n; i++ {",
      "\t\tif i > 0 {",
      "\t\t\tbuf.WriteByte(' ')",
      "\t\t}",
      "\t\tbuf.WriteString(fmt.Sprint(st.Get(i)))",
      "\t}",
      "\tbuf.WriteByte(']')",
      "\treturn buf.String()",
      "}"
    ],
    "description": "segDual32"
  },
  "golang线段树lazy": {
    "scope": "go,golang",
    "prefix": ["segLazy"],
    "body": [
      "const INF = 1e18",
      "",
      "// RangeAssignRangeSumMin",
      "",
      "$1",
      "type E = struct{ sum, min int }",
      "type Id = int",
      "",
      "func (*LazySegTree) e() E\t { return E{min: INF} }",
      "func (*LazySegTree) id() Id { return INF }",
      "func (*LazySegTree) op(left, right E) E {",
      "\treturn E{left.sum + right.sum, min(left.min, right.min)}",
      "}",
      "func (*LazySegTree) mapping(f Id, g E, size int) E {",
      "\tif f == INF {",
      "\t\treturn g",
      "\t}",
      "\treturn E{f * size, f}",
      "}",
      "func (*LazySegTree) composition(f, g Id) Id {",
      "\tif f == INF {",
      "\t\treturn g",
      "\t}",
      "\treturn f",
      "}",
      "func min(a, b int) int {",
      "\tif a < b {",
      "\t\treturn a",
      "\t}",
      "\treturn b",
      "}",
      "func max(a, b int) int {",
      "\tif a < b {",
      "\t\treturn b",
      "\t}",
      "\treturn a",
      "}",
      "",
      "// !template",
      "type LazySegTree struct {",
      "\tn\t\tint",
      "\tsize int",
      "\tlog\tint",
      "\tdata []E",
      "\tlazy []Id",
      "}",
      "",
      "func NewLazySegTree(n int, f func(int) E) *LazySegTree {",
      "\ttree := &LazySegTree{}",
      "\ttree.n = n",
      "\ttree.log = int(bits.Len(uint(n - 1)))",
      "\ttree.size = 1 << tree.log",
      "\ttree.data = make([]E, tree.size<<1)",
      "\ttree.lazy = make([]Id, tree.size)",
      "\tfor i := range tree.data {",
      "\t\ttree.data[i] = tree.e()",
      "\t}",
      "\tfor i := range tree.lazy {",
      "\t\ttree.lazy[i] = tree.id()",
      "\t}",
      "\tfor i := 0; i < n; i++ {",
      "\t\ttree.data[tree.size+i] = f(i)",
      "\t}",
      "\tfor i := tree.size - 1; i >= 1; i-- {",
      "\t\ttree.pushUp(i)",
      "\t}",
      "\treturn tree",
      "}",
      "",
      "func NewLazySegTreeFrom(leaves []E) *LazySegTree {",
      "\ttree := &LazySegTree{}",
      "\tn := len(leaves)",
      "\ttree.n = n",
      "\ttree.log = int(bits.Len(uint(n - 1)))",
      "\ttree.size = 1 << tree.log",
      "\ttree.data = make([]E, tree.size<<1)",
      "\ttree.lazy = make([]Id, tree.size)",
      "\tfor i := range tree.data {",
      "\t\ttree.data[i] = tree.e()",
      "\t}",
      "\tfor i := range tree.lazy {",
      "\t\ttree.lazy[i] = tree.id()",
      "\t}",
      "\tfor i := 0; i < n; i++ {",
      "\t\ttree.data[tree.size+i] = leaves[i]",
      "\t}",
      "\tfor i := tree.size - 1; i >= 1; i-- {",
      "\t\ttree.pushUp(i)",
      "\t}",
      "\treturn tree",
      "}",
      "",
      "// 查询切片[left:right]的值",
      "//",
      "//\t0<=left<=right<=len(tree.data)",
      "func (tree *LazySegTree) Query(left, right int) E {",
      "\tif left < 0 {",
      "\t\tleft = 0",
      "\t}",
      "\tif right > tree.n {",
      "\t\tright = tree.n",
      "\t}",
      "\tif left >= right {",
      "\t\treturn tree.e()",
      "\t}",
      "\tleft += tree.size",
      "\tright += tree.size",
      "\tfor i := tree.log; i >= 1; i-- {",
      "\t\tif ((left >> i) << i) != left {",
      "\t\t\ttree.pushDown(left >> i)",
      "\t\t}",
      "\t\tif ((right >> i) << i) != right {",
      "\t\t\ttree.pushDown((right - 1) >> i)",
      "\t\t}",
      "\t}",
      "\tsml, smr := tree.e(), tree.e()",
      "\tfor left < right {",
      "\t\tif left&1 != 0 {",
      "\t\t\tsml = tree.op(sml, tree.data[left])",
      "\t\t\tleft++",
      "\t\t}",
      "\t\tif right&1 != 0 {",
      "\t\t\tright--",
      "\t\t\tsmr = tree.op(tree.data[right], smr)",
      "\t\t}",
      "\t\tleft >>= 1",
      "\t\tright >>= 1",
      "\t}",
      "\treturn tree.op(sml, smr)",
      "}",
      "func (tree *LazySegTree) QueryAll() E {",
      "\treturn tree.data[1]",
      "}",
      "func (tree *LazySegTree) GetAll() []E {",
      "\tfor i := 1; i < tree.size; i++ {",
      "\t\ttree.pushDown(i)",
      "\t}",
      "\tres := make([]E, tree.n)",
      "\tcopy(res, tree.data[tree.size:tree.size+tree.n])",
      "\treturn res",
      "}",
      "",
      "// 更新切片[left:right]的值",
      "//",
      "//\t0<=left<=right<=len(tree.data)",
      "func (tree *LazySegTree) Update(left, right int, f Id) {",
      "\tif left < 0 {",
      "\t\tleft = 0",
      "\t}",
      "\tif right > tree.n {",
      "\t\tright = tree.n",
      "\t}",
      "\tif left >= right {",
      "\t\treturn",
      "\t}",
      "\tleft += tree.size",
      "\tright += tree.size",
      "\tfor i := tree.log; i >= 1; i-- {",
      "\t\tif ((left >> i) << i) != left {",
      "\t\t\ttree.pushDown(left >> i)",
      "\t\t}",
      "\t\tif ((right >> i) << i) != right {",
      "\t\t\ttree.pushDown((right - 1) >> i)",
      "\t\t}",
      "\t}",
      "\tl2, r2 := left, right",
      "\tfor left < right {",
      "\t\tif left&1 != 0 {",
      "\t\t\ttree.propagate(left, f)",
      "\t\t\tleft++",
      "\t\t}",
      "\t\tif right&1 != 0 {",
      "\t\t\tright--",
      "\t\t\ttree.propagate(right, f)",
      "\t\t}",
      "\t\tleft >>= 1",
      "\t\tright >>= 1",
      "\t}",
      "\tleft = l2",
      "\tright = r2",
      "\tfor i := 1; i <= tree.log; i++ {",
      "\t\tif ((left >> i) << i) != left {",
      "\t\t\ttree.pushUp(left >> i)",
      "\t\t}",
      "\t\tif ((right >> i) << i) != right {",
      "\t\t\ttree.pushUp((right - 1) >> i)",
      "\t\t}",
      "\t}",
      "}",
      "",
      "// 二分查询最小的 left 使得切片 [left:right] 内的值满足 predicate",
      "func (tree *LazySegTree) MinLeft(right int, predicate func(data E) bool) int {",
      "\tif right == 0 {",
      "\t\treturn 0",
      "\t}",
      "\tright += tree.size",
      "\tfor i := tree.log; i >= 1; i-- {",
      "\t\ttree.pushDown((right - 1) >> i)",
      "\t}",
      "\tres := tree.e()",
      "\tfor {",
      "\t\tright--",
      "\t\tfor right > 1 && right&1 != 0 {",
      "\t\t\tright >>= 1",
      "\t\t}",
      "\t\tif !predicate(tree.op(tree.data[right], res)) {",
      "\t\t\tfor right < tree.size {",
      "\t\t\t\ttree.pushDown(right)",
      "\t\t\t\tright = right<<1 | 1",
      "\t\t\t\tif tmp := tree.op(tree.data[right], res); predicate(tmp) {",
      "\t\t\t\t\tres = tmp",
      "\t\t\t\t\tright--",
      "\t\t\t\t}",
      "\t\t\t}",
      "\t\t\treturn right + 1 - tree.size",
      "\t\t}",
      "\t\tres = tree.op(tree.data[right], res)",
      "\t\tif (right & -right) == right {",
      "\t\t\tbreak",
      "\t\t}",
      "\t}",
      "\treturn 0",
      "}",
      "",
      "// 二分查询最大的 right 使得切片 [left:right] 内的值满足 predicate",
      "func (tree *LazySegTree) MaxRight(left int, predicate func(data E) bool) int {",
      "\tif left == tree.n {",
      "\t\treturn tree.n",
      "\t}",
      "\tleft += tree.size",
      "\tfor i := tree.log; i >= 1; i-- {",
      "\t\ttree.pushDown(left >> i)",
      "\t}",
      "\tres := tree.e()",
      "\tfor {",
      "\t\tfor left&1 == 0 {",
      "\t\t\tleft >>= 1",
      "\t\t}",
      "\t\tif !predicate(tree.op(res, tree.data[left])) {",
      "\t\t\tfor left < tree.size {",
      "\t\t\t\ttree.pushDown(left)",
      "\t\t\t\tleft <<= 1",
      "\t\t\t\tif tmp := tree.op(res, tree.data[left]); predicate(tmp) {",
      "\t\t\t\t\tres = tmp",
      "\t\t\t\t\tleft++",
      "\t\t\t\t}",
      "\t\t\t}",
      "\t\t\treturn left - tree.size",
      "\t\t}",
      "\t\tres = tree.op(res, tree.data[left])",
      "\t\tleft++",
      "\t\tif (left & -left) == left {",
      "\t\t\tbreak",
      "\t\t}",
      "\t}",
      "\treturn tree.n",
      "}",
      "",
      "// 单点查询(不需要 pushUp/op 操作时使用)",
      "func (tree *LazySegTree) Get(index int) E {",
      "\tindex += tree.size",
      "\tfor i := tree.log; i >= 1; i-- {",
      "\t\ttree.pushDown(index >> i)",
      "\t}",
      "\treturn tree.data[index]",
      "}",
      "",
      "// 单点赋值",
      "func (tree *LazySegTree) Set(index int, e E) {",
      "\tindex += tree.size",
      "\tfor i := tree.log; i >= 1; i-- {",
      "\t\ttree.pushDown(index >> i)",
      "\t}",
      "\ttree.data[index] = e",
      "\tfor i := 1; i <= tree.log; i++ {",
      "\t\ttree.pushUp(index >> i)",
      "\t}",
      "}",
      "",
      "func (tree *LazySegTree) pushUp(root int) {",
      "\ttree.data[root] = tree.op(tree.data[root<<1], tree.data[root<<1|1])",
      "}",
      "func (tree *LazySegTree) pushDown(root int) {",
      "\tif tree.lazy[root] != tree.id() {",
      "\t\ttree.propagate(root<<1, tree.lazy[root])",
      "\t\ttree.propagate(root<<1|1, tree.lazy[root])",
      "\t\ttree.lazy[root] = tree.id()",
      "\t}",
      "}",
      "func (tree *LazySegTree) propagate(root int, f Id) {",
      "\tsize := 1 << (tree.log - (bits.Len32(uint32(root)) - 1) /**topbit**/)",
      "\ttree.data[root] = tree.mapping(f, tree.data[root], size)",
      "\t// !叶子结点不需要更新lazy",
      "\tif root < tree.size {",
      "\t\ttree.lazy[root] = tree.composition(f, tree.lazy[root])",
      "\t}",
      "}",
      "",
      "func (tree *LazySegTree) String() string {",
      "\tvar sb []string",
      "\tsb = append(sb, \"[\")",
      "\tfor i := 0; i < tree.n; i++ {",
      "\t\tif i != 0 {",
      "\t\t\tsb = append(sb, \", \")",
      "\t\t}",
      "\t\tsb = append(sb, fmt.Sprintf(\"%v\", tree.Get(i)))",
      "\t}",
      "\tsb = append(sb, \"]\")",
      "\treturn strings.Join(sb, \"\")",
      "}"
    ],
    "description": "golang线段树lazy"
  },
  "golang线段树lazy-32": {
    "scope": "go,golang",
    "prefix": ["segLazy32"],
    "body": [
      "const INF32 int32 = 1 << 30",
      "",
      "// RangeAssignRangeSumMin",
      "",
      "$1",
      "type E = struct {",
      "\tsum int",
      "\tmin int32",
      "}",
      "",
      "type Id = int32",
      "",
      "func (*LazySegTree32) e() E\t { return E{min: INF32} }",
      "func (*LazySegTree32) id() Id { return INF32 }",
      "func (*LazySegTree32) op(left, right E) E {",
      "\treturn E{left.sum + right.sum, min32(left.min, right.min)}",
      "}",
      "func (*LazySegTree32) mapping(f Id, g E, size int) E {",
      "\tif f == INF32 {",
      "\t\treturn g",
      "\t}",
      "\treturn E{int(f) * size, f}",
      "}",
      "func (*LazySegTree32) composition(f, g Id) Id {",
      "\tif f == INF32 {",
      "\t\treturn g",
      "\t}",
      "\treturn f",
      "}",
      "func min32(a, b int32) int32 {",
      "\tif a < b {",
      "\t\treturn a",
      "\t}",
      "\treturn b",
      "}",
      "func max32(a, b int32) int32 {",
      "\tif a < b {",
      "\t\treturn b",
      "\t}",
      "\treturn a",
      "}",
      "",
      "// !template",
      "type LazySegTree32 struct {",
      "\tn\t\tint32",
      "\tsize int32",
      "\tlog\tint32",
      "\tdata []E",
      "\tlazy []Id",
      "}",
      "",
      "func NewLazySegTree32(n int32, f func(int32) E) *LazySegTree32 {",
      "\ttree := &LazySegTree32{}",
      "\ttree.n = n",
      "\ttree.log = int32(bits.Len32(uint32(n - 1)))",
      "\ttree.size = 1 << tree.log",
      "\ttree.data = make([]E, tree.size<<1)",
      "\ttree.lazy = make([]Id, tree.size)",
      "\tfor i := range tree.data {",
      "\t\ttree.data[i] = tree.e()",
      "\t}",
      "\tfor i := range tree.lazy {",
      "\t\ttree.lazy[i] = tree.id()",
      "\t}",
      "\tfor i := int32(0); i < n; i++ {",
      "\t\ttree.data[tree.size+i] = f(i)",
      "\t}",
      "\tfor i := tree.size - 1; i >= 1; i-- {",
      "\t\ttree.pushUp(i)",
      "\t}",
      "\treturn tree",
      "}",
      "",
      "func NewLazySegTree32From(leaves []E) *LazySegTree32 {",
      "\ttree := &LazySegTree32{}",
      "\tn := int32(len(leaves))",
      "\ttree.n = n",
      "\ttree.log = int32(bits.Len32(uint32(n - 1)))",
      "\ttree.size = 1 << tree.log",
      "\ttree.data = make([]E, tree.size<<1)",
      "\ttree.lazy = make([]Id, tree.size)",
      "\tfor i := range tree.data {",
      "\t\ttree.data[i] = tree.e()",
      "\t}",
      "\tfor i := range tree.lazy {",
      "\t\ttree.lazy[i] = tree.id()",
      "\t}",
      "\tfor i := int32(0); i < n; i++ {",
      "\t\ttree.data[tree.size+i] = leaves[i]",
      "\t}",
      "\tfor i := tree.size - 1; i >= 1; i-- {",
      "\t\ttree.pushUp(i)",
      "\t}",
      "\treturn tree",
      "}",
      "",
      "// 查询切片[left:right]的值",
      "//",
      "//\t0<=left<=right<=len(tree.data)",
      "func (tree *LazySegTree32) Query(left, right int32) E {",
      "\tif left < 0 {",
      "\t\tleft = 0",
      "\t}",
      "\tif right > tree.n {",
      "\t\tright = tree.n",
      "\t}",
      "\tif left >= right {",
      "\t\treturn tree.e()",
      "\t}",
      "\tleft += tree.size",
      "\tright += tree.size",
      "\tfor i := tree.log; i >= 1; i-- {",
      "\t\tif ((left >> i) << i) != left {",
      "\t\t\ttree.pushDown(left >> i)",
      "\t\t}",
      "\t\tif ((right >> i) << i) != right {",
      "\t\t\ttree.pushDown((right - 1) >> i)",
      "\t\t}",
      "\t}",
      "\tsml, smr := tree.e(), tree.e()",
      "\tfor left < right {",
      "\t\tif left&1 != 0 {",
      "\t\t\tsml = tree.op(sml, tree.data[left])",
      "\t\t\tleft++",
      "\t\t}",
      "\t\tif right&1 != 0 {",
      "\t\t\tright--",
      "\t\t\tsmr = tree.op(tree.data[right], smr)",
      "\t\t}",
      "\t\tleft >>= 1",
      "\t\tright >>= 1",
      "\t}",
      "\treturn tree.op(sml, smr)",
      "}",
      "func (tree *LazySegTree32) QueryAll() E {",
      "\treturn tree.data[1]",
      "}",
      "func (tree *LazySegTree32) GetAll() []E {",
      "\tfor i := int32(1); i < tree.size; i++ {",
      "\t\ttree.pushDown(i)",
      "\t}",
      "\tres := make([]E, tree.n)",
      "\tcopy(res, tree.data[tree.size:tree.size+tree.n])",
      "\treturn res",
      "}",
      "",
      "// 更新切片[left:right]的值",
      "//",
      "//\t0<=left<=right<=len(tree.data)",
      "func (tree *LazySegTree32) Update(left, right int32, f Id) {",
      "\tif left < 0 {",
      "\t\tleft = 0",
      "\t}",
      "\tif right > tree.n {",
      "\t\tright = tree.n",
      "\t}",
      "\tif left >= right {",
      "\t\treturn",
      "\t}",
      "\tleft += tree.size",
      "\tright += tree.size",
      "\tfor i := tree.log; i >= 1; i-- {",
      "\t\tif ((left >> i) << i) != left {",
      "\t\t\ttree.pushDown(left >> i)",
      "\t\t}",
      "\t\tif ((right >> i) << i) != right {",
      "\t\t\ttree.pushDown((right - 1) >> i)",
      "\t\t}",
      "\t}",
      "\tl2, r2 := left, right",
      "\tfor left < right {",
      "\t\tif left&1 != 0 {",
      "\t\t\ttree.propagate(left, f)",
      "\t\t\tleft++",
      "\t\t}",
      "\t\tif right&1 != 0 {",
      "\t\t\tright--",
      "\t\t\ttree.propagate(right, f)",
      "\t\t}",
      "\t\tleft >>= 1",
      "\t\tright >>= 1",
      "\t}",
      "\tleft = l2",
      "\tright = r2",
      "\tfor i := int32(1); i <= tree.log; i++ {",
      "\t\tif ((left >> i) << i) != left {",
      "\t\t\ttree.pushUp(left >> i)",
      "\t\t}",
      "\t\tif ((right >> i) << i) != right {",
      "\t\t\ttree.pushUp((right - 1) >> i)",
      "\t\t}",
      "\t}",
      "}",
      "",
      "// 二分查询最小的 left 使得切片 [left:right] 内的值满足 predicate",
      "func (tree *LazySegTree32) MinLeft(right int32, predicate func(data E) bool) int32 {",
      "\tif right == 0 {",
      "\t\treturn 0",
      "\t}",
      "\tright += tree.size",
      "\tfor i := tree.log; i >= 1; i-- {",
      "\t\ttree.pushDown((right - 1) >> i)",
      "\t}",
      "\tres := tree.e()",
      "\tfor {",
      "\t\tright--",
      "\t\tfor right > 1 && right&1 != 0 {",
      "\t\t\tright >>= 1",
      "\t\t}",
      "\t\tif !predicate(tree.op(tree.data[right], res)) {",
      "\t\t\tfor right < tree.size {",
      "\t\t\t\ttree.pushDown(right)",
      "\t\t\t\tright = right<<1 | 1",
      "\t\t\t\tif tmp := tree.op(tree.data[right], res); predicate(tmp) {",
      "\t\t\t\t\tres = tmp",
      "\t\t\t\t\tright--",
      "\t\t\t\t}",
      "\t\t\t}",
      "\t\t\treturn right + 1 - tree.size",
      "\t\t}",
      "\t\tres = tree.op(tree.data[right], res)",
      "\t\tif (right & -right) == right {",
      "\t\t\tbreak",
      "\t\t}",
      "\t}",
      "\treturn 0",
      "}",
      "",
      "// 二分查询最大的 right 使得切片 [left:right] 内的值满足 predicate",
      "func (tree *LazySegTree32) MaxRight(left int32, predicate func(data E) bool) int32 {",
      "\tif left == tree.n {",
      "\t\treturn tree.n",
      "\t}",
      "\tleft += tree.size",
      "\tfor i := tree.log; i >= 1; i-- {",
      "\t\ttree.pushDown(left >> i)",
      "\t}",
      "\tres := tree.e()",
      "\tfor {",
      "\t\tfor left&1 == 0 {",
      "\t\t\tleft >>= 1",
      "\t\t}",
      "\t\tif !predicate(tree.op(res, tree.data[left])) {",
      "\t\t\tfor left < tree.size {",
      "\t\t\t\ttree.pushDown(left)",
      "\t\t\t\tleft <<= 1",
      "\t\t\t\tif tmp := tree.op(res, tree.data[left]); predicate(tmp) {",
      "\t\t\t\t\tres = tmp",
      "\t\t\t\t\tleft++",
      "\t\t\t\t}",
      "\t\t\t}",
      "\t\t\treturn left - tree.size",
      "\t\t}",
      "\t\tres = tree.op(res, tree.data[left])",
      "\t\tleft++",
      "\t\tif (left & -left) == left {",
      "\t\t\tbreak",
      "\t\t}",
      "\t}",
      "\treturn tree.n",
      "}",
      "",
      "// 单点查询(不需要 pushUp/op 操作时使用)",
      "func (tree *LazySegTree32) Get(index int32) E {",
      "\tindex += tree.size",
      "\tfor i := tree.log; i >= 1; i-- {",
      "\t\ttree.pushDown(index >> i)",
      "\t}",
      "\treturn tree.data[index]",
      "}",
      "",
      "// 单点赋值",
      "func (tree *LazySegTree32) Set(index int32, e E) {",
      "\tindex += tree.size",
      "\tfor i := tree.log; i >= 1; i-- {",
      "\t\ttree.pushDown(index >> i)",
      "\t}",
      "\ttree.data[index] = e",
      "\tfor i := int32(1); i <= tree.log; i++ {",
      "\t\ttree.pushUp(index >> i)",
      "\t}",
      "}",
      "",
      "func (tree *LazySegTree32) pushUp(root int32) {",
      "\ttree.data[root] = tree.op(tree.data[root<<1], tree.data[root<<1|1])",
      "}",
      "func (tree *LazySegTree32) pushDown(root int32) {",
      "\tif tree.lazy[root] != tree.id() {",
      "\t\ttree.propagate(root<<1, tree.lazy[root])",
      "\t\ttree.propagate(root<<1|1, tree.lazy[root])",
      "\t\ttree.lazy[root] = tree.id()",
      "\t}",
      "}",
      "func (tree *LazySegTree32) propagate(root int32, f Id) {",
      "\tsize := 1 << (tree.log - int32((bits.Len32(uint32(root)) - 1)) /**topbit**/)",
      "\ttree.data[root] = tree.mapping(f, tree.data[root], size)",
      "\t// !叶子结点不需要更新lazy",
      "\tif root < tree.size {",
      "\t\ttree.lazy[root] = tree.composition(f, tree.lazy[root])",
      "\t}",
      "}",
      "",
      "func (tree *LazySegTree32) String() string {",
      "\tvar sb []string",
      "\tsb = append(sb, \"[\")",
      "\tfor i := int32(0); i < tree.n; i++ {",
      "\t\tif i != 0 {",
      "\t\t\tsb = append(sb, \", \")",
      "\t\t}",
      "\t\tsb = append(sb, fmt.Sprintf(\"%v\", tree.Get(i)))",
      "\t}",
      "\tsb = append(sb, \"]\")",
      "\treturn strings.Join(sb, \"\")",
      "}"
    ],
    "description": "segLazy32"
  },
  "golang线段树动态开点": {
    "scope": "go,golang",
    "prefix": ["segDynamic"],
    "body": [
      "// PointAddRangeSum",
      "$1",
      "type E = int",
      "func e() E { return 0 }",
      "func op(a, b E) E { return a + b }",
      "type DynamicSegTreeSparse struct {",
      "  L, R       int",
      "  persistent bool",
      "  unit       E",
      "}",
      "type SegNode struct {",
      "  idx     int",
      "  l, r    *SegNode",
      "  x, prod E",
      "}",
      "// 指定 [left,right) 区间建立动态开点线段树.",
      "func NewDynamicSegTreeSparse(left, right int, persistent bool) *DynamicSegTreeSparse {",
      "  return &DynamicSegTreeSparse{",
      "    L: left,",
      "    R: right,",
      "    persistent: persistent,",
      "    unit: e(),",
      "  }",
      "}",
      "func (ds *DynamicSegTreeSparse) NewRoot() *SegNode { return nil }",
      "// 查询区间 [left, right).",
      "// L<=left<=right<=R",
      "func (ds *DynamicSegTreeSparse) Query(root *SegNode, left, right int) E {",
      "  if left == right {",
      "    return ds.unit",
      "  }",
      "  x := ds.unit",
      "  ds._queryRec(root, ds.L, ds.R, left, right, &x)",
      "  return x",
      "}",
      "func (ds *DynamicSegTreeSparse) QueryAll(root *SegNode) E {",
      "  return ds.Query(root, ds.L, ds.R)",
      "}",
      "// L<=index<R",
      "func (ds *DynamicSegTreeSparse) Set(root *SegNode, index int, value E) *SegNode {",
      "  return ds._setRec(root, ds.L, ds.R, index, value)",
      "}",
      "func (ds *DynamicSegTreeSparse) Get(root *SegNode, index int) E {",
      "  return ds._getRec(root, index)",
      "}",
      "// L<=left<R",
      "func (ds *DynamicSegTreeSparse) Update(root *SegNode, index int, value E) *SegNode {",
      "  return ds._updateRec(root, ds.L, ds.R, index, value)",
      "}",
      "// 二分查询最小的 left 使得切片 [left:right] 内的值满足 check.",
      "// L<=right<=R",
      "func (ds *DynamicSegTreeSparse) MinLeft(root *SegNode, right int, check func(E) bool) int {",
      "  x := ds.unit",
      "  return ds._minLeftRec(root, ds.L, ds.R, right, check, &x)",
      "}",
      "// 二分查询最大的 right 使得切片 [left:right] 内的值满足 check.",
      "// L<=left<=R",
      "func (ds *DynamicSegTreeSparse) MaxRight(root *SegNode, left int, check func(E) bool) int {",
      "  x := ds.unit",
      "  return ds._maxRightRec(root, ds.L, ds.R, left, check, &x)",
      "}",
      "func (ds *DynamicSegTreeSparse) GetAll(root *SegNode) []struct {",
      "  index int",
      "  value E",
      "} {",
      "  res := make([]struct {",
      "    index int",
      "    value E",
      "  }, 0)",
      "  ds._getAllRec(root, &res)",
      "  return res",
      "}",
      "func (ds *DynamicSegTreeSparse) _pushUp(node *SegNode) {",
      "  node.prod = node.x",
      "  if node.l != nil {",
      "    node.prod = op(node.l.prod, node.prod)",
      "  }",
      "  if node.r != nil {",
      "    node.prod = op(node.prod, node.r.prod)",
      "  }",
      "}",
      "func (ds *DynamicSegTreeSparse) _newNode(idx int, x E) *SegNode {",
      "  return &SegNode{idx: idx, x: x, prod: x}",
      "}",
      "func (ds *DynamicSegTreeSparse) _copyNode(node *SegNode) *SegNode {",
      "  if node == nil || !ds.persistent {",
      "    return node",
      "  }",
      "  return &SegNode{idx: node.idx, l: node.l, r: node.r, x: node.x, prod: node.prod}",
      "}",
      "func (ds *DynamicSegTreeSparse) _setRec(root *SegNode, l, r, i int, x E) *SegNode {",
      "  if root == nil {",
      "    root = ds._newNode(i, x)",
      "    return root",
      "  }",
      "  root = ds._copyNode(root)",
      "  if root.idx == i {",
      "    root.x = x",
      "    ds._pushUp(root)",
      "    return root",
      "  }",
      "  m := (l + r) >> 1",
      "  if i < m {",
      "    if root.idx < i {",
      "      root.idx, i = i, root.idx",
      "      root.x, x = x, root.x",
      "    }",
      "    root.l = ds._setRec(root.l, l, m, i, x)",
      "  } else {",
      "    if i < root.idx {",
      "      root.idx, i = i, root.idx",
      "      root.x, x = x, root.x",
      "    }",
      "    root.r = ds._setRec(root.r, m, r, i, x)",
      "  }",
      "  ds._pushUp(root)",
      "  return root",
      "}",
      "func (ds *DynamicSegTreeSparse) _updateRec(root *SegNode, l, r, i int, x E) *SegNode {",
      "  if root == nil {",
      "    root = ds._newNode(i, x)",
      "    return root",
      "  }",
      "  root = ds._copyNode(root)",
      "  if root.idx == i {",
      "    root.x = op(root.x, x)",
      "    ds._pushUp(root)",
      "    return root",
      "  }",
      "  m := (l + r) >> 1",
      "  if i < m {",
      "    if root.idx < i {",
      "      root.idx, i = i, root.idx",
      "      root.x, x = x, root.x",
      "    }",
      "    root.l = ds._updateRec(root.l, l, m, i, x)",
      "  } else {",
      "    if i < root.idx {",
      "      root.idx, i = i, root.idx",
      "      root.x, x = x, root.x",
      "    }",
      "    root.r = ds._updateRec(root.r, m, r, i, x)",
      "  }",
      "  ds._pushUp(root)",
      "  return root",
      "}",
      "func (ds *DynamicSegTreeSparse) _queryRec(root *SegNode, l, r, ql, qr int, x *E) {",
      "  ql = max(ql, l)",
      "  qr = min(qr, r)",
      "  if ql >= qr || root == nil {",
      "    return",
      "  }",
      "  if l == ql && r == qr {",
      "    *x = op(*x, root.prod)",
      "    return",
      "  }",
      "  m := (l + r) >> 1",
      "  ds._queryRec(root.l, l, m, ql, qr, x)",
      "  if ql <= root.idx && root.idx < qr {",
      "    *x = op(*x, root.x)",
      "  }",
      "  ds._queryRec(root.r, m, r, ql, qr, x)",
      "}",
      "func (ds *DynamicSegTreeSparse) _minLeftRec(root *SegNode, l, r, qr int, check func(E) bool, x *E) int {",
      "  if root == nil || qr <= l {",
      "    return ds.L",
      "  }",
      "  if check(op(root.prod, *x)) {",
      "    *x = op(root.prod, *x)",
      "    return ds.L",
      "  }",
      "  m := (l + r) >> 1",
      "  k := ds._minLeftRec(root.r, m, r, qr, check, x)",
      "  if k != ds.L {",
      "    return k",
      "  }",
      "  if root.idx < qr {",
      "    *x = op(root.x, *x)",
      "    if !check(*x) {",
      "      return root.idx + 1",
      "    }",
      "  }",
      "  return ds._minLeftRec(root.l, l, m, qr, check, x)",
      "}",
      "func (ds *DynamicSegTreeSparse) _maxRightRec(root *SegNode, l, r, ql int, check func(E) bool, x *E) int {",
      "  if root == nil || r <= ql {",
      "    return ds.R",
      "  }",
      "  if check(op(*x, root.prod)) {",
      "    *x = op(*x, root.prod)",
      "    return ds.R",
      "  }",
      "  m := (l + r) >> 1",
      "  k := ds._maxRightRec(root.l, l, m, ql, check, x)",
      "  if k != ds.R {",
      "    return k",
      "  }",
      "  if ql <= root.idx {",
      "    *x = op(*x, root.x)",
      "    if !check(*x) {",
      "      return root.idx",
      "    }",
      "  }",
      "  return ds._maxRightRec(root.r, m, r, ql, check, x)",
      "}",
      "func (ds *DynamicSegTreeSparse) _getAllRec(root *SegNode, res *[]struct {",
      "  index int",
      "  value E",
      "}) {",
      "  if root == nil {",
      "    return",
      "  }",
      "  ds._getAllRec(root.l, res)",
      "  *res = append(*res, struct {",
      "    index int",
      "    value E",
      "  }{root.idx, root.x})",
      "  ds._getAllRec(root.r, res)",
      "}",
      "func (ds *DynamicSegTreeSparse) _getRec(root *SegNode, idx int) E {",
      "  if root == nil {",
      "    return ds.unit",
      "  }",
      "  if idx == root.idx {",
      "    return root.x",
      "  }",
      "  if idx < root.idx {",
      "    return ds._getRec(root.l, idx)",
      "  }",
      "  return ds._getRec(root.r, idx)",
      "}",
      "func min(a, b int) int {",
      "  if a < b {",
      "    return a",
      "  }",
      "  return b",
      "}",
      "func max(a, b int) int {",
      "  if a > b {",
      "    return a",
      "  }",
      "  return b",
      "}"
    ],
    "description": "golang线段树动态开点,区间查询,单点修改"
  },
  "golang线段树动态开点lazy": {
    "scope": "go,golang",
    "prefix": ["segDynamicLazy"],
    "body": [
      "// RangeAssignRangeSum",
      "$1",
      "type E = int",
      "type Id = int",
      "func e1() E                { return 0 }",
      "func e2(left, right int) E { return 0 } // default query value",
      "func id() Id               { return -1 }",
      "func op(a, b E) E          { return a + b }",
      "func mapping(f Id, g E, size int) E {",
      " if f == -1 {",
      " return g",
      " }",
      " return f * size",
      "}",
      "func composition(f, g Id) Id {",
      " if f == -1 {",
      " return g",
      " }",
      " return f",
      "}",
      "type DynamicSegTreeLazy struct {",
      "  L, R       int",
      "  persistent bool",
      "  dataUnit   E",
      "  lazyUnit   Id",
      "}",
      "type SegNode struct {",
      "  l, r *SegNode",
      "  x    E",
      "  lazy Id",
      "}",
      "func NewDynamicSegTreeLazy(left, right int, persistent bool) *DynamicSegTreeLazy {",
      "  return &DynamicSegTreeLazy{",
      "    L:          left,",
      "    R:          right,",
      "    persistent: persistent,",
      "    dataUnit:   e1(),",
      "    lazyUnit:   id(),",
      "  }",
      "}",
      "func (ds *DynamicSegTreeLazy) NewRoot() *SegNode {",
      "  return &SegNode{x: e2(ds.L, ds.R), lazy: ds.lazyUnit}",
      "}",
      "func (ds *DynamicSegTreeLazy) Build(nums []E) *SegNode {",
      "  return ds._buildRec(0, len(nums), nums)",
      "}",
      "// L<=left<=right<=R",
      "func (ds *DynamicSegTreeLazy) Query(root *SegNode, left, right int) E {",
      "  if left == right {",
      "    return ds.dataUnit",
      "  }",
      "  x := ds.dataUnit",
      "  ds._queryRec(root, ds.L, ds.R, left, right, &x, ds.lazyUnit)",
      "  return x",
      "}",
      "func (ds *DynamicSegTreeLazy) QueryAll(root *SegNode) E {",
      "  return root.x",
      "}",
      "// L<=index<R",
      "func (ds *DynamicSegTreeLazy) Set(root *SegNode, index int, value E) *SegNode {",
      "  return ds._setRec(root, ds.L, ds.R, index, value)",
      "}",
      "// L<=left<R",
      "func (ds *DynamicSegTreeLazy) Update(root *SegNode, index int, value E) *SegNode {",
      "  return ds._updateRec(root, ds.L, ds.R, index, value)",
      "}",
      "// L<=left<=right<=R",
      "func (ds *DynamicSegTreeLazy) UpdateRange(root *SegNode, left, right int, lazy Id) *SegNode {",
      "  if left == right {",
      "    return root",
      "  }",
      "  return ds._updateRangeRec(root, ds.L, ds.R, left, right, lazy)",
      "}",
      "// 二分查询最大的 right 使得切片 [left:right] 内的值满足 check.",
      "// L<=right<=R",
      "func (ds *DynamicSegTreeLazy) MinLeft(root *SegNode, right int, check func(E) bool) int {",
      "  x := ds.dataUnit",
      "  return ds._minLeftRec(root, ds.L, ds.R, right, check, &x)",
      "}",
      "// 二分查询最小的 left 使得切片 [left:right] 内的值满足 check.",
      "// L<=left<=R",
      "func (ds *DynamicSegTreeLazy) MaxRight(root *SegNode, left int, check func(E) bool) int {",
      "  x := ds.dataUnit",
      "  return ds._maxRightRec(root, ds.L, ds.R, left, check, &x)",
      "}",
      "func (ds *DynamicSegTreeLazy) GetAll(root *SegNode) []E {",
      "  res := make([]E, 0, ds.R-ds.L)",
      "  ds._getAllRec(root, ds.L, ds.R, &res, ds.lazyUnit)",
      "  return res",
      "}",
      "func (ds *DynamicSegTreeLazy) _newNode(left, right int) *SegNode {",
      "return &SegNode{x: e2(left, right), lazy: ds.lazyUnit}",
      "}",
      "",
      "func (ds *DynamicSegTreeLazy) _newNodeWithValue(x E) *SegNode {",
      "return &SegNode{x: x, lazy: ds.lazyUnit}",
      "}",
      "",
      "func (ds *DynamicSegTreeLazy) _copyNode(node *SegNode) *SegNode {",
      "if node == nil || !ds.persistent {",
      "return node",
      "}",
      "return &SegNode{l: node.l, r: node.r, x: node.x, lazy: node.lazy}",
      "}",
      "",
      "func (ds *DynamicSegTreeLazy) _pushDown(node *SegNode, l, r int) {",
      "m := (l + r) >> 1",
      "if node.lazy == ds.lazyUnit {",
      "return",
      "}",
      "if node.l == nil {",
      "node.l = ds._newNode(l, m)",
      "} else {",
      "node.l = ds._copyNode(node.l)",
      "}",
      "node.l.x = mapping(node.lazy, node.l.x, m-l)",
      "node.l.lazy = composition(node.lazy, node.l.lazy)",
      "if node.r == nil {",
      "node.r = ds._newNode(m, r)",
      "} else {",
      "node.r = ds._copyNode(node.r)",
      "}",
      "node.r.x = mapping(node.lazy, node.r.x, r-m)",
      "node.r.lazy = composition(node.lazy, node.r.lazy)",
      "node.lazy = ds.lazyUnit",
      "}",
      "func (ds *DynamicSegTreeLazy) _buildRec(left, right int, nums []E) *SegNode {",
      "if left == right {",
      "return nil",
      "}",
      "if right == left+1 {",
      "return ds._newNodeWithValue(nums[left])",
      "}",
      "mid := (left + right) >> 1",
      "lRoot := ds._buildRec(left, mid, nums)",
      "rRoot := ds._buildRec(mid, right, nums)",
      "x := op(lRoot.x, rRoot.x)",
      "root := ds._newNodeWithValue(x)",
      "root.l = lRoot",
      "root.r = rRoot",
      "return root",
      "}",
      "",
      "func (ds *DynamicSegTreeLazy) _setRec(root *SegNode, l, r, i int, x E) *SegNode {",
      "if l == r-1 {",
      "root = ds._copyNode(root)",
      "root.x = x",
      "root.lazy = ds.lazyUnit",
      "return root",
      "}",
      "ds._pushDown(root, l, r)",
      "m := (l + r) >> 1",
      "if root.l == nil {",
      "root.l = ds._newNode(l, m)",
      "}",
      "if root.r == nil {",
      "root.r = ds._newNode(m, r)",
      "}",
      "root = ds._copyNode(root)",
      "if i < m {",
      "root.l = ds._setRec(root.l, l, m, i, x)",
      "} else {",
      "root.r = ds._setRec(root.r, m, r, i, x)",
      "}",
      "root.x = op(root.l.x, root.r.x)",
      "return root",
      "}",
      "",
      "func (ds *DynamicSegTreeLazy) _updateRec(root *SegNode, l, r, i int, x E) *SegNode {",
      "if l == r-1 {",
      "root = ds._copyNode(root)",
      "root.x = op(root.x, x)",
      "root.lazy = ds.lazyUnit",
      "return root",
      "}",
      "ds._pushDown(root, l, r)",
      "m := (l + r) >> 1",
      "if root.l == nil {",
      "root.l = ds._newNode(l, m)",
      "}",
      "if root.r == nil {",
      "root.r = ds._newNode(m, r)",
      "}",
      "root = ds._copyNode(root)",
      "if i < m {",
      "root.l = ds._updateRec(root.l, l, m, i, x)",
      "} else {",
      "root.r = ds._updateRec(root.r, m, r, i, x)",
      "}",
      "root.x = op(root.l.x, root.r.x)",
      "return root",
      "}",
      "",
      "func (ds *DynamicSegTreeLazy) _queryRec(root *SegNode, l, r, ql, qr int, x *E, lazy Id) {",
      "ql = max(ql, l)",
      "qr = min(qr, r)",
      "if ql >= qr {",
      "return",
      "}",
      "if root == nil {",
      "*x = op(*x, mapping(lazy, e2(ql, qr), qr-ql))",
      "return",
      "}",
      "if l == ql && r == qr {",
      "*x = op(*x, mapping(lazy, root.x, r-l))",
      "return",
      "}",
      "m := (l + r) >> 1",
      "lazy = composition(lazy, root.lazy)",
      "ds._queryRec(root.l, l, m, ql, qr, x, lazy)",
      "ds._queryRec(root.r, m, r, ql, qr, x, lazy)",
      "}",
      "",
      "func (ds *DynamicSegTreeLazy) _updateRangeRec(root *SegNode, l, r, ql, qr int, lazy Id) *SegNode {",
      "if root == nil {",
      "root = ds._newNode(l, r)",
      "}",
      "ql = max(ql, l)",
      "qr = min(qr, r)",
      "if ql >= qr {",
      "return root",
      "}",
      "if l == ql && r == qr {",
      "root = ds._copyNode(root)",
      "root.x = mapping(lazy, root.x, r-l)",
      "root.lazy = composition(lazy, root.lazy)",
      "return root",
      "}",
      "ds._pushDown(root, l, r)",
      "m := (l + r) >> 1",
      "root = ds._copyNode(root)",
      "root.l = ds._updateRangeRec(root.l, l, m, ql, qr, lazy)",
      "root.r = ds._updateRangeRec(root.r, m, r, ql, qr, lazy)",
      "root.x = op(root.l.x, root.r.x)",
      "return root",
      "}",
      "",
      "func (ds *DynamicSegTreeLazy) _minLeftRec(root *SegNode, l, r, qr int, check func(E) bool, x *E) int {",
      "if qr <= l {",
      "return l",
      "}",
      "if root == nil {",
      "root = ds._newNode(l, r)",
      "}",
      "qr = min(qr, r)",
      "if r == qr && check(op(root.x, *x)) {",
      "*x = op(root.x, *x)",
      "return l",
      "}",
      "if r == l+1 {",
      "return r",
      "}",
      "ds._pushDown(root, l, r)",
      "m := (l + r) >> 1",
      "k := ds._minLeftRec(root.r, m, r, qr, check, x)",
      "if m < k {",
      "return k",
      "}",
      "return ds._minLeftRec(root.l, l, m, qr, check, x)",
      "}",
      "",
      "func (ds *DynamicSegTreeLazy) _maxRightRec(root *SegNode, l, r, ql int, check func(E) bool, x *E) int {",
      "if r <= ql {",
      "return r",
      "}",
      "if root == nil {",
      "root = ds._newNode(l, r)",
      "}",
      "ql = max(ql, l)",
      "if l == ql && check(op(*x, root.x)) {",
      "*x = op(*x, root.x)",
      "return r",
      "}",
      "if r == l+1 {",
      "return l",
      "}",
      "ds._pushDown(root, l, r)",
      "m := (l + r) >> 1",
      "k := ds._maxRightRec(root.l, l, m, ql, check, x)",
      "if m > k {",
      "return k",
      "}",
      "return ds._maxRightRec(root.r, m, r, ql, check, x)",
      "}",
      "",
      "func (ds *DynamicSegTreeLazy) _getAllRec(root *SegNode, l, r int, res *[]E, lazy Id) {",
      "if root == nil {",
      "root = ds._newNode(l, r)",
      "}",
      "if r-l == 1 {",
      "*res = append(*res, mapping(lazy, root.x, 1))",
      "return",
      "}",
      "m := (l + r) >> 1",
      "lazy = composition(lazy, root.lazy)",
      "ds._getAllRec(root.l, l, m, res, lazy)",
      "ds._getAllRec(root.r, m, r, res, lazy)",
      "}",
      "",
      "func min(a, b int) int {",
      "if a < b {",
      "return a",
      "}",
      "return b",
      "}",
      "",
      "func max(a, b int) int {",
      "if a > b {",
      "return a",
      "}",
      "return b",
      "}"
    ],
    "description": "golang线段树动态开点lazy,区间查询,区间修改"
  },
  "ts离散化(松离散)": {
    "scope": "ts,typescript",
    "prefix": ["sortedSet", "discretizeSparse"],
    "body": [
      "/**",
      " * (松)离散化.",
      " * @param offset 离散化后的排名偏移量.",
      " * @returns",
      " * - getRank: 给定一个数,返回它的排名`(offset ~ offset + count)`.",
      " * - count: 离散化(去重)后的元素个数.",
      " */",
      "function discretizeSparse(",
      "\tnums: number[],",
      "\toffset = 0",
      "): [getRank: (num: number) => number, count: number] {",
      "\tconst allNums = [...new Set(nums)].sort((a, b) => a - b)",
      "",
      "\t// bisect_left",
      "\tconst getRank = (num: number): number => {",
      "\t\tlet left = 0",
      "\t\tlet right = allNums.length - 1",
      "\t\twhile (left <= right) {",
      "\t\t\tconst mid = (left + right) >>> 1",
      "\t\t\tif (allNums[mid] >= num) {",
      "\t\t\t\tright = mid - 1",
      "\t\t\t} else {",
      "\t\t\t\tleft = mid + 1",
      "\t\t\t}",
      "\t\t}",
      "\t\treturn left + offset",
      "\t}",
      "\treturn [getRank, allNums.length]",
      "}"
    ],
    "description": "ts离散化(松离散)"
  },
  "ts离散化2(紧离散)": {
    "scope": "ts,typescript",
    "prefix": ["sortedSet", "discretizeCompressed"],
    "body": [
      "/**",
      " * (紧)离散化.",
      " * @param offset 离散化后的排名偏移量.",
      " * @returns",
      " * - getRank: 给定一个数,返回它的排名`(offset ~ offset + count)`.",
      " * - count: 离散化(去重)后的元素个数.",
      " */",
      "function discretizeCompressed(nums: number[], offset = 0): [getRank: (num: number) => number, getValue: (rank: number) => number, count: number] {",
      "\tconst allNums = [...new Set(nums)].sort((a, b) => a - b)",
      "\tconst mp = new Map<number, number>()",
      "\tfor (let index = 0; index < allNums.length; index++) mp.set(allNums[index], index + offset)",
      "\tconst getRank = (num: number) => mp.get(num)!",
      "\tconst getValue = (rank: number) => allNums[rank - offset]",
      "\treturn [getRank, getValue, allNums.length]",
      "}"
    ],
    "description": "ts离散化2(紧离散)"
  },
  "gcd": {
    "scope": "go,golang",
    "prefix": "gcd",
    "body": [
      "func gcd(a, b int) int {",
      "  for b != 0 {",
      "    a, b = b, a%b",
      "  }",
      "  return a",
      "}"
    ],
    "description": "golang最大公约数"
  },
  "binaryGcd": {
    "scope": "go,golang",
    "prefix": ["gcd", "binaryGcd"],
    "body": [
      "func binaryGcd(a, b int) int {",
      "  // 取绝对值",
      "  x, y := a, b",
      "  if x < 0 {",
      "    x = -x",
      "  }",
      "  if y < 0 {",
      "    y = -y",
      "  }",
      "  if x == 0 || y == 0 {",
      "    return x + y",
      "  }",
      "  n := bits.TrailingZeros(uint(x))",
      "  m := bits.TrailingZeros(uint(y))",
      "  x >>= n",
      "  y >>= m",
      "  for x != y {",
      "    d := bits.TrailingZeros(uint(x - y))",
      "    f := x > y",
      "    var c int",
      "    if f {",
      "      c = x",
      "    } else {",
      "      c = y",
      "    }",
      "    if !f {",
      "      y = x",
      "    }",
      "    x = (c - y) >> d",
      "  }",
      "  return x << min(n, m)",
      "}",
      "func min(a, b int) int {",
      "  if a < b {",
      "    return a",
      "  }",
      "  return b",
      "}"
    ],
    "description": "golang binaryGcd"
  },
  "Monoid-Affine": {
    "scope": "go,golang",
    "prefix": ["affine", "仿射变换", "monoid-affine"],
    "body": [
      "const MOD int = 1e9 + 7",
      "type E = struct{ mul, add int }",
      "const IS_COMMUTATIVE = false        // 仿射变换群不满足交换律",
      "func e() E          { return E{1, 0} }",
      "func op(e1, e2 E) E { return E{e1.mul * e2.mul % MOD, (e1.add*e2.mul + e2.add) % MOD} }"
    ],
    "description": "仿射变换"
  },
  "affine": {
    "scope": "go,golang",
    "prefix": "affine",
    "body": [
      "",
      "const INF int = 1e18",
      "",
      "const MOD int = 998244353",
      "",
      "type E = struct{ mul, add int }",
      "",
      "const IS_COMMUTATIVE = false // 仿射变换群不满足交换律",
      "func e() E {",
      "\treturn E{1, 0}",
      "}",
      "func op(e1, e2 E) E {",
      "\treturn E{e1.mul * e2.mul % MOD, (e1.add*e2.mul + e2.add) % MOD}",
      "}",
      "func inv(e E) E { // 仿射变换逆元",
      "\tmul, add := e.mul, e.add",
      "\tmul = modPow(mul, MOD-2, MOD) // modInv of mul",
      "\treturn E{mul, mul * (MOD - add) % MOD}",
      "}",
      "func pow(e E, x int) E {",
      "\tres := E{1, 0}",
      "\tfor x > 0 {",
      "\t\tif x&1 == 1 {",
      "\t\t\tres = op(res, e)",
      "\t\t}",
      "\t\te = op(e, e)",
      "\t\tx >>= 1",
      "\t}",
      "\treturn res",
      "}",
      "func eval(e E, x int) int {",
      "\treturn (e.mul*x + e.add) % MOD",
      "}",
      "",
      "func modPow(x, n, mod int) int {",
      "\tres := 1",
      "\tfor n > 0 {",
      "\t\tif n&1 == 1 {",
      "\t\t\tres = res * x % mod",
      "\t\t}",
      "\t\tx = x * x % mod",
      "\t\tn >>= 1",
      "\t}",
      "\treturn res",
      "}"
    ],
    "description": "affine"
  },
  "Monoid-Sum": {
    "scope": "go,golang",
    "prefix": ["Monoid-Sum"],
    "body": [
      "type E = struct{ sum, size int }",
      "type Id = int",
      "",
      "func e() E                   { return E{0, 0} }",
      "func id() Id                 { return 0 }",
      "func op(e1, e2 E) E          { return E{e1.sum + e2.sum, e1.size + e2.size} }",
      "func mapping(f Id, g E) E    { return E{g.sum + f*g.size, g.size} }",
      "func composition(f, g Id) Id { return f + g }"
    ]
  },
  "argSort": {
    "scope": "go,golang",
    "prefix": ["argSort"],
    "body": [
      "func argSort(n int32, less func(i, j int32) bool) (order []int32) {",
      "\torder = make([]int32, n)",
      "\tfor i := range order {",
      "\t\torder[i] = int32(i)",
      "\t}",
      "\tsort.Slice(order, func(i, j int) bool { return less(order[i], order[j]) })",
      "\treturn",
      "}",
      "",
      "func reArrage[T any](nums []T, order []int32) []T {",
      "\tres := make([]T, len(order))",
      "\tfor i := range order {",
      "\t\tres[i] = nums[order[i]]",
      "\t}",
      "\treturn res",
      "}"
    ],
    "description": "将0-n-1按照less排序"
  },
  "reArrange": {
    "scope": "go,golang",
    "prefix": ["reArrange"],
    "body": [
      "func reArrage[T any](arr []T, order []int) []T {",
      "\tres := make([]T, len(order))",
      "\tfor i := range order {",
      "\t\tres[i] = arr[order[i]]",
      "\t}",
      "\treturn res",
      "}"
    ],
    "description": "将arr按照order的顺序重新排列"
  },

  "bisectLeft": {
    "scope": "go,golang",
    "prefix": ["bisectLeft", "lowerBound"],
    "body": [
      "// Find the index of the first element that is not less than x.",
      "//",
      "//\tsort.SearchInts/LowerBound.",
      "func BisectLeft[T int | int32](nums []T, x T) int32 {",
      "\tleft, right := int32(0), int32(len(nums)-1)",
      "\tfor left <= right {",
      "\t\tmid := (left + right) >> 1",
      "\t\tif nums[mid] < x {",
      "\t\t\tleft = mid + 1",
      "\t\t} else {",
      "\t\t\tright = mid - 1",
      "\t\t}",
      "\t}",
      "\treturn left",
      "}",
      "",
      "// Find the index of the first element that is not less than x in the range [left, right].",
      "//",
      "//\tsort.SearchInts/LowerBound.",
      "func BisectLeftRange[T int | int32, S int | int32](nums []T, x T, left, right S) S {",
      "\tfor left <= right {",
      "\t\tmid := (left + right) >> 1",
      "\t\tif nums[mid] < x {",
      "\t\t\tleft = mid + 1",
      "\t\t} else {",
      "\t\t\tright = mid - 1",
      "\t\t}",
      "\t}",
      "\treturn left",
      "}"
    ],
    "description": "二分查找左边界,相当于sort.SearchInts或者lowerBound"
  },
  "bisectRight": {
    "scope": "go,golang",
    "prefix": ["bisectRight", "upperBound"],
    "body": [
      "// Find the index of the first element that is greater than x.",
      "//",
      "//\tUpperBound.",
      "func BisectRight[T int | int32](nums []T, x T) int32 {",
      "\tleft, right := int32(0), int32(len(nums)-1)",
      "\tfor left <= right {",
      "\t\tmid := (left + right) >> 1",
      "\t\tif nums[mid] <= x {",
      "\t\t\tleft = mid + 1",
      "\t\t} else {",
      "\t\t\tright = mid - 1",
      "\t\t}",
      "\t}",
      "\treturn left",
      "}",
      "",
      "// Find the index of the first element that is greater than x in the range [left, right].",
      "//",
      "//\tUpperBound.",
      "func BisectRightRange[T int | int32, S int | int32](nums []T, x T, left, right S) S {",
      "\tfor left <= right {",
      "\t\tmid := (left + right) >> 1",
      "\t\tif nums[mid] <= x {",
      "\t\t\tleft = mid + 1",
      "\t\t} else {",
      "\t\t\tright = mid - 1",
      "\t\t}",
      "\t}",
      "\treturn left",
      "}"
    ],
    "description": "二分查找右边界,相当于upperBound"
  },
  "遍历区间的距离": {
    "scope": "python",
    "prefix": ["调头距离", "calDist"],
    "body": [
      "def calDist(start: int, left: int, right: int) -> int:",
      "  '''从start出发,遍历[leftMost,rightMost]区间的最短距离(最多调头一次)'''",
      "  leftMax = max(0, start - left)",
      "  rightMax = max(0, right - start)",
      "  return min(2 * leftMax + rightMax, 2 * rightMax + leftMax)"
    ],
    "description": "遍历区间的距离"
  },
  "斐波那契数列第k项": {
    "scope": "python",
    "prefix": ["斐波那契数列第k项", "fibonacci"],
    "body": [
      "def kthFibonacci(k: int) -> int:",
      "  '''斐波那契数列前k(0-indexed)项:0,1,1,2,3,5...'''",
      "  f, res = (0, 1), (1, 0)",
      "  while k:",
      "    a, b = f",
      "    c, d = res",
      "    if k & 1:",
      "      res = ((a * c + b * d) % MOD, (b * c + (a + b) * d) % MOD)",
      "    f = ((a * a + b * b) % MOD, (b * (a + a + b)) % MOD)",
      "    k >>= 1",
      "  return res[1]"
    ],
    "description": "斐波那契数列第k项"
  },

  "forSubset": {
    "scope": "typescript",
    "prefix": ["forSubset", "subset"],
    "body": [
      "const state = 0b1101",
      "for (let g1 = state; ~g1; g1 = g1 === 0 ? -1 : (g1 - 1) & state) {",
      "  if (g1 === state || g1 === 0) continue",
      "  const g2 = state ^ g1",
      "  console.log(g1.toString(2), g2.toString(2))",
      "}"
    ],
    "description": "forSubset枚举某个状态的所有子集(子集的子集)"
  },
  "forSubset-go": {
    "scope": "go,golang",
    "prefix": ["forSubset", "subset"],
    "body": [
      "state := 0b1101",
      "for g1 := state; g1 >= 0; {",
      "  if g1 == state || g1 == 0 { // 排除空集和全集",
      "    g1--",
      "    continue",
      "  }",
      "  g2 := state ^ g1",
      "  fmt.Println(g1, g2)",
      "  if g1 == 0 {",
      "    g1 = -1",
      "  } else {",
      "    g1 = (g1 - 1) & state",
      "  }",
      "}"
    ],
    "description": "forSubset枚举某个状态的所有子集(子集的子集)"
  },
  "forSubset-py": {
    "scope": "python",
    "prefix": ["forSubset", "subset"],
    "body": [
      "state = 0b1101",
      "g1 = state",
      "while g1 >= 0:",
      "    if g1 == state or g1 == 0:  # 跳过空集和全集",
      "        g1 -= 1",
      "        continue",
      "    g2 = g1 ^ state",
      "    print(bin(g1)[2:], bin(g2)[2:])",
      "    g1 = -1 if g1 == 0 else (g1 - 1) & state"
    ],
    "description": "forSubset枚举某个状态的所有子集(子集的子集)"
  },
  "enumerateBits": {
    "scope": "python",
    "prefix": ["enumerateBits"],
    "body": [
      "state = 0b1101",
      "while state > 0:",
      "    bit = (state & -state).bit_length() - 1",
      "    print(bit)  # 0, 2, 3",
      "    state ^= 1 << bit"
    ],
    "description": "enumerateBits遍历一个二进制数的所有1所在的位"
  },
  "区间 [0,right] 内模mod与k同余的数的个数": {
    "scope": "python",
    "prefix": ["modCount"],
    "body": [
      "def modCount(right: int, k: int, mod: int) -> int:",
      "  '''区间 [0,right] 内模mod与k同余的数的个数'''",
      "  assert 0 <= k < mod",
      "  return (right - k + mod) // mod"
    ],
    "description": "区间 [0,right] 内模mod与k同余的数的个数"
  },
  "isPrime-py": {
    "scope": "python",
    "prefix": ["isPrime"],
    "body": [
      "def isPrime(n: int) -> bool:",
      "  '''判断n是否为质数'''",
      "  if n < 2:",
      "    return False",
      "  for i in range(2, int(n ** 0.5) + 1):",
      "    if n % i == 0:",
      "      return False",
      "  return True"
    ],
    "description": "O(sqrt(n))判断n是否为质数"
  },
  "isPrime-ts": {
    "scope": "typescript",
    "prefix": ["isPrime"],
    "body": [
      "function isPrime(n: number): boolean {",
      "  if (n < 2) return false",
      "  const upper = ~~Math.sqrt(n)",
      "  for (let i = 2; i < upper + 1; i++) {",
      "    if (n % i === 0) return false",
      "  }",
      "  return true"
    ],
    "description": "O(sqrt(n))判断n是否为质数"
  },
  "isPrime-go": {
    "scope": "go,golang",
    "prefix": ["isPrime"],
    "body": [
      "func isPrime(n int) bool {",
      "  if n < 2 {",
      "    return false",
      "  }",
      "  upper := int(math.Sqrt(float64(n)))",
      "  for i := 2; i < upper+1; i++ {",
      "    if n%i == 0 {",
      "      return false",
      "    }",
      "  }",
      "  return true",
      "}"
    ],
    "description": "O(sqrt(n))判断n是否为质数"
  },
  "productWithoutOne": {
    "scope": "python",
    "prefix": ["productWithoutOne"],
    "body": [
      "from typing import Callable, List, TypeVar",
      "",
      "T = TypeVar('T')",
      "",
      "def productWithoutOne(nums: List[T], e: Callable[[], T], op: Callable[[T, T], T]) -> List[T]:",
      "    '''除自身以外数组的乘积.'''",
      "    n = len(nums)",
      "    res = [e() for _ in range(n)]",
      "    for i in range(n - 1):",
      "        res[i + 1] = op(res[i], nums[i])",
      "    x = e()",
      "    for i in range(n - 1, -1, -1):",
      "        res[i] = op(res[i], x)",
      "        x = op(nums[i], x)",
      "    return res"
    ],
    "description": "除自身以外数组的乘积"
  },
  "productWithoutOne-go": {
    "scope": "go,golang",
    "prefix": ["productWithoutOne"],
    "body": [
      "type E = int",
      "",
      "// 除自身以外数组的乘积.",
      "func productWithoutOne(nums []int, e func() int, op func(int, int) int) []int {",
      "  n := len(nums)",
      "  res := make([]int, n)",
      "  for i := 0; i < n-1; i++ {",
      "    res[i+1] = op(res[i], nums[i])",
      "  }",
      "  x := e()",
      "  for i := n - 1; i >= 0; i-- {",
      "    res[i] = op(res[i], x)",
      "    x = op(nums[i], x)",
      "  }",
      "  return res",
      "}"
    ],
    "description": "除自身以外数组的乘积"
  },

  "id-dict-python": {
    "prefix": ["id", "getId"],
    "scope": "python",
    "body": [
      "from typing import Generic, Optional, TypeVar",
      "V = TypeVar('V')",
      "class Dictionary(Generic[V]):",
      "  '''获取对象唯一标识的字典.'''",
      "  __slots__ = '_valueToId', '_idToValue'",
      "  def __init__(self):",
      "    self._valueToId = dict()",
      "    self._idToValue = []",
      "  def id(self, value: V) -> int:",
      "    res = self._valueToId.get(value, None)",
      "    if res is not None:",
      "      return res",
      "    id_ = len(self._idToValue)",
      "    self._idToValue.append(value)",
      "    self._valueToId[value] = id_",
      "    return id_",
      "  def value(self, id_: int) -> Optional[V]:",
      "    if id_ < 0 or id_ >= len(self._idToValue):",
      "      return None",
      "    return self._idToValue[id_]",
      "  def __contains__(self, v: int) -> bool:",
      "    return v in self._valueToId",
      "  def __len__(self) -> int:",
      "    return len(self._idToValue)"
    ],
    "description": "获取对象的唯一标识id"
  },
  "id-typescript": {
    "prefix": ["id", "getId"],
    "scope": "typescript",
    "body": [
      "const pool = new Map<unknown, number>()",
      "function id(o: unknown): number {",
      "  const res = pool.get(o)",
      "  if (res !== void 0) return res",
      "  const cur = pool.size",
      "  pool.set(o, cur)",
      "  return cur",
      "}"
    ],
    "description": "获取对象的唯一标识id"
  },
  "id-dict-typescript": {
    "prefix": ["id", "getId", "DiscretizeId"],
    "scope": "typescript",
    "body": [
      "/**",
      " * A dictionary that maps values to unique ids.",
      " */",
      "class Dictionary<V> {",
      "  private readonly _valueToId = new Map<V, number>()",
      "  private readonly _idToValue: V[] = []",
      "",
      "  id(value: V): number {",
      "    const res = this._valueToId.get(value)",
      "    if (res !== void 0) return res",
      "    const id = this._idToValue.length",
      "    this._idToValue.push(value)",
      "    this._valueToId.set(value, id)",
      "    return id",
      "  }",
      "",
      "  value(id: number): V | undefined {",
      "    if (id < 0 || id >= this._idToValue.length) return void 0",
      "    return this._idToValue[id]",
      "  }",
      "",
      "  has(value: V): boolean {",
      "    return this._valueToId.has(value)",
      "  }",
      "",
      "  get size(): number {",
      "    return this._idToValue.length",
      "  }",
      "}"
    ],
    "description": "获取对象的唯一标识id"
  },
  "id-v2-golang": {
    "scope": "go,golang",
    "prefix": "id",
    "body": [
      "\t\tpool := make(map[${1:int32}]int32)",
      "\t\tid := func(o ${1:int32}) int32 {",
      "\t\t\tif v, ok := pool[o]; ok {",
      "\t\t\t\treturn v",
      "\t\t\t}",
      "\t\t\tv := int32(len(pool))",
      "\t\t\tpool[o] = v",
      "\t\t\treturn v",
      "\t\t}",
      "\t\tfor i := int32(0); i < n; i++ {",
      "\t\t\tvalues[i] = id(values[i])",
      "\t\t}"
    ],
    "description": "获取对象的唯一标识id"
  },

  "id-dict-golang": {
    "prefix": ["id", "getId"],
    "scope": "go,golang",
    "body": [
      "type V = int",
      "type Dictionary struct {",
      "  _idToValue []V",
      "  _valueToId map[V]int",
      "}",
      "// A dictionary that maps values to unique ids.",
      "func NewDictionary() *Dictionary {",
      "  return &Dictionary{",
      "    _valueToId: map[V]int{},",
      "  }",
      "}",
      "func (d *Dictionary) Id(value V) int {",
      "  res, ok := d._valueToId[value]",
      "  if ok {",
      "    return res",
      "  }",
      "  id := len(d._idToValue)",
      "  d._idToValue = append(d._idToValue, value)",
      "  d._valueToId[value] = id",
      "  return id",
      "}",
      "func (d *Dictionary) Value(id int) V {",
      "  return d._idToValue[id]",
      "}",
      "func (d *Dictionary) Has(value V) bool {",
      "  _, ok := d._valueToId[value]",
      "  return ok",
      "}",
      "func (d *Dictionary) Size() int {",
      "  return len(d._idToValue)",
      "}"
    ],
    "description": "获取对象的唯一标识id"
  },
  "id-dict-golang-32": {
    "prefix": ["id32", "getId32", "dictionary32"],
    "scope": "go,golang",
    "body": [
      "",
      "type V = int32",
      "type Dictionary struct {",
      "\t_idToValue []V",
      "\t_valueToId map[V]int32",
      "}",
      "",
      "// A dictionary that maps values to unique ids.",
      "func NewDictionary() *Dictionary {",
      "\treturn &Dictionary{",
      "\t\t_valueToId: map[V]int32{},",
      "\t}",
      "}",
      "func (d *Dictionary) Id(value V) int32 {",
      "\tres, ok := d._valueToId[value]",
      "\tif ok {",
      "\t\treturn res",
      "\t}",
      "\tid := int32(len(d._idToValue))",
      "\td._idToValue = append(d._idToValue, value)",
      "\td._valueToId[value] = id",
      "\treturn id",
      "}",
      "func (d *Dictionary) Value(id int32) V {",
      "\treturn d._idToValue[id]",
      "}",
      "func (d *Dictionary) Has(value V) bool {",
      "\t_, ok := d._valueToId[value]",
      "\treturn ok",
      "}",
      "func (d *Dictionary) Size() int32 {",
      "\treturn int32(len(d._idToValue))",
      "}"
    ],
    "description": "获取对象的唯一标识id"
  },
  "genSplits-py": {
    "prefix": ["splits", "genSplits"],
    "scope": "python",
    "body": [
      "from typing import Generator, Sequence, List, TypeVar",
      "",
      "T = TypeVar('T')",
      "",
      "def genSplits(arr: Sequence[T]) -> Generator[List[Sequence[T]], None, None]:",
      "    '''遍历序列所有的分割方案.'''",
      "    if not arr:",
      "        return",
      "    n = len(arr)",
      "    for state in range(1 << (n - 1)):  # 枚举n-1个分割点",
      "        preSplit = 0",
      "        cur = []",
      "        for i in range(n - 1):",
      "            if state & (1 << i):",
      "                cur.append(arr[preSplit : i + 1])",
      "                preSplit = i + 1",
      "        cur.append(arr[preSplit:])",
      "        yield cur"
    ],
    "description": "遍历序列所有的分割方案"
  },
  "enumerateSplits-ts": {
    "prefix": ["splits", "enumerateSplits"],
    "scope": "typescript",
    "body": [
      "/**",
      " * 遍历数组所有的分割方案.",
      " */",
      "function enumerateSplits<T>(arr: T[], f: (splits: T[][]) => void): void {",
      "  if (!arr.length) return",
      "  const n = arr.length",
      "  for (let state = 0; state < 1 << (n - 1); state++) {",
      "    let preSplit = 0",
      "    const cur: T[][] = []",
      "    for (let i = 0; i < n - 1; i++) {",
      "      if (state & (1 << i)) {",
      "        cur.push(arr.slice(preSplit, i + 1))",
      "        preSplit = i + 1",
      "      }",
      "    }",
      "    cur.push(arr.slice(preSplit))",
      "    f(cur)",
      "  }",
      "}"
    ],
    "description": "遍历数组所有的分割方案"
  },
  "genSplits-ts": {
    "prefix": ["splits", "genSplits"],
    "scope": "typescript",
    "body": [
      "/**",
      " * 遍历数组所有的分割方案.",
      " */",
      "function* genSplits<T>(arr: T[]): Generator<T[][]> {",
      "  if (!arr.length) return",
      "  const n = arr.length",
      "  for (let state = 0; state < 1 << (n - 1); state++) {",
      "    let preSplit = 0",
      "    const cur: T[][] = []",
      "    for (let i = 0; i < n - 1; i++) {",
      "      if (state & (1 << i)) {",
      "        cur.push(arr.slice(preSplit, i + 1))",
      "        preSplit = i + 1",
      "      }",
      "    }",
      "    cur.push(arr.slice(preSplit))",
      "    yield cur",
      "  }",
      "}"
    ],
    "description": "遍历数组所有的分割方案"
  },
  "enumerateGroup-go": {
    "prefix": ["groupBy", "enumerateGroup"],
    "scope": "go,golang",
    "body": [
      "// 遍历连续相同元素的分组.相当于python中的`itertools.groupby`.",
      "func EnumerateGroup(arr []interface{}, f func(group []interface{}, start, end int)) {",
      "  ptr := 0",
      "  n := len(arr)",
      "  for ptr < n {",
      "    leader := arr[ptr]",
      "    group := []interface{}{leader}",
      "    start := ptr",
      "    ptr++",
      "    for ptr < n && arr[ptr] == leader {",
      "      group = append(group, arr[ptr])",
      "      ptr++",
      "    }",
      "    f(group, start, ptr)",
      "  }",
      "}"
    ],
    "description": "遍历连续相同元素的分组.相当于python中的`itertools.groupby`."
  },
  "enumerateGroup-ts": {
    "prefix": ["groupBy", "enumerateGroup"],
    "scope": "typescript",
    "body": [
      "/**",
      " * 遍历连续相同元素的分组.",
      " * @alias groupBy",
      " * @example",
      " * ```ts",
      " * const list = [1, 1, 2, 3, 3, 4, 4, 5, 5, 5]",
      " * enumerateGroup(list, group => console.log(group)) // [1, 1], [2], [3, 3], [4, 4], [5, 5, 5]",
      " * ```",
      " */",
      "function enumerateGroup<T>(",
      "  arr: ArrayLike<T>,",
      "  f: (group: T[], start: number, end: number) => void",
      "): void {",
      "  const n = arr.length",
      "  let ptr = 0",
      "  while (ptr < n) {",
      "    const leader = arr[ptr]",
      "    const group = [leader]",
      "    const start = ptr",
      "    ptr++",
      "    while (ptr < n && arr[ptr] === leader) {",
      "      group.push(arr[ptr])",
      "      ptr++",
      "    }",
      "    f(group, start, ptr)",
      "  }",
      "}"
    ],
    "description": "遍历连续相同元素的分组.相当于python中的`itertools.groupby`."
  },
  "go-DefaultDict": {
    "scope": "go,golang",
    "prefix": ["DefaultDict", "GetOrDefault"],
    "body": [
      "type K = int",
      "type V = int",
      "",
      "func GetOrDefault(dict map[K]V, key K, defaultValue V) V {",
      "\tif v, ok := dict[key]; ok {",
      "\t\treturn v",
      "\t}",
      "\treturn defaultValue",
      "}",
      ""
    ],
    "description": "go-DefaultDict"
  },
  "UnionFind": {
    "scope": "go,golang",
    "prefix": ["UnionFind", "并查集数组"],
    "body": [
      "",
      "type UnionFindArray struct {",
      "\t// 连通分量的个数",
      "\tPart int",
      "\tn\t\tint",
      "\tdata []int",
      "}",
      "",
      "func NewUnionFindArray(n int) *UnionFindArray {",
      "\tdata := make([]int, n)",
      "\tfor i := 0; i < n; i++ {",
      "\t\tdata[i] = -1",
      "\t}",
      "\treturn &UnionFindArray{",
      "\t\tPart: n,",
      "\t\tn:\t\tn,",
      "\t\tdata: data,",
      "\t}",
      "}",
      "",
      "// 按秩合并.",
      "func (ufa *UnionFindArray) Union(key1, key2 int) bool {",
      "\troot1, root2 := ufa.Find(key1), ufa.Find(key2)",
      "\tif root1 == root2 {",
      "\t\treturn false",
      "\t}",
      "\tif ufa.data[root1] > ufa.data[root2] {",
      "\t\troot1 ^= root2",
      "\t\troot2 ^= root1",
      "\t\troot1 ^= root2",
      "\t}",
      "\tufa.data[root1] += ufa.data[root2]",
      "\tufa.data[root2] = root1",
      "\tufa.Part--",
      "\treturn true",
      "}",
      "func (ufa *UnionFindArray) UnionWithCallback(key1, key2 int, cb func(big, small int)) bool {",
      "\troot1, root2 := ufa.Find(key1), ufa.Find(key2)",
      "\tif root1 == root2 {",
      "\t\treturn false",
      "\t}",
      "\tif ufa.data[root1] > ufa.data[root2] {",
      "\t\troot1 ^= root2",
      "\t\troot2 ^= root1",
      "\t\troot1 ^= root2",
      "\t}",
      "\tufa.data[root1] += ufa.data[root2]",
      "\tufa.data[root2] = root1",
      "\tufa.Part--",
      "\tif cb != nil {",
      "\t\tcb(root1, root2)",
      "\t}",
      "\treturn true",
      "}",
      "",
      "func (ufa *UnionFindArray) Find(key int) int {",
      "\tif ufa.data[key] < 0 {",
      "\t\treturn key",
      "\t}",
      "\tufa.data[key] = ufa.Find(ufa.data[key])",
      "\treturn ufa.data[key]",
      "}",
      "",
      "func (ufa *UnionFindArray) IsConnected(key1, key2 int) bool {",
      "\treturn ufa.Find(key1) == ufa.Find(key2)",
      "}",
      "",
      "func (ufa *UnionFindArray) GetSize(key int) int {",
      "\treturn -ufa.data[ufa.Find(key)]",
      "}",
      "",
      "func (ufa *UnionFindArray) GetGroups() map[int][]int {",
      "\tgroups := make(map[int][]int)",
      "\tfor i := 0; i < ufa.n; i++ {",
      "\t\troot := ufa.Find(i)",
      "\t\tgroups[root] = append(groups[root], i)",
      "\t}",
      "\treturn groups",
      "}",
      "",
      "func (ufa *UnionFindArray) String() string {",
      "\tsb := []string{\"UnionFindArray:\"}",
      "\tgroups := ufa.GetGroups()",
      "\tkeys := make([]int, 0, len(groups))",
      "\tfor k := range groups {",
      "\t\tkeys = append(keys, k)",
      "\t}",
      "\tsort.Ints(keys)",
      "\tfor _, root := range keys {",
      "\t\tmember := groups[root]",
      "\t\tcur := fmt.Sprintf(\"%d: %v\", root, member)",
      "\t\tsb = append(sb, cur)",
      "\t}",
      "\tsb = append(sb, fmt.Sprintf(\"Part: %d\", ufa.Part))",
      "\treturn strings.Join(sb, \"\\n\")",
      "}",
      "",
      "//",
      "//",
      "var _pool = make(map[interface{}]int)",
      "",
      "func id(o interface{}) int {",
      "\tif v, ok := _pool[o]; ok {",
      "\t\treturn v",
      "\t}",
      "\tv := len(_pool)",
      "\t_pool[o] = v",
      "\treturn v",
      "}",
      "",
      "type UnionFindMap struct {",
      "\tPart int",
      "\tdata map[int]int",
      "}",
      "",
      "func NewUnionFindMap() *UnionFindMap {",
      "\treturn &UnionFindMap{",
      "\t\tdata: make(map[int]int),",
      "\t}",
      "}",
      "",
      "func (ufm *UnionFindMap) Union(key1, key2 int) bool {",
      "\troot1, root2 := ufm.Find(key1), ufm.Find(key2)",
      "\tif root1 == root2 {",
      "\t\treturn false",
      "\t}",
      "\tif ufm.data[root1] > ufm.data[root2] {",
      "\t\troot1 ^= root2",
      "\t\troot2 ^= root1",
      "\t\troot1 ^= root2",
      "\t}",
      "\tufm.data[root1] += ufm.data[root2]",
      "\tufm.data[root2] = root1",
      "\tufm.Part--",
      "\treturn true",
      "}",
      "func (ufm *UnionFindMap) UnionWithCallback(key1, key2 int, cb func(big, small int)) bool {",
      "\troot1, root2 := ufm.Find(key1), ufm.Find(key2)",
      "\tif root1 == root2 {",
      "\t\treturn false",
      "\t}",
      "\tif ufm.data[root1] > ufm.data[root2] {",
      "\t\troot1 ^= root2",
      "\t\troot2 ^= root1",
      "\t\troot1 ^= root2",
      "\t}",
      "\tufm.data[root1] += ufm.data[root2]",
      "\tufm.data[root2] = root1",
      "\tufm.Part--",
      "\tif cb != nil {",
      "\t\tcb(root1, root2)",
      "\t}",
      "\treturn true",
      "}",
      "",
      "func (ufm *UnionFindMap) Find(key int) int {",
      "\tif _, ok := ufm.data[key]; !ok {",
      "\t\tufm.Add(key)",
      "\t\treturn key",
      "\t}",
      "\tif ufm.data[key] < 0 {",
      "\t\treturn key",
      "\t}",
      "\tufm.data[key] = ufm.Find(ufm.data[key])",
      "\treturn ufm.data[key]",
      "}",
      "",
      "func (ufm *UnionFindMap) IsConnected(key1, key2 int) bool {",
      "\treturn ufm.Find(key1) == ufm.Find(key2)",
      "}",
      "",
      "func (ufm *UnionFindMap) GetSize(key int) int {",
      "\treturn -ufm.data[ufm.Find(key)]",
      "}",
      "",
      "func (ufm *UnionFindMap) GetGroups() map[int][]int {",
      "\tgroups := make(map[int][]int)",
      "\tfor k := range ufm.data {",
      "\t\troot := ufm.Find(k)",
      "\t\tgroups[root] = append(groups[root], k)",
      "\t}",
      "\treturn groups",
      "}",
      "",
      "func (ufm *UnionFindMap) Has(key int) bool {",
      "\t_, ok := ufm.data[key]",
      "\treturn ok",
      "}",
      "",
      "func (ufm *UnionFindMap) Add(key int) bool {",
      "\tif _, ok := ufm.data[key]; ok {",
      "\t\treturn false",
      "\t}",
      "\tufm.data[key] = -1",
      "\tufm.Part++",
      "\treturn true",
      "}",
      "",
      "func (ufm *UnionFindMap) String() string {",
      "\tsb := []string{\"UnionFindMap:\"}",
      "\tgroups := ufm.GetGroups()",
      "\tkeys := make([]int, 0, len(groups))",
      "\tfor k := range groups {",
      "\t\tkeys = append(keys, k)",
      "\t}",
      "\tsort.Ints(keys)",
      "\tfor _, root := range keys {",
      "\t\tmember := groups[root]",
      "\t\tcur := fmt.Sprintf(\"%d: %v\", root, member)",
      "\t\tsb = append(sb, cur)",
      "\t}",
      "\tsb = append(sb, fmt.Sprintf(\"Part: %d\", ufm.Part))",
      "\treturn strings.Join(sb, \"\\n\")",
      "}",
      ""
    ],
    "description": "UnionFind"
  },

  "子数组计数": {
    "scope": "python",
    "prefix": ["subarray", "countSubarray"],
    "body": [
      "n = len(nums)",
      "res = 0",
      "for left in range(n):",
      "\t\tcur = []",
      "\t\tfor right in range(left, n):",
      "\t\t\t\t..."
    ],
    "description": "子数组计数"
  },
  "子数组计数-golang": {
    "scope": "go,golang",
    "prefix": ["subarray", "countSubarray"],
    "body": [
      "\tn := len(nums)",
      "\tres := 0",
      "\tfor left := 0; left < n; left++ {",
      "\t\tcur := []int{}",
      "\t\tfor right := left; right < n; right++ {",
      "",
      "\t\t}",
      "\t}"
    ],
    "description": "子数组计数"
  },
  "子数组计数-ts": {
    "scope": "typescript",
    "prefix": ["subarray", "countSubarray"],
    "body": [
      "const n = nums.length",
      "let res = 0",
      "for (let left = 0; left < n; left++) {",
      "\tconst cur = []",
      "\tfor (let right = left; right < n; right++) {",
      "\t\t//",
      "\t}",
      "}",
      ""
    ],
    "description": "子数组计数-ts"
  },
  "bfsGrid": {
    "scope": "python",
    "prefix": "bfsGrid",
    "body": [
      "",
      "from typing import List, Tuple",
      "from collections import deque",
      "",
      "DIR4 = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "INF = int(1e18)",
      "",
      "",
      "def bfsGrid(row: int, col: int, starts: List[Tuple[int, int]]) -> List[List[int]]:",
      "\t\t\"\"\"网格图bfs, 返回每个格子到起点的最短距离.\"\"\"",
      "\t\tdist = [[INF] * col for _ in range(row)]",
      "\t\tqueue = deque(starts)",
      "\t\tfor x, y in starts:",
      "\t\t\t\tdist[x][y] = 0",
      "",
      "\t\twhile queue:",
      "\t\t\t\tlen_ = len(queue)",
      "\t\t\t\tfor _ in range(len_):",
      "\t\t\t\t\t\tcurX, curY = queue.popleft()",
      "\t\t\t\t\t\tfor dx, dy in DIR4:",
      "\t\t\t\t\t\t\t\tnextX, nextY = curX + dx, curY + dy",
      "\t\t\t\t\t\t\t\tcand = dist[curX][curY] + 1",
      "\t\t\t\t\t\t\t\tif 0 <= nextX < row and 0 <= nextY < col and cand < dist[nextX][nextY]:",
      "\t\t\t\t\t\t\t\t\t\tdist[nextX][nextY] = cand",
      "\t\t\t\t\t\t\t\t\t\tqueue.append((nextX, nextY))",
      "",
      "\t\treturn dist"
    ],
    "description": "网格图bfs"
  },
  "distOnCircle": {
    "scope": "python",
    "prefix": ["distOnCycle", "distOnCircle", "环上两点距离"],
    "body": [
      "def distOnCycle(n: int, i: int, j: int) -> int:",
      "\t\t\"\"\"环上两点距离.\"\"\"",
      "\t\tcand1, cand2 = abs(i - j), n - abs(i - j)",
      "\t\treturn cand1 if cand1 < cand2 else cand2"
    ],
    "description": "环上两点距离"
  },
  "distOnCircle-golang": {
    "scope": "go,golang",
    "prefix": ["distOnCycle", "distOnCircle", "环上两点距离"],
    "body": [
      "\t// 环上两点距离.",
      "\tfunc distOnCycle(n, i, j int) int {",
      "\t\tcand1 := abs(i - j)",
      "\t\tcand2 := n - cand1",
      "\t\tif cand1 < cand2 {",
      "\t\t\t\treturn cand1",
      "\t\t}",
      "\t\treturn cand2",
      "\t}"
    ],
    "description": "环上两点距离"
  },
  "distOnCircle-ts": {
    "scope": "typescript",
    "prefix": ["distOnCycle", "distOnCircle", "环上两点距离"],
    "body": [
      "// 环上两点距离.",
      "function distOnCycle(n: number, i: number, j: number): number {",
      "\tconst cand1 = Math.abs(i - j)",
      "\tconst cand2 = n - cand1",
      "\treturn Math.min(cand1, cand2)",
      "}"
    ],
    "description": "环上两点距离"
  },
  "埃氏筛-go": {
    "scope": "go",
    "prefix": ["埃氏筛", "EratosthenesSieve"],
    "body": [
      "",
      "var E *EratosthenesSieve",
      "",
      "func init() {",
      "\tE = NewEratosthenesSieve(1e5 + 10)",
      "}",
      "",
      "// 埃氏筛",
      "type EratosthenesSieve struct {",
      "\tminPrime []int",
      "}",
      "",
      "func NewEratosthenesSieve(maxN int) *EratosthenesSieve {",
      "\tminPrime := make([]int, maxN+1)",
      "\tfor i := range minPrime {",
      "\t\tminPrime[i] = i",
      "\t}",
      "\tupper := int(math.Sqrt(float64(maxN))) + 1",
      "\tfor i := 2; i < upper; i++ {",
      "\t\tif minPrime[i] < i {",
      "\t\t\tcontinue",
      "\t\t}",
      "\t\tfor j := i * i; j <= maxN; j += i {",
      "\t\t\tif minPrime[j] == j {",
      "\t\t\t\tminPrime[j] = i",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "\treturn &EratosthenesSieve{minPrime}",
      "}",
      "",
      "func (es *EratosthenesSieve) IsPrime(n int) bool {",
      "\tif n < 2 {",
      "\t\treturn false",
      "\t}",
      "\treturn es.minPrime[n] == n",
      "}",
      "",
      "func (es *EratosthenesSieve) GetPrimeFactors(n int) map[int]int {",
      "\tres := make(map[int]int)",
      "\tfor n > 1 {",
      "\t\tm := es.minPrime[n]",
      "\t\tres[m]++",
      "\t\tn /= m",
      "\t}",
      "\treturn res",
      "}",
      "",
      "func (es *EratosthenesSieve) GetPrimes() []int {",
      "\tres := []int{}",
      "\tfor i, x := range es.minPrime {",
      "\t\tif i >= 2 && i == x {",
      "\t\t\tres = append(res, x)",
      "\t\t}",
      "\t}",
      "\treturn res",
      "}"
    ]
  },

  "rangeFreq-ts": {
    "scope": "typescript",
    "prefix": ["rangeFreq", "queryRangeFreq", "rangeCount", "countRange"],
    "body": [
      "/**",
      " * 查询区间`[start, end)`中值为`value`的元素个数.",
      " */",
      "function rangeFreq<T>(arr: ArrayLike<T>): (start: number, end: number, value: T) => number {",
      "\tconst mp = new Map<T, number[]>()",
      "\tfor (let i = 0; i < arr.length; i++) {",
      "\t\tconst v = arr[i]",
      "\t\tif (!mp.has(v)) mp.set(v, [])",
      "\t\tmp.get(v)!.push(i)",
      "\t}",
      "",
      "\tconst bisectLeft = (nums: ArrayLike<number>, target: number): number => {",
      "\t\tlet left = 0",
      "\t\tlet right = nums.length - 1",
      "\t\twhile (left <= right) {",
      "\t\t\tconst mid = (left + right) >> 1",
      "\t\t\tif (nums[mid] < target) left = mid + 1",
      "\t\t\telse right = mid - 1",
      "\t\t}",
      "\t\treturn left",
      "\t}",
      "",
      "\tconst bisectRight = (nums: ArrayLike<number>, target: number): number => {",
      "\t\tlet left = 0",
      "\t\tlet right = nums.length - 1",
      "\t\twhile (left <= right) {",
      "\t\t\tconst mid = (left + right) >> 1",
      "\t\t\tif (nums[mid] <= target) left = mid + 1",
      "\t\t\telse right = mid - 1",
      "\t\t}",
      "\t\treturn left",
      "\t}",
      "",
      "\treturn (start: number, end: number, value: T): number => {",
      "\t\tconst pos = mp.get(value)",
      "\t\tif (!pos) return 0",
      "\t\treturn bisectRight(pos, end - 1) - bisectLeft(pos, start)",
      "\t}",
      "}",
      ""
    ]
  },

  "BITArray-go": {
    "scope": "go",
    "prefix": "BITArray",
    "body": [
      "",
      "// !Point Add Range Sum, 0-based.",
      "type BITArray struct {",
      "\tn\t\t int",
      "\ttotal int",
      "\tdata\t[]int",
      "}",
      "",
      "func NewBitArray(n int) *BITArray {",
      "\tres := &BITArray{n: n, data: make([]int, n)}",
      "\treturn res",
      "}",
      "",
      "func NewBitArrayFrom(n int, f func(i int) int) *BITArray {",
      "\ttotal := 0",
      "\tdata := make([]int, n)",
      "\tfor i := 0; i < n; i++ {",
      "\t\tdata[i] = f(i)",
      "\t\ttotal += data[i]",
      "\t}",
      "\tfor i := 1; i <= n; i++ {",
      "\t\tj := i + (i & -i)",
      "\t\tif j <= n {",
      "\t\t\tdata[j-1] += data[i-1]",
      "\t\t}",
      "\t}",
      "\treturn &BITArray{n: n, total: total, data: data}",
      "}",
      "",
      "func (b *BITArray) Add(index int, v int) {",
      "\tb.total += v",
      "\tfor index++; index <= b.n; index += index & -index {",
      "\t\tb.data[index-1] += v",
      "\t}",
      "}",
      "",
      "// [0, end).",
      "func (b *BITArray) QueryPrefix(end int) int {",
      "\tif end > b.n {",
      "\t\tend = b.n",
      "\t}",
      "\tres := 0",
      "\tfor ; end > 0; end -= end & -end {",
      "\t\tres += b.data[end-1]",
      "\t}",
      "\treturn res",
      "}",
      "",
      "// [start, end).",
      "func (b *BITArray) QueryRange(start, end int) int {",
      "\tif start < 0 {",
      "\t\tstart = 0",
      "\t}",
      "\tif end > b.n {",
      "\t\tend = b.n",
      "\t}",
      "\tif start >= end {",
      "\t\treturn 0",
      "\t}",
      "\tif start == 0 {",
      "\t\treturn b.QueryPrefix(end)",
      "\t}",
      "\tpos, neg := 0, 0",
      "\tfor end > start {",
      "\t\tpos += b.data[end-1]",
      "\t\tend &= end - 1",
      "\t}",
      "\tfor start > end {",
      "\t\tneg += b.data[start-1]",
      "\t\tstart &= start - 1",
      "\t}",
      "\treturn pos - neg",
      "}",
      "",
      "func (b *BITArray) QueryAll() int {",
      "\treturn b.total",
      "}",
      "",
      "func (b *BITArray) MaxRight(check func(index, preSum int) bool) int {",
      "\ti := 0",
      "\ts := 0",
      "\tk := 1",
      "\tfor 2*k <= b.n {",
      "\t\tk *= 2",
      "\t}",
      "\tfor k > 0 {",
      "\t\tif i+k-1 < b.n {",
      "\t\t\tt := s + b.data[i+k-1]",
      "\t\t\tif check(i+k, t) {",
      "\t\t\t\ti += k",
      "\t\t\t\ts = t",
      "\t\t\t}",
      "\t\t}",
      "\t\tk >>= 1",
      "\t}",
      "\treturn i",
      "}",
      "",
      "// 0/1 树状数组查找第 k(0-based) 个1的位置.",
      "// UpperBound.",
      "func (b *BITArray) Kth(k int) int {",
      "\treturn b.MaxRight(func(index, preSum int) bool { return preSum <= k })",
      "}",
      "",
      "func (b *BITArray) String() string {",
      "\tsb := []string{}",
      "\tfor i := 0; i < b.n; i++ {",
      "\t\tsb = append(sb, fmt.Sprintf(\"%d\", b.QueryRange(i, i+1)))",
      "\t}",
      "\treturn fmt.Sprintf(\"BitArray: [%v]\", strings.Join(sb, \", \"))",
      "}",
      ""
    ]
  },
  "基环树找环": {
    "scope": "python",
    "prefix": ["基环树找环", "cyclePartition", "竞赛图找环"],
    "body": [
      "from collections import deque",
      "from typing import Iterable, List, Mapping, Sequence, Tuple, Union",
      "",
      "",
      "SequenceGraph = Sequence[Iterable[int]]",
      "MappingGraph = Mapping[int, Iterable[int]]",
      "Graph = Union[SequenceGraph, MappingGraph]",
      "",
      "",
      "def cyclePartition(",
      "\t\tn: int, graph: Graph, directed: bool",
      ") -> Tuple[List[List[int]], List[bool], List[int], List[int]]:",
      "\t\t\"\"\"返回基环树森林的环分组信息(环的大小>=2)以及每个点在拓扑排序中的最大深度.",
      "",
      "\t\tArgs:",
      "\t\t\t\t- n: 图的节点数.",
      "\t\t\t\t- graph: 图的邻接表表示.",
      "\t\t\t\t- directed: 图是否有向.",
      "",
      "\t\tReturns:",
      "\t\t\t\t- groups: 环分组,每个环的大小>=2.",
      "\t\t\t\t- inCycle: 每个点是否在环中.",
      "\t\t\t\t- belong: 每个点所在的环的编号.如果不在环中,则为-1.",
      "\t\t\t\t- depth: 每个点在拓扑排序中的最大深度,最外层的点深度为0.",
      "\t\t\"\"\"",
      "",
      "\t\tdef max(a: int, b: int) -> int:",
      "\t\t\t\treturn a if a > b else b",
      "",
      "\t\tdeg = [0] * n",
      "\t\tif directed:",
      "\t\t\t\tfor u in range(n):",
      "\t\t\t\t\t\tfor v in graph[u]:",
      "\t\t\t\t\t\t\t\tdeg[v] += 1",
      "\t\telse:",
      "\t\t\t\tfor u in range(n):",
      "\t\t\t\t\t\tfor v in graph[u]:",
      "\t\t\t\t\t\t\t\tif u < v:",
      "\t\t\t\t\t\t\t\t\t\tdeg[u] += 1",
      "\t\t\t\t\t\t\t\t\t\tdeg[v] += 1",
      "",
      "\t\tstartDeg = 0 if directed else 1",
      "\t\tqueue = deque([i for i in range(n) if deg[i] == startDeg])",
      "\t\tvisited = [False] * n",
      "\t\tdepth = [0] * n",
      "\t\twhile queue:",
      "\t\t\t\tcur = queue.popleft()",
      "\t\t\t\tvisited[cur] = True",
      "\t\t\t\tfor next_ in graph[cur]:",
      "\t\t\t\t\t\tdepth[next_] = max(depth[next_], depth[cur] + 1)",
      "\t\t\t\t\t\tdeg[next_] -= 1",
      "\t\t\t\t\t\tif deg[next_] == startDeg:",
      "\t\t\t\t\t\t\t\tqueue.append(next_)",
      "",
      "\t\tdef dfs(cur: int, path: List[int]) -> None:",
      "\t\t\t\tif visited[cur]:",
      "\t\t\t\t\t\treturn",
      "\t\t\t\tvisited[cur] = True",
      "\t\t\t\tpath.append(cur)",
      "\t\t\t\tfor next in graph[cur]:",
      "\t\t\t\t\t\tdfs(next, path)",
      "",
      "\t\tgroups = []",
      "\t\tfor i in range(n):",
      "\t\t\t\tif visited[i]:",
      "\t\t\t\t\t\tcontinue",
      "\t\t\t\tpath = []",
      "\t\t\t\tdfs(i, path)",
      "\t\t\t\tgroups.append(path)",
      "",
      "\t\tinCycle, belong = [False] * n, [-1] * n",
      "\t\tfor gid, group in enumerate(groups):",
      "\t\t\t\tfor node in group:",
      "\t\t\t\t\t\tinCycle[node] = True",
      "\t\t\t\t\t\tbelong[node] = gid",
      "",
      "\t\treturn groups, inCycle, belong, depth"
    ]
  },
  "多源bfs": {
    "scope": "python",
    "prefix": "bfsMultiStart",
    "body": [
      "def bfsMultiStart(starts: Iterable[int], adjList: List[List[int]]) -> List[int]:",
      "\t\t\"\"\"多源bfs\"\"\"",
      "\t\tn = len(adjList)",
      "\t\tdist = [INF] * n",
      "\t\tqueue = deque(starts)",
      "\t\tfor start in starts:",
      "\t\t\t\tdist[start] = 0",
      "\t\twhile queue:",
      "\t\t\t\tcur = queue.popleft()",
      "\t\t\t\tfor next in adjList[cur]:",
      "\t\t\t\t\t\tcand = dist[cur] + 1",
      "\t\t\t\t\t\tif cand < dist[next]:",
      "\t\t\t\t\t\t\t\tdist[next] = cand",
      "\t\t\t\t\t\t\t\tqueue.append(next)",
      "\t\treturn dist"
    ],
    "description": "多源bfs"
  },
  "bfs求路径": {
    "scope": "python",
    "prefix": "bfsPath",
    "body": [
      "def bfsPath(",
      "\t\tn: int, adjList: Sequence[Sequence[int]], start: int, end: int",
      ") -> Tuple[int, List[int]]:",
      "\t\t\"\"\"bfs求出起点到end的(最短距离,路径).时间复杂度O(V+E)\"\"\"",
      "\t\tdist = [INF] * n",
      "\t\tdist[start] = 0",
      "\t\tqueue = deque([start])",
      "\t\tpre = [-1] * n",
      "",
      "\t\twhile queue:",
      "\t\t\t\tcur = queue.popleft()",
      "\t\t\t\tfor next in adjList[cur]:",
      "\t\t\t\t\t\tcand = dist[cur] + 1",
      "\t\t\t\t\t\tif cand < dist[next]:",
      "\t\t\t\t\t\t\t\tdist[next] = cand",
      "\t\t\t\t\t\t\t\tpre[next] = cur",
      "\t\t\t\t\t\t\t\tqueue.append(next)",
      "",
      "\t\tif dist[end] == INF:",
      "\t\t\t\treturn INF, []",
      "",
      "\t\tpath = []",
      "\t\tcur = end",
      "\t\twhile pre[cur] != -1:",
      "\t\t\t\tpath.append(cur)",
      "\t\t\t\tcur = pre[cur]",
      "\t\tpath.append(start)",
      "\t\treturn dist[end], path[::-1]"
    ],
    "description": "bfs求路径"
  },
  "bfs求最短路-golaang": {
    "scope": "go",
    "prefix": ["bfs", "bfsPath", "bfsMultiStart", "bfsDepth", "bfsGrid"],
    "body": [
      "",
      "const INF int = 1e18",
      "",
      "// bfs求最无权图短路.",
      "func Bfs(start int, adjList [][]int) []int {",
      "\tn := len(adjList)",
      "\tdist := make([]int, n)",
      "\tfor i := range dist {",
      "\t\tdist[i] = INF",
      "\t}",
      "\tdist[start] = 0",
      "\tqueue := []int{start}",
      "\tfor len(queue) > 0 {",
      "\t\tcur := queue[0]",
      "\t\tqueue = queue[1:]",
      "\t\tfor _, next := range adjList[cur] {",
      "\t\t\tcand := dist[cur] + 1",
      "\t\t\tif cand < dist[next] {",
      "\t\t\t\tdist[next] = cand",
      "\t\t\t\tqueue = append(queue, next)",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "\treturn dist",
      "}",
      "",
      "// 多源bfs.",
      "func BfsMultiStart(starts []int, adjList [][]int) []int {",
      "\tn := len(adjList)",
      "\tdist := make([]int, n)",
      "\tfor i := range dist {",
      "\t\tdist[i] = INF",
      "\t}",
      "\tqueue := append(starts[:0:0], starts...)",
      "\tfor _, start := range starts {",
      "\t\tdist[start] = 0",
      "\t}",
      "\tfor len(queue) > 0 {",
      "\t\tcur := queue[0]",
      "\t\tqueue = queue[1:]",
      "\t\tfor _, next := range adjList[cur] {",
      "\t\t\tcand := dist[cur] + 1",
      "\t\t\tif cand < dist[next] {",
      "\t\t\t\tdist[next] = cand",
      "\t\t\t\tqueue = append(queue, next)",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "\treturn dist",
      "}",
      "",
      "// bfs求起点到终点的最短距离和路径.",
      "func BfsPath(n int, adjList [][]int, start int, end int) (res int, path []int) {",
      "\tdist := make([]int, n)",
      "\tfor i := range dist {",
      "\t\tdist[i] = INF",
      "\t}",
      "\tdist[start] = 0",
      "\tqueue := []int{start}",
      "\tpre := make([]int, n)",
      "\tfor i := range pre {",
      "\t\tpre[i] = -1",
      "\t}",
      "\tfor len(queue) > 0 {",
      "\t\tcur := queue[0]",
      "\t\tqueue = queue[1:]",
      "\t\tfor _, next := range adjList[cur] {",
      "\t\t\tcand := dist[cur] + 1",
      "\t\t\tif cand < dist[next] {",
      "\t\t\t\tdist[next] = cand",
      "\t\t\t\tpre[next] = cur",
      "\t\t\t\tqueue = append(queue, next)",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "\tif dist[end] == INF {",
      "\t\treturn INF, []int{}",
      "\t}",
      "\tcur := end",
      "\tfor pre[cur] != -1 {",
      "\t\tpath = append(path, cur)",
      "\t\tcur = pre[cur]",
      "\t}",
      "\tpath = append(path, start)",
      "\tfor i := 0; i < len(path)/2; i++ {",
      "\t\tpath[i], path[len(path)-1-i] = path[len(path)-1-i], path[i]",
      "\t}",
      "\treturn dist[end], path",
      "}",
      "",
      "// 返回距离start为dist的结点.",
      "func BfsDepth(n int, adjList [][]int, start int, dist int) []int {",
      "\tif dist < 0 {",
      "\t\treturn []int{}",
      "\t}",
      "\tif dist == 0 {",
      "\t\treturn []int{start}",
      "\t}",
      "\tqueue := []int{start}",
      "\tvisited := make([]bool, n)",
      "\ttodo := dist",
      "\tfor len(queue) > 0 && todo > 0 {",
      "\t\tlen_ := len(queue)",
      "\t\tfor i := 0; i < len_; i++ {",
      "\t\t\tcur := queue[0]",
      "\t\t\tqueue = queue[1:]",
      "\t\t\tfor _, next := range adjList[cur] {",
      "\t\t\t\tif !visited[next] {",
      "\t\t\t\t\tvisited[next] = true",
      "\t\t\t\t\tqueue = append(queue, next)",
      "\t\t\t\t}",
      "\t\t\t}",
      "\t\t}",
      "\t\ttodo--",
      "\t}",
      "\treturn queue",
      "}",
      "",
      "// 网格图bfs, 返回每个格子到起点的最短距离.",
      "func BfsGrid(row int, col int, starts [][]int) [][]int {",
      "\tDIR4 := [][]int{{-1, 0}, {1, 0}, {0, -1}, {0, 1}}",
      "\tdist := make([][]int, row)",
      "\tfor i := range dist {",
      "\t\tdist[i] = make([]int, col)",
      "\t\tfor j := range dist[i] {",
      "\t\t\tdist[i][j] = INF",
      "\t\t}",
      "\t}",
      "\tqueue := append(starts[:0:0], starts...)",
      "\tfor _, start := range starts {",
      "\t\tdist[start[0]][start[1]] = 0",
      "\t}",
      "\tfor len(queue) > 0 {",
      "\t\tlen_ := len(queue)",
      "\t\tfor i := 0; i < len_; i++ {",
      "\t\t\tcurX, curY := queue[0][0], queue[0][1]",
      "\t\t\tqueue = queue[1:]",
      "\t\t\tfor _, dir := range DIR4 {",
      "\t\t\t\tnextX, nextY := curX+dir[0], curY+dir[1]",
      "\t\t\t\tcand := dist[curX][curY] + 1",
      "\t\t\t\tif 0 <= nextX && nextX < row && 0 <= nextY && nextY < col && cand < dist[nextX][nextY] {",
      "\t\t\t\t\tdist[nextX][nextY] = cand",
      "\t\t\t\t\tqueue = append(queue, []int{nextX, nextY})",
      "\t\t\t\t}",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "\treturn dist",
      "}",
      ""
    ],
    "description": "bfs"
  },
  "diff差分-python": {
    "scope": "python",
    "prefix": ["DiffArray", "DiffMap"],
    "body": [
      "from bisect import bisect_right",
      "from collections import defaultdict",
      "from itertools import accumulate",
      "from typing import List",
      "",
      "",
      "class DiffArray:",
      "\t\t\"\"\"差分维护区间修改，区间查询.\"\"\"",
      "",
      "\t\t__slots__ = (\"_diff\", \"_dirty\")",
      "",
      "\t\tdef __init__(self, n: int) -> None:",
      "\t\t\t\tself._diff = [0] * (n + 1)",
      "\t\t\t\tself._dirty = False",
      "",
      "\t\tdef add(self, start: int, end: int, delta: int) -> None:",
      "\t\t\t\t\"\"\"区间 `[start,end)` 加上 `delta`.\"\"\"",
      "\t\t\t\tif start < 0:",
      "\t\t\t\t\t\tstart = 0",
      "\t\t\t\tif end >= len(self._diff):",
      "\t\t\t\t\t\tend = len(self._diff) - 1",
      "\t\t\t\tif start >= end:",
      "\t\t\t\t\t\treturn",
      "\t\t\t\tself._dirty = True",
      "\t\t\t\tself._diff[start] += delta",
      "\t\t\t\tself._diff[end] -= delta",
      "",
      "\t\tdef build(self) -> None:",
      "\t\t\t\tif self._dirty:",
      "\t\t\t\t\t\tself._diff = list(accumulate(self._diff))",
      "\t\t\t\t\t\tself._dirty = False",
      "",
      "\t\tdef get(self, pos: int) -> int:",
      "\t\t\t\t\"\"\"查询下标 `pos` 处的值.\"\"\"",
      "\t\t\t\tself.build()",
      "\t\t\t\treturn self._diff[pos]",
      "",
      "\t\tdef getAll(self) -> List[int]:",
      "\t\t\t\tself.build()",
      "\t\t\t\treturn self._diff[:-1]",
      "",
      "",
      "class DiffMap:",
      "\t\t\"\"\"差分维护区间修改，单点查询.\"\"\"",
      "",
      "\t\t__slots__ = (\"_diff\", \"_preSum\", \"_sortedKeys\", \"_dirty\")",
      "",
      "\t\tdef __init__(self) -> None:",
      "\t\t\t\tself._diff = defaultdict(int)",
      "\t\t\t\tself._sortedKeys = []",
      "\t\t\t\tself._preSum = []",
      "\t\t\t\tself._dirty = False",
      "",
      "\t\tdef add(self, start: int, end: int, delta: int) -> None:",
      "\t\t\t\t\"\"\"区间 `[start,end)` 加上 `delta`.\"\"\"",
      "\t\t\t\tif start >= end:",
      "\t\t\t\t\t\treturn",
      "\t\t\t\tself._dirty = True",
      "\t\t\t\tself._diff[start] += delta",
      "\t\t\t\tself._diff[end] -= delta",
      "",
      "\t\tdef build(self) -> None:",
      "\t\t\t\tif self._dirty:",
      "\t\t\t\t\t\tself._sortedKeys = sorted(self._diff)",
      "\t\t\t\t\t\tself._preSum = [0] + list(accumulate(self._diff[key] for key in self._sortedKeys))",
      "\t\t\t\t\t\tself._dirty = False",
      "",
      "\t\tdef get(self, pos: int) -> int:",
      "\t\t\t\t\"\"\"查询下标 `pos` 处的值.\"\"\"",
      "\t\t\t\tself.build()",
      "\t\t\t\treturn self._preSum[bisect_right(self._sortedKeys, pos)]",
      "",
      "",
      "if __name__ == \"__main__\":",
      "\t\t# 2251. 花期内花的数目",
      "\t\t# https://leetcode.cn/problems/number-of-flowers-in-full-bloom/description/",
      "",
      "\t\tclass Solution:",
      "\t\t\t\tdef fullBloomFlowers(self, flowers: List[List[int]], people: List[int]) -> List[int]:",
      "\t\t\t\t\t\tdiff = DiffMap()",
      "\t\t\t\t\t\tfor left, right in flowers:",
      "\t\t\t\t\t\t\t\tdiff.add(left, right + 1, 1)",
      "\t\t\t\t\t\treturn [diff.get(p) for p in people]",
      ""
    ]
  },
  "diff差分-golang": {
    "scope": "go",
    "prefix": ["DiffArray", "DiffMap"],
    "body": [
      "",
      "type DiffArray struct {",
      "\tdiff\t[]int",
      "\tdirty bool",
      "}",
      "",
      "func NewDiffArray(n int) *DiffArray {",
      "\treturn &DiffArray{",
      "\t\tdiff: make([]int, n+1),",
      "\t}",
      "}",
      "",
      "func (d *DiffArray) Add(start, end, delta int) {",
      "\tif start < 0 {",
      "\t\tstart = 0",
      "\t}",
      "\tif end >= len(d.diff) {",
      "\t\tend = len(d.diff) - 1",
      "\t}",
      "\tif start >= end {",
      "\t\treturn",
      "\t}",
      "\td.dirty = true",
      "\td.diff[start] += delta",
      "\td.diff[end] -= delta",
      "}",
      "",
      "func (d *DiffArray) Build() {",
      "\tif d.dirty {",
      "\t\tpreSum := make([]int, len(d.diff))",
      "\t\tfor i := 1; i < len(d.diff); i++ {",
      "\t\t\tpreSum[i] = preSum[i-1] + d.diff[i]",
      "\t\t}",
      "\t\td.diff = preSum",
      "\t\td.dirty = false",
      "\t}",
      "}",
      "",
      "func (d *DiffArray) Get(pos int) int {",
      "\td.Build()",
      "\treturn d.diff[pos]",
      "}",
      "",
      "func (d *DiffArray) GetAll() []int {",
      "\td.Build()",
      "\treturn d.diff[:len(d.diff)-1]",
      "}",
      "",
      "type DiffMap struct {",
      "\tdiff\t\t\t map[int]int",
      "\tsortedKeys []int",
      "\tpreSum\t\t []int",
      "\tdirty\t\t\tbool",
      "}",
      "",
      "func NewDiffMap() *DiffMap {",
      "\treturn &DiffMap{",
      "\t\tdiff: make(map[int]int),",
      "\t}",
      "}",
      "",
      "func (d *DiffMap) Add(start, end, delta int) {",
      "\tif start >= end {",
      "\t\treturn",
      "\t}",
      "\td.dirty = true",
      "\td.diff[start] += delta",
      "\td.diff[end] -= delta",
      "}",
      "",
      "func (d *DiffMap) Build() {",
      "\tif d.dirty {",
      "\t\td.sortedKeys = make([]int, 0, len(d.diff))",
      "\t\tfor key := range d.diff {",
      "\t\t\td.sortedKeys = append(d.sortedKeys, key)",
      "\t\t}",
      "\t\tsort.Ints(d.sortedKeys)",
      "\t\td.preSum = make([]int, len(d.sortedKeys)+1)",
      "\t\tfor i, key := range d.sortedKeys {",
      "\t\t\td.preSum[i+1] = d.preSum[i] + d.diff[key]",
      "\t\t}",
      "\t\td.dirty = false",
      "\t}",
      "}",
      "",
      "func (d *DiffMap) Get(pos int) int {",
      "\td.Build()",
      "\treturn d.preSum[sort.SearchInts(d.sortedKeys, pos+1)]",
      "}"
    ],
    "description": "差分"
  },
  "PreSumSuffixSum-python": {
    "scope": "python",
    "prefix": ["PreSumSuffixSum", "suffixSum", "preSum"],
    "body": [
      "from typing import Callable, Generic, List, Sequence, TypeVar",
      "",
      "",
      "T = TypeVar(\"T\")",
      "",
      "",
      "class PreSumSuffixSum(Generic[T]):",
      "\t\t__slots__ = (\"_e\", \"_op\", \"_preSum\", \"_suffixSum\")",
      "",
      "\t\tdef __init__(self, seq: Sequence[T], e: Callable[[], T], op: Callable[[T, T], T]) -> None:",
      "\t\t\t\tself._e = e",
      "\t\t\t\tself._op = op",
      "\t\t\t\tn = len(seq)",
      "\t\t\t\tpreSum: List[T] = [None] * (n + 1)\t# type: ignore",
      "\t\t\t\tsuffixSum: List[T] = [None] * (n + 1)\t# type: ignore",
      "\t\t\t\tpreSum[0] = e()",
      "\t\t\t\tsuffixSum[n] = e()",
      "\t\t\t\tfor i in range(n):",
      "\t\t\t\t\t\tpreSum[i + 1] = op(preSum[i], seq[i])",
      "\t\t\t\t\t\tsuffixSum[n - i - 1] = op(suffixSum[n - i], seq[n - i - 1])",
      "\t\t\t\tself._preSum = preSum",
      "\t\t\t\tself._suffixSum = suffixSum",
      "",
      "\t\tdef preSum(self, end: int) -> T:",
      "\t\t\t\t\"\"\"查询前缀[0,end)的和.\"\"\"",
      "\t\t\t\tif end < 0:",
      "\t\t\t\t\t\treturn self._e()",
      "\t\t\t\tif end >= len(self._preSum):",
      "\t\t\t\t\t\treturn self._preSum[-1]",
      "\t\t\t\treturn self._preSum[end]",
      "",
      "\t\tdef suffixSum(self, start: int) -> T:",
      "\t\t\t\t\"\"\"查询后缀[start,n)的和.\"\"\"",
      "\t\t\t\tif start < 0:",
      "\t\t\t\t\t\treturn self._suffixSum[0]",
      "\t\t\t\tif start >= len(self._suffixSum):",
      "\t\t\t\t\t\treturn self._e()",
      "\t\t\t\treturn self._suffixSum[start]"
    ],
    "description": "前缀后缀和"
  },
  "PreSumSuffixSum-golang": {
    "scope": "go",
    "prefix": ["PreSumSuffixSum", "suffixSum", "preSum"],
    "body": [
      "",
      "type E = int",
      "",
      "type PreSumSuffixSum struct {",
      "\tpreSum\t\t[]E",
      "\tsuffixSum []E",
      "\te\t\t\t\t func() E",
      "}",
      "",
      "func NewPreSumSuffixSum(arr []E, e func() E, op func(a, b E) E) *PreSumSuffixSum {",
      "\tn := len(arr)",
      "\tpreSum, suffixSum := make([]E, n+1), make([]E, n+1)",
      "\tpreSum[0] = e()",
      "\tsuffixSum[n] = e()",
      "\tfor i := 0; i < n; i++ {",
      "\t\tpreSum[i+1] = op(preSum[i], arr[i])",
      "\t\tsuffixSum[n-i-1] = op(suffixSum[n-i], arr[n-i-1])",
      "\t}",
      "\treturn &PreSumSuffixSum{preSum: preSum, suffixSum: suffixSum, e: e}",
      "}",
      "",
      "// 查询前缀 `[0,end)` 的和.",
      "func (p *PreSumSuffixSum) PreSum(end int) E {",
      "\tif end < 0 {",
      "\t\treturn p.e()",
      "\t}",
      "\tif end >= len(p.preSum) {",
      "\t\treturn p.preSum[len(p.preSum)-1]",
      "\t}",
      "\treturn p.preSum[end]",
      "}",
      "",
      "// 查询后缀 `[start,n)` 的和.",
      "func (p *PreSumSuffixSum) SuffixSum(start int) E {",
      "\tif start < 0 {",
      "\t\treturn p.suffixSum[0]",
      "\t}",
      "\tif start >= len(p.suffixSum) {",
      "\t\treturn p.e()",
      "\t}",
      "\treturn p.suffixSum[start]",
      "}"
    ],
    "description": "前缀后缀和"
  },
  "BisectInsort": {
    "scope": "go",
    "prefix": ["BisectInsort", "InsortRight"],
    "body": [
      "// bisect.insort/bisect.insortRight in python.",
      "func BisectInsort(nums *[]int, insertion int) {",
      "\tpos := BisectRight(*nums, insertion)",
      "\t*nums = append(*nums, 0)",
      "\tcopy((*nums)[pos+1:], (*nums)[pos:])",
      "\t(*nums)[pos] = insertion",
      "}",
      "",
      "var InsortRight = BisectInsort"
    ],
    "description": "bisect.insort/bisect.insortRight in python."
  },
  "离散化-python": {
    "scope": "python",
    "prefix": ["discretize", "sortedSet"],
    "body": [
      "from bisect import bisect_left",
      "from typing import Callable, List, Tuple",
      "",
      "",
      "def discretizeCompressed(nums: List[int], offset=0) -> Tuple[Callable[[int], int], int]:",
      "\t\t\"\"\"紧离散化.",
      "",
      "\t\tArgs:",
      "\t\t\t\t- nums: 原数组.",
      "\t\t\t\t- offset: 离散化的起始值偏移量.",
      "",
      "\t\tReturns:",
      "\t\t\t\t- getRank: 给定一个数,返回它的排名(offset ~ offset + count).",
      "\t\t\t\t- count: 离散化(去重)后的元素个数.",
      "\t\t\"\"\"",
      "\t\tallNums = sorted(set(nums))",
      "\t\trank = {num: i + offset for i, num in enumerate(allNums)}",
      "\t\treturn lambda x: rank[x], len(allNums)",
      "",
      "",
      "def discretizeSparse(nums: List[int], offset=0) -> Tuple[Callable[[int], int], int]:",
      "\t\t\"\"\"松离散化.",
      "",
      "\t\tArgs:",
      "\t\t\t\t- nums: 原数组.",
      "\t\t\t\t- offset: 离散化的起始值偏移量.",
      "",
      "\t\tReturns:",
      "\t\t\t\t- getRank: 给定一个数,返回它的排名(offset ~ offset + count).",
      "\t\t\t\t- count: 离散化(去重)后的元素个数.",
      "\t\t\"\"\"",
      "\t\tallNums = sorted(set(nums))",
      "\t\treturn lambda x: bisect_left(allNums, x) + offset, len(allNums)",
      ""
    ],
    "description": "离散化"
  },
  "discretizeFast": {
    "scope": "go",
    "prefix": "DiscretizeFast",
    "body": [
      "",
      "// 将nums中的元素进行离散化，返回新的数组和对应的原始值.",
      "// origin[newNums[i]] == nums[i]",
      "func Discretize(nums []int) (newNums []int32, origin []int) {",
      "\tnewNums = make([]int32, len(nums))",
      "\torigin = make([]int, 0, len(newNums))",
      "\torder := argSort(int32(len(nums)), func(i, j int32) bool { return nums[i] < nums[j] })",
      "\tfor _, i := range order {",
      "\t\tif len(origin) == 0 || origin[len(origin)-1] != nums[i] {",
      "\t\t\torigin = append(origin, nums[i])",
      "\t\t}",
      "\t\tnewNums[i] = int32(len(origin) - 1)",
      "\t}",
      "\torigin = origin[:len(origin):len(origin)]",
      "\treturn",
      "}",
      "",
      "func argSort(n int32, less func(i, j int32) bool) []int32 {",
      "\torder := make([]int32, n)",
      "\tfor i := range order {",
      "\t\torder[i] = int32(i)",
      "\t}",
      "\tsort.Slice(order, func(i, j int) bool { return less(order[i], order[j]) })",
      "\treturn order",
      "}",
      ""
    ],
    "description": "离散化"
  },
  "getFactors-go": {
    "scope": "go",
    "prefix": "getFactors",
    "body": [
      "",
      "// 返回 n 的所有因子. O(n^0.5).",
      "func GetFactors(n int) []int {",
      "\tif n <= 0 {",
      "\t\treturn nil",
      "\t}",
      "\tsmall := []int{}",
      "\tbig := []int{}",
      "\tupper := int(math.Sqrt(float64(n)))",
      "\tfor f := 1; f <= upper; f++ {",
      "\t\tif n%f == 0 {",
      "\t\t\tsmall = append(small, f)",
      "\t\t\tbig = append(big, n/f)",
      "\t\t}",
      "\t}",
      "\tif small[len(small)-1] == big[len(big)-1] {",
      "\t\tbig = big[:len(big)-1]",
      "\t}",
      "\tfor i, j := 0, len(big)-1; i < j; i, j = i+1, j-1 {",
      "\t\tbig[i], big[j] = big[j], big[i]",
      "\t}",
      "\tres := append(small, big...)",
      "\treturn res",
      "}"
    ],
    "description": "获取某个数的所有因子"
  },
  "getPrimeFactors-go": {
    "scope": "go",
    "prefix": "getPrimeFactors",
    "body": [
      "// 质因数分解.",
      "func GetPrimeFactors(n int, f func(v, c int)) {",
      "\tupper := n",
      "\ti := 2",
      "\tfor i*i <= upper {",
      "\t\tif upper%i == 0 {",
      "\t\t\tc := 0",
      "\t\t\tfor upper%i == 0 {",
      "\t\t\t\tc++",
      "\t\t\t\tupper /= i",
      "\t\t\t}",
      "\t\t\tf(i, c)",
      "\t\t}",
      "\t\ti++",
      "\t}",
      "\tif upper != 1 {",
      "\t\tf(upper, 1)",
      "\t}",
      "}"
    ],
    "description": "因数分解"
  },
  "getFactors-python": {
    "scope": "python",
    "prefix": "getFactors",
    "body": [
      "def getFactors(n: int) -> List[int]:",
      "\t\t\"\"\"n 的所有因数 O(sqrt(n))\"\"\"",
      "\t\tif n <= 0:",
      "\t\t\t\treturn []",
      "\t\tsmall, big = [], []",
      "\t\tupper = int(n**0.5) + 1",
      "\t\tfor i in range(1, upper):",
      "\t\t\t\tif n % i == 0:",
      "\t\t\t\t\t\tsmall.append(i)",
      "\t\t\t\t\t\tif i != n // i:",
      "\t\t\t\t\t\t\t\tbig.append(n // i)",
      "\t\treturn small + big[::-1]"
    ],
    "description": "获取某个数的所有因子"
  },
  "getPrimeFactors-python": {
    "scope": "python",
    "prefix": "getPrimeFactors",
    "body": [
      "from typing import List, Tuple",
      "",
      "",
      "def getPrimeFactors(n: int) -> List[Tuple[int, int]]:",
      "\t\t\"\"\"质因数分解.",
      "",
      "\t\t>>> getPrimeFactors(100)",
      "\t\t[(2, 2), (5, 2)]",
      "\t\t\"\"\"",
      "\t\tres = []",
      "\t\tupper = n",
      "\t\ti = 2",
      "\t\twhile i * i <= upper:",
      "\t\t\t\tif upper % i == 0:",
      "\t\t\t\t\t\tc = 0",
      "\t\t\t\t\t\twhile upper % i == 0:",
      "\t\t\t\t\t\t\t\tc += 1",
      "\t\t\t\t\t\t\t\tupper //= i",
      "\t\t\t\t\t\tres.append((i, c))",
      "\t\t\t\ti += 1",
      "\t\tif upper != 1:",
      "\t\t\t\tres.append((upper, 1))",
      "\t\treturn res"
    ],
    "description": "因数分解"
  },
  "INF-js": {
    "scope": "javascript,typescript",
    "prefix": "INF",
    "body": ["const INF = 2e9 // !超过int32使用2e15"],
    "description": "INF"
  },
  "freqCounter-py": {
    "scope": "python",
    "prefix": "freqCounter",
    "body": ["freqCounter = Counter(Counter(nums).values()) # len(freqCounter) <= sqrt(n)"],
    "description": "数组元素频率的Counter"
  },
  "freqCounter-ts": {
    "scope": "javascript,typescript",
    "prefix": "freqCounter",
    "body": [
      "\tconst tmpCounter = new Map<number, number>()",
      "\tnums.forEach(v => tmpCounter.set(v, (tmpCounter.get(v) || 0) + 1))",
      "\tconst freq = [...tmpCounter.values()]",
      "\tconst freqCounter = new Map<number, number>()  // len(freqCounter) <= sqrt(n)",
      "\tfreq.forEach(v => freqCounter.set(v, (freqCounter.get(v) || 0) + 1))"
    ],
    "description": "数组元素频率的Counter"
  },
  "freqCounter-go": {
    "scope": "go",
    "prefix": "freqCounter",
    "body": [
      "\ttmpCounter := make(map[int]int)",
      "\tfor _, v := range nums {",
      "\t\ttmpCounter[v]++",
      "\t}",
      "\tfreq := make([]int, 0, len(tmpCounter))",
      "\tfor _, v := range tmpCounter {",
      "\t\tfreq = append(freq, v)",
      "\t}",
      "\tfreqCounter := make(map[int]int, len(freq))  // len(freqCounter) <= sqrt(n)",
      "\tfor _, v := range freq {",
      "\t\tfreqCounter[v]++",
      "\t}"
    ],
    "description": "数组元素频率的Counter"
  },
  "counter-ts": {
    "scope": "typescript",
    "prefix": "counter",
    "body": [
      "\t\tconst counter = new Map<number, number>()",
      "\t\tnums.forEach(v => counter.set(v, (counter.get(v) || 0) + 1))"
    ],
    "description": "counter计数"
  },
  "counter-go": {
    "scope": "go",
    "prefix": "counter",
    "body": [
      "\\counter := make(map[int]int)",
      "\tfor _, v := range nums {",
      "\t\\counter[v]++",
      "\t}"
    ],
    "description": "counter计数"
  },
  "rangeFreq-python": {
    "scope": "python",
    "prefix": ["rangeFreq", "countRange", "rangeCount"],
    "body": [
      "mp = defaultdict(list)",
      "for i, v in enumerate(arr):",
      "\t\tmp[v].append(i)",
      "",
      "",
      "def query(start: int, end: int, value: int) -> int:",
      "\t\treturn bisect_left(mp[value], end) - bisect_left(mp[value], start)"
    ],
    "description": "区间频率"
  },
  "rangeFreq-golang": {
    "scope": "go",
    "prefix": "rangeFreq",
    "body": [
      "type V = int",
      "",
      "func RangeFreq(arr []V) func(start, end int, value V) int {",
      "\tmp := make(map[V][]int)",
      "\tfor i, v := range arr {",
      "\t\tmp[v] = append(mp[v], i)",
      "\t}",
      "",
      "\treturn func(start, end int, value V) int {",
      "\t\tif start < 0 {",
      "\t\t\tstart = 0",
      "\t\t}",
      "\t\tif end > len(arr) {",
      "\t\t\tend = len(arr)",
      "\t\t}",
      "\t\tif start >= end {",
      "\t\t\treturn 0",
      "\t\t}",
      "",
      "\t\tif indexes, ok := mp[value]; !ok {",
      "\t\t\treturn 0",
      "\t\t} else {",
      "\t\t\treturn sort.SearchInts(indexes, end) - sort.SearchInts(indexes, start)",
      "\t\t}",
      "\t}",
      "}"
    ],
    "description": "静态区间频率查询"
  },
  "floyd-go": {
    "scope": "go",
    "prefix": "floyd",
    "body": [
      "const INF int = 1e18",
      "",
      "func Floyd(n int, edges [][3]int, directed bool) [][]int {",
      "\tdist := make([][]int, n)",
      "\tfor i := 0; i < n; i++ {",
      "\t\tdist[i] = make([]int, n)",
      "\t\tfor j := 0; j < n; j++ {",
      "\t\t\tdist[i][j] = INF",
      "\t\t}",
      "\t\tdist[i][i] = 0",
      "\t}",
      "",
      "\tfor _, road := range edges {",
      "\t\tu, v, w := road[0], road[1], road[2]",
      "\t\tdist[u][v] = min(w, dist[u][v])",
      "\t\tif !directed {",
      "\t\t\tdist[v][u] = min(w, dist[v][u])",
      "\t\t}",
      "\t}",
      "",
      "\tfor k := 0; k < n; k++ {",
      "\t\tfor i := 0; i < n; i++ {",
      "\t\t\tif dist[i][k] == INF {",
      "\t\t\t\tcontinue",
      "\t\t\t}",
      "\t\t\tfor j := 0; j < n; j++ {",
      "\t\t\tif dist[k][j] == INF {",
      "\t\t\t\tcontinue",
      "\t\t\t}",
      "\t\t\t\tdist[i][j] = min(dist[i][j], dist[i][k]+dist[k][j])",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "",
      "\treturn dist",
      "}",
      "",
      "func min(a, b int) int {",
      "\tif a <= b {",
      "\t\treturn a",
      "\t}",
      "\treturn b",
      "}"
    ],
    "description": "floyd求全源最短路"
  },
  "floyd-python": {
    "scope": "python",
    "prefix": "floyd",
    "body": [
      "from typing import List",
      "",
      "",
      "INF = int(1e20)",
      "",
      "",
      "def floyd(n: int, edges: List[List[int]], directed: bool) -> List[List[int]]:",
      "\t\t\"\"\"",
      "\t\tFloyd 求多源最短路",
      "\t\t\"\"\"",
      "",
      "\t\tdef min2(a: int, b: int) -> int:",
      "\t\t\t\treturn a if a < b else b",
      "",
      "\t\tdist = [[INF] * n for _ in range(n)]",
      "\t\tfor i in range(n):",
      "\t\t\t\tdist[i][i] = 0",
      "",
      "\t\tfor u, v, w in edges:",
      "\t\t\t\tdist[u][v] = min2(dist[u][v], w)",
      "\t\t\t\tif not directed:",
      "\t\t\t\t\t\tdist[v][u] = min2(dist[v][u], w)",
      "",
      "\t\tfor k in range(n):",
      "\t\t\t\tfor i in range(n):",
      "\t\t\t\t\t\tif dist[i][k] == INF:",
      "\t\t\t\t\t\t\t\tcontinue",
      "\t\t\t\t\t\tfor j in range(n):",
      "\t\t\t\t\t\t\t\tif dist[k][j] == INF:",
      "\t\t\t\t\t\t\t\t\t\tcontinue",
      "\t\t\t\t\t\t\t\tcand = dist[i][k] + dist[k][j]",
      "\t\t\t\t\t\t\t\tdist[i][j] = cand if dist[i][j] > cand else dist[i][j]",
      "\t\treturn dist"
    ],
    "description": "floyd求全源最短路"
  },
  "max2": {
    "scope": "python",
    "prefix": "max2",
    "body": ["def max2(a: int, b: int) -> int:", "\t\treturn a if a > b else b", ""],
    "description": "max2"
  },
  "min2": {
    "scope": "python",
    "prefix": "min2",
    "body": ["def min2(a: int, b: int) -> int:", "\t\treturn a if a < b else b"],
    "description": "min2"
  },
  "getKth-py": {
    "scope": "python",
    "prefix": "getKth",
    "body": [
      "from typing import Callable",
      "",
      "",
      "def getKth0(left: int, right: int, countNgt: Callable[[int], int], kth: int) -> int:",
      "\t\t\"\"\"",
      "\t\t给定二分答案的区间[left,right], 求第kth小的答案.",
      "\t\tcountNgt: 答案不超过mid时, 满足条件的个数.",
      "\t\tkth从0开始.",
      "\t\t\"\"\"",
      "\t\twhile left <= right:",
      "\t\t\t\tmid = left + (right - left) // 2",
      "\t\t\t\tif countNgt(mid) <= kth:",
      "\t\t\t\t\t\tleft = mid + 1",
      "\t\t\t\telse:",
      "\t\t\t\t\t\tright = mid - 1",
      "\t\treturn right + 1",
      "",
      "",
      "def getKth1(left: int, right: int, countNgt: Callable[[int], int], kth: int) -> int:",
      "\t\t\"\"\"",
      "\t\t给定二分答案的区间[left,right], 求第kth小的答案.",
      "\t\tcountNgt: 答案不超过mid时, 满足条件的个数.",
      "\t\tkth从1开始.",
      "\t\t\"\"\"",
      "\t\twhile left <= right:",
      "\t\t\t\tmid = left + (right - left) // 2",
      "\t\t\t\tif countNgt(mid) < kth:",
      "\t\t\t\t\t\tleft = mid + 1",
      "\t\t\t\telse:",
      "\t\t\t\t\t\tright = mid - 1",
      "\t\treturn left",
      "",
      "",
      "EPS = 1e-12",
      "",
      "",
      "def getKth0Float64(left: float, right: float, countNgt: Callable[[float], int], kth: int) -> float:",
      "\t\t\"\"\"",
      "\t\t给定二分答案的区间[left,right], 求第kth小的答案.",
      "\t\tcountNgt: 答案不超过mid时, 满足条件的个数.",
      "\t\tkth从0开始.",
      "\t\t\"\"\"",
      "\t\twhile left <= right:",
      "\t\t\t\tmid = left + (right - left) / 2",
      "\t\t\t\tif countNgt(mid) <= kth:",
      "\t\t\t\t\t\tleft = mid + EPS",
      "\t\t\t\telse:",
      "\t\t\t\t\t\tright = mid - EPS",
      "\t\treturn right + EPS",
      "",
      "",
      "def getKth1Float64(left: float, right: float, countNgt: Callable[[float], int], kth: int) -> float:",
      "\t\t\"\"\"",
      "\t\t给定二分答案的区间[left,right], 求第kth小的答案.",
      "\t\tcountNgt: 答案不超过mid时, 满足条件的个数.",
      "\t\tkth从1开始.",
      "\t\t\"\"\"",
      "\t\twhile left <= right:",
      "\t\t\t\tmid = left + (right - left) / 2",
      "\t\t\t\tif countNgt(mid) < kth:",
      "\t\t\t\t\t\tleft = mid + EPS",
      "\t\t\t\telse:",
      "\t\t\t\t\t\tright = mid - EPS",
      "\t\treturn left"
    ],
    "description": "getKth"
  },
  "getKth-go": {
    "scope": "go",
    "prefix": "getKth",
    "body": [
      "",
      "// 给定二分答案的区间[left,right]，求第kth小的答案.",
      "// countNgt: 答案不超过mid时，满足条件的个数.",
      "// kth从0开始.",
      "func GetKth0(left int, right int, countNgt func(mid int) int, kth int) int {",
      "\tfor left <= right {",
      "\t\tmid := left + (right-left)>>1",
      "\t\tif countNgt(mid) <= kth {",
      "\t\t\tleft = mid + 1",
      "\t\t} else {",
      "\t\t\tright = mid - 1",
      "\t\t}",
      "\t}",
      "\treturn right + 1",
      "}",
      "",
      "// 给定二分答案的区间[left,right]，求第kth小的答案.",
      "// countNgt: 答案不超过mid时，满足条件的个数.",
      "// kth从1开始.",
      "func GetKth1(left int, right int, countNgt func(mid int) int, kth int) int {",
      "\tfor left <= right {",
      "\t\tmid := left + (right-left)>>1",
      "\t\tif countNgt(mid) < kth {",
      "\t\t\tleft = mid + 1",
      "\t\t} else {",
      "\t\t\tright = mid - 1",
      "\t\t}",
      "\t}",
      "\treturn left",
      "}",
      "",
      "const EPS = 1e-12",
      "",
      "// 给定二分答案的区间[left,right]，求第kth小的答案.",
      "// countNgt: 答案不超过mid时，满足条件的个数.",
      "// kth从0开始.",
      "func GetKth0Float64(left float64, right float64, countNgt func(mid float64) int, kth int) float64 {",
      "\tfor left <= right {",
      "\t\tmid := left + (right-left)/2",
      "\t\tif countNgt(mid) <= kth {",
      "\t\t\tleft = mid + EPS",
      "\t\t} else {",
      "\t\t\tright = mid - EPS",
      "\t\t}",
      "\t}",
      "\treturn right + EPS",
      "}",
      "",
      "// 给定二分答案的区间[left,right]，求第kth小的答案.",
      "// countNgt: 答案不超过mid时，满足条件的个数.",
      "// kth从1开始.",
      "func GetKth1Float64(left float64, right float64, countNgt func(mid float64) int, kth int) float64 {",
      "\tfor left <= right {",
      "\t\tmid := left + (right-left)/2",
      "\t\tif countNgt(mid) < kth {",
      "\t\t\tleft = mid + EPS",
      "\t\t} else {",
      "\t\t\tright = mid - EPS",
      "\t\t}",
      "\t}",
      "\treturn left",
      "}"
    ],
    "description": "getKth"
  },
  "dijkstra-go": {
    "scope": "go",
    "prefix": "dijkstra",
    "body": [
      "",
      "const INF int = 1e18",
      "",
      "type Neighbor struct{ to, weight int }",
      "",
      "func Dijkstra(n int, adjList [][]Neighbor, start int) (dist []int) {",
      "\tdist = make([]int, n)",
      "\tfor i := range dist {",
      "\t\tdist[i] = INF",
      "\t}",
      "\tdist[start] = 0",
      "",
      "\tpq := nhp(func(a, b H) int {",
      "\t\treturn a.dist - b.dist",
      "\t}, []H{{start, 0}})",
      "",
      "\tfor pq.Len() > 0 {",
      "\t\tcurNode := pq.Pop()",
      "\t\tcur, curDist := curNode.node, curNode.dist",
      "\t\tif curDist > dist[cur] {",
      "\t\t\tcontinue",
      "\t\t}",
      "",
      "\t\tfor _, edge := range adjList[cur] {",
      "\t\t\tnext, weight := edge.to, edge.weight",
      "\t\t\tif cand := curDist + weight; cand < dist[next] {",
      "\t\t\t\tdist[next] = cand",
      "\t\t\t\tpq.Push(H{next, cand})",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "",
      "\treturn",
      "}",
      "",
      "type H = struct{ node, dist int }",
      "",
      "// Should return a number:",
      "//",
      "//\tnegative , if a < b",
      "//\tzero\t\t , if a == b",
      "//\tpositive , if a > b",
      "type Comparator = func(a, b H) int",
      "",
      "func nhp(comparator Comparator, nums []H) *Heap {",
      "\tnums = append(nums[:0:0], nums...)",
      "\theap := &Heap{comparator: comparator, data: nums}",
      "\theap.heapify()",
      "\treturn heap",
      "}",
      "",
      "type Heap struct {",
      "\tdata\t\t\t []H",
      "\tcomparator Comparator",
      "}",
      "",
      "func (h *Heap) Push(value H) {",
      "\th.data = append(h.data, value)",
      "\th.pushUp(h.Len() - 1)",
      "}",
      "",
      "func (h *Heap) Pop() (value H) {",
      "\tif h.Len() == 0 {",
      "\t\treturn",
      "\t}",
      "",
      "\tvalue = h.data[0]",
      "\th.data[0] = h.data[h.Len()-1]",
      "\th.data = h.data[:h.Len()-1]",
      "\th.pushDown(0)",
      "\treturn",
      "}",
      "",
      "func (h *Heap) Peek() (value H) {",
      "\tif h.Len() == 0 {",
      "\t\treturn",
      "\t}",
      "\tvalue = h.data[0]",
      "\treturn",
      "}",
      "",
      "func (h *Heap) Len() int { return len(h.data) }",
      "",
      "func (h *Heap) heapify() {",
      "\tn := h.Len()",
      "\tfor i := (n >> 1) - 1; i > -1; i-- {",
      "\t\th.pushDown(i)",
      "\t}",
      "}",
      "",
      "func (h *Heap) pushUp(root int) {",
      "\tfor parent := (root - 1) >> 1; parent >= 0 && h.comparator(h.data[root], h.data[parent]) < 0; parent = (root - 1) >> 1 {",
      "\t\th.data[root], h.data[parent] = h.data[parent], h.data[root]",
      "\t\troot = parent",
      "\t}",
      "}",
      "",
      "func (h *Heap) pushDown(root int) {",
      "\tn := h.Len()",
      "\tfor left := (root<<1 + 1); left < n; left = (root<<1 + 1) {",
      "\t\tright := left + 1",
      "\t\tminIndex := root",
      "",
      "\t\tif h.comparator(h.data[left], h.data[minIndex]) < 0 {",
      "\t\t\tminIndex = left",
      "\t\t}",
      "",
      "\t\tif right < n && h.comparator(h.data[right], h.data[minIndex]) < 0 {",
      "\t\t\tminIndex = right",
      "\t\t}",
      "",
      "\t\tif minIndex == root {",
      "\t\t\treturn",
      "\t\t}",
      "",
      "\t\th.data[root], h.data[minIndex] = h.data[minIndex], h.data[root]",
      "\t\troot = minIndex",
      "\t}",
      "}",
      ""
    ],
    "description": "dijkstra"
  },
  "random-go": {
    "scope": "go",
    "prefix": "random",
    "body": [
      "type Random struct {",
      "\tseed\t\t uint64",
      "\thashBase uint64",
      "}",
      "",
      "func NewRandom() *Random\t\t\t\t\t\t\t\t { return &Random{seed: uint64(time.Now().UnixNano()/2 + 1)} }",
      "func NewRandomWithSeed(seed int) *Random { return &Random{seed: uint64(seed)} }",
      "",
      "func (r *Random) Rng() uint64 {",
      "\tr.seed ^= r.seed << 7",
      "\tr.seed ^= r.seed >> 9",
      "\treturn r.seed",
      "}",

      "func (r *Random) Rng61() uint64 { return r.Rng() & ((1 << 61) - 1) }",
      "",
      "func (r *Random) Next() uint64 { return r.Rng() }",
      "",
      "func (r *Random) RngWithMod(mod int) uint64 { return r.Rng() % uint64(mod) }",
      "",
      "// [left, right]",
      "func (r *Random) RandInt(min, max int) uint64 { return uint64(min) + r.Rng()%(uint64(max-min+1)) }",
      "",
      "// [start:stop:step]",
      "func (r *Random) RandRange(start, stop int, step int) uint64 {",
      "\twidth := stop - start",
      "\t// Fast path.",
      "\tif step == 1 {",
      "\t\treturn uint64(start) + r.Rng()%uint64(width)",
      "\t}",
      "\tvar n uint64",
      "\tif step > 0 {",
      "\t\tn = uint64((width + step - 1) / step)",
      "\t} else {",
      "\t\tn = uint64((width + step + 1) / step)",
      "\t}",
      "\treturn uint64(start) + uint64(step)*(r.Rng()%n)",
      "}",
      "",
      "// FastShuffle",
      "func (r *Random) Shuffle(nums []int) {",
      "\tfor i := range nums {",
      "\t\trand := r.RandInt(0, i)",
      "\t\tnums[i], nums[rand] = nums[rand], nums[i]",
      "\t}",
      "}",
      "",
      "func (r *Random) Sample(nums []int, k int) []int {",
      "\tnums = append(nums[:0:0], nums...)",
      "\tr.Shuffle(nums)",
      "\treturn nums[:k]",
      "}",
      "",
      "// 元组哈希",
      "func (r *Random) HashPair(a, b int) uint64 {",
      "\tif r.hashBase == 0 {",
      "\t\tr.hashBase = r.Rng()",
      "\t}",
      "\treturn uint64(a)*r.hashBase + uint64(b)",
      "}",
      "",
      "func (r *Random) GetHashBase1D(nums []int) []uint64 {",
      "\thashBase := make([]uint64, len(nums))",
      "\tfor i := range hashBase {",
      "\t\thashBase[i] = r.Rng()",
      "\t}",
      "\treturn hashBase",
      "}",
      "",
      "func (r *Random) GetHashBase2D(nums [][]int) [][]uint64 {",
      "\thashBase := make([][]uint64, len(nums))",
      "\tfor i := range hashBase {",
      "\t\thashBase[i] = make([]uint64, len(nums[i]))",
      "\t\tfor j := range hashBase[i] {",
      "\t\t\thashBase[i][j] = r.Rng()",
      "\t\t}",
      "\t}",
      "\treturn hashBase",
      "}"
    ],
    "description": "random"
  },

  "UnionFindArraySimple": {
    "scope": "python",
    "prefix": "UnionFindArraySimple",
    "body": [
      "class UnionFindArraySimple:",
      "\t\t__slots__ = (\"part\", \"n\", \"_data\")",
      "",
      "\t\tdef __init__(self, n: int):",
      "\t\t\t\tself.part = n",
      "\t\t\t\tself.n = n",
      "\t\t\t\tself._data = [-1] * n",
      "",
      "\t\tdef union(self, key1: int, key2: int) -> bool:",
      "\t\t\t\troot1, root2 = self.find(key1), self.find(key2)",
      "\t\t\t\tif root1 == root2:",
      "\t\t\t\t\t\treturn False",
      "\t\t\t\tif self._data[root1] > self._data[root2]:",
      "\t\t\t\t\t\troot1, root2 = root2, root1",
      "\t\t\t\tself._data[root1] += self._data[root2]",
      "\t\t\t\tself._data[root2] = root1",
      "\t\t\t\tself.part -= 1",
      "\t\t\t\treturn True",
      "",
      "\t\tdef find(self, key: int) -> int:",
      "\t\t\t\tif self._data[key] < 0:",
      "\t\t\t\t\t\treturn key",
      "\t\t\t\tself._data[key] = self.find(self._data[key])",
      "\t\t\t\treturn self._data[key]",
      "",
      "\t\tdef getSize(self, key: int) -> int:",
      "\t\t\t\treturn -self._data[self.find(key)]"
    ],
    "description": "UnionFindArraySimple"
  },
  "UnionFindArraySimple-golang": {
    "scope": "go",
    "prefix": "UnionFindArraySimple",
    "body": [
      "type UnionFindArraySimple struct {",
      "\tPart int",
      "\tn\t\tint",
      "\tdata []int32",
      "}",
      "",
      "func NewUnionFindArraySimple(n int) *UnionFindArraySimple {",
      "\tdata := make([]int32, n)",
      "\tfor i := 0; i < n; i++ {",
      "\t\tdata[i] = -1",
      "\t}",
      "\treturn &UnionFindArraySimple{Part: n, n: n, data: data}",
      "}",
      "",
      "func (u *UnionFindArraySimple) Union(key1 int, key2 int) bool {",
      "\troot1, root2 := u.Find(key1), u.Find(key2)",
      "\tif root1 == root2 {",
      "\t\treturn false",
      "\t}",
      "\tif u.data[root1] > u.data[root2] {",
      "\t\troot1, root2 = root2, root1",
      "\t}",
      "\tu.data[root1] += u.data[root2]",
      "\tu.data[root2] = int32(root1)",
      "\tu.Part--",
      "\treturn true",
      "}",
      "",

      "func (u *UnionFindArraySimple) Find(key int) int {",
      "\tif u.data[key] < 0 {",
      "\t\treturn key",
      "\t}",
      "\tu.data[key] = int32(u.Find(int(u.data[key])))",
      "\treturn int(u.data[key])",
      "}",
      "",
      "func (u *UnionFindArraySimple) GetSize(key int) int {",
      "\treturn int(-u.data[u.Find(key)])",
      "}",
      ""
    ],
    "description": "UnionFindArraySimple"
  },
  "UnionFindArraySimple32-golang": {
    "scope": "go",
    "prefix": "UnionFindArraySimple32",
    "body": [
      "",
      "type UnionFindArraySimple32 struct {",
      "\tPart int32",
      "\tn\t\tint32",
      "\tdata []int32",
      "}",
      "",
      "func NewUnionFindArraySimple32(n int32) *UnionFindArraySimple32 {",
      "\tdata := make([]int32, n)",
      "\tfor i := int32(0); i < n; i++ {",
      "\t\tdata[i] = -1",
      "\t}",
      "\treturn &UnionFindArraySimple32{Part: n, n: n, data: data}",
      "}",
      "",
      "func (u *UnionFindArraySimple32) Union(key1, key2 int32, beforeMerge func(big, small int32)) bool {",
      "\troot1, root2 := u.Find(key1), u.Find(key2)",
      "\tif root1 == root2 {",
      "\t\treturn false",
      "\t}",
      "\tif u.data[root1] > u.data[root2] {",
      "\t\troot1, root2 = root2, root1",
      "\t}",
      "\tif beforeMerge != nil {",
      "\t\tbeforeMerge(root1, root2)",
      "\t}",
      "\tu.data[root1] += u.data[root2]",
      "\tu.data[root2] = root1",
      "\tu.Part--",
      "\treturn true",
      "}",
      "",
      "func (u *UnionFindArraySimple32) Find(key int32) int32 {",
      "\troot := key",
      "\tfor u.data[root] >= 0 {",
      "\t\troot = u.data[root]",
      "\t}",
      "\tfor key != root {",
      "\t\tkey, u.data[key] = u.data[key], root",
      "\t}",
      "\treturn root",
      "}",
      "",
      "func (u *UnionFindArraySimple32) Size(key int32) int32 {",
      "\treturn -u.data[u.Find(key)]",
      "}"
    ],
    "description": "UnionFindArraySimple32"
  },
  "UnionFindMapSimple": {
    "scope": "go",
    "prefix": "UnionFindMapSimple",
    "body": [
      "",
      "type UnionFindMapSimple struct {",
      "\tPart int",
      "\tdata map[int32]int32",
      "}",
      "",
      "func NewUnionFindMap() *UnionFindMapSimple {",
      "\treturn &UnionFindMapSimple{",
      "\t\tdata: make(map[int32]int32),",
      "\t}",
      "}",
      "",
      "func (ufm *UnionFindMapSimple) Union(key1, key2 int) bool {",
      "\troot1, root2 := int32(ufm.Find(key1)), int32(ufm.Find(key2))",
      "\tif root1 == root2 {",
      "\t\treturn false",
      "\t}",
      "\tif ufm.data[root1] > ufm.data[root2] {",
      "\t\troot1, root2 = root2, root1",
      "\t}",
      "\tufm.data[root1] += ufm.data[root2]",
      "\tufm.data[root2] = root1",
      "\tufm.Part--",
      "\treturn true",
      "}",
      "",
      "func (ufm *UnionFindMapSimple) Find(key int) int {",
      "\tkey32 := int32(key)",
      "\tif _, ok := ufm.data[key32]; !ok {",
      "\t\tufm.Add(key)",
      "\t\treturn key",
      "\t}",
      "\tif ufm.data[key32] < 0 {",
      "\t\treturn key",
      "\t}",
      "\tufm.data[key32] = int32(ufm.Find(int(ufm.data[key32])))",
      "\treturn int(ufm.data[key32])",
      "}",
      "",
      "func (ufm *UnionFindMapSimple) Size(key int) int {",
      "\treturn int(-ufm.data[int32(ufm.Find(key))])",
      "}",
      "",
      "func (ufm *UnionFindMapSimple) Add(key int) bool {",
      "\tkey32 := int32(key)",
      "\tif _, ok := ufm.data[key32]; ok {",
      "\t\treturn false",
      "\t}",
      "\tufm.data[key32] = -1",
      "\tufm.Part++",
      "\treturn true",
      "}"
    ],
    "description": "UnionFindMapSimple"
  },
  "UnionFindMapSimple-python": {
    "scope": "python",
    "prefix": "UnionFindMapSimple",
    "body": [
      "class UnionFindMapSimple:",
      "\t\t__slots__ = (\"part\", \"_data\")",
      "",
      "\t\tdef __init__(self):",
      "\t\t\t\tself.part = 0",
      "\t\t\t\tself._data = dict()",
      "",
      "\t\tdef add(self, key: int) -> None:",
      "\t\t\t\tif key in self._data:",
      "\t\t\t\t\t\treturn",
      "\t\t\t\tself._data[key] = -1",
      "\t\t\t\tself.part += 1",
      "",
      "\t\tdef union(self, key1: int, key2: int) -> bool:",
      "\t\t\t\troot1, root2 = self.find(key1), self.find(key2)",
      "\t\t\t\tif root1 == root2:",
      "\t\t\t\t\t\treturn False",
      "\t\t\t\tif self._data[root1] > self._data[root2]:",
      "\t\t\t\t\t\troot1, root2 = root2, root1",
      "\t\t\t\tself._data[root1] += self._data[root2]",
      "\t\t\t\tself._data[root2] = root1",
      "\t\t\t\tself.part -= 1",
      "\t\t\t\treturn True",
      "",
      "\t\tdef find(self, key: int) -> int:",
      "\t\t\t\tif key not in self._data:",
      "\t\t\t\t\t\tself.add(key)",
      "\t\t\t\t\t\treturn key",
      "\t\t\t\tif self._data[key] < 0:",
      "\t\t\t\t\t\treturn key",
      "\t\t\t\tself._data[key] = self.find(self._data[key])",
      "\t\t\t\treturn self._data[key]",
      "",
      "\t\tdef getSize(self, key: int) -> int:",
      "\t\t\t\treturn -self._data[self.find(key)]",
      ""
    ],
    "description": "UnionFindMapSimple"
  },
  "ReverseString": {
    "scope": "go",
    "prefix": "ReverseString",
    "body": [
      "func ReverseString(s string) string {",
      "\tn := len(s)",
      "\trunes := make([]rune, n)",
      "\tfor _, r := range s {",
      "\t\tn--",
      "\t\trunes[n] = r",
      "\t}",
      "\treturn string(runes)",
      "}"
    ],
    "description": "ReverseString"
  },
  "binarySearch-py": {
    "scope": "python",
    "prefix": "binarySearch",
    "body": [
      "from typing import List, Sequence",
      "",
      "",
      "def binarySearch(nums: Sequence[int], target: int, findFirst=True) -> int:",
      "\t\t\"\"\"查询非递减数组中目标值的第一个或最后一个位置.",
      "",
      "\t\tArgs:",
      "",
      "\t\t- nums: 非递减数组",
      "\t\t- target: 目标值",
      "\t\t- findFirst: 是否查询第一个位置. 默认为 True.",
      "",
      "\t\tReturns:",
      "\t\t- int: 目标值的第一个或最后一个位置. 如果目标值不存在, 返回 -1.",
      "",
      "\t\t\"\"\"",
      "",
      "\t\tif not nums or (nums[0] > target or nums[-1] < target):",
      "\t\t\t\treturn -1",
      "\t\tif findFirst:",
      "\t\t\t\tleft, right = 0, len(nums) - 1",
      "\t\t\t\twhile left <= right:",
      "\t\t\t\t\t\tmid = left + (right - left) // 2",
      "\t\t\t\t\t\tif nums[mid] < target:",
      "\t\t\t\t\t\t\t\tleft = mid + 1",
      "\t\t\t\t\t\telse:",
      "\t\t\t\t\t\t\t\tright = mid - 1",
      "\t\t\t\treturn left if left < len(nums) and nums[left] == target else -1",
      "\t\telse:",
      "\t\t\t\tleft, right = 0, len(nums) - 1",
      "\t\t\t\twhile left <= right:",
      "\t\t\t\t\t\tmid = left + (right - left) // 2",
      "\t\t\t\t\t\tif nums[mid] <= target:",
      "\t\t\t\t\t\t\t\tleft = mid + 1",
      "\t\t\t\t\t\telse:",
      "\t\t\t\t\t\t\t\tright = mid - 1",
      "\t\t\t\treturn left - 1 if left > 0 and nums[left - 1] == target else -1",
      ""
    ],
    "description": "binarySearch-python"
  },
  "binarySearch-go": {
    "scope": "go,golang",
    "prefix": "BinarySearch",
    "body": [
      "type Int interface {",
      "\tint | uint | int8 | uint8 | int16 | uint16 | int32 | uint32 | int64 | uint64",
      "}",
      "",
      "// 查询非递减数组中目标值的第一个或最后一个位置.",
      "// arr: 非递减数组",
      "// target: 目标值",
      "// findFirst: 是否查询第一个位置. 默认为 true.",
      "// 返回目标值的第一个或最后一个位置. 如果目标值不存在, 返回-1.",
      "func BinarySearch[T Int](arr []T, target T, findFirst bool) int {",
      "\tif len(arr) == 0 || arr[0] > target || arr[len(arr)-1] < target {",
      "\t\treturn -1",
      "\t}",
      "\tif findFirst {",
      "\t\tleft, right := 0, len(arr)-1",
      "\t\tfor left <= right {",
      "\t\t\tmid := left + (right-left)>>1",
      "\t\t\tif arr[mid] < target {",
      "\t\t\t\tleft = mid + 1",
      "\t\t\t} else {",
      "\t\t\t\tright = mid - 1",
      "\t\t\t}",
      "\t\t}",
      "\t\tif left < len(arr) && arr[left] == target {",
      "\t\t\treturn left",
      "\t\t}",
      "\t\treturn -1",
      "\t} else {",
      "\t\tleft, right := 0, len(arr)-1",
      "\t\tfor left <= right {",
      "\t\t\tmid := left + (right-left)>>1",
      "\t\t\tif arr[mid] <= target {",
      "\t\t\t\tleft = mid + 1",
      "\t\t\t} else {",
      "\t\t\t\tright = mid - 1",
      "\t\t\t}",
      "\t\t}",
      "\t\tif left > 0 && arr[left-1] == target {",
      "\t\t\treturn left - 1",
      "\t\t}",
      "\t\treturn -1",
      "\t}",
      "}"
    ],
    "description": "BinarySearch"
  },
  "Int": {
    "scope": "go",
    "prefix": "Int",
    "body": [
      "type Int interface {",
      "\tint | uint | int8 | uint8 | int16 | uint16 | int32 | uint32 | int64 | uint64",
      "}"
    ],
    "description": "Int 泛型"
  },
  "heap-go": {
    "scope": "go",
    "prefix": "heap",
    "body": [
      "",
      "func NewHeap[H any](less func(a, b H) bool, nums []H) *Heap[H] {",
      "\tnums = append(nums[:0:0], nums...)",
      "\theap := &Heap[H]{less: less, data: nums}",
      "\theap.heapify()",
      "\treturn heap",
      "}",
      "",
      "type Heap[H any] struct {",
      "\tdata []H",
      "\tless func(a, b H) bool",
      "}",
      "",
      "func (h *Heap[H]) Push(value H) {",
      "\th.data = append(h.data, value)",
      "\th.pushUp(h.Len() - 1)",
      "}",
      "",
      "func (h *Heap[H]) Pop() (value H) {",
      "\tif h.Len() == 0 {",
      "\t\tpanic(\"heap is empty\")",
      "\t}",
      "\tvalue = h.data[0]",
      "\th.data[0] = h.data[h.Len()-1]",
      "\th.data = h.data[:h.Len()-1]",
      "\th.pushDown(0)",
      "\treturn",
      "}",
      "",
      "func (h *Heap[H]) Top() (value H) {",
      "\tvalue = h.data[0]",
      "\treturn",
      "}",
      "",
      "func (h *Heap[H]) Len() int { return len(h.data) }",
      "",
      "func (h *Heap[H]) heapify() {",
      "\tn := h.Len()",
      "\tfor i := (n >> 1) - 1; i > -1; i-- {",
      "\t\th.pushDown(i)",
      "\t}",
      "}",
      "",
      "func (h *Heap[H]) pushUp(root int) {",
      "\tfor parent := (root - 1) >> 1; parent >= 0 && h.less(h.data[root], h.data[parent]); parent = (root - 1) >> 1 {",
      "\t\th.data[root], h.data[parent] = h.data[parent], h.data[root]",
      "\t\troot = parent",
      "\t}",
      "}",
      "",
      "func (h *Heap[H]) pushDown(root int) {",
      "\tn := h.Len()",
      "\tfor left := (root<<1 + 1); left < n; left = (root<<1 + 1) {",
      "\t\tright := left + 1",
      "\t\tminIndex := root",
      "\t\tif h.less(h.data[left], h.data[minIndex]) {",
      "\t\t\tminIndex = left",
      "\t\t}",
      "\t\tif right < n && h.less(h.data[right], h.data[minIndex]) {",
      "\t\t\tminIndex = right",
      "\t\t}",
      "\t\tif minIndex == root {",
      "\t\t\treturn",
      "\t\t}",
      "\t\th.data[root], h.data[minIndex] = h.data[minIndex], h.data[root]",
      "\t\troot = minIndex",
      "\t}",
      "}"
    ],
    "description": "heap-go"
  },
  "id-generic": {
    "scope": "go",
    "prefix": ["id-generic", "getId-generic", "dictionary-generic"],
    "body": [
      "",
      "type Dictionary[V comparable] struct {",
      "\t_idToValue []V",
      "\t_valueToId map[V]int32",
      "}",
      "",
      "// A dictionary that maps values to unique ids.",
      "func NewDictionary[V comparable]() *Dictionary[V] {",
      "\treturn &Dictionary[V]{",
      "\t\t_valueToId: map[V]int32{},",
      "\t}",
      "}",
      "func (d *Dictionary[V]) Id(value V) int32 {",
      "\tres, ok := d._valueToId[value]",
      "\tif ok {",
      "\t\treturn res",
      "\t}",
      "\tid := int32(len(d._idToValue))",
      "\td._idToValue = append(d._idToValue, value)",
      "\td._valueToId[value] = id",
      "\treturn id",
      "}",
      "func (d *Dictionary[V]) Value(id int32) V {",
      "\treturn d._idToValue[id]",
      "}",
      "func (d *Dictionary[V]) Has(value V) bool {",
      "\t_, ok := d._valueToId[value]",
      "\treturn ok",
      "}",
      "func (d *Dictionary[V]) Size() int32 {",
      "\treturn int32(len(d._idToValue))",
      "}",
      ""
    ],
    "description": "id-generic"
  },
  "ArgSortCounting": {
    "scope": "go",
    "prefix": ["argSort", "argSortCounting"],
    "body": [
      "",
      "type Int interface {",
      "\tint | uint | int8 | uint8 | int16 | uint16 | int32 | uint32 | int64 | uint64",
      "}",
      "",
      "// 返回一个数字数组的排序后的索引.内部使用计数排序.",
      "func ArgSortCounting[T Int](nums []T, min, max T) []int {",
      "\tcounter := make([]int32, max-min+1)",
      "\tfor _, v := range nums {",
      "\t\tcounter[v-min]++",
      "\t}",
      "\tfor i := 1; i < len(counter); i++ {",
      "\t\tcounter[i] += counter[i-1]",
      "\t}",
      "\torder := make([]int, len(nums))",
      "\tfor i := len(nums) - 1; i >= 0; i-- { // 值相等时，按照下标从小到大排序",
      "\t\tv := nums[i] - min",
      "\t\tcounter[v]--",
      "\t\torder[counter[v]] = i",
      "\t}",
      "\treturn order",
      "}",
      "",
      "func ArgSort[T Int](nums []T) []int {",
      "\torder := make([]int, len(nums))",
      "\tfor i := range order {",
      "\t\torder[i] = i",
      "\t}",
      "\tsort.Slice(order, func(i, j int) bool { return nums[order[i]] < nums[order[j]] })",
      "\treturn order",
      "}",
      "",
      "func ReArrage[T any](arr []T, order []int) []T {",
      "\tres := make([]T, len(order))",
      "\tfor i := range order {",
      "\t\tres[i] = arr[order[i]]",
      "\t}",
      "\treturn res",
      "}"
    ],
    "description": "argSortCounting"
  },
  "A": {
    "scope": "go",
    "prefix": ["floorLog", "ceilLog"],
    "body": [
      "",
      "func CeilLog32(x uint32) int {",
      "\tif x <= 0 {",
      "\t\treturn 0",
      "\t}",
      "\treturn 32 - bits.LeadingZeros32(x-1)",
      "}",
      "",
      "func FloorLog32(x uint32) int {",
      "\tif x <= 0 {",
      "\t\tpanic(\"IllegalArgumentException\")",
      "\t}",
      "\treturn 31 - bits.LeadingZeros32(x)",
      "}",
      "",
      "func CeilLog64(x uint64) int {",
      "\tif x <= 0 {",
      "\t\treturn 0",
      "\t}",
      "\treturn 64 - bits.LeadingZeros64(x-1)",
      "}",
      "",
      "func FloorLog64(x uint64) int {",
      "\tif x <= 0 {",
      "\t\tpanic(\"IllegalArgumentException\")",
      "\t}",
      "\treturn 63 - bits.LeadingZeros64(x)",
      "}",
      ""
    ],
    "description": "log2"
  },
  "tree-weights": {
    "scope": "go",
    "prefix": ["weights", "treeWeights"],
    "body": [
      "\tweights := make([]map[int32]int32, n)",
      "\tfor i := int32(0); i < n; i++ {",
      "\t\tweights[i] = map[int32]int32{}",
      "\t}",
      "\tgetWeight := func(u, v int32) (weight int32, has bool) {",
      "\t\tif u > v {",
      "\t\t\tu, v = v, u",
      "\t\t}",
      "\t\tweight, has = weights[u][v]",
      "\t\treturn",
      "\t}"
    ],
    "description": "tree-weights"
  },
  "subtreeInfo": {
    "scope": "python",
    "prefix": ["subtreeInfo", "getSubtreeInfo"],
    "body": [
      "def getSubtreeInfo(",
      "\t\ttree: List[List[int]], root: int",
      ") -> Tuple[List[int], List[int], List[int], List[int]]:",
      "\t\t\"\"\"获取子树信息.height[i] 表示以 i 为根的子树的高度(距离最远的叶子节点的距离).\"\"\"",
      "\t\tn = len(tree)",
      "\t\tparent = [0] * n",
      "\t\tdepth = [0] * n",
      "\t\tsubsize = [0] * n",
      "\t\theight = [0] * n",
      "\t\ttopological = [0] * n",
      "\t\ttopological[0] = root",
      "\t\tparent[root] = root",
      "\t\tdepth[root] = 0",
      "\t\tleft, right = 0, 1",
      "\t\twhile left < right:",
      "\t\t\t\tcur = topological[left]",
      "\t\t\t\tfor next in tree[cur]:",
      "\t\t\t\t\t\tif next != parent[cur]:",
      "\t\t\t\t\t\t\t\ttopological[right] = next",
      "\t\t\t\t\t\t\t\tright += 1",
      "\t\t\t\t\t\t\t\tparent[next] = cur",
      "\t\t\t\t\t\t\t\tdepth[next] = depth[cur] + 1",
      "\t\t\t\tleft += 1",
      "\t\tright -= 1",
      "\t\twhile right >= 0:",
      "\t\t\t\tcur = topological[right]",
      "\t\t\t\tsubsize[cur] = 1",
      "\t\t\t\theight[cur] = 0",
      "\t\t\t\tfor next in tree[cur]:",
      "\t\t\t\t\t\tif next != parent[cur]:",
      "\t\t\t\t\t\t\t\tsubsize[cur] += subsize[next]",
      "\t\t\t\t\t\t\t\ttmp = height[next] + 1",
      "\t\t\t\t\t\t\t\tif tmp > height[cur]:",
      "\t\t\t\t\t\t\t\t\t\theight[cur] = tmp",
      "\t\t\t\tright -= 1",
      "\t\tparent[root] = -1",
      "\t\treturn parent, depth, subsize, height",
      ""
    ],
    "description": "subtreeInfo"
  },
  "DivideCycle": {
    "scope": "go",
    "prefix": ["DivideCycle", "divideCycle", "cycleDivide"],
    "body": [
      "",
      "// 环区间分解(环分解，环遍历)",
      "func DivideCycle(n int, start int, end int, f func(start, end int, times int)) {",
      "\tif start >= end || n <= 0 {",
      "\t\treturn",
      "\t}",
      "\tloop := (end - start) / n",
      "\tif loop > 0 {",
      "\t\tf(0, n, loop)",
      "\t}",
      "\tif (end-start)%n == 0 {",
      "\t\treturn",
      "\t}",
      "\tstart %= n",
      "\tend %= n",
      "\tif start < end {",
      "\t\tf(start, end, 1)",
      "\t} else {",
      "\t\tf(start, n, 1)",
      "\t\tif end > 0 {",
      "\t\t\tf(0, end, 1)",
      "\t\t}",
      "\t}",
      "}",
      ""
    ],
    "description": "DivideCycle"
  },
  "divideCycle": {
    "scope": "python",
    "prefix": ["divideCycle", "cycleDivide"],
    "body": [
      "from typing import Generator, Tuple",
      "",
      "",
      "def divideCycle(n: int, start: int, end: int) -> Generator[Tuple[int, int, int], None, None]:",
      "\t\t\"\"\"将环分解为若干形如 (start, end, times) 的区间.\"\"\"",
      "\t\tif start >= end or n <= 0:",
      "\t\t\t\treturn",
      "\t\tloop = (end - start) // n",
      "\t\tif loop > 0:",
      "\t\t\t\tyield 0, n, loop",
      "\t\tif (end - start) % n == 0:",
      "\t\t\t\treturn",
      "\t\tstart %= n",
      "\t\tend %= n",
      "\t\tif start < end:",
      "\t\t\t\tyield start, end, 1",
      "\t\telse:",
      "\t\t\t\tyield start, n, 1",
      "\t\t\t\tif end > 0:",
      "\t\t\t\t\t\tyield 0, end, 1",
      ""
    ],
    "description": "divideCycle"
  },
  "input-rust": {
    "scope": "rust",
    "prefix": ["setup_io", "input", "scanner", "io"],
    "body": [
      "// ---------- begin scannner ----------",
      "#[allow(dead_code)]",
      "mod scanner {",
      "\t\tuse std::str::FromStr;",
      "\t\tpub struct Scanner<'a> {",
      "\t\t\t\tit: std::str::SplitWhitespace<'a>,",
      "\t\t}",
      "\t\timpl<'a> Scanner<'a> {",
      "\t\t\t\tpub fn new(s: &'a str) -> Scanner<'a> {",
      "\t\t\t\t\t\tScanner {",
      "\t\t\t\t\t\t\t\tit: s.split_whitespace(),",
      "\t\t\t\t\t\t}",
      "\t\t\t\t}",
      "\t\t\t\tpub fn next<T: FromStr>(&mut self) -> T {",
      "\t\t\t\t\t\tself.it.next().unwrap().parse::<T>().ok().unwrap()",
      "\t\t\t\t}",
      "\t\t\t\tpub fn next_bytes(&mut self) -> Vec<u8> {",
      "\t\t\t\t\t\tself.it.next().unwrap().bytes().collect()",
      "\t\t\t\t}",
      "\t\t\t\tpub fn next_chars(&mut self) -> Vec<char> {",
      "\t\t\t\t\t\tself.it.next().unwrap().chars().collect()",
      "\t\t\t\t}",
      "\t\t\t\tpub fn next_vec<T: FromStr>(&mut self, len: usize) -> Vec<T> {",
      "\t\t\t\t\t\t(0..len).map(|_| self.next()).collect()",
      "\t\t\t\t}",
      "\t\t}",
      "}",
      "// ---------- end scannner ----------",
      "",
      "pub fn setup_io() -> (",
      "\t\tscanner::Scanner<'static>,",
      "\t\tstd::io::BufWriter<std::io::Stdout>,",
      ") {",
      "\t\tuse std::io::Read;",
      "\t\tstatic mut S: &mut String = &mut String::new();",
      "\t\tstd::io::stdin().read_to_string(unsafe { S }).unwrap();",
      "\t\tlet sc = scanner::Scanner::new(unsafe { S });",
      "\t\tlet out = std::io::stdout();",
      "\t\tlet out = std::io::BufWriter::new(out);",
      "\t\t(sc, out)",
      "}",
      "",
      "#[allow(unused)]",
      "fn demo() {",
      "\t\tuse std::io::Write; // !for writeln!",
      "",
      "\t\tlet (mut input, mut output) = setup_io();",
      "\t\tlet n: usize = input.next();",
      "\t\twriteln!(output, \"{}\", n).ok();",
      "}"
    ],
    "description": "input for rust"
  },
  "SortedSet": {
    "scope": "go",
    "prefix": "SortedSet",
    "body": [
      "",
      "type Int interface {",
      "\tint | uint | int8 | uint8 | int16 | uint16 | int32 | uint32 | int64 | uint64",
      "}",
      "",
      "func SortedSet[T Int](n int32, getX func(i int32) T) (newX []T, xtoi map[T]int32) {",
      "\tallNums := make(map[T]struct{})",
      "\tfor i := int32(0); i < n; i++ {",
      "\t\tallNums[getX(i)] = struct{}{}",
      "\t}",
      "\tnewX = make([]T, 0, len(allNums))",
      "\tfor x := range allNums {",
      "\t\tnewX = append(newX, x)",
      "\t}",
      "\tsort.Slice(newX, func(i, j int) bool { return newX[i] < newX[j] })",
      "\txtoi = make(map[T]int32, len(newX))",
      "\tfor i, x := range newX {",
      "\t\txtoi[x] = int32(i)",
      "\t}",
      "\treturn",
      "}"
    ],
    "description": "离散化"
  },
  "test": {
    "scope": "rust",
    "prefix": "test",
    "body": [
      "#[cfg(test)]",
      "mod tests {",
      "\t\tuse super::*;",
      "",
      "\t\t#[test]",
      "\t\tfn test() {",
      "\t\t\t\tmain();",
      "\t\t}",
      "}"
    ],
    "description": "test"
  },
  "sortedSet-2": {
    "scope": "go",
    "prefix": "SortedSet32",
    "body": [
      "func SortedSet32(nums []int) (newNums []int32, size int32) {",
      "\ttmp := append(nums[:0:0], nums...)",
      "\tsort.Ints(tmp)",
      "\tfor fast := 0; fast < len(tmp); fast++ {",
      "\t\tif tmp[fast] != tmp[size] {",
      "\t\t\tsize++",
      "\t\t\ttmp[size] = tmp[fast]",
      "\t\t}",
      "\t}",
      "\tsize++",
      "\ttmp = tmp[:size]",
      "\tnewNums = make([]int32, len(nums))",
      "\tfor i, v := range nums {",
      "\t\tnewNums[i] = int32(sort.SearchInts(tmp, v))",
      "\t}",
      "\treturn",
      "}"
    ],
    "description": "sortedSet-2"
  },
  "groupWhile": {
    "scope": "python",
    "prefix": ["groupByGroupWhile", "groupWhile", "enumerateGroupByGroupWhile", "分组循环"],
    "body": [
      "from typing import Callable, Generator, Tuple",
      "",
      "def groupWhile(",
      "\t\tn: int, predicate: Callable[[int, int], bool], skipFalsySingleValueGroup=False",
      ") -> Generator[Tuple[int, int], None, None]:",
      "\t\t\"\"\"",
      "\t\t分组循环.",
      "\t\t:param n: 数据流长度.",
      "\t\t:param predicate: `[left, curRight]` 闭区间内的元素是否能分到一组.",
      "\t\t:param skipFalsySingleValueGroup: 是否跳过`predicate`返回`False`的单个元素的分组.",
      "\t\t:yield: `[start, end)` 左闭右开分组结果.",
      "\t\t\"\"\"",
      "\t\tend = 0",
      "\t\twhile end < n:",
      "\t\t\t\tstart = end",
      "\t\t\t\twhile end < n and predicate(start, end):",
      "\t\t\t\t\t\tend += 1",
      "\t\t\t\tif end == start:",
      "\t\t\t\t\t\tend += 1",
      "\t\t\t\t\t\tif skipFalsySingleValueGroup:",
      "\t\t\t\t\t\t\t\tcontinue",
      "\t\t\t\tyield start, end"
    ],
    "description": "groupWhile"
  },
  "分组循环snippet": {
    "scope": "python",
    "prefix": ["分组循环snippet", "groupWhile"],
    "body": [
      "\t\tdef predicate(left: int, curRight: int) -> bool:",
      "\t\t\t\treturn False",
      "",
      "\t\tres = -1",
      "\t\tend, n = 0, len(nums)",
      "\t\twhile end < n:",
      "\t\t\t\tstart = end\t# 开始分组",
      "\t\t\t\twhile end < n and predicate(start, end):\t# [start, end] 闭区间内的元素是否能分到同一组",
      "\t\t\t\t\t\tend += 1",
      "",
      "\t\t\t\tif end == start:\t# 非法的单个元素的分组",
      "\t\t\t\t\t\tend += 1",
      "\t\t\t\t\t\t...",
      "\t\t\t\telse:",
      "\t\t\t\t\t\tres = max(res, end - start)\t# 处理分组结果 [start, end)",
      "",
      "\t\treturn res"
    ],
    "description": "分组循环snippet"
  },
  "cast": {
    "scope": "go",
    "prefix": ["cast", "unsafeCast"],
    "body": ["func cast[To, From any](v From) To {", "\treturn *(*To)(unsafe.Pointer(&v))", "}"],
    "description": "cast"
  },
  "bool2int": {
    "scope": "go",
    "prefix": "bool2int",
    "body": [
      "// bool2int returns 0 if x is false or 1 if x is true.",
      "func bool2int(x bool) int {",
      "\treturn int(*(*uint8)(unsafe.Pointer(&x)))",
      "}"
    ],
    "description": "bool2int"
  },
  "id": {
    "scope": "python",
    "prefix": "id",
    "body": [
      "pool = dict()",
      "for i, v in enumerate(nums):",
      "\t\tnums[i] = pool.setdefault(v, len(pool))"
    ],
    "description": "id"
  },
  "getNextIndex": {
    "scope": "python",
    "prefix": ["getNextIndex", "getPrevIndex", "getPrevAndNextIndex"],
    "body": [
      "",
      "from typing import List, Tuple",
      "",
      "",
      "def getPrevIndex(arr: List[int]) -> List[int]:",
      "\t\t\"\"\"",
      "\t\t获取数组中相同元素的前一个元素的位置.不存在则返回-1.",
      "\t\t\"\"\"",
      "",
      "\t\tpool = dict()",
      "\t\tfor i, v in enumerate(arr):",
      "\t\t\t\tarr[i] = pool.setdefault(v, len(pool))",
      "",
      "\t\tn = len(arr)",
      "\t\tnexts, valueNexts = [-1] * n, [-1] * len(pool)",
      "\t\tfor i, v in enumerate(arr):",
      "\t\t\t\tif valueNexts[v] != -1:",
      "\t\t\t\t\t\tnexts[i] = valueNexts[v]",
      "\t\t\t\tvalueNexts[v] = i",
      "\t\treturn nexts",
      "",
      "",
      "def getNextIndex(arr: List[int]) -> List[int]:",
      "\t\t\"\"\"",
      "\t\t获取数组中相同元素的后一个元素的位置.不存在则返回-1.",
      "\t\t\"\"\"",
      "\t\tpool = dict()",
      "\t\tfor i, v in enumerate(arr):",
      "\t\t\t\tarr[i] = pool.setdefault(v, len(pool))",
      "",
      "\t\tn = len(arr)",
      "\t\tnexts, valueNexts = [-1] * n, [-1] * len(pool)",
      "\t\tfor i in range(n - 1, -1, -1):",
      "\t\t\t\tv = arr[i]",
      "\t\t\t\tif valueNexts[v] != -1:",
      "\t\t\t\t\t\tnexts[i] = valueNexts[v]",
      "\t\t\t\tvalueNexts[v] = i",
      "\t\treturn nexts",
      "",
      "",
      "def getPrevAndNextIndex(arr: List[int]) -> Tuple[List[int], List[int]]:",
      "\t\t\"\"\"",
      "\t\t获取数组中相同元素的前一个和后一个元素的位置.不存在则返回-1.",
      "\t\t\"\"\"",
      "\t\tpool = dict()",
      "\t\tfor i, v in enumerate(arr):",
      "\t\t\t\tarr[i] = pool.setdefault(v, len(pool))",
      "",
      "\t\tn = len(arr)",
      "\t\tnexts, prevs, valueNexts, valuePrevs = [-1] * n, [-1] * n, [-1] * len(pool), [-1] * len(pool)",
      "\t\tfor i, v in enumerate(arr):",
      "\t\t\t\tif valueNexts[v] != -1:",
      "\t\t\t\t\t\tprevs[i] = valueNexts[v]",
      "\t\t\t\tvalueNexts[v] = i",
      "\t\tfor i in range(n - 1, -1, -1):",
      "\t\t\t\tv = arr[i]",
      "\t\t\t\tif valuePrevs[v] != -1:",
      "\t\t\t\t\t\tnexts[i] = valuePrevs[v]",
      "\t\t\t\tvaluePrevs[v] = i",
      "\t\treturn prevs, nexts"
    ],
    "description": "getNextIndex"
  },
  "GetNextIndex": {
    "scope": "go",
    "prefix": ["GetPrevIndex", "GetNextIndex", "GetPrevAndNextIndex"],
    "body": [
      "",
      "func GetPrevIndex[T comparable](arr []T) []int32 {",
      "\tpool := make(map[T]int32)",
      "\tnewNums := make([]int32, len(arr))",
      "\tfor i, v := range arr {",
      "\t\tif id, ok := pool[v]; !ok {",
      "\t\t\tnewId := int32(len(pool))",
      "\t\t\tpool[v] = newId",
      "\t\t\tnewNums[i] = newId",
      "\t\t} else {",
      "\t\t\tnewNums[i] = id",
      "\t\t}",
      "\t}",
      "",
      "\tn := int32(len(arr))",
      "\tprevs := make([]int32, n)",
      "\tvaluePrevs := make([]int32, len(pool))",
      "\tfor i := range valuePrevs {",
      "\t\tvaluePrevs[i] = -1",
      "\t}",
      "\tfor i, v := range newNums {",
      "\t\tif valuePrevs[v] != -1 {",
      "\t\t\tprevs[i] = valuePrevs[v]",
      "\t\t} else {",
      "\t\t\tprevs[i] = -1",
      "\t\t}",
      "\t\tvaluePrevs[v] = int32(i)",
      "\t}",
      "\treturn prevs",
      "}",
      "",
      "func GetNextIndex[T comparable](arr []T) []int32 {",
      "\tpool := make(map[T]int32)",
      "\tnewNums := make([]int32, len(arr))",
      "\tfor i, v := range arr {",
      "\t\tif id, ok := pool[v]; !ok {",
      "\t\t\tnewId := int32(len(pool))",
      "\t\t\tpool[v] = newId",
      "\t\t\tnewNums[i] = newId",
      "\t\t} else {",
      "\t\t\tnewNums[i] = id",
      "\t\t}",
      "\t}",
      "",
      "\tn := int32(len(arr))",
      "\tnexts := make([]int32, n)",
      "\tvalueNexts := make([]int32, len(pool))",
      "\tfor i := range valueNexts {",
      "\t\tvalueNexts[i] = -1",
      "\t}",
      "\tfor i := n - 1; i >= 0; i-- {",
      "\t\tv := newNums[i]",
      "\t\tif valueNexts[v] != -1 {",
      "\t\t\tnexts[i] = valueNexts[v]",
      "\t\t} else {",
      "\t\t\tnexts[i] = -1",
      "\t\t}",
      "\t\tvalueNexts[v] = i",
      "\t}",
      "\treturn nexts",
      "}",
      "",
      "func GetPrevAndNextIndex[T comparable](arr []T) ([]int32, []int32) {",
      "\tpool := make(map[T]int32)",
      "\tnewNums := make([]int32, len(arr))",
      "\tfor i, v := range arr {",
      "\t\tif id, ok := pool[v]; !ok {",
      "\t\t\tnewId := int32(len(pool))",
      "\t\t\tpool[v] = newId",
      "\t\t\tnewNums[i] = newId",
      "\t\t} else {",
      "\t\t\tnewNums[i] = id",
      "\t\t}",
      "\t}",
      "",
      "\tn := int32(len(arr))",
      "\tnexts := make([]int32, n)",
      "\tprevs := make([]int32, n)",
      "\tvalueNexts := make([]int32, len(pool))",
      "\tvaluePrevs := make([]int32, len(pool))",
      "\tfor i := range valueNexts {",
      "\t\tvalueNexts[i] = -1",
      "\t\tvaluePrevs[i] = -1",
      "\t}",
      "\tfor i, v := range newNums {",
      "\t\tif valueNexts[v] != -1 {",
      "\t\t\tprevs[i] = valueNexts[v]",
      "\t\t} else {",
      "\t\t\tprevs[i] = -1",
      "\t\t}",
      "\t\tvalueNexts[v] = int32(i)",
      "\t}",
      "\tfor i := n - 1; i >= 0; i-- {",
      "\t\tv := newNums[i]",
      "\t\tif valuePrevs[v] != -1 {",
      "\t\t\tnexts[i] = valuePrevs[v]",
      "\t\t} else {",
      "\t\t\tnexts[i] = -1",
      "\t\t}",
      "\t\tvaluePrevs[v] = i",
      "\t}",
      "\treturn prevs, nexts",
      "}",
      ""
    ],
    "description": "GetNextIndex"
  },
  "groupBy-python": {
    "scope": "python",
    "prefix": "groupBy",
    "body": ["for kind, group in groupby($1):", "\t\tlen_ = len(list(group))"],
    "description": "a"
  },
  "getNextZeroIndex": {
    "scope": "python",
    "prefix": ["getNextZeroIndex", "getNextTargetIndex"],
    "body": [
      "def getNextZeroIndex(nums, target) -> List[int]:",
      "\t\t\"\"\"",
      "\t\t获取数组中`target`的下一个位置(包含自身).不存在则返回n.",
      "",
      "\t\texample:",
      "\t\t```",
      "\t\twhile i != n:",
      "\t\t\t\ti = nexts[i+1]",
      "\t\t```",
      "\t\t\"\"\"",
      "\t\tn = len(nums)",
      "\t\tnexts = [0] * (n + 1)",
      "\t\tnexts[n] = n",
      "\t\tfor i in range(n - 1, -1, -1):",
      "\t\t\t\tnexts[i] = i if nums[i] == target else nexts[i + 1]",
      "\t\treturn nexts"
    ],
    "description": "getNextZeroIndex"
  },

  "enumerateSubstring": {
    "scope": "python",
    "prefix": "enumerateSubstring",
    "body": [
      "n = len($1)",
      "for i in range(n):",
      "\t\t...",
      "\t\tfor j in range(i, n):",
      "\t\t\t\t$1[i : j + 1]"
    ],
    "description": "enumerateSubstring"
  },
  "enumerateSubstring-go": {
    "scope": "go",
    "prefix": "enumerateSubstring",
    "body": [
      "\tn := len($1)",
      "\tfor i := 0; i < n; i++ {",
      "\t\t//",
      "\t\tfor j := i; j < n; j++ {",
      "\t\t\tsub := $1[i : j+1]",
      "\t\t}",
      "\t}"
    ],
    "description": "enumerateSubstring-go"
  },
  "enumerateSubstring-ts": {
    "scope": "typescript",
    "prefix": "enumerateSubstring",
    "body": [
      "\tconst n = $1.length",
      "\tfor (let i = 0; i < n; i++) {",
      "\t\t//",
      "\t\tfor (let j = i; j < n; j++) {",
      "\t\t\tconst sub = $1.slice(i, j + 1)",
      "\t\t}",
      "\t}"
    ],
    "description": "enumerateSubstring-ts"
  },
  "getNextZeroIndex-go": {
    "scope": "go",
    "prefix": ["getNextZeroIndex", "getNextTargetIndex"],
    "body": [
      "",
      "// 获取数组中`target`的下一个位置(包含自身),不存在则返回n:",
      "//",
      "//\tfor i != n:",
      "//\t\t\ti = nexts[i+1]",
      "func GetNextTargetIndex[T comparable](nums []T, target T) []int32 {",
      "\tn := int32(len(nums))",
      "\tnexts := make([]int32, n+1)",
      "\tnexts[n] = n",
      "\tfor i := n - 1; i >= 0; i-- {",
      "\t\tif nums[i] == target {",
      "\t\t\tnexts[i] = i",
      "\t\t} else {",
      "\t\t\tnexts[i] = nexts[i+1]",
      "\t\t}",
      "\t}",
      "\treturn nexts",
      "}",
      ""
    ],
    "description": "getNextZeroIndex-go"
  },
  "enumerateSubstringGroupByTargetCount": {
    "scope": "python",
    "prefix": "enumerateSubstringGroupByTargetCount",
    "body": [
      "def enumerateSubstringGroupByTargetCount(arr, target):",
      "\t\tn = len(arr)",
      "\t\tnexts = [0] * (n + 1)",
      "\t\tnexts[n] = n",
      "\t\tfor i in range(n - 1, -1, -1):",
      "\t\t\t\tnexts[i] = i if arr[i] == target else nexts[i + 1]",
      "\t\tfor i in range(n):",
      "\t\t\t\tj, count = i, 1 if arr[i] == target else 0",
      "\t\t\t\twhile j != n:",
      "\t\t\t\t\t\t# do something using (i, j, count)",
      "\t\t\t\t\t\t$1",
      "\t\t\t\t\t\tj = nexts[j + 1]",
      "\t\t\t\t\t\tcount += 1"
    ],
    "description": "enumerateSubstringGroupByTargetCount"
  },
  "EnumerateSubstringGroupByTargetCount": {
    "scope": "go",
    "prefix": "EnumerateSubstringGroupByTargetCount",
    "body": [
      "// 按照target的数量分组枚举子串",
      "// snippet:",
      "func EnumerateSubstringGroupByTargetCount[T comparable](arr []T, target T) {",
      "\tn := int32(len(arr))",
      "\tnexts := make([]int32, n+1)",
      "\tnexts[n] = n",
      "\tfor i := n - 1; i >= 0; i-- {",
      "\t\tif arr[i] == target {",
      "\t\t\tnexts[i] = i",
      "\t\t} else {",
      "\t\t\tnexts[i] = nexts[i+1]",
      "\t\t}",
      "\t}",
      "\tfor i := int32(0); i < n; i++ {",
      "\t\tj, count := i, 1",
      "\t\tif arr[i] == target {",
      "\t\t\tcount = 1",
      "\t\t} else {",
      "\t\t\tcount = 0",
      "\t\t}",
      "\t\tfor j != n {",
      "\t\t\t// do something using (i, j, count)",
      "\t\t\t//",
      "\t\t\tj = nexts[j+1]",
      "\t\t\tcount++",
      "\t\t}",
      "\t}",
      "}"
    ],
    "description": "EnumerateSubstringGroupByTargetCount"
  },
  "inputFast-golang": {
    "scope": "go",
    "prefix": ["inputFast", "input"],
    "body": [
      "func main() {",
      "\tconst eof = 0",
      "\tin := os.Stdin",
      "\tout := bufio.NewWriter(os.Stdout)",
      "\tdefer out.Flush()",
      "\t_i, _n, buf := 0, 0, make([]byte, 1<<12)",
      "",
      "\trc := func() byte {",
      "\t\tif _i == _n {",
      "\t\t\t_n, _ = in.Read(buf)",
      "\t\t\tif _n == 0 {",
      "\t\t\t\treturn eof",
      "\t\t\t}",
      "\t\t\t_i = 0",
      "\t\t}",
      "\t\tb := buf[_i]",
      "\t\t_i++",
      "\t\treturn b",
      "\t}",
      "",
      "\tNextByte := func() byte {",
      "\t\tb := rc()",
      "\t\tfor ; '0' > b; b = rc() {",
      "\t\t}",
      "\t\treturn b",
      "\t}",
      "\t_ = NextByte",
      "",
      "\t// 读一个整数，支持负数",
      "\tNextInt := func() (x int) {",
      "\t\tneg := false",
      "\t\tb := rc()",
      "\t\tfor ; '0' > b || b > '9'; b = rc() {",
      "\t\t\tif b == eof {",
      "\t\t\t\treturn",
      "\t\t\t}",
      "\t\t\tif b == '-' {",
      "\t\t\t\tneg = true",
      "\t\t\t}",
      "\t\t}",
      "\t\tfor ; '0' <= b && b <= '9'; b = rc() {",
      "\t\t\tx = x*10 + int(b&15)",
      "\t\t}",
      "\t\tif neg {",
      "\t\t\treturn -x",
      "\t\t}",
      "\t\treturn",
      "\t}",
      "\t_ = NextInt",
      "",
      "\t// 读一个仅包含小写字母的字符串",
      "\tNextString := func() (s []byte) {",
      "\t\tb := rc()",
      "\t\tfor ; 'a' > b || b > 'z'; b = rc() { // 'A' 'Z'",
      "\t\t}",
      "\t\tfor ; 'a' <= b && b <= 'z'; b = rc() { // 'A' 'Z'",
      "\t\t\ts = append(s, b)",
      "\t\t}",
      "\t\treturn",
      "\t}",
      "\t_ = NextString",
      "",
      "\t// 读一个长度为 n 的仅包含小写字母的字符串",
      "\tNextStringN := func(n int) []byte {",
      "\t\tb := rc()",
      "\t\tfor ; 'a' > b || b > 'z'; b = rc() { // 'A' 'Z'",
      "\t\t}",
      "\t\ts := make([]byte, 0, n)",
      "\t\ts = append(s, b)",
      "\t\tfor i := 1; i < n; i++ {",
      "\t\t\ts = append(s, rc())",
      "\t\t}",
      "\t\treturn s",
      "\t}",
      "\t_ = NextStringN",
      "",
      "\tn, q := NextInt(), NextInt()",
      "\tfmt.Fprintln(out, n, q)",
      "}",
      ""
    ],
    "description": "inputFast-golang"
  },
  "assert-go": {
    "scope": "go",
    "prefix": "assert",
    "body": ["func assert(cond bool, msg string) {", "\tif !cond {", "\t\tpanic(msg)", "\t}", "}"],
    "description": "assert-go"
  },
  "getPath": {
    "scope": "go",
    "prefix": ["getPath", "findPath"],
    "body": [
      "func GetPath(graph [][]int32, from, to int32) []int32 {",
      "\tn := int32(len(graph))",
      "\tvisited := make([]bool, n)",
      "\tvisited[from] = true",
      "\tstack := []int32{from}",
      "\tpre := make([]int32, n)",
      "\tfor len(stack) > 0 {",
      "\t\tcur := stack[len(stack)-1]",
      "\t\tif cur == to {",
      "\t\t\tbreak",
      "\t\t}",
      "\t\tstack = stack[:len(stack)-1]",
      "\t\tfor _, next := range graph[cur] {",
      "\t\t\tif !visited[next] {",
      "\t\t\t\tvisited[next] = true",
      "\t\t\t\tpre[next] = cur",
      "\t\t\t\tstack = append(stack, next)",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "\tif !visited[to] {",
      "\t\treturn nil",
      "\t}",
      "\tpath := []int32{to}",
      "\tfor v := to; v != from; v = pre[v] {",
      "\t\tpath = append(path, pre[v])",
      "\t}",
      "\tfor i := 0; i < len(path)/2; i++ {",
      "\t\tpath[i], path[len(path)-1-i] = path[len(path)-1-i], path[i]",
      "\t}",
      "\treturn path",
      "}"
    ],
    "description": "getPath"
  },
  "getPath-python": {
    "scope": "python",
    "prefix": ["getPath", "findPath"],
    "body": [
      "def getPath(graph: List[List[int]], start: int, target: int) -> List[int]:",
      "\t\tn = len(graph)",
      "\t\tvisited = [False] * n",
      "\t\tpre = [-1] * n",
      "\t\tstack = [start]",
      "\t\tvisited[start] = True",
      "\t\twhile stack:",
      "\t\t\t\tcur = stack.pop()",
      "\t\t\t\tif cur == target:",
      "\t\t\t\t\t\tbreak",
      "\t\t\t\tfor next_ in graph[cur]:",
      "\t\t\t\t\t\tif not visited[next_]:",
      "\t\t\t\t\t\t\t\tvisited[next_] = True",
      "\t\t\t\t\t\t\t\tpre[next_] = cur",
      "\t\t\t\t\t\t\t\tstack.append(next_)",
      "\t\tif not visited[target]:",
      "\t\t\t\treturn []",
      "\t\tres = []",
      "\t\twhile target != -1:",
      "\t\t\t\tres.append(target)",
      "\t\t\t\ttarget = pre[target]",
      "\t\treturn res[::-1]"
    ],
    "description": "getPath-python"
  },
  "PresumBisector": {
    "scope": "go",
    "prefix": ["PresumBisector", "PresumWithBisect"],
    "body": [
      "",
      "// 带有二分的前缀和，要求元素为非负数.",
      "type PresumBisector struct {",
      "\tn\t\t\tint32",
      "\tpresum []int",
      "}",
      "",
      "func NewPresumBisector(n int32, f func(i int32) int) *PresumBisector {",
      "\tpresum := make([]int, n+1)",
      "\tfor i := int32(1); i <= n; i++ {",
      "\t\tpresum[i] = presum[i-1] + f(i-1)",
      "\t}",
      "\treturn &PresumBisector{n: n, presum: presum}",
      "}",
      "",
      "func (p *PresumBisector) Query(start, end int32) int {",
      "\tif start <= 0 {",
      "\t\tstart = 0",
      "\t}",
      "\tif end > p.n {",
      "\t\tend = p.n",
      "\t}",
      "\tif start >= end {",
      "\t\treturn 0",
      "\t}",
      "\treturn p.presum[end] - p.presum[start]",
      "}",
      "",
      "// 返回最大的 right 使得 [left,right) 内的值满足 check.",
      "func (p *PresumBisector) MaxRight(left int32, check func(sum int, right int32) bool) int32 {",
      "\tif left >= p.n {",
      "\t\treturn p.n",
      "\t}",
      "\tok, ng := left, p.n+1",
      "\tfor ok+1 < ng {",
      "\t\tmid := (ok + ng) >> 1",
      "\t\tif check(p.Query(left, mid), mid) {",
      "\t\t\tok = mid",
      "\t\t} else {",
      "\t\t\tng = mid",
      "\t\t}",
      "\t}",
      "\treturn ok",
      "}",
      "",
      "// 返回最小的 left 使得 [left,right) 内的值满足 check.",
      "func (p *PresumBisector) MinLeft(right int32, check func(sum int, left int32) bool) int32 {",
      "\tif right <= 0 {",
      "\t\treturn 0",
      "\t}",
      "\tok, ng := right, int32(-1)",
      "\tfor ng+1 < ok {",
      "\t\tmid := (ok + ng) >> 1",
      "\t\tif check(p.Query(mid, right), mid) {",
      "\t\t\tok = mid",
      "\t\t} else {",
      "\t\t\tng = mid",
      "\t\t}",
      "\t}",
      "\treturn ok",
      "}",
      ""
    ],
    "description": "PresumBisector"
  },
  "minLeftMaxRight-go": {
    "scope": "go",
    "prefix": ["MinLeft", "MaxRight"],
    "body": [
      "",
      "// 返回最大的 right 使得 [left,right) 内的值满足 check.",
      "// !注意check内的right不包含,使用时需要right-1.",
      "// right<=upper.",
      "func MaxRight(left int, check func(right int) bool, upper int) int {",
      "\tok, ng := left, upper+1",
      "\tfor ok+1 < ng {",
      "\t\tmid := (ok + ng) >> 1",
      "\t\tif check(mid) {",
      "\t\t\tok = mid",
      "\t\t} else {",
      "\t\t\tng = mid",
      "\t\t}",
      "\t}",
      "\treturn ok",
      "}",
      "",
      "// 返回最小的 left 使得 [left,right) 内的值满足 check.",
      "// left>=lower.",
      "func MinLeft(right int, check func(left int) bool, lower int) int {",
      "\tok, ng := right, lower-1",
      "\tfor ng+1 < ok {",
      "\t\tmid := (ok + ng) >> 1",
      "\t\tif check(mid) {",
      "\t\t\tok = mid",
      "\t\t} else {",
      "\t\t\tng = mid",
      "\t\t}",
      "\t}",
      "\treturn ok",
      "}",
      ""
    ],
    "description": "minLeftMaxRight-go"
  },
  "minLeftMaxRight-py": {
    "scope": "python",
    "prefix": ["minLeft", "maxRight"],
    "body": [
      "from typing import Callable",
      "",
      "",
      "def maxRight(left: int, check: Callable[[int], bool], upper: int) -> int:",
      "\t\t\"\"\"返回最大的 right 使得 [left,right) 内的值满足 check. right<=upper.\"\"\"",
      "\t\tok, ng = left, upper + 1",
      "\t\twhile ok + 1 < ng:",
      "\t\t\t\tmid = (ok + ng) >> 1",
      "\t\t\t\tif check(mid):",
      "\t\t\t\t\t\tok = mid",
      "\t\t\t\telse:",
      "\t\t\t\t\t\tng = mid",
      "\t\treturn ok",
      "",
      "",
      "def minLeft(right: int, check: Callable[[int], bool], lower: int) -> int:",
      "\t\t\"\"\"返回最小的 left 使得 [left,right) 内的值满足 check. left>=lower.\"\"\"",
      "\t\tok, ng = right, lower - 1",
      "\t\twhile ng + 1 < ok:",
      "\t\t\t\tmid = (ok + ng) >> 1",
      "\t\t\t\tif check(mid):",
      "\t\t\t\t\t\tok = mid",
      "\t\t\t\telse:",
      "\t\t\t\t\t\tng = mid",
      "\t\treturn ok",
      ""
    ],
    "description": "minLeftMaxRight-py"
  },
  "WaveletMatrixFast-go": {
    "scope": "go",
    "prefix": "WaveletMatrixFast",
    "body": [
      "const INF int = 1e18",
      "",
      "type WaveletMatrixFast struct {",
      "\tn, log, upper int32",
      "",
      "\traw []int",
      "\tmid []int32",
      "\tbv\t[]*bitVector",
      "",
      "\tsmallRange bool",
      "\tindex\t\t\tfunc(int) int32",
      "}",
      "",
      "func NewWaveletMatrixFast(smallRange bool) *WaveletMatrixFast {",
      "\treturn &WaveletMatrixFast{smallRange: smallRange}",
      "}",
      "",
      "func (st *WaveletMatrixFast) Build(m int32, f func(i int32) (v int)) {",
      "\tarr := make([]int, m)",
      "\tfor i := int32(0); i < m; i++ {",
      "\t\tarr[i] = f(i)",
      "\t}",
      "\tst.build(arr)",
      "}",
      "",
      "// [start, end) x [0, y)",
      "func (st *WaveletMatrixFast) CountPrefix(start, end int32, y int) int32 {",
      "\tp := st.index(y)",
      "\tif p == 0 || start >= end {",
      "\t\treturn 0",
      "\t}",
      "\tif p == st.upper {",
      "\t\treturn end - start",
      "\t}",
      "\tres := int32(0)",
      "\tfor d := st.log - 1; d >= 0; d-- {",
      "\t\tl0, r0 := st.bv[d].Rank0(start), st.bv[d].Rank0(end)",
      "\t\tl1, r1 := start+st.mid[d]-l0, end+st.mid[d]-r0",
      "\t\tif p>>d&1 == 1 {",
      "\t\t\tres += r0 - l0",
      "\t\t\tstart, end = l1, r1",
      "\t\t} else {",
      "\t\t\tstart, end = l0, r0",
      "\t\t}",
      "\t}",
      "\treturn res",
      "}",
      "",
      "// [start, end) x [y1, y2)",
      "func (st *WaveletMatrixFast) Count(start, end int32, y1, y2 int) int32 {",
      "\tif y1 >= y2 {",
      "\t\treturn 0",
      "\t}",
      "\treturn st.CountPrefix(start, end, y2) - st.CountPrefix(start, end, y1)",
      "}",
      "",
      "// [start, end)区间内第k(k>=0)小的元素.",
      "func (st *WaveletMatrixFast) Kth(start, end int32, k int32) int {",
      "\tif k < 0 {",
      "\t\tk = 0",
      "\t}",
      "\tif n := end - start - 1; k > n {",
      "\t\tk = n",
      "\t}",
      "\tp := int32(0)",
      "\tfor d := st.log - 1; d >= 0; d-- {",
      "\t\tl0, r0 := st.bv[d].Rank0(start), st.bv[d].Rank0(end)",
      "\t\tl1, r1 := start+st.mid[d]-l0, end+st.mid[d]-r0",
      "\t\tif k < r0-l0 {",
      "\t\t\tstart, end = l0, r0",
      "\t\t} else {",
      "\t\t\tk -= r0 - l0",
      "\t\t\tstart, end = l1, r1",
      "\t\t\tp |= 1 << d",
      "\t\t}",
      "\t}",
      "\treturn st.raw[p]",
      "}",
      "",
      "// <= y 的最大值. 不存在则返回 -INF.",
      "func (st *WaveletMatrixFast) Prev(start, end int32, y int) int {",
      "\tif start < 0 {",
      "\t\tstart = 0",
      "\t}",
      "\tif end > st.n {",
      "\t\tend = st.n",
      "\t}",
      "\tif start >= end {",
      "\t\treturn -INF",
      "\t}",
      "\tk := st.index(y + 1)",
      "\tp := int32(-1)",
      "\tvar dfs func(int32, int32, int32, int32, int32)",
      "\tdfs = func(d, L, R, a, b int32) {",
      "\t\tif b-1 <= p || L == R || k <= a {",
      "\t\t\treturn",
      "\t\t}",
      "\t\tif d == 0 {",
      "\t\t\tif p < a {",
      "\t\t\t\tp = a",
      "\t\t\t}",
      "\t\t\treturn",
      "\t\t}",
      "\t\td--",
      "\t\tc := (a + b) >> 1",
      "\t\tl0, r0 := st.bv[d].Rank0(L), st.bv[d].Rank0(R)",
      "\t\tl1, r1 := L+st.mid[d]-l0, R+st.mid[d]-r0",
      "\t\tdfs(d, l1, r1, c, b)",
      "\t\tdfs(d, l0, r0, a, c)",
      "\t}",
      "\tdfs(st.log, start, end, 0, 1<<st.log)",
      "\tif p == -1 {",
      "\t\treturn -INF",
      "\t}",
      "\treturn st.raw[p]",
      "}",
      "",
      "// >= y 的最小值. 不存在则返回 INF.",
      "func (st *WaveletMatrixFast) Next(start, end int32, y int) int {",
      "\tif start < 0 {",
      "\t\tstart = 0",
      "\t}",
      "\tif end > st.n {",
      "\t\tend = st.n",
      "\t}",
      "\tif start >= end {",
      "\t\treturn INF",
      "\t}",
      "\tk := st.index(y)",
      "\tp := st.upper",
      "\tvar dfs func(int32, int32, int32, int32, int32)",
      "\tdfs = func(d, L, R, a, b int32) {",
      "\t\tif p <= a || L == R || b <= k {",
      "\t\t\treturn",
      "\t\t}",
      "\t\tif d == 0 {",
      "\t\t\tif a < p {",
      "\t\t\t\tp = a",
      "\t\t\t}",
      "\t\t\treturn",
      "\t\t}",
      "\t\td--",
      "\t\tc := (a + b) >> 1",
      "\t\tl0, r0 := st.bv[d].Rank0(L), st.bv[d].Rank0(R)",
      "\t\tl1, r1 := L+st.mid[d]-l0, R+st.mid[d]-r0",
      "\t\tdfs(d, l0, r0, a, c)",
      "\t\tdfs(d, l1, r1, c, b)",
      "\t}",
      "\tdfs(st.log, start, end, 0, 1<<st.log)",
      "\tif p == st.upper {",
      "\t\treturn INF",
      "\t}",
      "\treturn st.raw[p]",
      "}",
      "",
      "// upper: 向上取中位数还是向下取中位数.",
      "func (st *WaveletMatrixFast) Median(start, end int32, upper bool) int {",
      "\tif start < 0 || start >= end || end > st.n {",
      "\t\tpanic(\"invalid range\")",
      "\t}",
      "\tvar k int32",
      "\tif upper {",
      "\t\tk = (end - start) >> 1",
      "\t} else {",
      "\t\tk = (end - start - 1) >> 1",
      "\t}",
      "\treturn st.Kth(start, end, k)",
      "}",
      "",
      "func (st *WaveletMatrixFast) build(arr []int) {",
      "\tn := int32(len(arr))",
      "\tcompressed, index := createIndexCompressionSame(arr, st.smallRange)",
      "\tupper := int32(0)",
      "\tfor _, v := range compressed {",
      "\t\tif v > upper {",
      "\t\t\tupper = v",
      "\t\t}",
      "\t}",
      "\tupper++",
      "\traw := make([]int, upper)",
      "\tfor i, v := range arr {",
      "\t\traw[compressed[i]] = v",
      "\t}",
      "\tlog := int32(0)",
      "\tfor 1<<log < upper {",
      "\t\tlog++",
      "\t}",
      "\tmid := make([]int32, log)",
      "\tbv := make([]*bitVector, log)",
      "\tfor i := range bv {",
      "\t\tbv[i] = newBitVector(n)",
      "\t}",
      "\tarr0, arr1 := make([]int32, n), make([]int32, n)",
      "\tfor d := log - 1; d >= 0; d-- {",
      "\t\tp0, p1 := int32(0), int32(0)",
      "\t\tfor i := int32(0); i < n; i++ {",
      "\t\t\tf := (compressed[i] >> d & 1) == 1",
      "\t\t\tif !f {",
      "\t\t\t\tarr0[p0] = compressed[i]",
      "",
      "\t\t\t\tp0++",
      "\t\t\t} else {",
      "\t\t\t\tbv[d].Set(i)",
      "\t\t\t\tarr1[p1] = compressed[i]",
      "\t\t\t\tp1++",
      "\t\t\t}",
      "\t\t}",
      "\t\tcompressed, arr0 = arr0, compressed",
      "\t\tcopy(compressed[p0:], arr1[:p1])",
      "\t\tmid[d] = p0",
      "\t\tbv[d].Build()",
      "\t}",
      "",
      "\tst.n, st.log, st.upper = n, log, upper",
      "\tst.raw, st.mid, st.bv = raw, mid, bv",
      "\tst.index = index",
      "}",
      "",
      "type bitVector struct {",
      "\tbits\t []uint64",
      "\tpreSum []int32",
      "}",
      "",
      "func newBitVector(n int32) *bitVector {",
      "\treturn &bitVector{bits: make([]uint64, n>>6+1), preSum: make([]int32, n>>6+1)}",
      "}",
      "",
      "func (bv *bitVector) Set(i int32) {",
      "\tbv.bits[i>>6] |= 1 << (i & 63)",
      "}",
      "",
      "func (bv *bitVector) Build() {",
      "\tfor i := 0; i < len(bv.bits)-1; i++ {",
      "\t\tbv.preSum[i+1] = bv.preSum[i] + int32(bits.OnesCount64(bv.bits[i]))",
      "\t}",
      "}",
      "",
      "func (bv *bitVector) Rank0(k int32) int32 {",
      "\treturn k - bv.preSum[k>>6] - int32(bits.OnesCount64(bv.bits[k>>6]&((1<<(k&63))-1)))",
      "}",
      "",
      "func createIndexCompressionSame(arr []int, smallRange bool) (compressedArr []int32, index func(int) int32) {",
      "\tif smallRange {",
      "\t\treturn indexCompressionSameSmall(arr)",
      "\t} else {",
      "\t\treturn indexCompressionSameLarge(arr)",
      "\t}",
      "}",
      "",
      "func indexCompressionSameSmall(arr []int) (compressedArr []int32, index func(int) int32) {",
      "\tvar min_, max_ int",
      "\tvar data []int32",
      "\tcompressedArr = make([]int32, len(arr))",
      "\tfor i, v := range arr {",
      "\t\tcompressedArr[i] = int32(v)",
      "\t}",
      "\tmin32, max32 := int32(0), int32(-1)",
      "\tif len(compressedArr) > 0 {",
      "\t\tfor _, x := range compressedArr {",
      "\t\t\tif x < min32 {",
      "\t\t\t\tmin32 = x",
      "\t\t\t}",
      "\t\t\tif x > max32 {",
      "\t\t\t\tmax32 = x",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "\tdata = make([]int32, max32-min32+2)",
      "\tfor _, x := range compressedArr {",
      "\t\tdata[x-min32+1] = 1",
      "\t}",
      "\tfor i := 0; i < len(data)-1; i++ {",
      "\t\tdata[i+1] += data[i]",
      "\t}",
      "\tfor i, v := range compressedArr {",
      "\t\tcompressedArr[i] = data[v-min32]",
      "\t}",
      "\tmin_, max_ = int(min32), int(max32)",
      "\tindex = func(x int) int32 { return data[clamp(x-min_, 0, max_-min_+1)] }",
      "\treturn",
      "}",
      "",
      "func indexCompressionSameLarge(arr []int) (compressedArr []int32, index func(int) int32) {",
      "\tvar data []int",
      "\torder := argSort(arr)",
      "\tcompressedArr = make([]int32, len(arr))",
      "\tfor _, v := range order {",
      "\t\tif len(data) == 0 || data[len(data)-1] != arr[v] {",
      "\t\t\tdata = append(data, arr[v])",
      "\t\t}",
      "\t\tcompressedArr[v] = int32(len(data) - 1)",
      "\t}",
      "\tdata = data[:len(data):len(data)]",
      "\tindex = func(x int) int32 { return int32(sort.SearchInts(data, x)) }",
      "\treturn",
      "}",
      "",
      "func clamp(x, min, max int) int {",
      "\tif x < min {",
      "\t\treturn min",
      "\t}",
      "\tif x > max {",
      "\t\treturn max",
      "\t}",
      "\treturn x",
      "}",
      "",
      "func argSort(nums []int) []int32 {",
      "\torder := make([]int32, len(nums))",
      "\tfor i := int32(0); i < int32(len(order)); i++ {",
      "\t\torder[i] = i",
      "\t}",
      "\tsort.Slice(order, func(i, j int) bool { return nums[order[i]] < nums[order[j]] })",
      "\treturn order",
      "}",
      ""
    ],
    "description": "WaveletMatrixFast"
  },
  "WaveletMatrixWithSumFast-go": {
    "scope": "go",
    "prefix": ["WaveletMatrixWithSumFast", "WaveletMatrixFastWithSum"],
    "body": [
      "",
      "const INF int = 2e18",
      "",
      "type E = int",
      "",
      "func e() E\t\t\t\t{ return 0 }",
      "func op(a, b E) E { return a + b }",
      "func inv(a E) E\t { return -a } // 可选, 查询范围和时用于差分",
      "",
      "// (类)线段树的实现.",
      "type SegTreeLike struct {",
      "\tseg *StaticRangeProductGroup",
      "\t// seg *SegmentTree // StaticRangeProduct",
      "}",
      "",
      "func (st *SegTreeLike) Build(sum []E) {",
      "\tst.seg = NewStaticRangeProductGroup(sum)",
      "\t// st.seg = NewSegmentTreeFrom(sum)",
      "}",
      "",
      "func (st *SegTreeLike) Query(start, end int32) E {",
      "\treturn st.seg.Query(start, end)",
      "}",
      "",
      "func (st *SegTreeLike) Set(i int32, e E) {",
      "\t// st.seg.Set(i, e)",
      "}",
      "",
      "func (st *SegTreeLike) Update(i int32, e E) {",
      "\t// st.seg.Update(i, e)",
      "}",
      "",
      "// ------------------- SegTreeOnWaveletMatrix -------------------",
      "",
      "var _ ISegTreeLike = (*SegTreeLike)(nil)",
      "",
      "type ISegTreeLike interface {",
      "\tBuild(sum []E)",
      "\tQuery(start, end int32) E",
      "\tSet(i int32, e E)",
      "\tUpdate(i int32, e E)",
      "}",
      "",
      "// 内部不使用接口约束，因为接口会导致性能下降.",
      "type WaveletMatrixWithSumFast struct {",
      "\tn, log, upper int32",
      "",
      "\traw []int",
      "\tmid []int32",
      "\tbv\t[]*bitVector",
      "\tseg []*SegTreeLike",
      "",
      "\tsmallRange bool",
      "\tindex\t\t\tfunc(int) int32",
      "}",
      "",
      "func NewWaveletMatrixWithSumFast(smallRange bool) *WaveletMatrixWithSumFast {",
      "\treturn &WaveletMatrixWithSumFast{smallRange: smallRange}",
      "}",
      "",
      "func (st *WaveletMatrixWithSumFast) Build(m int32, f func(i int32) (v int, e E)) {",
      "\tarr, sum := make([]int, m), make([]E, m)",
      "\tfor i := int32(0); i < m; i++ {",
      "\t\tarr[i], sum[i] = f(i)",
      "\t}",
      "\tst.build(arr, sum)",
      "}",
      "",
      "// [start, end) x [0, y)",
      "func (st *WaveletMatrixWithSumFast) CountPrefix(start, end int32, y int) int32 {",
      "\tp := st.index(y)",
      "\tif p == 0 || start >= end {",
      "\t\treturn 0",
      "\t}",
      "\tif p == st.upper {",
      "\t\treturn end - start",
      "\t}",
      "\tres := int32(0)",
      "\tfor d := st.log - 1; d >= 0; d-- {",
      "\t\tl0, r0 := st.bv[d].Rank0(start), st.bv[d].Rank0(end)",
      "\t\tl1, r1 := start+st.mid[d]-l0, end+st.mid[d]-r0",
      "\t\tif p>>d&1 == 1 {",
      "\t\t\tres += r0 - l0",
      "\t\t\tstart, end = l1, r1",
      "\t\t} else {",
      "\t\t\tstart, end = l0, r0",
      "\t\t}",
      "\t}",
      "\treturn res",
      "}",
      "",
      "// [start, end) x [y1, y2)",
      "func (st *WaveletMatrixWithSumFast) Count(start, end int32, y1, y2 int) int32 {",
      "\tif y1 >= y2 {",
      "\t\treturn 0",
      "\t}",
      "\treturn st.CountPrefix(start, end, y2) - st.CountPrefix(start, end, y1)",
      "}",
      "",
      "// [start, end) x [0, y)",
      "func (st *WaveletMatrixWithSumFast) CountAndSumPrefix(start, end int32, y int) (int32, E) {",
      "\tp := st.index(y)",
      "\tif p == 0 {",
      "\t\treturn 0, e()",
      "\t}",
      "\tif p == st.upper {",
      "\t\treturn end - start, st.seg[st.log].Query(start, end)",
      "\t}",
      "\tcount := int32(0)",
      "\tsum := e()",
      "\tfor d := st.log - 1; d >= 0; d-- {",
      "\t\tl0, r0 := st.bv[d].Rank0(start), st.bv[d].Rank0(end)",
      "\t\tl1, r1 := start+st.mid[d]-l0, end+st.mid[d]-r0",
      "\t\tif p>>d&1 == 1 {",
      "\t\t\tcount += r0 - l0",
      "\t\t\tsum = op(sum, st.seg[d].Query(l0, r0))",
      "\t\t\tstart, end = l1, r1",
      "\t\t} else {",
      "\t\t\tstart, end = l0, r0",
      "\t\t}",
      "\t}",
      "\treturn count, sum",
      "}",
      "",
      "// [start, end) x [y1, y2)",
      "func (st *WaveletMatrixWithSumFast) CountAndSum(start, end int32, y1, y2 int) (int32, E) {",
      "\tif start < 0 {",
      "\t\tstart = 0",
      "\t}",
      "\tif end > st.n {",
      "\t\tend = st.n",
      "\t}",
      "\tif start >= end || y1 >= y2 {",
      "\t\treturn 0, e()",
      "\t}",
      "\tlo, hi := st.index(y1), st.index(y2)",
      "\tcount := int32(0)",
      "\tsum := e()",
      "\tvar dfs func(int32, int32, int32, int32, int32)",
      "\tdfs = func(d, L, R, a, b int32) {",
      "\t\tif hi <= a || b <= lo {",
      "\t\t\treturn",
      "\t\t}",
      "\t\tif lo <= a && b <= hi {",
      "\t\t\tcount += R - L",
      "\t\t\tsum = op(sum, st.seg[d].Query(L, R))",
      "\t\t\treturn",
      "\t\t}",
      "\t\td--",
      "\t\tc := (a + b) >> 1",
      "\t\tl0, r0 := st.bv[d].Rank0(L), st.bv[d].Rank0(R)",
      "\t\tl1, r1 := L+st.mid[d]-l0, R+st.mid[d]-r0",
      "\t\tdfs(d, l0, r0, a, c)",
      "\t\tdfs(d, l1, r1, c, b)",
      "\t}",
      "\tdfs(st.log, start, end, 0, 1<<st.log)",
      "\treturn count, sum",
      "}",
      "",
      "// [start, end) x [0, y)",
      "func (st *WaveletMatrixWithSumFast) SumPrefix(start, end int32, y int) E {",
      "\t_, sum := st.CountAndSumPrefix(start, end, y)",
      "\treturn sum",
      "}",
      "",
      "// [start, end) x [y1, y2)",
      "func (st *WaveletMatrixWithSumFast) Sum(start, end int32, y1, y2 int) E {",
      "\t_, sum := st.CountAndSum(start, end, y1, y2)",
      "\treturn sum",
      "}",
      "",
      "func (st *WaveletMatrixWithSumFast) SumAll(start, end int32) E {",
      "\treturn st.seg[st.log].Query(start, end)",
      "}",
      "",
      "// 排名在[k1, k2)间的元素的和.要求运算存在逆元.",
      "func (st *WaveletMatrixWithSumFast) SumIndexRange(start, end int32, k1, k2 int32) E {",
      "\tif k1 < 0 {",
      "\t\tk1 = 0",
      "\t}",
      "\tif k2 > end-start {",
      "\t\tk2 = end - start",
      "\t}",
      "\tif start < 0 {",
      "\t\tstart = 0",
      "\t}",
      "\tif end > st.n {",
      "\t\tend = st.n",
      "\t}",
      "\tif start >= end || k1 >= k2 {",
      "\t\treturn e()",
      "\t}",
      "\t_, sum1 := st.KthValueAndSum(start, end, k1)",
      "\t_, sum2 := st.KthValueAndSum(start, end, k2)",
      "\treturn op(inv(sum1), sum2)",
      "}",
      "",
      "// [start, end)区间内第k(k>=0)小的元素.",
      "func (st *WaveletMatrixWithSumFast) Kth(start, end int32, k int32) int {",
      "\tif k < 0 {",
      "\t\tk = 0",
      "\t}",
      "\tif n := end - start - 1; k > n {",
      "\t\tk = n",
      "\t}",
      "\tp := int32(0)",
      "\tfor d := st.log - 1; d >= 0; d-- {",
      "\t\tl0, r0 := st.bv[d].Rank0(start), st.bv[d].Rank0(end)",
      "\t\tl1, r1 := start+st.mid[d]-l0, end+st.mid[d]-r0",
      "\t\tif k < r0-l0 {",
      "\t\t\tstart, end = l0, r0",
      "\t\t} else {",
      "\t\t\tk -= r0 - l0",
      "\t\t\tstart, end = l1, r1",
      "\t\t\tp |= 1 << d",
      "\t\t}",
      "\t}",
      "\treturn st.raw[p]",
      "}",
      "",
      "// 返回区间 [start, end) 中的 (第k小的元素, 前k个元素(不包括第k小的元素) 的 op 的结果).",
      "// 如果k >= end-start, 返回 (INF, 区间 op 的结果).",
      "func (st *WaveletMatrixWithSumFast) KthValueAndSum(start, end int32, k int32) (int, E) {",
      "\tif start < 0 {",
      "\t\tstart = 0",
      "\t}",
      "\tif end > st.n {",
      "\t\tend = st.n",
      "\t}",
      "\tif start >= end {",
      "\t\treturn INF, e()",
      "\t}",
      "\tif k >= end-start {",
      "\t\treturn INF, st.SumAll(start, end)",
      "\t}",
      "\tp := int32(0)",
      "\tsum := e()",
      "\tfor d := st.log - 1; d >= 0; d-- {",
      "\t\tl0, r0 := st.bv[d].Rank0(start), st.bv[d].Rank0(end)",
      "\t\tl1, r1 := start+st.mid[d]-l0, end+st.mid[d]-r0",
      "\t\tif k < r0-l0 {",
      "\t\t\tstart, end = l0, r0",
      "\t\t} else {",
      "\t\t\tsum = op(sum, st.seg[d].Query(l0, r0))",
      "\t\t\tk -= r0 - l0",
      "\t\t\tstart, end = l1, r1",
      "\t\t\tp |= 1 << d",
      "\t\t}",
      "\t}",
      "\tsum = op(sum, st.seg[0].Query(start, start+k))",
      "\treturn st.raw[p], sum",
      "}",
      "",
      "// <= y 的最大值. 不存在则返回 -INF.",
      "func (st *WaveletMatrixWithSumFast) Prev(start, end int32, y int) int {",
      "\tif start < 0 {",
      "\t\tstart = 0",
      "\t}",
      "\tif end > st.n {",
      "\t\tend = st.n",
      "\t}",
      "\tif start >= end {",
      "\t\treturn -INF",
      "\t}",
      "\tk := st.index(y + 1)",
      "\tp := int32(-1)",
      "\tvar dfs func(int32, int32, int32, int32, int32)",
      "\tdfs = func(d, L, R, a, b int32) {",
      "\t\tif b-1 <= p || L == R || k <= a {",
      "\t\t\treturn",
      "\t\t}",
      "\t\tif d == 0 {",
      "\t\t\tif p < a {",
      "\t\t\t\tp = a",
      "\t\t\t}",
      "\t\t\treturn",
      "\t\t}",
      "\t\td--",
      "\t\tc := (a + b) >> 1",
      "\t\tl0, r0 := st.bv[d].Rank0(L), st.bv[d].Rank0(R)",
      "\t\tl1, r1 := L+st.mid[d]-l0, R+st.mid[d]-r0",
      "\t\tdfs(d, l1, r1, c, b)",
      "\t\tdfs(d, l0, r0, a, c)",
      "\t}",
      "\tdfs(st.log, start, end, 0, 1<<st.log)",
      "\tif p == -1 {",
      "\t\treturn -INF",
      "\t}",
      "\treturn st.raw[p]",
      "}",
      "",
      "// >= y 的最小值. 不存在则返回 INF.",
      "func (st *WaveletMatrixWithSumFast) Next(start, end int32, y int) int {",
      "\tif start < 0 {",
      "\t\tstart = 0",
      "\t}",
      "\tif end > st.n {",
      "\t\tend = st.n",
      "\t}",
      "\tif start >= end {",
      "\t\treturn INF",
      "\t}",
      "\tk := st.index(y)",
      "\tp := st.upper",
      "\tvar dfs func(int32, int32, int32, int32, int32)",
      "\tdfs = func(d, L, R, a, b int32) {",
      "\t\tif p <= a || L == R || b <= k {",
      "\t\t\treturn",
      "\t\t}",
      "\t\tif d == 0 {",
      "\t\t\tif a < p {",
      "\t\t\t\tp = a",
      "\t\t\t}",
      "\t\t\treturn",
      "\t\t}",
      "\t\td--",
      "\t\tc := (a + b) >> 1",
      "\t\tl0, r0 := st.bv[d].Rank0(L), st.bv[d].Rank0(R)",
      "\t\tl1, r1 := L+st.mid[d]-l0, R+st.mid[d]-r0",
      "\t\tdfs(d, l0, r0, a, c)",
      "\t\tdfs(d, l1, r1, c, b)",
      "\t}",
      "\tdfs(st.log, start, end, 0, 1<<st.log)",
      "\tif p == st.upper {",
      "\t\treturn INF",
      "\t}",
      "\treturn st.raw[p]",
      "}",
      "",
      "// upper: 向上取中位数还是向下取中位数.",
      "func (st *WaveletMatrixWithSumFast) Median(start, end int32, upper bool) int {",
      "\tif start < 0 || start >= end || end > st.n {",
      "\t\tpanic(\"invalid range\")",
      "\t}",
      "\tvar k int32",
      "\tif upper {",
      "\t\tk = (end - start) >> 1",
      "\t} else {",
      "\t\tk = (end - start - 1) >> 1",
      "\t}",
      "\treturn st.Kth(start, end, k)",
      "}",
      "",
      "// [start, end) x [0, y) 使得 check(count, sum) 为真的最大的 (count, sum)",
      "func (st *WaveletMatrixWithSumFast) MaxRight(start, end int32, check func(int32, E) bool) (int32, E) {",
      "\tif start >= end {",
      "\t\treturn 0, e()",
      "\t}",
      "\tif s := st.SumAll(start, end); check(end-start, s) {",
      "\t\treturn end - start, s",
      "\t}",
      "\tcount := int32(0)",
      "\tsum := e()",
      "\tfor d := st.log - 1; d >= 0; d-- {",
      "\t\tl0, r0 := st.bv[d].Rank0(start), st.bv[d].Rank0(end)",
      "\t\tl1, r1 := start+st.mid[d]-l0, end+st.mid[d]-r0",
      "\t\tcount1 := count + r0 - l0",
      "\t\tsum1 := op(sum, st.seg[d].Query(l0, r0))",
      "\t\tif check(count1, sum1) {",
      "\t\t\tcount, sum = count1, sum1",
      "\t\t\tstart, end = l1, r1",
      "\t\t} else {",
      "\t\t\tstart, end = l0, r0",
      "\t\t}",
      "\t}",
      "\treturn count, sum",
      "}",
      "",
      "// 设置第i个元素的和.",
      "func (st *WaveletMatrixWithSumFast) Set(i int32, e E) {",
      "\tleft, right := i, i+1",
      "\tst.seg[st.log].Set(left, e)",
      "\tfor d := st.log - 1; d >= 0; d-- {",
      "\t\tl0, r0 := st.bv[d].Rank0(left), st.bv[d].Rank0(right)",
      "\t\tl1, r1 := left+st.mid[d]-l0, right+st.mid[d]-r0",
      "\t\tif l0 < r0 {",
      "\t\t\tleft, right = l0, r0",
      "\t\t}",
      "\t\tif l0 == r0 {",
      "\t\t\tleft, right = l1, r1",
      "\t\t}",
      "\t\tst.seg[d].Set(left, e)",
      "\t}",
      "}",
      "",
      "// 更新第i个元素的和.",
      "func (st *WaveletMatrixWithSumFast) Update(i int32, e E) {",
      "\tleft, right := i, i+1",
      "\tst.seg[st.log].Update(left, e)",
      "\tfor d := st.log - 1; d >= 0; d-- {",
      "\t\tl0, r0 := st.bv[d].Rank0(left), st.bv[d].Rank0(right)",
      "\t\tl1, r1 := left+st.mid[d]-l0, right+st.mid[d]-r0",
      "\t\tif l0 < r0 {",
      "\t\t\tleft, right = l0, r0",
      "\t\t}",
      "\t\tif l0 == r0 {",
      "\t\t\tleft, right = l1, r1",
      "\t\t}",
      "\t\tst.seg[d].Update(left, e)",
      "\t}",
      "}",
      "",
      "func (st *WaveletMatrixWithSumFast) build(arr []int, sum []E) {",
      "\tn := int32(len(arr))",
      "\tcompressed, index := createIndexCompressionSame(arr, st.smallRange)",
      "\tupper := int32(0)",
      "\tfor _, v := range compressed {",
      "\t\tif v > upper {",
      "\t\t\tupper = v",
      "\t\t}",
      "\t}",
      "\tupper++",
      "\traw := make([]int, upper)",
      "\tfor i, v := range arr {",
      "\t\traw[compressed[i]] = v",
      "\t}",
      "\tlog := int32(0)",
      "\tfor 1<<log < upper {",
      "\t\tlog++",
      "\t}",
      "\tmid := make([]int32, log)",
      "\tbv := make([]*bitVector, log)",
      "\tfor i := range bv {",
      "\t\tbv[i] = newBitVector(n)",
      "\t}",
      "\tarr0, arr1 := make([]int32, n), make([]int32, n)",
      "\tsum0, sum1 := make([]E, n), make([]E, n)",
      "\tseg := make([]*SegTreeLike, log+1)",
      "\tfor i := range seg {",
      "\t\tseg[i] = &SegTreeLike{}",
      "\t}",
      "\tseg[log].Build(sum)",
      "\tfor d := log - 1; d >= 0; d-- {",
      "\t\tp0, p1 := int32(0), int32(0)",
      "\t\tfor i := int32(0); i < n; i++ {",
      "\t\t\tf := (compressed[i] >> d & 1) == 1",
      "\t\t\tif !f {",
      "\t\t\t\tarr0[p0] = compressed[i]",
      "\t\t\t\tsum0[p0] = sum[i]",
      "\t\t\t\tp0++",
      "\t\t\t} else {",
      "\t\t\t\tbv[d].Set(i)",
      "\t\t\t\tarr1[p1] = compressed[i]",
      "\t\t\t\tsum1[p1] = sum[i]",
      "\t\t\t\tp1++",
      "\t\t\t}",
      "\t\t}",
      "\t\tcompressed, arr0 = arr0, compressed",
      "\t\tsum, sum0 = sum0, sum",
      "\t\tcopy(compressed[p0:], arr1[:p1])",
      "\t\tcopy(sum[p0:], sum1[:p1])",
      "\t\tmid[d] = p0",
      "\t\tbv[d].Build()",
      "\t\tseg[d].Build(sum)",
      "\t}",
      "",
      "\tst.n, st.log, st.upper = n, log, upper",
      "\tst.raw, st.mid, st.bv, st.seg = raw, mid, bv, seg",
      "\tst.index = index",
      "}",
      "",
      "type bitVector struct {",
      "\tbits\t []uint64",
      "\tpreSum []int32",
      "}",
      "",
      "func newBitVector(n int32) *bitVector {",
      "\treturn &bitVector{bits: make([]uint64, n>>6+1), preSum: make([]int32, n>>6+1)}",
      "}",
      "",
      "func (bv *bitVector) Set(i int32) {",
      "\tbv.bits[i>>6] |= 1 << (i & 63)",
      "}",
      "",
      "func (bv *bitVector) Build() {",
      "\tfor i := 0; i < len(bv.bits)-1; i++ {",
      "\t\tbv.preSum[i+1] = bv.preSum[i] + int32(bits.OnesCount64(bv.bits[i]))",
      "\t}",
      "}",
      "",
      "func (bv *bitVector) Rank0(k int32) int32 {",
      "\treturn k - bv.preSum[k>>6] - int32(bits.OnesCount64(bv.bits[k>>6]&((1<<(k&63))-1)))",
      "}",
      "",
      "func createIndexCompressionSame(arr []int, smallRange bool) (compressedArr []int32, index func(int) int32) {",
      "\tif smallRange {",
      "\t\treturn indexCompressionSameSmall(arr)",
      "\t} else {",
      "\t\treturn indexCompressionSameLarge(arr)",
      "\t}",
      "}",
      "",
      "func indexCompressionSameSmall(arr []int) (compressedArr []int32, index func(int) int32) {",
      "\tvar min_, max_ int",
      "\tvar data []int32",
      "\tcompressedArr = make([]int32, len(arr))",
      "\tfor i, v := range arr {",
      "\t\tcompressedArr[i] = int32(v)",
      "\t}",
      "\tmin32, max32 := int32(0), int32(-1)",
      "\tif len(compressedArr) > 0 {",
      "\t\tfor _, x := range compressedArr {",
      "\t\t\tif x < min32 {",
      "\t\t\t\tmin32 = x",
      "\t\t\t}",
      "\t\t\tif x > max32 {",
      "\t\t\t\tmax32 = x",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "\tdata = make([]int32, max32-min32+2)",
      "\tfor _, x := range compressedArr {",
      "\t\tdata[x-min32+1] = 1",
      "\t}",
      "\tfor i := 0; i < len(data)-1; i++ {",
      "\t\tdata[i+1] += data[i]",
      "\t}",
      "\tfor i, v := range compressedArr {",
      "\t\tcompressedArr[i] = data[v-min32]",
      "\t}",
      "\tmin_, max_ = int(min32), int(max32)",
      "\tindex = func(x int) int32 { return data[clamp(x-min_, 0, max_-min_+1)] }",
      "\treturn",
      "}",
      "",
      "func indexCompressionSameLarge(arr []int) (compressedArr []int32, index func(int) int32) {",
      "\tvar data []int",
      "\torder := argSort(arr)",
      "\tcompressedArr = make([]int32, len(arr))",
      "\tfor _, v := range order {",
      "\t\tif len(data) == 0 || data[len(data)-1] != arr[v] {",
      "\t\t\tdata = append(data, arr[v])",
      "\t\t}",
      "\t\tcompressedArr[v] = int32(len(data) - 1)",
      "\t}",
      "\tdata = data[:len(data):len(data)]",
      "\tindex = func(x int) int32 { return int32(sort.SearchInts(data, x)) }",
      "\treturn",
      "}",
      "",
      "func clamp(x, min, max int) int {",
      "\tif x < min {",
      "\t\treturn min",
      "\t}",
      "\tif x > max {",
      "\t\treturn max",
      "\t}",
      "\treturn x",
      "}",
      "",
      "func argSort(nums []int) []int32 {",
      "\torder := make([]int32, len(nums))",
      "\tfor i := int32(0); i < int32(len(order)); i++ {",
      "\t\torder[i] = i",
      "\t}",
      "\tsort.Slice(order, func(i, j int) bool { return nums[order[i]] < nums[order[j]] })",
      "\treturn order",
      "}",
      "",
      "const INF32 int32 = 1 << 30",
      "",
      "// PointAddRangeSum.",
      "",
      "func (*SegmentTree) e() E\t\t\t\t{ return 0 }",
      "func (*SegmentTree) op(a, b E) E { return a + b }",
      "func min32(a, b int32) int32 {",
      "\tif a < b {",
      "\t\treturn a",
      "\t}",
      "\treturn b",
      "}",
      "func max32(a, b int32) int32 {",
      "\tif a > b {",
      "\t\treturn a",
      "\t}",
      "\treturn b",
      "}",
      "",
      "type SegmentTree struct {",
      "\tn, size int32",
      "\tseg\t\t []E",
      "}",
      "",
      "func NewSegmentTree(n int32, f func(int32) E) *SegmentTree {",
      "\tres := &SegmentTree{}",
      "\tsize := int32(1)",
      "\tfor size < n {",
      "\t\tsize <<= 1",
      "\t}",
      "\tseg := make([]E, size<<1)",
      "\tfor i := range seg {",
      "\t\tseg[i] = res.e()",
      "\t}",
      "\tfor i := int32(0); i < n; i++ {",
      "\t\tseg[i+size] = f(i)",
      "\t}",
      "\tfor i := size - 1; i > 0; i-- {",
      "\t\tseg[i] = res.op(seg[i<<1], seg[i<<1|1])",
      "\t}",
      "\tres.n = n",
      "\tres.size = size",
      "\tres.seg = seg",
      "\treturn res",
      "}",
      "func NewSegmentTreeFrom(leaves []E) *SegmentTree {",
      "\tres := &SegmentTree{}",
      "\tn := int32(len(leaves))",
      "\tsize := int32(1)",
      "\tfor size < n {",
      "\t\tsize <<= 1",
      "\t}",
      "\tseg := make([]E, size<<1)",
      "\tfor i := range seg {",
      "\t\tseg[i] = res.e()",
      "\t}",
      "\tfor i := int32(0); i < n; i++ {",
      "\t\tseg[i+size] = leaves[i]",
      "\t}",
      "\tfor i := size - 1; i > 0; i-- {",
      "\t\tseg[i] = res.op(seg[i<<1], seg[i<<1|1])",
      "\t}",
      "\tres.n = n",
      "\tres.size = size",
      "\tres.seg = seg",
      "\treturn res",
      "}",
      "func (st *SegmentTree) Get(index int32) E {",
      "\tif index < 0 || index >= st.n {",
      "\t\treturn st.e()",
      "\t}",
      "\treturn st.seg[index+st.size]",
      "}",
      "func (st *SegmentTree) Set(index int32, value E) {",
      "\tif index < 0 || index >= st.n {",
      "\t\treturn",
      "\t}",
      "\tindex += st.size",
      "\tst.seg[index] = value",
      "\tfor index >>= 1; index > 0; index >>= 1 {",
      "\t\tst.seg[index] = st.op(st.seg[index<<1], st.seg[index<<1|1])",
      "\t}",
      "}",
      "func (st *SegmentTree) Update(index int32, value E) {",
      "\tif index < 0 || index >= st.n {",
      "\t\treturn",
      "\t}",
      "\tindex += st.size",
      "\tst.seg[index] = st.op(st.seg[index], value)",
      "\tfor index >>= 1; index > 0; index >>= 1 {",
      "\t\tst.seg[index] = st.op(st.seg[index<<1], st.seg[index<<1|1])",
      "\t}",
      "}",
      "",
      "// [start, end)",
      "func (st *SegmentTree) Query(start, end int32) E {",
      "\tif start < 0 {",
      "\t\tstart = 0",
      "\t}",
      "\tif end > st.n {",
      "\t\tend = st.n",
      "\t}",
      "\tif start >= end {",
      "\t\treturn st.e()",
      "\t}",
      "\tleftRes, rightRes := st.e(), st.e()",
      "\tstart += st.size",
      "\tend += st.size",
      "\tfor start < end {",
      "\t\tif start&1 == 1 {",
      "\t\t\tleftRes = st.op(leftRes, st.seg[start])",
      "\t\t\tstart++",
      "\t\t}",
      "\t\tif end&1 == 1 {",
      "\t\t\tend--",
      "\t\t\trightRes = st.op(st.seg[end], rightRes)",
      "\t\t}",
      "\t\tstart >>= 1",
      "\t\tend >>= 1",
      "\t}",
      "\treturn st.op(leftRes, rightRes)",
      "}",
      "func (st *SegmentTree) QueryAll() E { return st.seg[1] }",
      "func (st *SegmentTree) GetAll() []E {",
      "\tres := make([]E, st.n)",
      "\tcopy(res, st.seg[st.size:st.size+st.n])",
      "\treturn res",
      "}",
      "",
      "type StaticRangeProductGroup struct {",
      "\tdata []E",
      "}",
      "",
      "func NewStaticRangeProductGroup(arr []E) *StaticRangeProductGroup {",
      "\tm := int32(len(arr))",
      "\tdata := make([]E, m+1)",
      "\tdata[0] = e()",
      "\tfor i := int32(0); i < m; i++ {",
      "\t\tdata[i+1] = op(data[i], arr[i])",
      "\t}",
      "\treturn &StaticRangeProductGroup{data}",
      "}",
      "",
      "func (s *StaticRangeProductGroup) Query(start, end int32) E {",
      "\tif start >= end {",
      "\t\treturn e()",
      "\t}",
      "\treturn op(inv(s.data[start]), s.data[end])",
      "}"
    ],
    "description": "WaveletMatrixWithSumFast"
  },
  "abs-go": {
    "scope": "go",
    "prefix": "abs",
    "body": [
      "func abs(x int) int {",
      "\tif x < 0 {",
      "\t\treturn -x",
      "\t}",
      "\treturn x",
      "}",
      "",
      "func abs32(x int32) int32 {",
      "\tif x < 0 {",
      "\t\treturn -x",
      "\t}",
      "\treturn x",
      "}"
    ],
    "description": "abs"
  },
  "IncreasingArray-go": {
    "scope": "go",
    "prefix": ["IncreasingArray", "SortedArray"],
    "body": [
      "",
      "type IncreasingArray struct {",
      "\tArr\t\t[]int",
      "\tPresum []int",
      "}",
      "",
      "func NewIncreasingArray(increasingArray []int) *IncreasingArray {",
      "\tif !sort.IntsAreSorted(increasingArray) {",
      "\t\tpanic(\"input array should be increasing\")",
      "\t}",
      "\tpresum := make([]int, len(increasingArray)+1)",
      "\tfor i := 0; i < len(increasingArray); i++ {",
      "\t\tpresum[i+1] = presum[i] + increasingArray[i]",
      "\t}",
      "\treturn &IncreasingArray{Arr: increasingArray, Presum: presum}",
      "}",
      "",
      "// 每次选取最矮的矩形中编号最小的，并把它的高度+1",
      "// 返回第K次选取的矩形的高度和编号.",
      "// k>=1.",
      "func (a *IncreasingArray) Increase(k int) (value, pos int) {",
      "\tif k <= 0 {",
      "\t\tpanic(\"k should be >=1\")",
      "\t}",
      "\t// !二分无法与哪个数齐平",
      "\tright := MaxRight(0, func(r int) bool { return a.Arr[r-1]*r-a.Presum[r] < k }, len(a.Arr))",
      "\tfilled := a.Arr[right-1]*right - a.Presum[right]",
      "\tremain := k - filled",
      "\tdiv, mod := remain/right, remain%right",
      "\tvalue = a.Arr[right-1] + div",
      "\tif mod > 0 {",
      "\t\tvalue++",
      "\t}",
      "\tpos = mod - 1",
      "\tif pos < 0 {",
      "\t\tpos += right",
      "\t}",
      "\treturn",
      "}",
      "",
      "func (a *IncreasingArray) IncreaseForMin(k int) int {",
      "\tif k <= 0 {",
      "\t\treturn a.Arr[0]",
      "\t}",
      "\tright := MaxRight(0, func(r int) bool { return a.Arr[r-1]*r-a.Presum[r] < k }, len(a.Arr))",
      "\tfilled := a.Arr[right-1]*right - a.Presum[right]",
      "\tremain := k - filled",
      "\treturn a.Arr[right-1] + remain/right",
      "}",
      "",
      "// 每次选取最矮的矩形中编号最小的，并把它的高度+1",
      "// 返回操作后的数组.",
      "func (a *IncreasingArray) IncreaseForArray(k int) []int {",
      "\tif k <= 0 {",
      "\t\treturn a.Arr",
      "\t}",
      "\tright := MaxRight(0, func(r int) bool { return a.Arr[r-1]*r-a.Presum[r] < k }, len(a.Arr))",
      "\tfilled := a.Arr[right-1]*right - a.Presum[right]",
      "\tremain := k - filled",
      "\tdiv, mod := remain/right, remain%right",
      "\tbase := a.Arr[right-1] + div",
      "\tres := append(a.Arr[:0:0], a.Arr...)",
      "\tfor i := 0; i < right; i++ {",
      "\t\tres[i] = base",
      "\t\tif i < mod {",
      "\t\t\tres[i]++",
      "\t\t}",
      "\t}",
      "\treturn res",
      "}",
      "",
      "// 每次选取最高的矩形中编号最小的，并把它的高度-1",
      "// 返回第K次选取的矩形的高度和编号.",
      "// k>=1.",
      "func (a *IncreasingArray) Decrease(k int) (value, pos int) {",
      "\tif k <= 0 {",
      "\t\tpanic(\"k should be >=1\")",
      "\t}",
      "\tleft := MinLeft(",
      "\t\tlen(a.Arr),",
      "\t\tfunc(l int) bool {",
      "\t\t\treturn (a.Presum[len(a.Arr)]-a.Presum[l])-a.Arr[l]*(len(a.Arr)-l) < k",
      "\t\t},",
      "\t\t0,",
      "\t)",
      "\tfilled := a.Presum[len(a.Arr)] - a.Presum[left] - a.Arr[left]*(len(a.Arr)-left)",
      "\tremain := k - filled",
      "\tdiv, mod := remain/(len(a.Arr)-left), remain%(len(a.Arr)-left)",
      "\tvalue = a.Arr[left] - div",
      "\tif mod > 0 {",
      "\t\tvalue--",
      "\t}",
      "\tpos = mod - 1",
      "\tif pos < 0 {",
      "\t\tpos += len(a.Arr) - left",
      "\t}",
      "\tpos += left",
      "\treturn",
      "}",
      "",
      "func (a *IncreasingArray) DecreaseForMax(k int) int {",
      "\tif k <= 0 {",
      "\t\treturn a.Arr[len(a.Arr)-1]",
      "\t}",
      "\tleft := MinLeft(",
      "\t\tlen(a.Arr),",
      "\t\tfunc(l int) bool {",
      "\t\t\treturn (a.Presum[len(a.Arr)]-a.Presum[l])-a.Arr[l]*(len(a.Arr)-l) < k",
      "\t\t},",
      "\t\t0,",
      "\t)",
      "\tfilled := a.Presum[len(a.Arr)] - a.Presum[left] - a.Arr[left]*(len(a.Arr)-left)",
      "\tremain := k - filled",
      "\treturn a.Arr[left] - remain/(len(a.Arr)-left)",
      "}",
      "",
      "// 每次选取最高的矩形中编号最小的，并把它的高度-1",
      "// 返回操作后的数组.",
      "func (a *IncreasingArray) DecreaseForArray(k int) []int {",
      "\tif k <= 0 {",
      "\t\treturn a.Arr",
      "\t}",
      "\tleft := MinLeft(",
      "\t\tlen(a.Arr),",
      "\t\tfunc(l int) bool {",
      "\t\t\treturn (a.Presum[len(a.Arr)]-a.Presum[l])-a.Arr[l]*(len(a.Arr)-l) < k",
      "\t\t},",
      "\t\t0,",
      "\t)",
      "\tfilled := a.Presum[len(a.Arr)] - a.Presum[left] - a.Arr[left]*(len(a.Arr)-left)",
      "\tremain := k - filled",
      "\tdiv, mod := remain/(len(a.Arr)-left), remain%(len(a.Arr)-left)",
      "\tbase := a.Arr[left] - div",
      "\tres := append(a.Arr[:0:0], a.Arr...)",
      "\tfor i := left; i < len(a.Arr); i++ {",
      "\t\tres[i] = base",
      "\t\tif i-left < mod {",
      "\t\t\tres[i]--",
      "\t\t}",
      "\t}",
      "\treturn res",
      "}",
      "",
      "// 求所有数与v取min的和.",
      "func (a *IncreasingArray) SumWithUpClamp(v int) int {",
      "\tpos := sort.SearchInts(a.Arr, v)",
      "\treturn a.Presum[pos] + (len(a.Arr)-pos)*v",
      "}",
      "",
      "func (a *IncreasingArray) SumWithUpClampRange(v int, start, end int) int {",
      "\tif start < 0 {",
      "\t\tstart = 0",
      "\t}",
      "\tif end > len(a.Arr) {",
      "\t\tend = len(a.Arr)",
      "\t}",
      "\tif start >= end {",
      "\t\treturn 0",
      "\t}",
      "\tlessCount := sort.SearchInts(a.Arr[start:end], v)",
      "\tlessSum := a.Presum[start+lessCount] - a.Presum[start]",
      "\treturn lessSum + v*(end-start-lessCount)",
      "}",
      "",
      "// 求所有数与v取max的和.",
      "func (a *IncreasingArray) SumWithLowClamp(v int) int {",
      "\tpos := sort.SearchInts(a.Arr, v)",
      "\treturn pos*v + a.Presum[len(a.Arr)] - a.Presum[pos]",
      "}",
      "",
      "func (a *IncreasingArray) SumWithLowClampRange(v int, start, end int) int {",
      "\tif start < 0 {",
      "\t\tstart = 0",
      "\t}",
      "\tif end > len(a.Arr) {",
      "\t\tend = len(a.Arr)",
      "\t}",
      "\tif start >= end {",
      "\t\treturn 0",
      "\t}",
      "\tlessCount := sort.SearchInts(a.Arr[start:end], v)",
      "\tlargerSum := a.Presum[end] - a.Presum[start+lessCount]",
      "\treturn v*lessCount + largerSum",
      "}",
      "",
      "// 求所有数与v的绝对值差的和.",
      "func (a *IncreasingArray) DiffSum(v int) int {",
      "\tpos := sort.SearchInts(a.Arr, v)",
      "\tn := len(a.Arr)",
      "\tleftSum := v*pos - a.Presum[pos]",
      "\trightSum := a.Presum[n] - a.Presum[pos] - v*(n-pos)",
      "\treturn leftSum + rightSum",
      "}",
      "",
      "func (a *IncreasingArray) DiffSumRange(v int, start, end int) int {",
      "\tif start < 0 {",
      "\t\tstart = 0",
      "\t}",
      "\tif end > len(a.Arr) {",
      "\t\tend = len(a.Arr)",
      "\t}",
      "\tif start >= end {",
      "\t\treturn 0",
      "\t}",
      "\tpresum := a.Presum",
      "\tpos := sort.SearchInts(a.Arr, v)",
      "\tif pos <= start {",
      "\t\treturn (presum[end] - presum[start]) - v*(end-start)",
      "\t}",
      "\tif pos >= end {",
      "\t\treturn v*(end-start) - (presum[end] - presum[start])",
      "\t}",
      "\tleftSum := v*(pos-start) - (presum[pos] - presum[start])",
      "\trightSum := presum[end] - presum[pos] - v*(end-pos)",
      "\treturn leftSum + rightSum",
      "}",
      "",
      "// !WaveletMatrixLike Api",
      "",
      "// [start,end) x [y1,y2) 中的数的个数.",
      "func (a *IncreasingArray) CountRange(start, end int, y1, y2 int) int {",
      "\tcount, _ := a.CountAndSumRange(start, end, y1, y2)",
      "\treturn count",
      "}",
      "",
      "// [start,end) x [y1,y2) 中的数的和.",
      "func (a *IncreasingArray) SumRange(start, end int, y1, y2 int) int {",
      "\t_, sum := a.CountAndSumRange(start, end, y1, y2)",
      "\treturn sum",
      "}",
      "",
      "// [start,end) x [y1,y2) 中的数的个数、和.",
      "func (a *IncreasingArray) CountAndSumRange(start, end int, y1, y2 int) (int, int) {",
      "\tif y1 >= y2 {",
      "\t\treturn 0, 0",
      "\t}",
      "\tif start < 0 {",
      "\t\tstart = 0",
      "\t}",
      "\tif end > len(a.Arr) {",
      "\t\tend = len(a.Arr)",
      "\t}",
      "\tif start >= end {",
      "\t\treturn 0, 0",
      "\t}",
      "\tnums := a.Arr[start:end]",
      "\tleft := sort.SearchInts(nums, y1)",
      "\tright := sort.SearchInts(nums, y2)",
      "\treturn right - left, a.Presum[start+right] - a.Presum[start+left]",
      "}",
      "",
      "// 返回最大的 right 使得 [left,right) 内的值满足 check.",
      "// right<=upper.",
      "func MaxRight(left int, check func(right int) bool, upper int) int {",
      "\tok, ng := left, upper+1",
      "\tfor ok+1 < ng {",
      "\t\tmid := (ok + ng) >> 1",
      "\t\tif check(mid) {",
      "\t\t\tok = mid",
      "\t\t} else {",
      "\t\t\tng = mid",
      "\t\t}",
      "\t}",
      "\treturn ok",
      "}",
      "",
      "// 返回最小的 left 使得 [left,right) 内的值满足 check.",
      "// left>=lower.",
      "func MinLeft(right int, check func(left int) bool, lower int) int {",
      "\tok, ng := right, lower-1",
      "\tfor ng+1 < ok {",
      "\t\tmid := (ok + ng) >> 1",
      "\t\tif check(mid) {",
      "\t\t\tok = mid",
      "\t\t} else {",
      "\t\t\tng = mid",
      "\t\t}",
      "\t}",
      "\treturn ok",
      "}",
      "",
      "func abs(x int) int {",
      "\tif x < 0 {",
      "\t\treturn -x",
      "\t}",
      "\treturn x",
      "}",
      "",
      "func min(a, b int) int {",
      "\tif a < b {",
      "\t\treturn a",
      "\t}",
      "\treturn b",
      "}",
      "",
      "func max(a, b int) int {",
      "\tif a > b {",
      "\t\treturn a",
      "\t}",
      "\treturn b",
      "}",
      "",
      "func min32(a, b int32) int32 {",
      "\tif a < b {",
      "\t\treturn a",
      "\t}",
      "\treturn b",
      "}",
      "",
      "func max32(a, b int32) int32 {",
      "\tif a > b {",
      "\t\treturn a",
      "\t}",
      "\treturn b",
      "}",
      "",
      "func mins(nums ...int) int {",
      "\tres := nums[0]",
      "\tfor _, num := range nums {",
      "\t\tif num < res {",
      "\t\t\tres = num",
      "\t\t}",
      "\t}",
      "\treturn res",
      "}",
      "",
      "func maxs(nums ...int) int {",
      "\tres := nums[0]",
      "\tfor _, num := range nums {",
      "\t\tif num > res {",
      "\t\t\tres = num",
      "\t\t}",
      "\t}",
      "\treturn res",
      "}",
      "",
      "func assert(cond bool, msg string) {",
      "\tif !cond {",
      "\t\tpanic(msg)",
      "\t}",
      "}"
    ],
    "description": "IncreasingArray"
  },
  "Discretize32-go": {
    "scope": "go",
    "prefix": "Discretize32",
    "body": [
      "",
      "// 将nums中的元素进行离散化，返回新的数组和对应的原始值.",
      "// origin[newNums[i]] == nums[i]",
      "func Discretize32(nums []int32) (newNums []int32, origin []int32) {",
      "\tnewNums = make([]int32, len(nums))",
      "\torigin = make([]int32, 0, len(newNums))",
      "\torder := argSort(int32(len(nums)), func(i, j int32) bool { return nums[i] < nums[j] })",
      "\tfor _, i := range order {",
      "\t\tif len(origin) == 0 || origin[len(origin)-1] != nums[i] {",
      "\t\t\torigin = append(origin, nums[i])",
      "\t\t}",
      "\t\tnewNums[i] = int32(len(origin) - 1)",
      "\t}",
      "\torigin = origin[:len(origin):len(origin)]",
      "\treturn",
      "}",
      "",
      "func argSort(n int32, less func(i, j int32) bool) []int32 {",
      "\torder := make([]int32, n)",
      "\tfor i := range order {",
      "\t\torder[i] = int32(i)",
      "\t}",
      "\tsort.Slice(order, func(i, j int) bool { return less(order[i], order[j]) })",
      "\treturn order",
      "}",
      ""
    ],
    "description": "Discretize32"
  },
  "DiscretizeId": {
    "scope": "go",
    "prefix": "DiscretizeId",
    "body": [
      "// 将nums中的元素进行重映射，返回新的数组和对应的原始值.",
      "// origin[newNums[i]] == nums[i]",
      "func DiscretizeId[T comparable](nums []T) (newNums []int32, origin []T) {",
      "\tpool := make(map[T]int32)",
      "\tnewNums = make([]int32, len(nums))",
      "\torigin = make([]T, 0, len(newNums))",
      "\tfor i, v := range nums {",
      "\t\tif id, ok := pool[v]; ok {",
      "\t\t\tnewNums[i] = id",
      "\t\t} else {",
      "\t\t\tid := int32(len(origin))",
      "\t\t\tpool[v] = id",
      "\t\t\tnewNums[i] = id",
      "\t\t\torigin = append(origin, v)",
      "\t\t}",
      "\t}",
      "\torigin = origin[:len(origin):len(origin)]",
      "\treturn",
      "}"
    ],
    "description": "DiscretizeId"
  },
  "maxIndex": {
    "scope": "go",
    "prefix": ["maxIndex", "minIndex", "indexMax", "indexMin"],
    "body": [
      "$1",
      "type Ordered interface {",
      "\t~int | ~int8 | ~int16 | ~int32 | ~int64 |",
      "\t\t~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64 | ~uintptr |",
      "\t\t~float32 | ~float64 |",
      "\t\t~string",
      "}",
      "",
      "func maxIndex[S Ordered](n int32, f func(int32) S) int32 {",
      "\tif n < 1 {",
      "\t\treturn -1",
      "\t}",
      "\tmv, mi := f(0), int32(0)",
      "\tfor i := int32(1); i < n; i++ {",
      "\t\tif v := f(i); v > mv {",
      "\t\t\tmv, mi = v, i",
      "\t\t}",
      "\t}",
      "\treturn mi",
      "}",
      "",
      "func minIndex[S Ordered](n int32, f func(int32) S) int32 {",
      "\tif n < 1 {",
      "\t\treturn -1",
      "\t}",
      "\tmv, mi := f(0), int32(0)",
      "\tfor i := int32(1); i < n; i++ {",
      "\t\tif v := f(i); v < mv {",
      "\t\t\tmv, mi = v, i",
      "\t\t}",
      "\t}",
      "\treturn mi",
      "}",
      ""
    ],
    "description": "maxIndex"
  },
  "enumerateGroup": {
    "scope": "go",
    "prefix": ["EnumerateGroup", "EnumerateGroupByKey"],
    "body": [
      "// 遍历连续相同元素的分组.相当于python中的`itertools.groupby`.",
      "func EnumerateGroup[E comparable](arr []E, f func(start, end int)) {",
      "\tn := len(arr)",
      "\tend := 0",
      "\tfor end < n {",
      "\t\tstart := end",
      "\t\tleader := arr[end]",
      "\t\tend++",
      "\t\tfor end < n && arr[end] == leader {",
      "\t\t\tend++",
      "\t\t}",
      "\t\tf(start, end) // [start, end)",
      "\t}",
      "}",
      "",
      "// 遍历连续key相同元素的分组.",
      "func EnumerateGroupByKey[E any, K comparable](arr []E, key func(index int) K, f func(start, end int)) {",
      "\tn := len(arr)",
      "\tend := 0",
      "\tfor end < n {",
      "\t\tstart := end",
      "\t\tleader := key(end)",
      "\t\tend++",
      "\t\tfor end < n && key(end) == leader {",
      "\t\t\tend++",
      "\t\t}",
      "\t\tf(start, end) // [start, end)",
      "\t}",
      "}"
    ],
    "description": "enumerateGroup"
  },
  "tree32": {
    "scope": "go",
    "prefix": ["Tree32", "NewTree32"],
    "body": [
      "$1",
      "type neighbor = struct {",
      "\tto\t int32",
      "\teid\tint32",
      "\tcost int",
      "}",
      "",
      "type Tree32 struct {",
      "\tLid, Rid\t\t\t[]int32",
      "\tIdToNode\t\t\t[]int32",
      "\tDepth\t\t\t\t []int32",
      "\tDepthWeighted []int",
      "\tParent\t\t\t\t[]int32",
      "\tHead\t\t\t\t\t[]int32 // 重链头",
      "\tTree\t\t\t\t\t[][]neighbor",
      "\tEdges\t\t\t\t [][2]int32",
      "\tvToE\t\t\t\t\t[]int32 // 节点v的父边的id",
      "\tn\t\t\t\t\t\t int32",
      "}",
      "",
      "func NewTree32(n int32) *Tree32 {",
      "\tres := &Tree32{Tree: make([][]neighbor, n), Edges: make([][2]int32, 0, n-1), n: n}",
      "\treturn res",
      "}",
      "",
      "func (t *Tree32) AddEdge(u, v int32, w int) {",
      "\teid := int32(len(t.Edges))",
      "\tt.Tree[u] = append(t.Tree[u], neighbor{to: v, eid: eid, cost: w})",
      "\tt.Tree[v] = append(t.Tree[v], neighbor{to: u, eid: eid, cost: w})",
      "\tt.Edges = append(t.Edges, [2]int32{u, v})",
      "}",
      "",
      "func (t *Tree32) AddDirectedEdge(from, to int32, cost int) {",
      "\teid := int32(len(t.Edges))",
      "\tt.Tree[from] = append(t.Tree[from], neighbor{to: to, eid: eid, cost: cost})",
      "\tt.Edges = append(t.Edges, [2]int32{from, to})",
      "}",
      "",
      "func (t *Tree32) Build(root int32) {",
      "\tif root != -1 && int32(len(t.Edges)) != t.n-1 {",
      "\t\tpanic(\"edges count != n-1\")",
      "\t}",
      "\tn := t.n",
      "\tt.Lid = make([]int32, n)",
      "\tt.Rid = make([]int32, n)",
      "\tt.IdToNode = make([]int32, n)",
      "\tt.Depth = make([]int32, n)",
      "\tt.DepthWeighted = make([]int, n)",
      "\tt.Parent = make([]int32, n)",
      "\tt.Head = make([]int32, n)",
      "\tt.vToE = make([]int32, n)",
      "\tfor i := int32(0); i < n; i++ {",
      "\t\tt.Depth[i] = -1",
      "\t\tt.Head[i] = root",
      "\t\tt.vToE[i] = -1",
      "\t}",
      "\tif root != -1 {",
      "\t\tt._dfsSize(root, -1)",
      "\t\ttime := int32(0)",
      "\t\tt._dfsHld(root, &time)",
      "\t} else {",
      "\t\ttime := int32(0)",
      "\t\tfor i := int32(0); i < n; i++ {",
      "\t\t\tif t.Depth[i] == -1 {",
      "\t\t\t\tt._dfsSize(i, -1)",
      "\t\t\t\tt._dfsHld(i, &time)",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "}",
      "",
      "// 从v开始沿着重链向下收集节点.",
      "func (t *Tree32) HeavyPathAt(v int32) []int32 {",
      "\tpath := []int32{v}",
      "\tfor {",
      "\t\ta := path[len(path)-1]",
      "\t\tfor _, e := range t.Tree[a] {",
      "\t\t\tif e.to != t.Parent[a] && t.Head[e.to] == v {",
      "\t\t\t\tpath = append(path, e.to)",
      "\t\t\t\tbreak",
      "\t\t\t}",
      "\t\t}",
      "\t\tif path[len(path)-1] == a {",
      "\t\t\tbreak",
      "\t\t}",
      "\t}",
      "\treturn path",
      "}",
      "",
      "// 返回重儿子，如果没有返回 -1.",
      "func (t *Tree32) HeavyChild(v int32) int32 {",
      "\tk := t.Lid[v] + 1",
      "\tif k == t.n {",
      "\t\treturn -1",
      "\t}",
      "\tw := t.IdToNode[k]",
      "\tif t.Parent[w] == v {",
      "\t\treturn w",
      "\t}",
      "\treturn -1",
      "}",
      "",
      "// 从v开始向上走k步.",
      "func (t *Tree32) KthAncestor(v, k int32) int32 {",
      "\tif k > t.Depth[v] {",
      "\t\treturn -1",
      "\t}",
      "\tfor {",
      "\t\tu := t.Head[v]",
      "\t\tif t.Lid[v]-k >= t.Lid[u] {",
      "\t\t\treturn t.IdToNode[t.Lid[v]-k]",
      "\t\t}",
      "\t\tk -= t.Lid[v] - t.Lid[u] + 1",
      "\t\tv = t.Parent[u]",
      "\t}",
      "}",
      "",
      "func (t *Tree32) Lca(u, v int32) int32 {",
      "\tfor {",
      "\t\tif t.Lid[u] > t.Lid[v] {",
      "\t\t\tu, v = v, u",
      "\t\t}",
      "\t\tif t.Head[u] == t.Head[v] {",
      "\t\t\treturn u",
      "\t\t}",
      "\t\tv = t.Parent[t.Head[v]]",
      "\t}",
      "}",
      "",
      "func (t *Tree32) LcaRooted(u, v, root int32) int32 {",
      "\treturn t.Lca(u, v) ^ t.Lca(u, root) ^ t.Lca(v, root)",
      "}",
      "",
      "func (t *Tree32) Dist(a, b int32) int32 {",
      "\tc := t.Lca(a, b)",
      "\treturn t.Depth[a] + t.Depth[b] - 2*t.Depth[c]",
      "}",
      "",
      "func (t *Tree32) DistWeighted(a, b int32) int {",
      "\tc := t.Lca(a, b)",
      "\treturn t.DepthWeighted[a] + t.DepthWeighted[b] - 2*t.DepthWeighted[c]",
      "}",
      "",
      "// c 是否在 p 的子树中.c和p不能相等.",
      "func (t *Tree32) InSubtree(c, p int32) bool {",
      "\treturn t.Lid[p] <= t.Lid[c] && t.Lid[c] < t.Rid[p]",
      "}",
      "",
      "// 从 a 开始走 k 步到 b.",
      "func (t *Tree32) Jump(a, b, k int32) int32 {",
      "\tif k == 1 {",
      "\t\tif a == b {",
      "\t\t\treturn -1",
      "\t\t}",
      "\t\tif t.InSubtree(b, a) {",
      "\t\t\treturn t.KthAncestor(b, t.Depth[b]-t.Depth[a]-1)",
      "\t\t}",
      "\t\treturn t.Parent[a]",
      "\t}",
      "\tc := t.Lca(a, b)",
      "\tdac := t.Depth[a] - t.Depth[c]",
      "\tdbc := t.Depth[b] - t.Depth[c]",
      "\tif k > dac+dbc {",
      "\t\treturn -1",
      "\t}",
      "\tif k <= dac {",
      "\t\treturn t.KthAncestor(a, k)",
      "\t}",
      "\treturn t.KthAncestor(b, dac+dbc-k)",
      "}",
      "",
      "func (t *Tree32) SubtreeSize(v int32) int32 {",
      "\treturn t.Rid[v] - t.Lid[v]",
      "}",
      "",
      "func (t *Tree32) SubtreeSizeRooted(v, root int32) int32 {",
      "\tif v == root {",
      "\t\treturn t.n",
      "\t}",
      "\tx := t.Jump(v, root, 1)",
      "\tif t.InSubtree(v, x) {",
      "\t\treturn t.Rid[v] - t.Lid[v]",
      "\t}",
      "\treturn t.n - t.Rid[x] + t.Lid[x]",
      "}",
      "",
      "func (t *Tree32) CollectChild(v int32) []int32 {",
      "\tvar res []int32",
      "\tfor _, e := range t.Tree[v] {",
      "\t\tif e.to != t.Parent[v] {",
      "\t\t\tres = append(res, e.to)",
      "\t\t}",
      "\t}",
      "\treturn res",
      "}",
      "",
      "// 收集与 v 相邻的轻边.",
      "func (t *Tree32) CollectLight(v int32) []int32 {",
      "\tvar res []int32",
      "\tskip := true",
      "\tfor _, e := range t.Tree[v] {",
      "\t\tif e.to != t.Parent[v] {",
      "\t\t\tif !skip {",
      "\t\t\t\tres = append(res, e.to)",
      "\t\t\t}",
      "\t\t\tskip = false",
      "\t\t}",
      "\t}",
      "\treturn res",
      "}",
      "",
      "func (tree *Tree32) RestorePath(from, to int32) []int32 {",
      "\tres := []int32{}",
      "\tcomposition := tree.GetPathDecomposition(from, to, 0)",
      "\tfor _, e := range composition {",
      "\t\ta, b := e[0], e[1]",
      "\t\tif a <= b {",
      "\t\t\tfor i := a; i <= b; i++ {",
      "\t\t\t\tres = append(res, tree.IdToNode[i])",
      "\t\t\t}",
      "\t\t} else {",
      "\t\t\tfor i := a; i >= b; i-- {",
      "\t\t\t\tres = append(res, tree.IdToNode[i])",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "\treturn res",
      "}",
      "",
      "// 返回沿着`路径顺序`的 [起点,终点] 的 欧拉序 `左闭右闭` 数组.",
      "//",
      "//\t!eg:[[2 0] [4 4]] 沿着路径顺序但不一定沿着欧拉序.",
      "func (tree *Tree32) GetPathDecomposition(u, v int32, edge int32) [][2]int32 {",
      "\tup, down := [][2]int32{}, [][2]int32{}",
      "\tlid, head, parent := tree.Lid, tree.Head, tree.Parent",
      "\tfor {",
      "\t\tif head[u] == head[v] {",
      "\t\t\tbreak",
      "\t\t}",
      "\t\tif lid[u] < lid[v] {",
      "\t\t\tdown = append(down, [2]int32{lid[head[v]], lid[v]})",
      "\t\t\tv = parent[head[v]]",
      "\t\t} else {",
      "\t\t\tup = append(up, [2]int32{lid[u], lid[head[u]]})",
      "\t\t\tu = parent[head[u]]",
      "\t\t}",
      "\t}",
      "\tif lid[u] < lid[v] {",
      "\t\tdown = append(down, [2]int32{lid[u] + edge, lid[v]})",
      "\t} else if lid[v]+edge <= lid[u] {",
      "\t\tup = append(up, [2]int32{lid[u], lid[v] + edge})",
      "\t}",
      "\tfor i := 0; i < len(down)/2; i++ {",
      "\t\tdown[i], down[len(down)-1-i] = down[len(down)-1-i], down[i]",
      "\t}",
      "\treturn append(up, down...)",
      "}",
      "",
      "// 遍历路径上的 `[起点,终点)` 欧拉序 `左闭右开` 区间.",
      "func (tree *Tree32) EnumeratePathDecomposition(u, v int32, edge int32, f func(start, end int32)) {",
      "\thead, lid, parent := tree.Head, tree.Lid, tree.Parent",
      "\tfor {",
      "\t\tif head[u] == head[v] {",
      "\t\t\tbreak",
      "\t\t}",
      "\t\tif lid[u] < lid[v] {",
      "\t\t\ta, b := lid[head[v]], lid[v]",
      "\t\t\tif a > b {",
      "\t\t\t\ta, b = b, a",
      "\t\t\t}",
      "\t\t\tf(a, b+1)",
      "\t\t\tv = parent[head[v]]",
      "\t\t} else {",
      "\t\t\ta, b := lid[u], lid[head[u]]",
      "\t\t\tif a > b {",
      "\t\t\t\ta, b = b, a",
      "\t\t\t}",
      "\t\t\tf(a, b+1)",
      "\t\t\tu = parent[head[u]]",
      "\t\t}",
      "\t}",
      "\tif lid[u] < lid[v] {",
      "\t\ta, b := lid[u]+edge, lid[v]",
      "\t\tif a > b {",
      "\t\t\ta, b = b, a",
      "\t\t}",
      "\t\tf(a, b+1)",
      "\t} else if lid[v]+edge <= lid[u] {",
      "\t\ta, b := lid[u], lid[v]+edge",
      "\t\tif a > b {",
      "\t\t\ta, b = b, a",
      "\t\t}",
      "\t\tf(a, b+1)",
      "\t}",
      "}",
      "",
      "// 返回 root 的欧拉序区间, 左闭右开, 0-indexed.",
      "func (tree *Tree32) Id(root int32) (int32, int32) {",
      "\treturn tree.Lid[root], tree.Rid[root]",
      "}",
      "",
      "// 返回返回边 u-v 对应的 边id.",
      "func (tree *Tree32) Eid(u, v int32) int32 {",
      "\tif tree.Parent[u] != v {",
      "\t\tu, v = v, u",
      "\t}",
      "\treturn tree.vToE[u]",
      "}",
      "",
      "// 点v对应的父边的边id.如果v是根节点则返回-1.",
      "func (tre *Tree32) VToE(v int32) int32 {",
      "\treturn tre.vToE[v]",
      "}",
      "",
      "// 第i条边对应的深度更深的那个节点.",
      "func (tree *Tree32) EToV(i int32) int32 {",
      "\tu, v := tree.Edges[i][0], tree.Edges[i][1]",
      "\tif tree.Parent[u] == v {",
      "\t\treturn u",
      "\t}",
      "\treturn v",
      "}",
      "",
      "func (tree *Tree32) ELid(u int32) int32 {",
      "\treturn 2*tree.Lid[u] - tree.Depth[u]",
      "}",
      "",
      "func (tree *Tree32) ERid(u int32) int32 {",
      "\treturn 2*tree.Rid[u] - tree.Depth[u] - 1",
      "}",
      "",
      "func (t *Tree32) _dfsSize(cur, pre int32) {",
      "\tsize := t.Rid",
      "\tt.Parent[cur] = pre",
      "\tif pre != -1 {",
      "\t\tt.Depth[cur] = t.Depth[pre] + 1",
      "\t} else {",
      "\t\tt.Depth[cur] = 0",
      "\t}",
      "\tsize[cur] = 1",
      "\tnexts := t.Tree[cur]",
      "\tfor i := int32(len(nexts)) - 2; i >= 0; i-- {",
      "\t\te := nexts[i+1]",
      "\t\tif t.Depth[e.to] == -1 {",
      "\t\t\tnexts[i], nexts[i+1] = nexts[i+1], nexts[i]",
      "\t\t}",
      "\t}",
      "\thldSize := int32(0)",
      "\tfor i, e := range nexts {",
      "\t\tto := e.to",
      "\t\tif t.Depth[to] == -1 {",
      "\t\t\tt.DepthWeighted[to] = t.DepthWeighted[cur] + e.cost",
      "\t\t\tt.vToE[to] = e.eid",
      "\t\t\tt._dfsSize(to, cur)",
      "\t\t\tsize[cur] += size[to]",
      "\t\t\tif size[to] > hldSize {",
      "\t\t\t\thldSize = size[to]",
      "\t\t\t\tif i != 0 {",
      "\t\t\t\t\tnexts[0], nexts[i] = nexts[i], nexts[0]",
      "\t\t\t\t}",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "}",
      "",
      "func (t *Tree32) _dfsHld(cur int32, times *int32) {",
      "\tt.Lid[cur] = *times",
      "\t*times++",
      "\tt.Rid[cur] += t.Lid[cur]",
      "\tt.IdToNode[t.Lid[cur]] = cur",
      "\theavy := true",
      "\tfor _, e := range t.Tree[cur] {",
      "\t\tto := e.to",
      "\t\tif t.Depth[to] > t.Depth[cur] {",
      "\t\t\tif heavy {",
      "\t\t\t\tt.Head[to] = t.Head[cur]",
      "\t\t\t} else {",
      "\t\t\t\tt.Head[to] = to",
      "\t\t\t}",
      "\t\t\theavy = false",
      "\t\t\tt._dfsHld(to, times)",
      "\t\t}",
      "\t}",
      "}",
      "",
      "// 路径 [a,b] 与 [c,d] 的交集.",
      "// 如果为空则返回 {-1,-1}，如果只有一个交点则返回 {x,x}，如果有两个交点则返回 {x,y}.",
      "func (t *Tree32) PathIntersection(a, b, c, d int32) (int32, int32) {",
      "\tab := t.Lca(a, b)",
      "\tac := t.Lca(a, c)",
      "\tad := t.Lca(a, d)",
      "\tbc := t.Lca(b, c)",
      "\tbd := t.Lca(b, d)",
      "\tcd := t.Lca(c, d)",
      "\tx := ab ^ ac ^ bc // meet(a,b,c)",
      "\ty := ab ^ ad ^ bd // meet(a,b,d)",
      "\tif x != y {",
      "\t\treturn x, y",
      "\t}",
      "\tz := ac ^ ad ^ cd",
      "\tif x != z {",
      "\t\tx = -1",
      "\t}",
      "\treturn x, x",
      "}"
    ],
    "description": "Tree32"
  },
  "TreeMonoid32Lazy": {
    "scope": "go",
    "prefix": "TreeMonoid32Lazy",
    "body": [
      "",
      "// RangeAddRangeMaxIndex",
      "",
      "$1",
      "const INF int = 1e18",
      "",
      "const commutative bool = true // !E是否可交换,即 op(a,b) == op(b,a)",
      "",
      "type E = struct {",
      "\tid\t int32",
      "\tdist int",
      "}",
      "type Id = int",
      "",
      "func e() E\t { return E{id: -1, dist: -INF} }",
      "func id() Id { return 0 }",
      "func op(left, right E) E {",
      "\tif left.dist > right.dist {",
      "\t\treturn left",
      "\t}",
      "\treturn right",
      "}",
      "func mapping(f Id, g E, size int) E {",
      "\tg.dist += f",
      "\treturn g",
      "}",
      "func composition(f, g Id) Id {",
      "\treturn f + g",
      "}",
      "",
      "type TreeMonoid32Lazy struct {",
      "\tedge\t\t\tint32",
      "\tn\t\t\t\t int32",
      "\ttree\t\t\t*Tree32",
      "\tseg, segR *LazySegTree32",
      "}",
      "",
      "func NewTreeMonoid32Lazy(tree *Tree32, edge bool) *TreeMonoid32Lazy {",
      "\tvar edgeValue int32",
      "\tif edge {",
      "\t\tedgeValue = 1",
      "\t}",
      "\treturn &TreeMonoid32Lazy{edge: edgeValue, n: tree.n, tree: tree}",
      "}",
      "",
      "func (tag *TreeMonoid32Lazy) Build(f func(vidOrEid int32) E) {",
      "\tidToNode := tag.tree.IdToNode",
      "\tvToE := tag.tree.vToE",
      "\tif tag.edge == 0 {",
      "\t\tfv := func(i int32) E { return f(idToNode[i]) }",
      "\t\ttag.seg = NewLazySegTree32(tag.n, fv, e, id, op, mapping, composition)",
      "\t\tif !commutative {",
      "\t\t\ttag.segR = NewLazySegTree32(tag.n, fv, e, id, func(a, b E) E { return op(b, a) }, mapping, composition)",
      "\t\t}",
      "\t} else {",
      "\t\tfe := func(i int32) E {",
      "\t\t\tif i == 0 {",
      "\t\t\t\treturn e()",
      "\t\t\t}",
      "\t\t\treturn f(vToE[idToNode[i]])",
      "\t\t}",
      "\t\ttag.seg = NewLazySegTree32(tag.n, fe, e, id, op, mapping, composition)",
      "\t\tif !commutative {",
      "\t\t\ttag.segR = NewLazySegTree32(tag.n, fe, e, id, func(a, b E) E { return op(b, a) }, mapping, composition)",
      "\t\t}",
      "\t}",
      "}",
      "",
      "func (tag *TreeMonoid32Lazy) Set(i int32, x E) {",
      "\tif tag.edge != 0 {",
      "\t\ti = tag.tree.EToV(i)",
      "\t}",
      "\ti = tag.tree.Lid[i]",
      "\ttag.seg.Set(i, x)",
      "\tif !commutative {",
      "\t\ttag.segR.Set(i, x)",
      "\t}",
      "}",
      "",
      "func (tag *TreeMonoid32Lazy) Update(i int32, x E) {",
      "\tif tag.edge != 0 {",
      "\t\ti = tag.tree.EToV(i)",
      "\t}",
      "\ti = tag.tree.Lid[i]",
      "\ttag.seg.Multiply(i, x)",
      "\tif !commutative {",
      "\t\ttag.segR.Multiply(i, x)",
      "\t}",
      "}",
      "",
      "func (tag *TreeMonoid32Lazy) Get(i int32) E {",
      "\tif tag.edge != 0 {",
      "\t\ti = tag.tree.EToV(i)",
      "\t}",
      "\treturn tag.seg.Get(tag.tree.Lid[i])",
      "}",
      "",
      "func (tag *TreeMonoid32Lazy) GetAll() []E {",
      "\tdata := tag.seg.GetAll()",
      "\ttree := tag.tree",
      "\tif tag.edge == 0 {",
      "\t\tres := make([]E, tag.n)",
      "\t\tfor v := int32(0); v < tag.n; v++ {",
      "\t\t\tres[v] = data[tree.Lid[v]]",
      "\t\t}",
      "\t\treturn res",
      "\t} else {",
      "\t\tres := make([]E, tag.n-1)",
      "\t\tfor i := int32(0); i < tag.n-1; i++ {",
      "\t\t\tres[i] = data[tree.Lid[tree.EToV(i)]]",
      "\t\t}",
      "\t\treturn res",
      "\t}",
      "}",
      "",
      "func (tag *TreeMonoid32Lazy) QueryPath(from, to int32) E {",
      "\tpd := tag.tree.GetPathDecomposition(from, to, tag.edge)",
      "\tres := e()",
      "\tfor i := 0; i < len(pd); i++ {",
      "\t\tres = op(res, tag.getProd(pd[i][0], pd[i][1]))",
      "\t}",
      "\treturn res",
      "}",
      "",
      "func (tag *TreeMonoid32Lazy) QueryAll() E {",
      "\tif !commutative {",
      "\t\tpanic(\"not implemented\")",
      "\t}",
      "\treturn tag.seg.QueryAll()",
      "}",
      "",
      "func (tag *TreeMonoid32Lazy) QuerySubtree(u int32) E {",
      "\tif !commutative {",
      "\t\tpanic(\"not implemented\")",
      "\t}",
      "\tl, r := tag.tree.Lid[u], tag.tree.Rid[u]",
      "\treturn tag.seg.Query(l+tag.edge, r)",
      "}",
      "",
      "func (tag *TreeMonoid32Lazy) UpdateSubtree(u int32, f Id) {",
      "\tl, r := tag.tree.Lid[u], tag.tree.Rid[u]",
      "\ttag.seg.Update(l+tag.edge, r, f)",
      "\tif !commutative {",
      "\t\ttag.segR.Update(l+tag.edge, r, f)",
      "\t}",
      "}",
      "",
      "// outtree: 除开u的子树外的其他节点",
      "func (tag *TreeMonoid32Lazy) UpdateOuttree(u int32, f Id) {",
      "\tl, r := tag.tree.Lid[u], tag.tree.Rid[u]",
      "\ttag.seg.Update(tag.edge, l+tag.edge, f)",
      "\ttag.seg.Update(r, tag.n, f)",
      "\tif !commutative {",
      "\t\ttag.segR.Update(tag.edge, l+tag.edge, f)",
      "\t\ttag.segR.Update(r, tag.n, f)",
      "\t}",
      "}",
      "",
      "func (tag *TreeMonoid32Lazy) UpdatePath(u, v int32, f Id) {",
      "\tpd := tag.tree.GetPathDecomposition(u, v, tag.edge)",
      "\tfor i := 0; i < len(pd); i++ {",
      "\t\tl, r := pd[i][0], pd[i][1]",
      "\t\tif l > r {",
      "\t\t\tl, r = r, l",
      "\t\t}",
      "\t\ttag.seg.Update(l, r+1, f)",
      "\t\tif !commutative {",
      "\t\t\ttag.segR.Update(l, r+1, f)",
      "\t\t}",
      "\t}",
      "}",
      "",
      "// 满足 check 为true的最远的节点.",
      "// 如果不存在返回 -1.",
      "func (tag *TreeMonoid32Lazy) MaxPath(from, to int32, check func(E) bool) int32 {",
      "\tif tag.edge != 0 {",
      "\t\treturn tag.maxPathEdge(from, to, check)",
      "\t}",
      "\tif !check(tag.QueryPath(from, from)) {",
      "\t\treturn -1",
      "\t}",
      "\tpd := tag.tree.GetPathDecomposition(from, to, tag.edge)",
      "\tval := e()",
      "\tidToNode := tag.tree.IdToNode",
      "\tfor _, e := range pd {",
      "\t\tx := tag.getProd(e[0], e[1])",
      "\t\tif tmp := op(val, x); check(tmp) {",
      "\t\t\tval = tmp",
      "\t\t\tfrom = idToNode[e[1]]",
      "\t\t\tcontinue",
      "\t\t}",
      "\t\tcheckTmp := func(x E) bool { return check(op(val, x)) }",
      "\t\tif e[0] <= e[1] {",
      "\t\t\ti := tag.seg.MaxRight(e[0], checkTmp)",
      "\t\t\tif i == e[0] {",
      "\t\t\t\treturn from",
      "\t\t\t}",
      "\t\t\treturn idToNode[i-1]",
      "\t\t} else {",
      "\t\t\ti := int32(0)",
      "\t\t\tif commutative {",
      "\t\t\t\ti = tag.seg.MinLeft(e[0]+1, checkTmp)",
      "\t\t\t} else {",
      "\t\t\t\ti = tag.segR.MinLeft(e[0]+1, checkTmp)",
      "\t\t\t}",
      "\t\t\tif i == e[0]+1 {",
      "\t\t\t\treturn from",
      "\t\t\t}",
      "\t\t\treturn idToNode[i]",
      "\t\t}",
      "\t}",
      "\treturn to",
      "}",
      "",
      "func (tag *TreeMonoid32Lazy) maxPathEdge(from, to int32, check func(E) bool) int32 {",
      "\tif !check(e()) {",
      "\t\treturn -1",
      "\t}",
      "\tlca := tag.tree.Lca(from, to)",
      "\tpd := tag.tree.GetPathDecomposition(from, lca, tag.edge)",
      "\tval := e()",
      "\tparent, idToNode := tag.tree.Parent, tag.tree.IdToNode",
      "\tfor _, e := range pd {",
      "\t\tx := tag.getProd(e[0], e[1])",
      "\t\tif tmp := op(val, x); check(tmp) {",
      "\t\t\tval = tmp",
      "\t\t\tfrom = parent[idToNode[e[1]]]",
      "\t\t\tcontinue",
      "\t\t}",
      "\t\tcheckTmp := func(x E) bool { return check(op(val, x)) }",
      "\t\ti := int32(0)",
      "\t\tif commutative {",
      "\t\t\ti = tag.seg.MinLeft(e[0]+1, checkTmp)",
      "\t\t} else {",
      "\t\t\ti = tag.segR.MinLeft(e[0]+1, checkTmp)",
      "\t\t}",
      "\t\tif i == e[0]+1 {",
      "\t\t\treturn from",
      "\t\t}",
      "\t\treturn parent[idToNode[i]]",
      "\t}",
      "\tpd = tag.tree.GetPathDecomposition(lca, to, tag.edge)",
      "\tfor _, e := range pd {",
      "\t\tx := tag.getProd(e[0], e[1])",
      "\t\tif tmp := op(val, x); check(tmp) {",
      "\t\t\tval = tmp",
      "\t\t\tfrom = idToNode[e[1]]",
      "\t\t\tcontinue",
      "\t\t}",
      "\t\tcheckTmp := func(x E) bool { return check(op(val, x)) }",
      "\t\ti := tag.seg.MaxRight(e[0], checkTmp)",
      "\t\tif i == e[0] {",
      "\t\t\treturn from",
      "\t\t}",
      "\t\treturn idToNode[i-1]",
      "\t}",
      "\treturn to",
      "}",
      "",
      "func (tag *TreeMonoid32Lazy) getProd(a, b int32) E {",
      "\tif commutative {",
      "\t\tif a <= b {",
      "\t\t\treturn tag.seg.Query(a, b+1)",
      "\t\t}",
      "\t\treturn tag.seg.Query(b, a+1)",
      "\t} else {",
      "\t\tif a <= b {",
      "\t\t\treturn tag.seg.Query(a, b+1)",
      "\t\t}",
      "\t\treturn tag.segR.Query(b, a+1)",
      "\t}",
      "}",
      "",
      "// !template",
      "type LazySegTree32 struct {",
      "\tn\t\t\t\t\t int32",
      "\tsize\t\t\t\tint32",
      "\tlog\t\t\t\t int32",
      "\tdata\t\t\t\t[]E",
      "\tlazy\t\t\t\t[]Id",
      "\te\t\t\t\t\t func() E",
      "\tid\t\t\t\t\tfunc() Id",
      "\top\t\t\t\t\tfunc(E, E) E",
      "\tmapping\t\t func(Id, E, int) E",
      "\tcomposition func(Id, Id) Id",
      "}",
      "",
      "func NewLazySegTree32(",
      "\tn int32, f func(int32) E,",
      "\te func() E, id func() Id,",
      "\top func(E, E) E, mapping func(Id, E, int) E, composition func(Id, Id) Id,",
      ") *LazySegTree32 {",
      "\ttree := &LazySegTree32{e: e, id: id, op: op, mapping: mapping, composition: composition}",
      "\ttree.n = n",
      "\ttree.log = int32(bits.Len32(uint32(n - 1)))",
      "\ttree.size = 1 << tree.log",
      "\ttree.data = make([]E, tree.size<<1)",
      "\ttree.lazy = make([]Id, tree.size)",
      "\tfor i := range tree.data {",
      "\t\ttree.data[i] = tree.e()",
      "\t}",
      "\tfor i := range tree.lazy {",
      "\t\ttree.lazy[i] = tree.id()",
      "\t}",
      "\tfor i := int32(0); i < n; i++ {",
      "\t\ttree.data[tree.size+i] = f(i)",
      "\t}",
      "\tfor i := tree.size - 1; i >= 1; i-- {",
      "\t\ttree.pushUp(i)",
      "\t}",
      "\treturn tree",
      "}",
      "",
      "// 查询切片[left:right]的值",
      "//",
      "//\t0<=left<=right<=len(tree.data)",
      "func (tree *LazySegTree32) Query(left, right int32) E {",
      "\tif left < 0 {",
      "\t\tleft = 0",
      "\t}",
      "\tif right > tree.n {",
      "\t\tright = tree.n",
      "\t}",
      "\tif left >= right {",
      "\t\treturn tree.e()",
      "\t}",
      "\tleft += tree.size",
      "\tright += tree.size",
      "\tfor i := tree.log; i >= 1; i-- {",
      "\t\tif ((left >> i) << i) != left {",
      "\t\t\ttree.pushDown(left >> i)",
      "\t\t}",
      "\t\tif ((right >> i) << i) != right {",
      "\t\t\ttree.pushDown((right - 1) >> i)",
      "\t\t}",
      "\t}",
      "\tsml, smr := tree.e(), tree.e()",
      "\tfor left < right {",
      "\t\tif left&1 != 0 {",
      "\t\t\tsml = tree.op(sml, tree.data[left])",
      "\t\t\tleft++",
      "\t\t}",
      "\t\tif right&1 != 0 {",
      "\t\t\tright--",
      "\t\t\tsmr = tree.op(tree.data[right], smr)",
      "\t\t}",
      "\t\tleft >>= 1",
      "\t\tright >>= 1",
      "\t}",
      "\treturn tree.op(sml, smr)",
      "}",
      "func (tree *LazySegTree32) QueryAll() E {",
      "\treturn tree.data[1]",
      "}",
      "func (tree *LazySegTree32) GetAll() []E {",
      "\tfor i := int32(1); i < tree.size; i++ {",
      "\t\ttree.pushDown(i)",
      "\t}",
      "\tres := make([]E, tree.n)",
      "\tcopy(res, tree.data[tree.size:tree.size+tree.n])",
      "\treturn res",
      "}",
      "",
      "// 更新切片[left:right]的值",
      "//",
      "//\t0<=left<=right<=len(tree.data)",
      "func (tree *LazySegTree32) Update(left, right int32, f Id) {",
      "\tif left < 0 {",
      "\t\tleft = 0",
      "\t}",
      "\tif right > tree.n {",
      "\t\tright = tree.n",
      "\t}",
      "\tif left >= right {",
      "\t\treturn",
      "\t}",
      "\tleft += tree.size",
      "\tright += tree.size",
      "\tfor i := tree.log; i >= 1; i-- {",
      "\t\tif ((left >> i) << i) != left {",
      "\t\t\ttree.pushDown(left >> i)",
      "\t\t}",
      "\t\tif ((right >> i) << i) != right {",
      "\t\t\ttree.pushDown((right - 1) >> i)",
      "\t\t}",
      "\t}",
      "\tl2, r2 := left, right",
      "\tfor left < right {",
      "\t\tif left&1 != 0 {",
      "\t\t\ttree.propagate(left, f)",
      "\t\t\tleft++",
      "\t\t}",
      "\t\tif right&1 != 0 {",
      "\t\t\tright--",
      "\t\t\ttree.propagate(right, f)",
      "\t\t}",
      "\t\tleft >>= 1",
      "\t\tright >>= 1",
      "\t}",
      "\tleft = l2",
      "\tright = r2",
      "\tfor i := int32(1); i <= tree.log; i++ {",
      "\t\tif ((left >> i) << i) != left {",
      "\t\t\ttree.pushUp(left >> i)",
      "\t\t}",
      "\t\tif ((right >> i) << i) != right {",
      "\t\t\ttree.pushUp((right - 1) >> i)",
      "\t\t}",
      "\t}",
      "}",
      "",
      "// 二分查询最小的 left 使得切片 [left:right] 内的值满足 predicate",
      "func (tree *LazySegTree32) MinLeft(right int32, predicate func(data E) bool) int32 {",
      "\tif right == 0 {",
      "\t\treturn 0",
      "\t}",
      "\tright += tree.size",
      "\tfor i := tree.log; i >= 1; i-- {",
      "\t\ttree.pushDown((right - 1) >> i)",
      "\t}",
      "\tres := tree.e()",
      "\tfor {",
      "\t\tright--",
      "\t\tfor right > 1 && right&1 != 0 {",
      "\t\t\tright >>= 1",
      "\t\t}",
      "\t\tif !predicate(tree.op(tree.data[right], res)) {",
      "\t\t\tfor right < tree.size {",
      "\t\t\t\ttree.pushDown(right)",
      "\t\t\t\tright = right<<1 | 1",
      "\t\t\t\tif tmp := tree.op(tree.data[right], res); predicate(tmp) {",
      "\t\t\t\t\tres = tmp",
      "\t\t\t\t\tright--",
      "\t\t\t\t}",
      "\t\t\t}",
      "\t\t\treturn right + 1 - tree.size",
      "\t\t}",
      "\t\tres = tree.op(tree.data[right], res)",
      "\t\tif (right & -right) == right {",
      "\t\t\tbreak",
      "\t\t}",
      "\t}",
      "\treturn 0",
      "}",
      "",
      "// 二分查询最大的 right 使得切片 [left:right] 内的值满足 predicate",
      "func (tree *LazySegTree32) MaxRight(left int32, predicate func(data E) bool) int32 {",
      "\tif left == tree.n {",
      "\t\treturn tree.n",
      "\t}",
      "\tleft += tree.size",
      "\tfor i := tree.log; i >= 1; i-- {",
      "\t\ttree.pushDown(left >> i)",
      "\t}",
      "\tres := tree.e()",
      "\tfor {",
      "\t\tfor left&1 == 0 {",
      "\t\t\tleft >>= 1",
      "\t\t}",
      "\t\tif !predicate(tree.op(res, tree.data[left])) {",
      "\t\t\tfor left < tree.size {",
      "\t\t\t\ttree.pushDown(left)",
      "\t\t\t\tleft <<= 1",
      "\t\t\t\tif tmp := tree.op(res, tree.data[left]); predicate(tmp) {",
      "\t\t\t\t\tres = tmp",
      "\t\t\t\t\tleft++",
      "\t\t\t\t}",
      "\t\t\t}",
      "\t\t\treturn left - tree.size",
      "\t\t}",
      "\t\tres = tree.op(res, tree.data[left])",
      "\t\tleft++",
      "\t\tif (left & -left) == left {",
      "\t\t\tbreak",
      "\t\t}",
      "\t}",
      "\treturn tree.n",
      "}",
      "",
      "// 单点查询(不需要 pushUp/op 操作时使用)",
      "func (tree *LazySegTree32) Get(index int32) E {",
      "\tindex += tree.size",
      "\tfor i := tree.log; i >= 1; i-- {",
      "\t\ttree.pushDown(index >> i)",
      "\t}",
      "\treturn tree.data[index]",
      "}",
      "",
      "// 单点赋值",
      "func (tree *LazySegTree32) Set(index int32, e E) {",
      "\tindex += tree.size",
      "\tfor i := tree.log; i >= 1; i-- {",
      "\t\ttree.pushDown(index >> i)",
      "\t}",
      "\ttree.data[index] = e",
      "\tfor i := int32(1); i <= tree.log; i++ {",
      "\t\ttree.pushUp(index >> i)",
      "\t}",
      "}",
      "",
      "func (tree *LazySegTree32) Multiply(index int32, e E) {",
      "\tindex += tree.size",
      "\tfor i := tree.log; i >= 1; i-- {",
      "\t\ttree.pushDown(index >> i)",
      "\t}",
      "\ttree.data[index] = tree.op(tree.data[index], e)",
      "\tfor i := int32(1); i <= tree.log; i++ {",
      "\t\ttree.pushUp(index >> i)",
      "\t}",
      "}",
      "",
      "func (tree *LazySegTree32) pushUp(root int32) {",
      "\ttree.data[root] = tree.op(tree.data[root<<1], tree.data[root<<1|1])",
      "}",
      "func (tree *LazySegTree32) pushDown(root int32) {",
      "\tif tree.lazy[root] != tree.id() {",
      "\t\ttree.propagate(root<<1, tree.lazy[root])",
      "\t\ttree.propagate(root<<1|1, tree.lazy[root])",
      "\t\ttree.lazy[root] = tree.id()",
      "\t}",
      "}",
      "func (tree *LazySegTree32) propagate(root int32, f Id) {",
      "\tsize := 1 << (tree.log - int32((bits.Len32(uint32(root)) - 1)) /**topbit**/)",
      "\ttree.data[root] = tree.mapping(f, tree.data[root], size)",
      "\tif root < tree.size {",
      "\t\ttree.lazy[root] = tree.composition(f, tree.lazy[root])",
      "\t}",
      "}",
      "",
      "func (tree *LazySegTree32) String() string {",
      "\tvar sb []string",
      "\tsb = append(sb, \"[\")",
      "\tfor i := int32(0); i < tree.n; i++ {",
      "\t\tif i != 0 {",
      "\t\t\tsb = append(sb, \", \")",
      "\t\t}",
      "\t\tsb = append(sb, fmt.Sprintf(\"%v\", tree.Get(i)))",
      "\t}",
      "\tsb = append(sb, \"]\")",
      "\treturn strings.Join(sb, \"\")",
      "}",
      "",
      "type neighbor = struct {",
      "\tto\t int32",
      "\teid\tint32",
      "\tcost int",
      "}",
      "",
      "type Tree32 struct {",
      "\tLid, Rid\t\t\t[]int32",
      "\tIdToNode\t\t\t[]int32",
      "\tDepth\t\t\t\t []int32",
      "\tDepthWeighted []int",
      "\tParent\t\t\t\t[]int32",
      "\tHead\t\t\t\t\t[]int32 // 重链头",
      "\tTree\t\t\t\t\t[][]neighbor",
      "\tEdges\t\t\t\t [][2]int32",
      "\tvToE\t\t\t\t\t[]int32 // 节点v的父边的id",
      "\tn\t\t\t\t\t\t int32",
      "}",
      "",
      "func NewTree32(n int32) *Tree32 {",
      "\tres := &Tree32{Tree: make([][]neighbor, n), Edges: make([][2]int32, 0, n-1), n: n}",
      "\treturn res",
      "}",
      "",
      "func (t *Tree32) AddEdge(u, v int32, w int) {",
      "\teid := int32(len(t.Edges))",
      "\tt.Tree[u] = append(t.Tree[u], neighbor{to: v, eid: eid, cost: w})",
      "\tt.Tree[v] = append(t.Tree[v], neighbor{to: u, eid: eid, cost: w})",
      "\tt.Edges = append(t.Edges, [2]int32{u, v})",
      "}",
      "",
      "func (t *Tree32) AddDirectedEdge(from, to int32, cost int) {",
      "\teid := int32(len(t.Edges))",
      "\tt.Tree[from] = append(t.Tree[from], neighbor{to: to, eid: eid, cost: cost})",
      "\tt.Edges = append(t.Edges, [2]int32{from, to})",
      "}",
      "",
      "func (t *Tree32) Build(root int32) {",
      "\tif root != -1 && int32(len(t.Edges)) != t.n-1 {",
      "\t\tpanic(\"edges count != n-1\")",
      "\t}",
      "\tn := t.n",
      "\tt.Lid = make([]int32, n)",
      "\tt.Rid = make([]int32, n)",
      "\tt.IdToNode = make([]int32, n)",
      "\tt.Depth = make([]int32, n)",
      "\tt.DepthWeighted = make([]int, n)",
      "\tt.Parent = make([]int32, n)",
      "\tt.Head = make([]int32, n)",
      "\tt.vToE = make([]int32, n)",
      "\tfor i := int32(0); i < n; i++ {",
      "\t\tt.Depth[i] = -1",
      "\t\tt.Head[i] = root",
      "\t\tt.vToE[i] = -1",
      "\t}",
      "\tif root != -1 {",
      "\t\tt._dfsSize(root, -1)",
      "\t\ttime := int32(0)",
      "\t\tt._dfsHld(root, &time)",
      "\t} else {",
      "\t\ttime := int32(0)",
      "\t\tfor i := int32(0); i < n; i++ {",
      "\t\t\tif t.Depth[i] == -1 {",
      "\t\t\t\tt._dfsSize(i, -1)",
      "\t\t\t\tt._dfsHld(i, &time)",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "}",
      "",
      "// 从v开始沿着重链向下收集节点.",
      "func (t *Tree32) HeavyPathAt(v int32) []int32 {",
      "\tpath := []int32{v}",
      "\tfor {",
      "\t\ta := path[len(path)-1]",
      "\t\tfor _, e := range t.Tree[a] {",
      "\t\t\tif e.to != t.Parent[a] && t.Head[e.to] == v {",
      "\t\t\t\tpath = append(path, e.to)",
      "\t\t\t\tbreak",
      "\t\t\t}",
      "\t\t}",
      "\t\tif path[len(path)-1] == a {",
      "\t\t\tbreak",
      "\t\t}",
      "\t}",
      "\treturn path",
      "}",
      "",
      "// 返回重儿子，如果没有返回 -1.",
      "func (t *Tree32) HeavyChild(v int32) int32 {",
      "\tk := t.Lid[v] + 1",
      "\tif k == t.n {",
      "\t\treturn -1",
      "\t}",
      "\tw := t.IdToNode[k]",
      "\tif t.Parent[w] == v {",
      "\t\treturn w",
      "\t}",
      "\treturn -1",
      "}",
      "",
      "// 从v开始向上走k步.",
      "func (t *Tree32) KthAncestor(v, k int32) int32 {",
      "\tif k > t.Depth[v] {",
      "\t\treturn -1",
      "\t}",
      "\tfor {",
      "\t\tu := t.Head[v]",
      "\t\tif t.Lid[v]-k >= t.Lid[u] {",
      "\t\t\treturn t.IdToNode[t.Lid[v]-k]",
      "\t\t}",
      "\t\tk -= t.Lid[v] - t.Lid[u] + 1",
      "\t\tv = t.Parent[u]",
      "\t}",
      "}",
      "",
      "func (t *Tree32) Lca(u, v int32) int32 {",
      "\tfor {",
      "\t\tif t.Lid[u] > t.Lid[v] {",
      "\t\t\tu, v = v, u",
      "\t\t}",
      "\t\tif t.Head[u] == t.Head[v] {",
      "\t\t\treturn u",
      "\t\t}",
      "\t\tv = t.Parent[t.Head[v]]",
      "\t}",
      "}",
      "",
      "func (t *Tree32) LcaRooted(u, v, root int32) int32 {",
      "\treturn t.Lca(u, v) ^ t.Lca(u, root) ^ t.Lca(v, root)",
      "}",
      "",
      "func (t *Tree32) Dist(a, b int32) int32 {",
      "\tc := t.Lca(a, b)",
      "\treturn t.Depth[a] + t.Depth[b] - 2*t.Depth[c]",
      "}",
      "",
      "func (t *Tree32) DistWeighted(a, b int32) int {",
      "\tc := t.Lca(a, b)",
      "\treturn t.DepthWeighted[a] + t.DepthWeighted[b] - 2*t.DepthWeighted[c]",
      "}",
      "",
      "// c 是否在 p 的子树中.c和p不能相等.",
      "func (t *Tree32) InSubtree(c, p int32) bool {",
      "\treturn t.Lid[p] <= t.Lid[c] && t.Lid[c] < t.Rid[p]",
      "}",
      "",
      "// 从 a 开始走 k 步到 b.",
      "func (t *Tree32) Jump(a, b, k int32) int32 {",
      "\tif k == 1 {",
      "\t\tif a == b {",
      "\t\t\treturn -1",
      "\t\t}",
      "\t\tif t.InSubtree(b, a) {",
      "\t\t\treturn t.KthAncestor(b, t.Depth[b]-t.Depth[a]-1)",
      "\t\t}",
      "\t\treturn t.Parent[a]",
      "\t}",
      "\tc := t.Lca(a, b)",
      "\tdac := t.Depth[a] - t.Depth[c]",
      "\tdbc := t.Depth[b] - t.Depth[c]",
      "\tif k > dac+dbc {",
      "\t\treturn -1",
      "\t}",
      "\tif k <= dac {",
      "\t\treturn t.KthAncestor(a, k)",
      "\t}",
      "\treturn t.KthAncestor(b, dac+dbc-k)",
      "}",
      "",
      "func (t *Tree32) SubtreeSize(v int32) int32 {",
      "\treturn t.Rid[v] - t.Lid[v]",
      "}",
      "",
      "func (t *Tree32) SubtreeSizeRooted(v, root int32) int32 {",
      "\tif v == root {",
      "\t\treturn t.n",
      "\t}",
      "\tx := t.Jump(v, root, 1)",
      "\tif t.InSubtree(v, x) {",
      "\t\treturn t.Rid[v] - t.Lid[v]",
      "\t}",
      "\treturn t.n - t.Rid[x] + t.Lid[x]",
      "}",
      "",
      "func (t *Tree32) CollectChild(v int32) []int32 {",
      "\tvar res []int32",
      "\tfor _, e := range t.Tree[v] {",
      "\t\tif e.to != t.Parent[v] {",
      "\t\t\tres = append(res, e.to)",
      "\t\t}",
      "\t}",
      "\treturn res",
      "}",
      "",
      "// 收集与 v 相邻的轻边.",
      "func (t *Tree32) CollectLight(v int32) []int32 {",
      "\tvar res []int32",
      "\tskip := true",
      "\tfor _, e := range t.Tree[v] {",
      "\t\tif e.to != t.Parent[v] {",
      "\t\t\tif !skip {",
      "\t\t\t\tres = append(res, e.to)",
      "\t\t\t}",
      "\t\t\tskip = false",
      "\t\t}",
      "\t}",
      "\treturn res",
      "}",
      "",
      "func (tree *Tree32) RestorePath(from, to int32) []int32 {",
      "\tres := []int32{}",
      "\tcomposition := tree.GetPathDecomposition(from, to, 0)",
      "\tfor _, e := range composition {",
      "\t\ta, b := e[0], e[1]",
      "\t\tif a <= b {",
      "\t\t\tfor i := a; i <= b; i++ {",
      "\t\t\t\tres = append(res, tree.IdToNode[i])",
      "\t\t\t}",
      "\t\t} else {",
      "\t\t\tfor i := a; i >= b; i-- {",
      "\t\t\t\tres = append(res, tree.IdToNode[i])",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "\treturn res",
      "}",
      "",
      "// 返回沿着`路径顺序`的 [起点,终点] 的 欧拉序 `左闭右闭` 数组.",
      "//",
      "//\t!eg:[[2 0] [4 4]] 沿着路径顺序但不一定沿着欧拉序.",
      "func (tree *Tree32) GetPathDecomposition(u, v int32, edge int32) [][2]int32 {",
      "\tup, down := [][2]int32{}, [][2]int32{}",
      "\tlid, head, parent := tree.Lid, tree.Head, tree.Parent",
      "\tfor {",
      "\t\tif head[u] == head[v] {",
      "\t\t\tbreak",
      "\t\t}",
      "\t\tif lid[u] < lid[v] {",
      "\t\t\tdown = append(down, [2]int32{lid[head[v]], lid[v]})",
      "\t\t\tv = parent[head[v]]",
      "\t\t} else {",
      "\t\t\tup = append(up, [2]int32{lid[u], lid[head[u]]})",
      "\t\t\tu = parent[head[u]]",
      "\t\t}",
      "\t}",
      "\tif lid[u] < lid[v] {",
      "\t\tdown = append(down, [2]int32{lid[u] + edge, lid[v]})",
      "\t} else if lid[v]+edge <= lid[u] {",
      "\t\tup = append(up, [2]int32{lid[u], lid[v] + edge})",
      "\t}",
      "\tfor i := 0; i < len(down)/2; i++ {",
      "\t\tdown[i], down[len(down)-1-i] = down[len(down)-1-i], down[i]",
      "\t}",
      "\treturn append(up, down...)",
      "}",
      "",
      "// 遍历路径上的 `[起点,终点)` 欧拉序 `左闭右开` 区间.",
      "func (tree *Tree32) EnumeratePathDecomposition(u, v int32, edge int32, f func(start, end int32)) {",
      "\thead, lid, parent := tree.Head, tree.Lid, tree.Parent",
      "\tfor {",
      "\t\tif head[u] == head[v] {",
      "\t\t\tbreak",
      "\t\t}",
      "\t\tif lid[u] < lid[v] {",
      "\t\t\ta, b := lid[head[v]], lid[v]",
      "\t\t\tif a > b {",
      "\t\t\t\ta, b = b, a",
      "\t\t\t}",
      "\t\t\tf(a, b+1)",
      "\t\t\tv = parent[head[v]]",
      "\t\t} else {",
      "\t\t\ta, b := lid[u], lid[head[u]]",
      "\t\t\tif a > b {",
      "\t\t\t\ta, b = b, a",
      "\t\t\t}",
      "\t\t\tf(a, b+1)",
      "\t\t\tu = parent[head[u]]",
      "\t\t}",
      "\t}",
      "\tif lid[u] < lid[v] {",
      "\t\ta, b := lid[u]+edge, lid[v]",
      "\t\tif a > b {",
      "\t\t\ta, b = b, a",
      "\t\t}",
      "\t\tf(a, b+1)",
      "\t} else if lid[v]+edge <= lid[u] {",
      "\t\ta, b := lid[u], lid[v]+edge",
      "\t\tif a > b {",
      "\t\t\ta, b = b, a",
      "\t\t}",
      "\t\tf(a, b+1)",
      "\t}",
      "}",
      "",
      "// 返回 root 的欧拉序区间, 左闭右开, 0-indexed.",
      "func (tree *Tree32) Id(root int32) (int32, int32) {",
      "\treturn tree.Lid[root], tree.Rid[root]",
      "}",
      "",
      "// 返回返回边 u-v 对应的 边id.",
      "func (tree *Tree32) Eid(u, v int32) int32 {",
      "\tif tree.Parent[u] != v {",
      "\t\tu, v = v, u",
      "\t}",
      "\treturn tree.vToE[u]",
      "}",
      "",
      "// 点v对应的父边的边id.如果v是根节点则返回-1.",
      "func (tre *Tree32) VToE(v int32) int32 {",
      "\treturn tre.vToE[v]",
      "}",
      "",
      "// 第i条边对应的深度更深的那个节点.",
      "func (tree *Tree32) EToV(i int32) int32 {",
      "\tu, v := tree.Edges[i][0], tree.Edges[i][1]",
      "\tif tree.Parent[u] == v {",
      "\t\treturn u",
      "\t}",
      "\treturn v",
      "}",
      "",
      "func (tree *Tree32) ELid(u int32) int32 {",
      "\treturn 2*tree.Lid[u] - tree.Depth[u]",
      "}",
      "",
      "func (tree *Tree32) ERid(u int32) int32 {",
      "\treturn 2*tree.Rid[u] - tree.Depth[u] - 1",
      "}",
      "",
      "func (t *Tree32) _dfsSize(cur, pre int32) {",
      "\tsize := t.Rid",
      "\tt.Parent[cur] = pre",
      "\tif pre != -1 {",
      "\t\tt.Depth[cur] = t.Depth[pre] + 1",
      "\t} else {",
      "\t\tt.Depth[cur] = 0",
      "\t}",
      "\tsize[cur] = 1",
      "\tnexts := t.Tree[cur]",
      "\tfor i := int32(len(nexts)) - 2; i >= 0; i-- {",
      "\t\te := nexts[i+1]",
      "\t\tif t.Depth[e.to] == -1 {",
      "\t\t\tnexts[i], nexts[i+1] = nexts[i+1], nexts[i]",
      "\t\t}",
      "\t}",
      "\thldSize := int32(0)",
      "\tfor i, e := range nexts {",
      "\t\tto := e.to",
      "\t\tif t.Depth[to] == -1 {",
      "\t\t\tt.DepthWeighted[to] = t.DepthWeighted[cur] + e.cost",
      "\t\t\tt.vToE[to] = e.eid",
      "\t\t\tt._dfsSize(to, cur)",
      "\t\t\tsize[cur] += size[to]",
      "\t\t\tif size[to] > hldSize {",
      "\t\t\t\thldSize = size[to]",
      "\t\t\t\tif i != 0 {",
      "\t\t\t\t\tnexts[0], nexts[i] = nexts[i], nexts[0]",
      "\t\t\t\t}",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "}",
      "",
      "func (t *Tree32) _dfsHld(cur int32, times *int32) {",
      "\tt.Lid[cur] = *times",
      "\t*times++",
      "\tt.Rid[cur] += t.Lid[cur]",
      "\tt.IdToNode[t.Lid[cur]] = cur",
      "\theavy := true",
      "\tfor _, e := range t.Tree[cur] {",
      "\t\tto := e.to",
      "\t\tif t.Depth[to] > t.Depth[cur] {",
      "\t\t\tif heavy {",
      "\t\t\t\tt.Head[to] = t.Head[cur]",
      "\t\t\t} else {",
      "\t\t\t\tt.Head[to] = to",
      "\t\t\t}",
      "\t\t\theavy = false",
      "\t\t\tt._dfsHld(to, times)",
      "\t\t}",
      "\t}",
      "}",
      "",
      "// 路径 [a,b] 与 [c,d] 的交集.",
      "// 如果为空则返回 {-1,-1}，如果只有一个交点则返回 {x,x}，如果有两个交点则返回 {x,y}.",
      "func (t *Tree32) PathIntersection(a, b, c, d int32) (int32, int32) {",
      "\tab := t.Lca(a, b)",
      "\tac := t.Lca(a, c)",
      "\tad := t.Lca(a, d)",
      "\tbc := t.Lca(b, c)",
      "\tbd := t.Lca(b, d)",
      "\tcd := t.Lca(c, d)",
      "\tx := ab ^ ac ^ bc // meet(a,b,c)",
      "\ty := ab ^ ad ^ bd // meet(a,b,d)",
      "\tif x != y {",
      "\t\treturn x, y",
      "\t}",
      "\tz := ac ^ ad ^ cd",
      "\tif x != z {",
      "\t\tx = -1",
      "\t}",
      "\treturn x, x",
      "}"
    ],
    "description": "TreeMonoid32Lazy"
  },
  "retain-go": {
    "scope": "go",
    "prefix": "retain",
    "body": [
      "func Retain[T any](arr *[]T, f func(index int) bool) {",
      "\tptr := 0",
      "\tn := len(*arr)",
      "\tfor i := 0; i < n; i++ {",
      "\t\tif f(i) {",
      "\t\t\t(*arr)[ptr] = (*arr)[i]",
      "\t\t\tptr++",
      "\t\t}",
      "\t}",
      "\t*arr = (*arr)[:ptr:ptr]",
      "}"
    ],
    "description": "Retain"
  },
  "GridBfs": {
    "scope": "go",
    "prefix": "gridbfs",
    "body": [
      "",
      "var dir8 = [][]int32{{1, 0}, {0, 1}, {-1, 0}, {0, -1}, {1, 1}, {1, -1}, {-1, 1}, {-1, -1}}",
      "",
      "// 网格最短路.",
      "func GridBfs(",
      "\trow, col int32, sx, sy int32, dmax int32,",
      "\tisWall func(int32, int32) bool,",
      ") [][]int32 {",
      "\tisIn := func(x, y int32) bool {",
      "\t\tif x < 0 || row <= x {",
      "\t\t\treturn false",
      "\t\t}",
      "\t\tif y < 0 || col <= y {",
      "\t\t\treturn false",
      "\t\t}",
      "\t\treturn !isWall(x, y)",
      "\t}",
      "",
      "\tdist := make([][]int32, row)",
      "\tfor i := range dist {",
      "\t\tdist[i] = make([]int32, col)",
      "\t\tfor j := range dist[i] {",
      "\t\t\tdist[i][j] = INF32",
      "\t\t}",
      "\t}",
      "\tqueue := [][2]int32{{sx, sy}}",
      "\tadd := func(x, y, d int32) {",
      "\t\tif !isIn(x, y) {",
      "\t\t\treturn",
      "\t\t}",
      "\t\tif dist[x][y] > d {",
      "\t\t\tdist[x][y] = d",
      "\t\t\tqueue = append(queue, [2]int32{x, y})",
      "\t\t}",
      "\t}",
      "\tadd(sx, sy, 0)",
      "",
      "\tfor len(queue) > 0 {",
      "\t\tx, y := queue[0][0], queue[0][1]",
      "\t\tqueue = queue[1:]",
      "\t\tfor i := int32(0); i < dmax; i++ {",
      "\t\t\tnx, ny := x+dir8[i][0], y+dir8[i][1]",
      "\t\t\tadd(nx, ny, dist[x][y]+1)",
      "\t\t}",
      "\t}",
      "\treturn dist",
      "}"
    ],
    "description": "GridBfs"
  },
  "RestorePath": {
    "scope": "go",
    "prefix": "RestorePath",
    "body": [
      "// 还原路径/dp复原.",
      "func RestorePath(target int, pre []int) []int {",
      "\tpath := []int{target}",
      "\tcur := target",
      "\tfor pre[cur] != -1 {",
      "\t\tcur = pre[cur]",
      "\t\tpath = append(path, cur)",
      "\t}",
      "\tfor i, j := 0, len(path)-1; i < j; i, j = i+1, j-1 {",
      "\t\tpath[i], path[j] = path[j], path[i]",
      "\t}",
      "\treturn path",
      "}"
    ]
  },
  "RestorePath2": {
    "scope": "go",
    "prefix": "RestorePath2",
    "body": [
      "",
      "// 还原路径/dp复原.",
      "func RestorePath2(start, target int, pre []int) []int {",
      "\tpath := []int{target}",
      "\tcur := target",
      "\tfor cur != start {",
      "\t\tcur = pre[cur]",
      "\t\tpath = append(path, cur)",
      "\t}",
      "\tfor i, j := 0, len(path)-1; i < j; i, j = i+1, j-1 {",
      "\t\tpath[i], path[j] = path[j], path[i]",
      "\t}",
      "\treturn path",
      "}"
    ],
    "description": "a"
  },
  "fastSet32": {
    "scope": "go",
    "prefix": "fastSet32",
    "body": [
      "",
      "type FastSet32 struct {",
      "\tn, lg int32",
      "\tseg\t [][]uint64",
      "\tsize\tint32",
      "}",
      "",
      "func NewFastSet32(n int32) *FastSet32 {",
      "\tres := &FastSet32{n: n}",
      "\tseg := [][]uint64{}",
      "\tn_ := n",
      "\tfor {",
      "\t\tseg = append(seg, make([]uint64, (n_+63)>>6))",
      "\t\tn_ = (n_ + 63) >> 6",
      "\t\tif n_ <= 1 {",
      "\t\t\tbreak",
      "\t\t}",
      "\t}",
      "\tres.seg = seg",
      "\tres.lg = int32(len(seg))",
      "\treturn res",
      "}",
      "",
      "func NewFastSet32From(n int32, f func(i int32) bool) *FastSet32 {",
      "\tres := NewFastSet32(n)",
      "\tfor i := int32(0); i < n; i++ {",
      "\t\tif f(i) {",
      "\t\t\tres.seg[0][i>>6] |= 1 << (i & 63)",
      "\t\t\tres.size++",
      "\t\t}",
      "\t}",
      "\tfor h := int32(0); h < res.lg-1; h++ {",
      "\t\tfor i := 0; i < len(res.seg[h]); i++ {",
      "\t\t\tif res.seg[h][i] != 0 {",
      "\t\t\t\tres.seg[h+1][i>>6] |= 1 << (i & 63)",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "\treturn res",
      "}",
      "",
      "func (fs *FastSet32) Has(i int32) bool {",
      "\treturn (fs.seg[0][i>>6]>>(i&63))&1 != 0",
      "}",
      "",
      "func (fs *FastSet32) Insert(i int32) bool {",
      "\tif fs.Has(i) {",
      "\t\treturn false",
      "\t}",
      "\tfor h := int32(0); h < fs.lg; h++ {",
      "\t\tfs.seg[h][i>>6] |= 1 << (i & 63)",
      "\t\ti >>= 6",
      "\t}",
      "\tfs.size++",
      "\treturn true",
      "}",
      "",
      "func (fs *FastSet32) Erase(i int32) bool {",
      "\tif !fs.Has(i) {",
      "\t\treturn false",
      "\t}",
      "\tfor h := int32(0); h < fs.lg; h++ {",
      "\t\tcache := fs.seg[h]",
      "\t\tcache[i>>6] &= ^(1 << (i & 63))",
      "\t\tif cache[i>>6] != 0 {",
      "\t\t\tbreak",
      "\t\t}",
      "\t\ti >>= 6",
      "\t}",
      "\tfs.size--",
      "\treturn true",
      "}",
      "",
      "// 返回大于等于i的最小元素.如果不存在,返回n.",
      "func (fs *FastSet32) Next(i int32) int32 {",
      "\tif i < 0 {",
      "\t\ti = 0",
      "\t}",
      "\tif i >= fs.n {",
      "\t\treturn fs.n",
      "\t}",
      "",
      "\tfor h := int32(0); h < fs.lg; h++ {",
      "\t\tcache := fs.seg[h]",
      "\t\tif i>>6 == int32(len(cache)) {",
      "\t\t\tbreak",
      "\t\t}",
      "\t\td := cache[i>>6] >> (i & 63)",
      "\t\tif d == 0 {",
      "\t\t\ti = i>>6 + 1",
      "\t\t\tcontinue",
      "\t\t}",
      "\t\t// find",
      "\t\ti += fs.bsf(d)",
      "\t\tfor g := h - 1; g >= 0; g-- {",
      "\t\t\ti <<= 6",
      "\t\t\ti += fs.bsf(fs.seg[g][i>>6])",
      "\t\t}",
      "",
      "\t\treturn i",
      "\t}",
      "",
      "\treturn fs.n",
      "}",
      "",
      "// 返回小于等于i的最大元素.如果不存在,返回-1.",
      "func (fs *FastSet32) Prev(i int32) int32 {",
      "\tif i < 0 {",
      "\t\treturn -1",
      "\t}",
      "\tif i >= fs.n {",
      "\t\ti = fs.n - 1",
      "\t}",
      "",
      "\tfor h := int32(0); h < fs.lg; h++ {",
      "\t\tif i == -1 {",
      "\t\t\tbreak",
      "\t\t}",
      "\t\td := fs.seg[h][i>>6] << (63 - i&63)",
      "\t\tif d == 0 {",
      "\t\t\ti = i>>6 - 1",
      "\t\t\tcontinue",
      "\t\t}",
      "\t\t// find",
      "\t\ti += fs.bsr(d) - 63",
      "\t\tfor g := h - 1; g >= 0; g-- {",
      "\t\t\ti <<= 6",
      "\t\t\ti += fs.bsr(fs.seg[g][i>>6])",
      "\t\t}",
      "",
      "\t\treturn i",
      "\t}",
      "",
      "\treturn -1",
      "}",
      "",
      "// 遍历[start,end)区间内的元素.",
      "func (fs *FastSet32) Enumerate(start, end int32, f func(i int32)) {",
      "\tfor x := fs.Next(start); x < end; x = fs.Next(x + 1) {",
      "\t\tf(x)",
      "\t}",
      "}",
      "",
      "func (fs *FastSet32) String() string {",
      "\tres := []string{}",
      "\tfor i := int32(0); i < fs.n; i++ {",
      "\t\tif fs.Has(i) {",
      "\t\t\tres = append(res, strconv.Itoa(int(i)))",
      "\t\t}",
      "\t}",
      "\treturn fmt.Sprintf(\"FastSet{%v}\", strings.Join(res, \", \"))",
      "}",
      "",
      "func (fs *FastSet32) Size() int32 {",
      "\treturn fs.size",
      "}",
      "",
      "func (*FastSet32) bsr(x uint64) int32 {",
      "\treturn 63 - int32(bits.LeadingZeros64(x))",
      "}",
      "",
      "func (*FastSet32) bsf(x uint64) int32 {",
      "\treturn int32(bits.TrailingZeros64(x))",
      "}"
    ],
    "description": "fastSet32"
  },
  "TopoSort": {
    "scope": "go",
    "prefix": "TopoSort",
    "body": [
      "func TopoSort(n int, adjList [][]int, directed bool) (order []int, ok bool) {",
      "\tdeg := make([]int, n)",
      "\tstartDeg := 0",
      "\tif directed {",
      "\t\tfor _, adj := range adjList {",
      "\t\t\tfor _, j := range adj {",
      "\t\t\t\tdeg[j]++",
      "\t\t\t}",
      "\t\t}",
      "\t} else {",
      "\t\tfor i, adj := range adjList {",
      "\t\t\tdeg[i] = len(adj)",
      "\t\t}",
      "\t\tstartDeg = 1",
      "\t}",
      "",
      "\tqueue := []int{}",
      "\tfor v := 0; v < n; v++ {",
      "\t\tif deg[v] == startDeg {",
      "\t\t\tqueue = append(queue, v)",
      "\t\t}",
      "\t}",
      "",
      "\tfor len(queue) > 0 {",
      "\t\tcur := queue[0]",
      "\t\tqueue = queue[1:]",
      "\t\torder = append(order, cur)",
      "\t\tfor _, next := range adjList[cur] {",
      "\t\t\tdeg[next]--",
      "\t\t\tif deg[next] == startDeg {",
      "\t\t\t\tqueue = append(queue, next)",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "",
      "\tif len(order) < n {",
      "\t\treturn nil, false",
      "\t}",
      "\treturn order, true",
      "}",
      ""
    ],
    "description": "TopoSort"
  },
  "reverse-go": {
    "scope": "go",
    "prefix": "Reverse",
    "body": [
      "func Reverse[S ~[]E, E any](arr S) {",
      "\tn := len(arr)",
      "\tfor i := 0; i < n/2; i++ {",
      "\t\tarr[i], arr[n-1-i] = arr[n-1-i], arr[i]",
      "\t}",
      "}",
      ""
    ],
    "description": "Reverse"
  },
  "reverse-func-go": {
    "scope": "go",
    "prefix": "ReverseFunc",
    "body": [
      "func ReverseFunc[E any](n int, ptr func(i int) *E) {",
      "\tfor i := 0; i < n/2; i++ {",
      "\t\ta, b := ptr(i), ptr(n-1-i)",
      "\t\t*a, *b = *b, *a",
      "\t}",
      "}"
    ],
    "description": "ReverseFunc"
  },
  "monoidAffine": {
    "scope": "go",
    "prefix": "monoidAffine",
    "body": [
      "\t// MonoidAffine",
      "\tconst MOD int = 1e9 + 7",
      "\tmodPow := func(x, n, mod int) int {",
      "\t\tres := 1",
      "\t\tfor n > 0 {",
      "\t\t\tif n&1 == 1 {",
      "\t\t\t\tres = res * x % mod",
      "\t\t\t}",
      "\t\t\tx = x * x % mod",
      "\t\t\tn >>= 1",
      "\t\t}",
      "\t\treturn res",
      "\t}",
      "",
      "\ttype E = [2]int // (mul, add)",
      "\te := func() E {",
      "\t\treturn E{1, 0}",
      "\t}",
      "\top := func(a, b E) E {",
      "\t\treturn E{(a[0] * b[0]) % MOD, (a[1]*b[0] + b[1]) % MOD}",
      "\t}",
      "\tinv := func(a E) E {",
      "\t\tmul, add := a[0], a[1]",
      "\t\tmul = modPow(mul, MOD-2, MOD) // modInv of mul",
      "\t\treturn E{mul, mul * (MOD - add) % MOD}",
      "\t}"
    ],
    "description": "monoidAffine"
  },
  "collectCycle-py": {
    "scope": "python",
    "prefix": "collectCycle",
    "body": [
      "def collectCycle(nexts: List[int], start: int) -> List[int]:",
      "\t\t\"\"\"置换环找环.nexts数组中元素各不相同.\"\"\"",
      "\t\tcycle = []",
      "\t\tcur = start",
      "\t\twhile True:",
      "\t\t\t\tcycle.append(cur)",
      "\t\t\t\tcur = nexts[cur]",
      "\t\t\t\tif cur == start:",
      "\t\t\t\t\t\tbreak",
      "\t\treturn cycle"
    ],
    "description": "collectCycle"
  },
  "collectCycle-go": {
    "scope": "go",
    "prefix": "collectCycle",
    "body": [
      "// 置换环找环.nexts数组中元素各不相同.",
      "func collectCycle(nexts []int32, start int32) []int32 {",
      "\tcycle := []int32{}",
      "\tcur := start",
      "\tfor {",
      "\t\tcycle = append(cycle, cur)",
      "\t\tcur = nexts[cur]",
      "\t\tif cur == start {",
      "\t\t\tbreak",
      "\t\t}",
      "\t}",
      "\treturn cycle",
      "}"
    ],
    "description": "collectCycle"
  },
  "minArg": {
    "scope": "python",
    "prefix": ["minArg", "min_arg", "maxArg", "max_arg"],
    "body": [
      "def minArg(arr: List[int]) -> int:",
      "\t\tminVal, minIdx = arr[0], 0",
      "\t\tfor i in range(1, len(arr)):",
      "\t\t\t\tif arr[i] < minVal:",
      "\t\t\t\t\t\tminVal = arr[i]",
      "\t\t\t\t\t\tminIdx = i",
      "\t\treturn minIdx",
      "",
      "",
      "def maxArg(arr: List[int]) -> int:",
      "\t\tmaxVal, maxIdx = arr[0], 0",
      "\t\tfor i in range(1, len(arr)):",
      "\t\t\t\tif arr[i] > maxVal:",
      "\t\t\t\t\t\tmaxVal = arr[i]",
      "\t\t\t\t\t\tmaxIdx = i",
      "\t\treturn maxIdx"
    ],
    "description": "minArg"
  },
  "NewDeque": {
    "scope": "go",
    "prefix": ["NewDeque", "newDeque", "Deque"],
    "body": [
      "type Deque[D any] struct{ l, r []D }",
      "",
      "func NewDeque[D any](cap int32) *Deque[D] {",
      "\treturn &Deque[D]{make([]D, 0, 1+cap/2), make([]D, 0, 1+cap/2)}",
      "}",
      "",
      "func (q Deque[D]) Empty() bool {",
      "\treturn len(q.l) == 0 && len(q.r) == 0",
      "}",
      "",
      "func (q Deque[D]) Size() int {",
      "\treturn len(q.l) + len(q.r)",
      "}",
      "",
      "func (q *Deque[D]) AppendLeft(v D) {",
      "\tq.l = append(q.l, v)",
      "}",
      "",
      "func (q *Deque[D]) Append(v D) {",
      "\tq.r = append(q.r, v)",
      "}",
      "",
      "func (q *Deque[D]) PopLeft() (v D) {",
      "\tif len(q.l) > 0 {",
      "\t\tq.l, v = q.l[:len(q.l)-1], q.l[len(q.l)-1]",
      "\t} else {",
      "\t\tv, q.r = q.r[0], q.r[1:]",
      "\t}",
      "\treturn",
      "}",
      "",
      "func (q *Deque[D]) Pop() (v D) {",
      "\tif len(q.r) > 0 {",
      "\t\tq.r, v = q.r[:len(q.r)-1], q.r[len(q.r)-1]",
      "\t} else {",
      "\t\tv, q.l = q.l[0], q.l[1:]",
      "\t}",
      "\treturn",
      "}",
      "",
      "func (q Deque[D]) Front() D {",
      "\tif len(q.l) > 0 {",
      "\t\treturn q.l[len(q.l)-1]",
      "\t}",
      "\treturn q.r[0]",
      "}",
      "",
      "func (q Deque[D]) Back() D {",
      "\tif len(q.r) > 0 {",
      "\t\treturn q.r[len(q.r)-1]",
      "\t}",
      "\treturn q.l[0]",
      "}",
      "",
      "// 0 <= i < q.Size()",
      "func (q Deque[D]) At(i int) D {",
      "\tif i < len(q.l) {",
      "\t\treturn q.l[len(q.l)-1-i]",
      "\t}",
      "\treturn q.r[i-len(q.l)]",
      "}",
      ""
    ],
    "description": "NewDeque"
  },
  "bfs01": {
    "scope": "go",
    "prefix": "bfs01",
    "body": [
      "const INF32 int32 = 1e9 + 10",
      "",
      "func bfs0132(adjList [][][2]int32, start int32) (dist, pre []int32) {",
      "\tn := int32(len(adjList))",
      "\tdist = make([]int32, n)",
      "\tpre = make([]int32, n)",
      "\tfor i := int32(0); i < n; i++ {",
      "\t\tdist[i] = INF32",
      "\t\tpre[i] = -1",
      "\t}",
      "\tqueue := NewDeque[int32](n)",
      "\tqueue.Append(start)",
      "\tdist[start] = 0",
      "\tfor queue.Size() > 0 {",
      "\t\tcur := queue.PopLeft()",
      "\t\tfor _, e := range adjList[cur] {",
      "\t\t\tnext, weight := e[0], e[1]",
      "\t\t\tcand := dist[cur] + weight",
      "\t\t\tif cand < dist[next] {",
      "\t\t\t\tdist[next] = cand",
      "\t\t\t\tpre[next] = cur",
      "\t\t\t\tif weight == 0 {",
      "\t\t\t\t\tqueue.AppendLeft(next)",
      "\t\t\t\t} else {",
      "\t\t\t\t\tqueue.Append(next)",
      "\t\t\t\t}",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "\treturn",
      "}",
      "",
      "type Deque[D any] struct{ l, r []D }",
      "",
      "func NewDeque[D any](cap int32) *Deque[D] {",
      "\treturn &Deque[D]{make([]D, 0, 1+cap/2), make([]D, 0, 1+cap/2)}",
      "}",
      "",
      "func (q Deque[D]) Empty() bool {",
      "\treturn len(q.l) == 0 && len(q.r) == 0",
      "}",
      "",
      "func (q Deque[D]) Size() int {",
      "\treturn len(q.l) + len(q.r)",
      "}",
      "",
      "func (q *Deque[D]) AppendLeft(v D) {",
      "\tq.l = append(q.l, v)",
      "}",
      "",
      "func (q *Deque[D]) Append(v D) {",
      "\tq.r = append(q.r, v)",
      "}",
      "",
      "func (q *Deque[D]) PopLeft() (v D) {",
      "\tif len(q.l) > 0 {",
      "\t\tq.l, v = q.l[:len(q.l)-1], q.l[len(q.l)-1]",
      "\t} else {",
      "\t\tv, q.r = q.r[0], q.r[1:]",
      "\t}",
      "\treturn",
      "}",
      "",
      "func (q *Deque[D]) Pop() (v D) {",
      "\tif len(q.r) > 0 {",
      "\t\tq.r, v = q.r[:len(q.r)-1], q.r[len(q.r)-1]",
      "\t} else {",
      "\t\tv, q.l = q.l[0], q.l[1:]",
      "\t}",
      "\treturn",
      "}",
      "",
      "func (q Deque[D]) Front() D {",
      "\tif len(q.l) > 0 {",
      "\t\treturn q.l[len(q.l)-1]",
      "\t}",
      "\treturn q.r[0]",
      "}",
      "",
      "func (q Deque[D]) Back() D {",
      "\tif len(q.r) > 0 {",
      "\t\treturn q.r[len(q.r)-1]",
      "\t}",
      "\treturn q.l[0]",
      "}",
      "",
      "// 0 <= i < q.Size()",
      "func (q Deque[D]) At(i int) D {",
      "\tif i < len(q.l) {",
      "\t\treturn q.l[len(q.l)-1-i]",
      "\t}",
      "\treturn q.r[i-len(q.l)]",
      "}",
      ""
    ],
    "description": "bfs01"
  },
  "enumerateSubset-py": {
    "scope": "python",
    "prefix": ["enumerateSubset", "subset"],
    "body": [
      "def enumerateSubset(s: int):",
      "\t\t\"\"\"降序枚举非空子集(包含s自身).\"\"\"",
      "\t\tt = s",
      "\t\twhile t:",
      "\t\t\t\tyield t",
      "\t\t\t\tt = (t - 1) & s"
    ],
    "description": "a"
  },
  "EnumerateSubset": {
    "scope": "go",
    "prefix": ["EnumerateSubset", "enumerateSubset"],
    "body": [
      "// 降序枚举非空子集(包含s自身).",
      "func EnumerateSubset(s int, f func(b int)) {",
      "\tfor b := s; b > 0; b = (b - 1) & s {",
      "\t\tf(b)",
      "\t}",
      "}"
    ],
    "description": "EnumerateSubset"
  },
  "nextPermutation-py": {
    "scope": "python",
    "prefix": ["nextPermutation", "prePermutation"],
    "body": [
      "def nextPermutation(nums) -> bool:",
      "\t\t\"\"\"O(n)返回下一个字典序的排列.\"\"\"",
      "\t\tleft = right = len(nums) - 1",
      "\t\twhile left > 0 and nums[left - 1] >= nums[left]:\t# 1. 找到最后一个递增位置",
      "\t\t\t\tleft -= 1",
      "\t\tif left == 0:\t# 全部递减",
      "\t\t\t\treturn False",
      "\t\tlast = left - 1\t# 最后一个递增位置",
      "\t\twhile nums[right] <= nums[last]:\t# 2. 找到最小的可交换的right，交换这两个数",
      "\t\t\t\tright -= 1",
      "\t\tnums[last], nums[right] = nums[right], nums[last]",
      "\t\tleft, right = last + 1, len(nums) - 1\t# 3. 翻转后面间这段递减数列",
      "\t\twhile left < right:",
      "\t\t\t\tnums[left], nums[right] = nums[right], nums[left]",
      "\t\t\t\tleft += 1",
      "\t\t\t\tright -= 1",
      "\t\treturn True",
      "",
      "",
      "def prePermutation(nums) -> bool:",
      "\t\t\"\"\"O(n)返回上一个字典序的排列.\"\"\"",
      "\t\tleft = right = len(nums) - 1",
      "\t\twhile left > 0 and nums[left - 1] <= nums[left]:\t# 1. 找到最后一个递减位置",
      "\t\t\t\tleft -= 1",
      "\t\tif left == 0:\t# 全部递增",
      "\t\t\t\treturn False",
      "\t\tlast = left - 1\t# 最后一个递减位置",
      "\t\twhile nums[right] >= nums[last]:\t# 2. 找到最大的可交换的right，交换这两个数",
      "\t\t\t\tright -= 1",
      "\t\tnums[last], nums[right] = nums[right], nums[last]",
      "\t\tleft, right = last + 1, len(nums) - 1\t# 3. 翻转后面间这段递增数列",
      "\t\twhile left < right:",
      "\t\t\t\tnums[left], nums[right] = nums[right], nums[left]",
      "\t\t\t\tleft += 1",
      "\t\t\t\tright -= 1",
      "\t\treturn True"
    ],
    "description": "nextPermutation"
  },

  "nextPermutation-go": {
    "scope": "go",
    "prefix": ["nextPermutation", "prePermutation"],
    "body": [
      "// 原地返回下一个字典序的排列.",
      "// 不包含重复排列.",
      "func nextPermutation[T cmp.Ordered](nums []T) bool {",
      "\tleft, right := len(nums)-1, len(nums)-1",
      "\tfor left > 0 && nums[left-1] >= nums[left] {",
      "\t\tleft--",
      "\t}",
      "\tif left == 0 {",
      "\t\treturn false",
      "\t}",
      "\tlast := left - 1",
      "\tfor nums[right] <= nums[last] {",
      "\t\tright--",
      "\t}",
      "\tnums[last], nums[right] = nums[right], nums[last]",
      "\tfor i, j := last+1, len(nums)-1; i < j; i, j = i+1, j-1 {",
      "\t\tnums[i], nums[j] = nums[j], nums[i]",
      "\t}",
      "\treturn true",
      "}",
      "",
      "// 原地返回上一个字典序的排列.",
      "// 不包含重复排列.",
      "func prePermutation[T cmp.Ordered](nums []T) bool {",
      "\tleft, right := len(nums)-1, len(nums)-1",
      "\tfor left > 0 && nums[left-1] <= nums[left] {",
      "\t\tleft--",
      "\t}",
      "\tif left == 0 {",
      "\t\treturn false",
      "\t}",
      "\tlast := left - 1",
      "\tfor nums[right] >= nums[last] {",
      "\t\tright--",
      "\t}",
      "\tnums[last], nums[right] = nums[right], nums[last]",
      "\tfor i, j := last+1, len(nums)-1; i < j; i, j = i+1, j-1 {",
      "\t\tnums[i], nums[j] = nums[j], nums[i]",
      "\t}",
      "\treturn true",
      "}"
    ],
    "description": "nextPermutation"
  },
  "isPalindrome": {
    "scope": "go",
    "prefix": "isPalindrome",
    "body": [
      "func isPalindrome[T comparable](nums []T) bool {",
      "\tfor i := 0; i < len(nums)/2; i++ {",
      "\t\tif nums[i] != nums[len(nums)-1-i] {",
      "\t\t\treturn false",
      "\t\t}",
      "\t}",
      "\treturn true",
      "}"
    ],
    "description": "isPalindrome"
  },
  "more-itertools-basic": {
    "scope": "python",
    "prefix": [
      "more-itertools-basic",
      "chunked_even",
      "distribute",
      "batched",
      "spy",
      "unzip",
      "take",
      "tail",
      "consume",
      "nth",
      "triplewise",
      "ncycles",
      "collapse",
      "prepend",
      "unique",
      "iter_index"
    ],
    "body": [
      "import operator",
      "from collections import deque",
      "from itertools import chain, groupby, islice, repeat, tee",
      "from typing import Iterable, List, Optional, Sized, TypeVar",
      "",
      "T = TypeVar(\"T\")",
      "",
      "",
      "def chunked_even(iterable: Iterable[T], n: int):",
      "\t\t\"\"\"Break *iterable* into lists of approximately length *n*.",
      "\t\tItems are distributed such the lengths of the lists differ by at most",
      "\t\t1 item.",
      "",
      "\t\t>>> iterable = [1, 2, 3, 4, 5, 6, 7]",
      "\t\t>>> n = 3",
      "\t\t>>> list(chunked_even(iterable, n))\t# List lengths: 3, 2, 2",
      "\t\t[[1, 2, 3], [4, 5], [6, 7]]",
      "\t\t>>> list(chunked(iterable, n))\t# List lengths: 3, 3, 1",
      "\t\t[[1, 2, 3], [4, 5, 6], [7]]",
      "",
      "\t\t\"\"\"",
      "\t\titerable = iter(iterable)",
      "",
      "\t\t# Initialize a buffer to process the chunks while keeping",
      "\t\t# some back to fill any underfilled chunks",
      "\t\tmin_buffer = (n - 1) * (n - 2)",
      "\t\tbuffer = list(islice(iterable, min_buffer))",
      "",
      "\t\t# Append items until we have a completed chunk",
      "\t\tfor _ in islice(map(buffer.append, iterable), n, None, n):",
      "\t\t\t\tyield buffer[:n]",
      "\t\t\t\tdel buffer[:n]",
      "",
      "\t\t# Check if any chunks need addition processing",
      "\t\tif not buffer:",
      "\t\t\t\treturn",
      "\t\tlength = len(buffer)",
      "",
      "\t\t# Chunks are either size `full_size <= n` or `partial_size = full_size - 1`",
      "\t\tq, r = divmod(length, n)",
      "\t\tnum_lists = q + (1 if r > 0 else 0)",
      "\t\tq, r = divmod(length, num_lists)",
      "\t\tfull_size = q + (1 if r > 0 else 0)",
      "\t\tpartial_size = full_size - 1",
      "\t\tnum_full = length - partial_size * num_lists",
      "",
      "\t\t# Yield chunks of full size",
      "\t\tpartial_start_idx = num_full * full_size",
      "\t\tif full_size > 0:",
      "\t\t\t\tfor i in range(0, partial_start_idx, full_size):",
      "\t\t\t\t\t\tyield buffer[i : i + full_size]",
      "",
      "\t\t# Yield chunks of partial size",
      "\t\tif partial_size > 0:",
      "\t\t\t\tfor i in range(partial_start_idx, length, partial_size):",
      "\t\t\t\t\t\tyield buffer[i : i + partial_size]",
      "",
      "",
      "def distribute(n: int, iterable: Iterable[T]):",
      "\t\t\"\"\"Distribute the items from *iterable* among *n* smaller iterables.",
      "",
      "\t\t\t\t>>> group_1, group_2 = distribute(2, [1, 2, 3, 4, 5, 6])",
      "\t\t\t\t>>> list(group_1)",
      "\t\t\t\t[1, 3, 5]",
      "\t\t\t\t>>> list(group_2)",
      "\t\t\t\t[2, 4, 6]",
      "",
      "\t\tIf the length of *iterable* is not evenly divisible by *n*, then the",
      "\t\tlength of the returned iterables will not be identical:",
      "",
      "\t\t\t\t>>> children = distribute(3, [1, 2, 3, 4, 5, 6, 7])",
      "\t\t\t\t>>> [list(c) for c in children]",
      "\t\t\t\t[[1, 4, 7], [2, 5], [3, 6]]",
      "",
      "\t\tIf the length of *iterable* is smaller than *n*, then the last returned",
      "\t\titerables will be empty:",
      "",
      "\t\t\t\t>>> children = distribute(5, [1, 2, 3])",
      "\t\t\t\t>>> [list(c) for c in children]",
      "\t\t\t\t[[1], [2], [3], [], []]",
      "",
      "\t\tThis function uses :func:`itertools.tee` and may require significant",
      "\t\tstorage.",
      "",
      "\t\tIf you need the order items in the smaller iterables to match the",
      "\t\toriginal iterable, see :func:`divide`.",
      "",
      "\t\t\"\"\"",
      "\t\tif n < 1:",
      "\t\t\t\traise ValueError(\"n must be at least 1\")",
      "",
      "\t\tchildren = tee(iterable, n)",
      "\t\treturn [islice(it, index, None, n) for index, it in enumerate(children)]",
      "",
      "",
      "def unzip(iterable):",
      "\t\t\"\"\"The inverse of :func:`zip`, this function disaggregates the elements",
      "\t\tof the zipped *iterable*.",
      "",
      "\t\tThe ``i``-th iterable contains the ``i``-th element from each element",
      "\t\tof the zipped iterable. The first element is used to determine the",
      "\t\tlength of the remaining elements.",
      "",
      "\t\t\t\t>>> iterable = [('a', 1), ('b', 2), ('c', 3), ('d', 4)]",
      "\t\t\t\t>>> letters, numbers = unzip(iterable)",
      "\t\t\t\t>>> list(letters)",
      "\t\t\t\t['a', 'b', 'c', 'd']",
      "\t\t\t\t>>> list(numbers)",
      "\t\t\t\t[1, 2, 3, 4]",
      "",
      "\t\tThis is similar to using ``zip(*iterable)``, but it avoids reading",
      "\t\t*iterable* into memory. Note, however, that this function uses",
      "\t\t:func:`itertools.tee` and thus may require significant storage.",
      "",
      "\t\t\"\"\"",
      "\t\thead, iterable = spy(iter(iterable))",
      "\t\tif not head:",
      "\t\t\t\t# empty iterable, e.g. zip([], [], [])",
      "\t\t\t\treturn ()",
      "\t\t# spy returns a one-length iterable as head",
      "\t\thead = head[0]",
      "\t\titerables = tee(iterable, len(head))",
      "",
      "\t\tdef itemgetter(i):",
      "\t\t\t\tdef getter(obj):",
      "\t\t\t\t\t\ttry:",
      "\t\t\t\t\t\t\t\treturn obj[i]",
      "\t\t\t\t\t\texcept IndexError:",
      "\t\t\t\t\t\t\t\t# basically if we have an iterable like",
      "\t\t\t\t\t\t\t\t# iter([(1, 2, 3), (4, 5), (6,)])",
      "\t\t\t\t\t\t\t\t# the second unzipped iterable would fail at the third tuple",
      "\t\t\t\t\t\t\t\t# since it would try to access tup[1]",
      "\t\t\t\t\t\t\t\t# same with the third unzipped iterable and the second tuple",
      "\t\t\t\t\t\t\t\t# to support these \"improperly zipped\" iterables,",
      "\t\t\t\t\t\t\t\t# we create a custom itemgetter",
      "\t\t\t\t\t\t\t\t# which just stops the unzipped iterables",
      "\t\t\t\t\t\t\t\t# at first length mismatch",
      "\t\t\t\t\t\t\t\traise StopIteration",
      "",
      "\t\t\t\treturn getter",
      "",
      "\t\treturn tuple(map(itemgetter(i), it) for i, it in enumerate(iterables))",
      "",
      "",
      "def spy(iterable: Iterable[T], n: int = 1):",
      "\t\t\"\"\"Return a 2-tuple with a list containing the first *n* elements of",
      "\t\t*iterable*, and an iterator with the same items as *iterable*.",
      "\t\tThis allows you to \"look ahead\" at the items in the iterable without",
      "\t\tadvancing it.",
      "",
      "\t\tThere is one item in the list by default:",
      "",
      "\t\t\t\t>>> iterable = 'abcdefg'",
      "\t\t\t\t>>> head, iterable = spy(iterable)",
      "\t\t\t\t>>> head",
      "\t\t\t\t['a']",
      "\t\t\t\t>>> list(iterable)",
      "\t\t\t\t['a', 'b', 'c', 'd', 'e', 'f', 'g']",
      "",
      "\t\tYou may use unpacking to retrieve items instead of lists:",
      "",
      "\t\t\t\t>>> (head,), iterable = spy('abcdefg')",
      "\t\t\t\t>>> head",
      "\t\t\t\t'a'",
      "\t\t\t\t>>> (first, second), iterable = spy('abcdefg', 2)",
      "\t\t\t\t>>> first",
      "\t\t\t\t'a'",
      "\t\t\t\t>>> second",
      "\t\t\t\t'b'",
      "",
      "\t\tThe number of items requested can be larger than the number of items in",
      "\t\tthe iterable:",
      "",
      "\t\t\t\t>>> iterable = [1, 2, 3, 4, 5]",
      "\t\t\t\t>>> head, iterable = spy(iterable, 10)",
      "\t\t\t\t>>> head",
      "\t\t\t\t[1, 2, 3, 4, 5]",
      "\t\t\t\t>>> list(iterable)",
      "\t\t\t\t[1, 2, 3, 4, 5]",
      "",
      "\t\t\"\"\"",
      "\t\tit = iter(iterable)",
      "\t\thead = take(n, it)",
      "",
      "\t\treturn head.copy(), chain(head, it)",
      "",
      "",
      "def take(n: int, iterable: Iterable[T]):",
      "\t\t\"\"\"Return first *n* items of the iterable as a list.",
      "",
      "\t\t\t\t>>> take(3, range(10))",
      "\t\t\t\t[0, 1, 2]",
      "",
      "\t\tIf there are fewer than *n* items in the iterable, all of them are",
      "\t\treturned.",
      "",
      "\t\t\t\t>>> take(10, range(3))",
      "\t\t\t\t[0, 1, 2]",
      "",
      "\t\t\"\"\"",
      "\t\treturn list(islice(iterable, n))",
      "",
      "",
      "def batched(iterable: List[T], n: int, *, strict: bool = False):",
      "\t\t\"\"\"Batch data into tuples of length *n*. If the number of items in",
      "\t\t*iterable* is not divisible by *n*:",
      "\t\t* The last batch will be shorter if *strict* is ``False``.",
      "\t\t* :exc:`ValueError` will be raised if *strict* is ``True``.",
      "",
      "\t\t>>> list(batched('ABCDEFG', 3))",
      "\t\t[('A', 'B', 'C'), ('D', 'E', 'F'), ('G',)]",
      "",
      "\t\tOn Python 3.13 and above, this is an alias for :func:`itertools.batched`.",
      "\t\t\"\"\"",
      "\t\tif n < 1:",
      "\t\t\t\traise ValueError(\"n must be at least one\")",
      "\t\tit = iter(iterable)",
      "\t\twhile batch := tuple(islice(it, n)):",
      "\t\t\t\tif strict and len(batch) != n:",
      "\t\t\t\t\t\traise ValueError(\"batched(): incomplete batch\")",
      "\t\t\t\tyield batch",
      "",
      "",
      "def triplewise(iterable: Iterable[T]):",
      "\t\t\"\"\"Return overlapping triplets from *iterable*.",
      "",
      "\t\t>>> list(triplewise('ABCDE'))",
      "\t\t[('A', 'B', 'C'), ('B', 'C', 'D'), ('C', 'D', 'E')]",
      "",
      "\t\t\"\"\"",
      "\t\t# This deviates from the itertools documentation reciple - see",
      "\t\t# https://github.com/more-itertools/more-itertools/issues/889",
      "\t\tt1, t2, t3 = tee(iterable, 3)",
      "\t\tnext(t3, None)",
      "\t\tnext(t3, None)",
      "\t\tnext(t2, None)",
      "\t\treturn zip(t1, t2, t3)",
      "",
      "",
      "def ncycles(iterable: Iterable[T], n: int):",
      "\t\t\"\"\"Returns the sequence elements *n* times",
      "",
      "\t\t>>> list(ncycles([\"a\", \"b\"], 3))",
      "\t\t['a', 'b', 'a', 'b', 'a', 'b']",
      "",
      "\t\t\"\"\"",
      "\t\treturn chain.from_iterable(repeat(tuple(iterable), n))",
      "",
      "",
      "def collapse(",
      "\t\titerable: Iterable[T], *, levels: Optional[int] = None, base_type: Optional[type] = None",
      "):",
      "\t\t\"\"\"Flatten an iterable with multiple levels of nesting (e.g., a list of",
      "\t\tlists of tuples) into non-iterable types.",
      "",
      "\t\t\t\t>>> iterable = [(1, 2), ([3, 4], [[5], [6]])]",
      "\t\t\t\t>>> list(collapse(iterable))",
      "\t\t\t\t[1, 2, 3, 4, 5, 6]",
      "",
      "\t\tBinary and text strings are not considered iterable and",
      "\t\twill not be collapsed.",
      "",
      "\t\tTo avoid collapsing other types, specify *base_type*:",
      "",
      "\t\t\t\t>>> iterable = ['ab', ('cd', 'ef'), ['gh', 'ij']]",
      "\t\t\t\t>>> list(collapse(iterable, base_type=tuple))",
      "\t\t\t\t['ab', ('cd', 'ef'), 'gh', 'ij']",
      "",
      "\t\tSpecify *levels* to stop flattening after a certain level:",
      "",
      "\t\t>>> iterable = [('a', ['b']), ('c', ['d'])]",
      "\t\t>>> list(collapse(iterable))\t# Fully flattened",
      "\t\t['a', 'b', 'c', 'd']",
      "\t\t>>> list(collapse(iterable, levels=1))\t# Only one level flattened",
      "\t\t['a', ['b'], 'c', ['d']]",
      "",
      "\t\t\"\"\"",
      "\t\tstack = deque()",
      "\t\t# Add our first node group, treat the iterable as a single node",
      "\t\tstack.appendleft((0, repeat(iterable, 1)))",
      "",
      "\t\twhile stack:",
      "\t\t\t\tnode_group = stack.popleft()",
      "\t\t\t\tlevel, nodes = node_group",
      "",
      "\t\t\t\t# Check if beyond max level",
      "\t\t\t\tif levels is not None and level > levels:",
      "\t\t\t\t\t\tyield from nodes",
      "\t\t\t\t\t\tcontinue",
      "",
      "\t\t\t\tfor node in nodes:",
      "\t\t\t\t\t\t# Check if done iterating",
      "\t\t\t\t\t\tif isinstance(node, (str, bytes)) or (",
      "\t\t\t\t\t\t\t\t(base_type is not None) and isinstance(node, base_type)",
      "\t\t\t\t\t\t):",
      "\t\t\t\t\t\t\t\tyield node",
      "\t\t\t\t\t\t# Otherwise try to create child nodes",
      "\t\t\t\t\t\telse:",
      "\t\t\t\t\t\t\t\ttry:",
      "\t\t\t\t\t\t\t\t\t\ttree = iter(node)",
      "\t\t\t\t\t\t\t\texcept TypeError:",
      "\t\t\t\t\t\t\t\t\t\tyield node",
      "\t\t\t\t\t\t\t\telse:",
      "\t\t\t\t\t\t\t\t\t\t# Save our current location",
      "\t\t\t\t\t\t\t\t\t\tstack.appendleft(node_group)",
      "\t\t\t\t\t\t\t\t\t\t# Append the new child node",
      "\t\t\t\t\t\t\t\t\t\tstack.appendleft((level + 1, tree))",
      "\t\t\t\t\t\t\t\t\t\t# Break to process child node",
      "\t\t\t\t\t\t\t\t\t\tbreak",
      "",
      "",
      "def prepend(value: T, iterator: Iterable[T]):",
      "\t\t\"\"\"Yield *value*, followed by the elements in *iterator*.",
      "",
      "\t\t\t\t>>> value = '0'",
      "\t\t\t\t>>> iterator = ['1', '2', '3']",
      "\t\t\t\t>>> list(prepend(value, iterator))",
      "\t\t\t\t['0', '1', '2', '3']",
      "",
      "\t\tTo prepend multiple values, see :func:`itertools.chain`",
      "\t\tor :func:`value_chain`.",
      "",
      "\t\t\"\"\"",
      "\t\treturn chain([value], iterator)",
      "",
      "",
      "def nth(iterable: Iterable[T], n: int, default=None):",
      "\t\t\"\"\"Returns the nth item or a default value.",
      "",
      "\t\t>>> l = range(10)",
      "\t\t>>> nth(l, 3)",
      "\t\t3",
      "\t\t>>> nth(l, 20, \"zebra\")",
      "\t\t'zebra'",
      "",
      "\t\t\"\"\"",
      "\t\treturn next(islice(iterable, n, None), default)",
      "",
      "",
      "def tail(n: int, iterable: Iterable[T]):",
      "\t\t\"\"\"Return an iterator over the last *n* items of *iterable*.",
      "",
      "\t\t>>> t = tail(3, 'ABCDEFG')",
      "\t\t>>> list(t)",
      "\t\t['E', 'F', 'G']",
      "",
      "\t\t\"\"\"",
      "\t\t# If the given iterable has a length, then we can use islice to get its",
      "\t\t# final elements. Note that if the iterable is not actually Iterable,",
      "\t\t# either islice or deque will throw a TypeError. This is why we don't",
      "\t\t# check if it is Iterable.",
      "\t\tif isinstance(iterable, Sized):",
      "\t\t\t\tyield from islice(iterable, max(0, len(iterable) - n), None)",
      "\t\telse:",
      "\t\t\t\tyield from iter(deque(iterable, maxlen=n))",
      "",
      "",
      "def unique(iterable, key=None, reverse=False):",
      "\t\t\"\"\"Yields unique elements in sorted order.",
      "",
      "\t\t>>> list(unique([[1, 2], [3, 4], [1, 2]]))",
      "\t\t[[1, 2], [3, 4]]",
      "",
      "\t\t*key* and *reverse* are passed to :func:`sorted`.",
      "",
      "\t\t>>> list(unique('ABBcCAD', str.casefold))",
      "\t\t['A', 'B', 'c', 'D']",
      "\t\t>>> list(unique('ABBcCAD', str.casefold, reverse=True))",
      "\t\t['D', 'c', 'B', 'A']",
      "",
      "\t\tThe elements in *iterable* need not be hashable, but they must be",
      "\t\tcomparable for sorting to work.",
      "\t\t\"\"\"",
      "\t\treturn _unique_justseen(sorted(iterable, key=key, reverse=reverse), key=key)",
      "",
      "",
      "def _unique_justseen(iterable, key=None):",
      "\t\t\"\"\"Yields elements in order, ignoring serial duplicates",
      "",
      "\t\t>>> list(unique_justseen('AAAABBBCCDAABBB'))",
      "\t\t['A', 'B', 'C', 'D', 'A', 'B']",
      "\t\t>>> list(unique_justseen('ABBCcAD', str.lower))",
      "\t\t['A', 'B', 'C', 'A', 'D']",
      "",
      "\t\t\"\"\"",
      "\t\tif key is None:",
      "\t\t\t\treturn map(operator.itemgetter(0), groupby(iterable))",
      "",
      "\t\treturn map(next, map(operator.itemgetter(1), groupby(iterable, key)))",
      "",
      "",
      "def iter_index(iterable, value, start=0, stop=None):",
      "\t\t\"\"\"Yield the index of each place in *iterable* that *value* occurs,",
      "\t\tbeginning with index *start* and ending before index *stop*.",
      "",
      "",
      "\t\t>>> list(iter_index('AABCADEAF', 'A'))",
      "\t\t[0, 1, 4, 7]",
      "\t\t>>> list(iter_index('AABCADEAF', 'A', 1))\t# start index is inclusive",
      "\t\t[1, 4, 7]",
      "\t\t>>> list(iter_index('AABCADEAF', 'A', 1, 7))\t# stop index is not inclusive",
      "\t\t[1, 4]",
      "",
      "\t\tThe behavior for non-scalar *values* matches the built-in Python types.",
      "",
      "\t\t>>> list(iter_index('ABCDABCD', 'AB'))",
      "\t\t[0, 4]",
      "\t\t>>> list(iter_index([0, 1, 2, 3, 0, 1, 2, 3], [0, 1]))",
      "\t\t[]",
      "\t\t>>> list(iter_index([[0, 1], [2, 3], [0, 1], [2, 3]], [0, 1]))",
      "\t\t[0, 2]",
      "",
      "\t\tSee :func:`locate` for a more general means of finding the indexes",
      "\t\tassociated with particular values.",
      "",
      "\t\t\"\"\"",
      "\t\tseq_index = getattr(iterable, \"index\", None)",
      "\t\tif seq_index is None:",
      "\t\t\t\t# Slow path for general iterables",
      "\t\t\t\tit = islice(iterable, start, stop)",
      "\t\t\t\tfor i, element in enumerate(it, start):",
      "\t\t\t\t\t\tif element is value or element == value:",
      "\t\t\t\t\t\t\t\tyield i",
      "\t\telse:",
      "\t\t\t\t# Fast path for sequences",
      "\t\t\t\tstop = len(iterable) if stop is None else stop",
      "\t\t\t\ti = start - 1",
      "\t\t\t\ttry:",
      "\t\t\t\t\t\twhile True:",
      "\t\t\t\t\t\t\t\tyield (i := seq_index(value, i + 1, stop))",
      "\t\t\t\texcept ValueError:",
      "\t\t\t\t\t\tpass",
      "",
      "",
      "def consume(iterator: Iterable[T], n: Optional[int] = None):",
      "\t\t\"\"\"Advance *iterable* by *n* steps. If *n* is ``None``, consume it",
      "\t\tentirely.",
      "",
      "\t\tEfficiently exhausts an iterator without returning values. Defaults to",
      "\t\tconsuming the whole iterator, but an optional second argument may be",
      "\t\tprovided to limit consumption.",
      "",
      "\t\t\t\t>>> i = (x for x in range(10))",
      "\t\t\t\t>>> next(i)",
      "\t\t\t\t0",
      "\t\t\t\t>>> consume(i, 3)",
      "\t\t\t\t>>> next(i)",
      "\t\t\t\t4",
      "\t\t\t\t>>> consume(i)",
      "\t\t\t\t>>> next(i)",
      "\t\t\t\tTraceback (most recent call last):",
      "\t\t\t\t\tFile \"<stdin>\", line 1, in <module>",
      "\t\t\t\tStopIteration",
      "",
      "\t\tIf the iterator has fewer items remaining than the provided limit, the",
      "\t\twhole iterator will be consumed.",
      "",
      "\t\t\t\t>>> i = (x for x in range(3))",
      "\t\t\t\t>>> consume(i, 5)",
      "\t\t\t\t>>> next(i)",
      "\t\t\t\tTraceback (most recent call last):",
      "\t\t\t\t\tFile \"<stdin>\", line 1, in <module>",
      "\t\t\t\tStopIteration",
      "",
      "\t\t\"\"\"",
      "\t\t# Use functions that consume iterators at C speed.",
      "\t\tif n is None:",
      "\t\t\t\t# feed the entire iterator into a zero-length deque",
      "\t\t\t\tdeque(iterator, maxlen=0)",
      "\t\telse:",
      "\t\t\t\t# advance to the empty slice starting at position n",
      "\t\t\t\tnext(islice(iterator, n, n), None)"
    ],
    "description": "more-itertools-basic"
  },
  "more-itertools-combinatoric": {
    "scope": "python",
    "prefix": [
      "more-itertools-combinatoric",
      "distinct_permutations",
      "distinct_combinations",
      "circular_shifts",
      "partitions",
      "set_partitions",
      "powerset",
      "powerset_of_sets",
      "product_index",
      "combination_index",
      "permutation_index",
      "combination_with_replacement_index",
      "random_product",
      "random_permutation",
      "random_combination",
      "random_combination_with_replacement",
      "nth_product",
      "nth_permutation",
      "nth_combination",
      "nth_combination_with_replacement"
    ],
    "body": [
      "import math",
      "from random import choice, randrange, sample",
      "from sys import hexversion",
      "from collections import defaultdict, deque",
      "from functools import partial, reduce",
      "from itertools import chain, combinations, cycle, repeat, starmap, zip_longest",
      "from operator import itemgetter, mul",
      "from typing import Any, Iterable, List, Optional, Sequence, TypeVar",
      "",
      "T = TypeVar(\"T\")",
      "",
      "_marker: Any = object()",
      "",
      "",
      "def distinct_permutations(iterable: Iterable[T], r: Optional[int] = None):",
      "\t\t\"\"\"Yield successive distinct permutations of the elements in *iterable*.",
      "",
      "\t\t\t\t>>> sorted(distinct_permutations([1, 0, 1]))",
      "\t\t\t\t[(0, 1, 1), (1, 0, 1), (1, 1, 0)]",
      "",
      "\t\tEquivalent to yielding from ``set(permutations(iterable))``, except",
      "\t\tduplicates are not generated and thrown away. For larger input sequences",
      "\t\tthis is much more efficient.",
      "",
      "\t\tDuplicate permutations arise when there are duplicated elements in the",
      "\t\tinput iterable. The number of items returned is",
      "\t\t`n! / (x_1! * x_2! * ... * x_n!)`, where `n` is the total number of",
      "\t\titems input, and each `x_i` is the count of a distinct item in the input",
      "\t\tsequence.",
      "",
      "\t\tIf *r* is given, only the *r*-length permutations are yielded.",
      "",
      "\t\t\t\t>>> sorted(distinct_permutations([1, 0, 1], r=2))",
      "\t\t\t\t[(0, 1), (1, 0), (1, 1)]",
      "\t\t\t\t>>> sorted(distinct_permutations(range(3), r=2))",
      "\t\t\t\t[(0, 1), (0, 2), (1, 0), (1, 2), (2, 0), (2, 1)]",
      "",
      "\t\t*iterable* need not be sortable, but note that using equal (``x == y``)",
      "\t\tbut non-identical (``id(x) != id(y)``) elements may produce surprising",
      "\t\tbehavior. For example, ``1`` and ``True`` are equal but non-identical:",
      "",
      "\t\t\t\t>>> list(distinct_permutations([1, True, '3']))\t# doctest: +SKIP",
      "\t\t\t\t[",
      "\t\t\t\t\t\t(1, True, '3'),",
      "\t\t\t\t\t\t(1, '3', True),",
      "\t\t\t\t\t\t('3', 1, True)",
      "\t\t\t\t]",
      "\t\t\t\t>>> list(distinct_permutations([1, 2, '3']))\t# doctest: +SKIP",
      "\t\t\t\t[",
      "\t\t\t\t\t\t(1, 2, '3'),",
      "\t\t\t\t\t\t(1, '3', 2),",
      "\t\t\t\t\t\t(2, 1, '3'),",
      "\t\t\t\t\t\t(2, '3', 1),",
      "\t\t\t\t\t\t('3', 1, 2),",
      "\t\t\t\t\t\t('3', 2, 1)",
      "\t\t\t\t]",
      "\t\t\"\"\"",
      "",
      "\t\t# Algorithm: https://w.wiki/Qai",
      "\t\tdef _full(A):",
      "\t\t\t\twhile True:",
      "\t\t\t\t\t\t# Yield the permutation we have",
      "\t\t\t\t\t\tyield tuple(A)",
      "",
      "\t\t\t\t\t\t# Find the largest index i such that A[i] < A[i + 1]",
      "\t\t\t\t\t\tfor i in range(size - 2, -1, -1):",
      "\t\t\t\t\t\t\t\tif A[i] < A[i + 1]:",
      "\t\t\t\t\t\t\t\t\t\tbreak",
      "\t\t\t\t\t\t#\tIf no such index exists, this permutation is the last one",
      "\t\t\t\t\t\telse:",
      "\t\t\t\t\t\t\t\treturn",
      "",
      "\t\t\t\t\t\t# Find the largest index j greater than j such that A[i] < A[j]",
      "\t\t\t\t\t\tfor j in range(size - 1, i, -1):",
      "\t\t\t\t\t\t\t\tif A[i] < A[j]:",
      "\t\t\t\t\t\t\t\t\t\tbreak",
      "",
      "\t\t\t\t\t\t# Swap the value of A[i] with that of A[j], then reverse the",
      "\t\t\t\t\t\t# sequence from A[i + 1] to form the new permutation",
      "\t\t\t\t\t\tA[i], A[j] = A[j], A[i]\t# type: ignore",
      "\t\t\t\t\t\tA[i + 1 :] = A[: i - size : -1]\t# A[i + 1:][::-1]",
      "",
      "\t\t# Algorithm: modified from the above",
      "\t\tdef _partial(A, r):",
      "\t\t\t\t# Split A into the first r items and the last r items",
      "\t\t\t\thead, tail = A[:r], A[r:]",
      "\t\t\t\tright_head_indexes = range(r - 1, -1, -1)",
      "\t\t\t\tleft_tail_indexes = range(len(tail))",
      "",
      "\t\t\t\twhile True:",
      "\t\t\t\t\t\t# Yield the permutation we have",
      "\t\t\t\t\t\tyield tuple(head)",
      "",
      "\t\t\t\t\t\t# Starting from the right, find the first index of the head with",
      "\t\t\t\t\t\t# value smaller than the maximum value of the tail - call it i.",
      "\t\t\t\t\t\tpivot = tail[-1]",
      "\t\t\t\t\t\tfor i in right_head_indexes:",
      "\t\t\t\t\t\t\t\tif head[i] < pivot:",
      "\t\t\t\t\t\t\t\t\t\tbreak",
      "\t\t\t\t\t\t\t\tpivot = head[i]",
      "\t\t\t\t\t\telse:",
      "\t\t\t\t\t\t\t\treturn",
      "",
      "\t\t\t\t\t\t# Starting from the left, find the first value of the tail",
      "\t\t\t\t\t\t# with a value greater than head[i] and swap.",
      "\t\t\t\t\t\tfor j in left_tail_indexes:",
      "\t\t\t\t\t\t\t\tif tail[j] > head[i]:",
      "\t\t\t\t\t\t\t\t\t\thead[i], tail[j] = tail[j], head[i]",
      "\t\t\t\t\t\t\t\t\t\tbreak",
      "\t\t\t\t\t\t# If we didn't find one, start from the right and find the first",
      "\t\t\t\t\t\t# index of the head with a value greater than head[i] and swap.",
      "\t\t\t\t\t\telse:",
      "\t\t\t\t\t\t\t\tfor j in right_head_indexes:",
      "\t\t\t\t\t\t\t\t\t\tif head[j] > head[i]:",
      "\t\t\t\t\t\t\t\t\t\t\t\thead[i], head[j] = head[j], head[i]",
      "\t\t\t\t\t\t\t\t\t\t\t\tbreak",
      "",
      "\t\t\t\t\t\t# Reverse head[i + 1:] and swap it with tail[:r - (i + 1)]",
      "\t\t\t\t\t\ttail += head[: i - r : -1]\t# head[i + 1:][::-1]",
      "\t\t\t\t\t\ti += 1",
      "\t\t\t\t\t\thead[i:], tail[:] = tail[: r - i], tail[r - i :]",
      "",
      "\t\titems = list(iterable)",
      "",
      "\t\ttry:",
      "\t\t\t\titems.sort()\t# type: ignore",
      "\t\t\t\tsortable = True",
      "\t\texcept TypeError:",
      "\t\t\t\tsortable = False",
      "",
      "\t\t\t\tindices_dict = defaultdict(list)",
      "",
      "\t\t\t\tfor item in items:",
      "\t\t\t\t\t\tindices_dict[items.index(item)].append(item)",
      "",
      "\t\t\t\tindices = [items.index(item) for item in items]",
      "\t\t\t\tindices.sort()",
      "",
      "\t\t\t\tequivalent_items = {k: cycle(v) for k, v in indices_dict.items()}",
      "",
      "\t\t\t\tdef permuted_items(permuted_indices):",
      "\t\t\t\t\t\treturn tuple(next(equivalent_items[index]) for index in permuted_indices)",
      "",
      "\t\tsize = len(items)",
      "\t\tif r is None:",
      "\t\t\t\tr = size",
      "",
      "\t\t# functools.partial(_partial, ... )",
      "\t\talgorithm = _full if (r == size) else partial(_partial, r=r)",
      "",
      "\t\tif 0 < r <= size:",
      "\t\t\t\tif sortable:",
      "\t\t\t\t\t\treturn algorithm(items)",
      "\t\t\t\telse:",
      "\t\t\t\t\t\treturn (permuted_items(permuted_indices) for permuted_indices in algorithm(indices))\t# type: ignore",
      "",
      "\t\treturn iter(() if r else ((),))",
      "",
      "",
      "def distinct_combinations(iterable: Iterable[T], r: int):",
      "\t\t\"\"\"Yield the distinct combinations of *r* items taken from *iterable*.",
      "",
      "\t\t\t\t>>> list(distinct_combinations([0, 0, 1], 2))",
      "\t\t\t\t[(0, 0), (0, 1)]",
      "",
      "\t\tEquivalent to ``set(combinations(iterable))``, except duplicates are not",
      "\t\tgenerated and thrown away. For larger input sequences this is much more",
      "\t\tefficient.",
      "",
      "\t\t\"\"\"",
      "\t\tif r < 0:",
      "\t\t\t\traise ValueError(\"r must be non-negative\")",
      "\t\telif r == 0:",
      "\t\t\t\tyield ()",
      "\t\t\t\treturn",
      "\t\tpool = tuple(iterable)",
      "\t\tgenerators = [_unique_everseen(enumerate(pool), key=itemgetter(1))]",
      "\t\tcurrent_combo = [None] * r",
      "\t\tlevel = 0",
      "\t\twhile generators:",
      "\t\t\t\ttry:",
      "\t\t\t\t\t\tcur_idx, p = next(generators[-1])",
      "\t\t\t\texcept StopIteration:",
      "\t\t\t\t\t\tgenerators.pop()",
      "\t\t\t\t\t\tlevel -= 1",
      "\t\t\t\t\t\tcontinue",
      "\t\t\t\tcurrent_combo[level] = p",
      "\t\t\t\tif level + 1 == r:",
      "\t\t\t\t\t\tyield tuple(current_combo)",
      "\t\t\t\telse:",
      "\t\t\t\t\t\tgenerators.append(",
      "\t\t\t\t\t\t\t\t_unique_everseen(",
      "\t\t\t\t\t\t\t\t\t\tenumerate(pool[cur_idx + 1 :], cur_idx + 1),",
      "\t\t\t\t\t\t\t\t\t\tkey=itemgetter(1),",
      "\t\t\t\t\t\t\t\t)",
      "\t\t\t\t\t\t)",
      "\t\t\t\t\t\tlevel += 1",
      "",
      "",
      "def _unique_everseen(iterable, key=None):",
      "\t\t\"\"\"",
      "\t\tYield unique elements, preserving order.",
      "",
      "\t\t\t\t>>> list(unique_everseen('AAAABBBCCDAABBB'))",
      "\t\t\t\t['A', 'B', 'C', 'D']",
      "\t\t\t\t>>> list(unique_everseen('ABBCcAD', str.lower))",
      "\t\t\t\t['A', 'B', 'C', 'D']",
      "",
      "\t\tSequences with a mix of hashable and unhashable items can be used.",
      "\t\tThe function will be slower (i.e., `O(n^2)`) for unhashable items.",
      "",
      "\t\tRemember that ``list`` objects are unhashable - you can use the *key*",
      "\t\tparameter to transform the list to a tuple (which is hashable) to",
      "\t\tavoid a slowdown.",
      "",
      "\t\t\t\t>>> iterable = ([1, 2], [2, 3], [1, 2])",
      "\t\t\t\t>>> list(unique_everseen(iterable))\t# Slow",
      "\t\t\t\t[[1, 2], [2, 3]]",
      "\t\t\t\t>>> list(unique_everseen(iterable, key=tuple))\t# Faster",
      "\t\t\t\t[[1, 2], [2, 3]]",
      "",
      "\t\tSimilarly, you may want to convert unhashable ``set`` objects with",
      "\t\t``key=frozenset``. For ``dict`` objects,",
      "\t\t``key=lambda x: frozenset(x.items())`` can be used.",
      "",
      "\t\t\"\"\"",
      "\t\tseenset = set()",
      "\t\tseenset_add = seenset.add",
      "\t\tseenlist = []",
      "\t\tseenlist_add = seenlist.append",
      "\t\tuse_key = key is not None",
      "",
      "\t\tfor element in iterable:",
      "\t\t\t\tk = key(element) if use_key else element",
      "\t\t\t\ttry:",
      "\t\t\t\t\t\tif k not in seenset:",
      "\t\t\t\t\t\t\t\tseenset_add(k)",
      "\t\t\t\t\t\t\t\tyield element",
      "\t\t\t\texcept TypeError:",
      "\t\t\t\t\t\tif k not in seenlist:",
      "\t\t\t\t\t\t\t\tseenlist_add(k)",
      "\t\t\t\t\t\t\t\tyield element",
      "",
      "",
      "def circular_shifts(iterable: Iterable[T], steps: int = 1):",
      "\t\t\"\"\"Yield the circular shifts of *iterable*.",
      "",
      "\t\t>>> list(circular_shifts(range(4)))",
      "\t\t[(0, 1, 2, 3), (1, 2, 3, 0), (2, 3, 0, 1), (3, 0, 1, 2)]",
      "",
      "\t\tSet *steps* to the number of places to rotate to the left",
      "\t\t(or to the right if negative).\tDefaults to 1.",
      "",
      "\t\t>>> list(circular_shifts(range(4), 2))",
      "\t\t[(0, 1, 2, 3), (2, 3, 0, 1)]",
      "",
      "\t\t>>> list(circular_shifts(range(4), -1))",
      "\t\t[(0, 1, 2, 3), (3, 0, 1, 2), (2, 3, 0, 1), (1, 2, 3, 0)]",
      "",
      "\t\t\"\"\"",
      "\t\tbuffer = deque(iterable)",
      "\t\tif steps == 0:",
      "\t\t\t\traise ValueError(\"Steps should be a non-zero integer\")",
      "",
      "\t\tbuffer.rotate(steps)",
      "\t\tsteps = -steps",
      "\t\tn = len(buffer)",
      "\t\tn //= math.gcd(n, steps)",
      "",
      "\t\tfor _ in repeat(None, n):",
      "\t\t\t\tbuffer.rotate(steps)",
      "\t\t\t\tyield tuple(buffer)",
      "",
      "",
      "def partitions(iterable: Iterable[T]):",
      "\t\t\"\"\"Yield all possible order-preserving partitions of *iterable*.",
      "",
      "\t\t>>> iterable = 'abc'",
      "\t\t>>> for part in partitions(iterable):",
      "\t\t...\t\t print([''.join(p) for p in part])",
      "\t\t['abc']",
      "\t\t['a', 'bc']",
      "\t\t['ab', 'c']",
      "\t\t['a', 'b', 'c']",
      "",
      "\t\tThis is unrelated to :func:`partition`.",
      "",
      "\t\t\"\"\"",
      "\t\tsequence = list(iterable)",
      "\t\tn = len(sequence)",
      "\t\tfor i in powerset(range(1, n)):",
      "\t\t\t\tyield [sequence[i:j] for i, j in zip((0,) + i, i + (n,))]",
      "",
      "",
      "def set_partitions(",
      "\t\titerable: Iterable[T],",
      "\t\tk: Optional[int] = None,",
      "):",
      "\t\t\"\"\"",
      "\t\tYield the set partitions of *iterable* into *k* parts. Set partitions are",
      "\t\tnot order-preserving.",
      "",
      "\t\t>>> iterable = 'abc'",
      "\t\t>>> for part in set_partitions(iterable, 2):",
      "\t\t...\t\t print([''.join(p) for p in part])",
      "\t\t['a', 'bc']",
      "\t\t['ab', 'c']",
      "\t\t['b', 'ac']",
      "",
      "",
      "\t\tIf *k* is not given, every set partition is generated.",
      "",
      "\t\t>>> iterable = 'abc'",
      "\t\t>>> for part in set_partitions(iterable):",
      "\t\t...\t\t print([''.join(p) for p in part])",
      "\t\t['abc']",
      "\t\t['a', 'bc']",
      "\t\t['ab', 'c']",
      "\t\t['b', 'ac']",
      "\t\t['a', 'b', 'c']",
      "",
      "\t\t\"\"\"",
      "\t\tL = list(iterable)",
      "\t\tn = len(L)",
      "\t\tif k is not None:",
      "\t\t\t\tif k < 1:",
      "\t\t\t\t\t\traise ValueError(\"Can't partition in a negative or zero number of groups\")",
      "\t\t\t\telif k > n:",
      "\t\t\t\t\t\treturn",
      "",
      "\t\tdef set_partitions_helper(L, k):",
      "\t\t\t\tn = len(L)",
      "\t\t\t\tif k == 1:",
      "\t\t\t\t\t\tyield [L]",
      "\t\t\t\telif n == k:",
      "\t\t\t\t\t\tyield [[s] for s in L]",
      "\t\t\t\telse:",
      "\t\t\t\t\t\te, *M = L",
      "\t\t\t\t\t\tfor p in set_partitions_helper(M, k - 1):",
      "\t\t\t\t\t\t\t\tyield [[e], *p]",
      "\t\t\t\t\t\tfor p in set_partitions_helper(M, k):",
      "\t\t\t\t\t\t\t\tfor i in range(len(p)):",
      "\t\t\t\t\t\t\t\t\t\tyield p[:i] + [[e] + p[i]] + p[i + 1 :]",
      "",
      "\t\tif k is None:",
      "\t\t\t\tfor k in range(1, n + 1):",
      "\t\t\t\t\t\tyield from set_partitions_helper(L, k)",
      "\t\telse:",
      "\t\t\t\tyield from set_partitions_helper(L, k)",
      "",
      "",
      "def set_partitions_all(arr: List[T]):",
      "\t\tif len(arr) == 1:",
      "\t\t\t\tyield [arr]",
      "\t\t\t\treturn",
      "",
      "\t\tfirst = arr[0]",
      "\t\tfor smaller in set_partitions_all(arr[1:]):",
      "\t\t\t\t# insert `first` in each of the subpartition's subsets",
      "\t\t\t\tfor n, subset in enumerate(smaller):",
      "\t\t\t\t\t\tyield smaller[:n] + [[first] + subset] + smaller[n + 1 :]",
      "\t\t\t\t# put `first` in its own subset",
      "\t\t\t\tyield [[first]] + smaller",
      "",
      "",
      "def powerset(iterable: Iterable[T]):",
      "\t\t\"\"\"Yields all possible subsets of the iterable.",
      "",
      "\t\t\t\t>>> list(powerset([1, 2, 3]))",
      "\t\t\t\t[(), (1,), (2,), (3,), (1, 2), (1, 3), (2, 3), (1, 2, 3)]",
      "",
      "\t\t:func:`powerset` will operate on iterables that aren't :class:`set`",
      "\t\tinstances, so repeated elements in the input will produce repeated elements",
      "\t\tin the output.",
      "",
      "\t\t\t\t>>> seq = [1, 1, 0]",
      "\t\t\t\t>>> list(powerset(seq))",
      "\t\t\t\t[(), (1,), (1,), (0,), (1, 1), (1, 0), (1, 0), (1, 1, 0)]",
      "",
      "\t\tFor a variant that efficiently yields actual :class:`set` instances, see",
      "\t\t:func:`powerset_of_sets`.",
      "\t\t\"\"\"",
      "\t\ts = list(iterable)",
      "\t\treturn chain.from_iterable(combinations(s, r) for r in range(len(s) + 1))",
      "",
      "",
      "def powerset_of_sets(iterable: Iterable[T]):",
      "\t\t\"\"\"Yields all possible subsets of the iterable.",
      "",
      "\t\t\t\t>>> list(powerset_of_sets([1, 2, 3]))\t# doctest: +SKIP",
      "\t\t\t\t[set(), {1}, {2}, {3}, {1, 2}, {1, 3}, {2, 3}, {1, 2, 3}]",
      "\t\t\t\t>>> list(powerset_of_sets([1, 1, 0]))\t# doctest: +SKIP",
      "\t\t\t\t[set(), {1}, {0}, {0, 1}]",
      "",
      "\t\t:func:`powerset_of_sets` takes care to minimize the number",
      "\t\tof hash operations performed.",
      "\t\t\"\"\"",
      "\t\tsets = tuple(map(set, dict.fromkeys(map(frozenset, zip(iterable)))))",
      "\t\tfor r in range(len(sets) + 1):",
      "\t\t\t\tyield from starmap(set().union, combinations(sets, r))",
      "",
      "",
      "def product_index(element, *args):",
      "\t\t\"\"\"Equivalent to ``list(product(*args)).index(element)``",
      "",
      "\t\tThe products of *args* can be ordered lexicographically.",
      "\t\t:func:`product_index` computes the first index of *element* without",
      "\t\tcomputing the previous products.",
      "",
      "\t\t\t\t>>> product_index([8, 2], range(10), range(5))",
      "\t\t\t\t42",
      "",
      "\t\t``ValueError`` will be raised if the given *element* isn't in the product",
      "\t\tof *args*.",
      "\t\t\"\"\"",
      "\t\tindex = 0",
      "",
      "\t\tfor x, pool in zip_longest(element, args, fillvalue=_marker):",
      "\t\t\t\tif x is _marker or pool is _marker:",
      "\t\t\t\t\t\traise ValueError(\"element is not a product of args\")",
      "",
      "\t\t\t\tpool = tuple(pool)",
      "\t\t\t\tindex = index * len(pool) + pool.index(x)",
      "",
      "\t\treturn index",
      "",
      "",
      "def combination_index(element, iterable):",
      "\t\t\"\"\"Equivalent to ``list(combinations(iterable, r)).index(element)``",
      "",
      "\t\tThe subsequences of *iterable* that are of length *r* can be ordered",
      "\t\tlexicographically. :func:`combination_index` computes the index of the",
      "\t\tfirst *element*, without computing the previous combinations.",
      "",
      "\t\t\t\t>>> combination_index('adf', 'abcdefg')",
      "\t\t\t\t10",
      "",
      "\t\t``ValueError`` will be raised if the given *element* isn't one of the",
      "\t\tcombinations of *iterable*.",
      "\t\t\"\"\"",
      "\t\telement = enumerate(element)",
      "\t\tk, y = next(element, (None, None))",
      "\t\tif k is None:",
      "\t\t\t\treturn 0",
      "",
      "\t\tindexes = []",
      "\t\tpool = enumerate(iterable)",
      "\t\tfor n, x in pool:",
      "\t\t\t\tif x == y:",
      "\t\t\t\t\t\tindexes.append(n)",
      "\t\t\t\t\t\ttmp, y = next(element, (None, None))",
      "\t\t\t\t\t\tif tmp is None:",
      "\t\t\t\t\t\t\t\tbreak",
      "\t\t\t\t\t\telse:",
      "\t\t\t\t\t\t\t\tk = tmp",
      "\t\telse:",
      "\t\t\t\traise ValueError(\"element is not a combination of iterable\")",
      "",
      "\t\tn, _ = _last(pool, default=(n, None))",
      "",
      "\t\t# Python versions below 3.8 don't have math.comb",
      "\t\tindex = 1",
      "\t\tfor i, j in enumerate(reversed(indexes), start=1):",
      "\t\t\t\tj = n - j",
      "\t\t\t\tif i <= j:",
      "\t\t\t\t\t\tindex += math.comb(j, i)",
      "",
      "\t\treturn math.comb(n + 1, k + 1) - index",
      "",
      "",
      "def _last(iterable, default=_marker):",
      "\t\t\"\"\"Return the last item of *iterable*, or *default* if *iterable* is",
      "\t\tempty.",
      "",
      "\t\t\t\t>>> last([0, 1, 2, 3])",
      "\t\t\t\t3",
      "\t\t\t\t>>> last([], 'some default')",
      "\t\t\t\t'some default'",
      "",
      "\t\tIf *default* is not provided and there are no items in the iterable,",
      "\t\traise ``ValueError``.",
      "\t\t\"\"\"",
      "\t\ttry:",
      "\t\t\t\tif isinstance(iterable, Sequence):",
      "\t\t\t\t\t\treturn iterable[-1]",
      "\t\t\t\t# Work around https://bugs.python.org/issue38525",
      "\t\t\t\telif hasattr(iterable, \"__reversed__\") and (hexversion != 0x030800F0):",
      "\t\t\t\t\t\treturn next(reversed(iterable))",
      "\t\t\t\telse:",
      "\t\t\t\t\t\treturn deque(iterable, maxlen=1)[-1]",
      "\t\texcept (IndexError, TypeError, StopIteration):",
      "\t\t\t\tif default is _marker:",
      "\t\t\t\t\t\traise ValueError(",
      "\t\t\t\t\t\t\t\t\"last() was called on an empty iterable, and no default was \" \"provided.\"",
      "\t\t\t\t\t\t)",
      "\t\t\t\treturn default",
      "",
      "",
      "def permutation_index(element, iterable):",
      "\t\t\"\"\"Equivalent to ``list(permutations(iterable, r)).index(element)```",
      "",
      "\t\tThe subsequences of *iterable* that are of length *r* where order is",
      "\t\timportant can be ordered lexicographically. :func:`permutation_index`",
      "\t\tcomputes the index of the first *element* directly, without computing",
      "\t\tthe previous permutations.",
      "",
      "\t\t\t\t>>> permutation_index([1, 3, 2], range(5))",
      "\t\t\t\t19",
      "",
      "\t\t``ValueError`` will be raised if the given *element* isn't one of the",
      "\t\tpermutations of *iterable*.",
      "\t\t\"\"\"",
      "\t\tindex = 0",
      "\t\tpool = list(iterable)",
      "\t\tfor i, x in zip(range(len(pool), -1, -1), element):",
      "\t\t\t\tr = pool.index(x)",
      "\t\t\t\tindex = index * i + r",
      "\t\t\t\tdel pool[r]",
      "",
      "\t\treturn index",
      "",
      "",
      "def combination_with_replacement_index(element, iterable):",
      "\t\t\"\"\"Equivalent to",
      "\t\t``list(combinations_with_replacement(iterable, r)).index(element)``",
      "",
      "\t\tThe subsequences with repetition of *iterable* that are of length *r* can",
      "\t\tbe ordered lexicographically. :func:`combination_with_replacement_index`",
      "\t\tcomputes the index of the first *element*, without computing the previous",
      "\t\tcombinations with replacement.",
      "",
      "\t\t\t\t>>> combination_with_replacement_index('adf', 'abcdefg')",
      "\t\t\t\t20",
      "",
      "\t\t``ValueError`` will be raised if the given *element* isn't one of the",
      "\t\tcombinations with replacement of *iterable*.",
      "\t\t\"\"\"",
      "\t\telement = tuple(element)",
      "\t\tl = len(element)",
      "\t\telement = enumerate(element)",
      "",
      "\t\tk, y = next(element, (None, None))",
      "\t\tif k is None:",
      "\t\t\t\treturn 0",
      "",
      "\t\tindexes = []",
      "\t\tpool = tuple(iterable)",
      "\t\tfor n, x in enumerate(pool):",
      "\t\t\t\twhile x == y:",
      "\t\t\t\t\t\tindexes.append(n)",
      "\t\t\t\t\t\ttmp, y = next(element, (None, None))",
      "\t\t\t\t\t\tif tmp is None:",
      "\t\t\t\t\t\t\t\tbreak",
      "\t\t\t\t\t\telse:",
      "\t\t\t\t\t\t\t\tk = tmp",
      "\t\t\t\tif y is None:",
      "\t\t\t\t\t\tbreak",
      "\t\telse:",
      "\t\t\t\traise ValueError(\"element is not a combination with replacement of iterable\")",
      "",
      "\t\tn = len(pool)",
      "\t\toccupations = [0] * n",
      "\t\tfor p in indexes:",
      "\t\t\t\toccupations[p] += 1",
      "",
      "\t\tindex = 0",
      "\t\tcumulative_sum = 0",
      "\t\tfor k in range(1, n):",
      "\t\t\t\tcumulative_sum += occupations[k - 1]",
      "\t\t\t\tj = l + n - 1 - k - cumulative_sum",
      "\t\t\t\ti = n - k",
      "\t\t\t\tif i <= j:",
      "\t\t\t\t\t\tindex += math.comb(j, i)",
      "",
      "\t\treturn index",
      "",
      "",
      "def random_product(*args, repeat=1):",
      "\t\t\"\"\"Draw an item at random from each of the input iterables.",
      "",
      "\t\t\t\t>>> random_product('abc', range(4), 'XYZ')\t# doctest:+SKIP",
      "\t\t\t\t('c', 3, 'Z')",
      "",
      "\t\tIf *repeat* is provided as a keyword argument, that many items will be",
      "\t\tdrawn from each iterable.",
      "",
      "\t\t\t\t>>> random_product('abcd', range(4), repeat=2)\t# doctest:+SKIP",
      "\t\t\t\t('a', 2, 'd', 3)",
      "",
      "\t\tThis equivalent to taking a random selection from",
      "\t\t``itertools.product(*args, **kwarg)``.",
      "",
      "\t\t\"\"\"",
      "\t\tpools = [tuple(pool) for pool in args] * repeat",
      "\t\treturn tuple(choice(pool) for pool in pools)",
      "",
      "",
      "def random_permutation(iterable, r=None):",
      "\t\t\"\"\"Return a random *r* length permutation of the elements in *iterable*.",
      "",
      "\t\tIf *r* is not specified or is ``None``, then *r* defaults to the length of",
      "\t\t*iterable*.",
      "",
      "\t\t\t\t>>> random_permutation(range(5))\t# doctest:+SKIP",
      "\t\t\t\t(3, 4, 0, 1, 2)",
      "",
      "\t\tThis equivalent to taking a random selection from",
      "\t\t``itertools.permutations(iterable, r)``.",
      "",
      "\t\t\"\"\"",
      "\t\tpool = tuple(iterable)",
      "\t\tr = len(pool) if r is None else r",
      "\t\treturn tuple(sample(pool, r))",
      "",
      "",
      "def random_combination(iterable, r):",
      "\t\t\"\"\"Return a random *r* length subsequence of the elements in *iterable*.",
      "",
      "\t\t\t\t>>> random_combination(range(5), 3)\t# doctest:+SKIP",
      "\t\t\t\t(2, 3, 4)",
      "",
      "\t\tThis equivalent to taking a random selection from",
      "\t\t``itertools.combinations(iterable, r)``.",
      "",
      "\t\t\"\"\"",
      "\t\tpool = tuple(iterable)",
      "\t\tn = len(pool)",
      "\t\tindices = sorted(sample(range(n), r))",
      "\t\treturn tuple(pool[i] for i in indices)",
      "",
      "",
      "def random_combination_with_replacement(iterable, r):",
      "\t\t\"\"\"Return a random *r* length subsequence of elements in *iterable*,",
      "\t\tallowing individual elements to be repeated.",
      "",
      "\t\t\t\t>>> random_combination_with_replacement(range(3), 5) # doctest:+SKIP",
      "\t\t\t\t(0, 0, 1, 2, 2)",
      "",
      "\t\tThis equivalent to taking a random selection from",
      "\t\t``itertools.combinations_with_replacement(iterable, r)``.",
      "",
      "\t\t\"\"\"",
      "\t\tpool = tuple(iterable)",
      "\t\tn = len(pool)",
      "\t\tindices = sorted(randrange(n) for _ in range(r))",
      "\t\treturn tuple(pool[i] for i in indices)",
      "",
      "",
      "def nth_product(index, *args):",
      "\t\t\"\"\"Equivalent to ``list(product(*args))[index]``.",
      "",
      "\t\tThe products of *args* can be ordered lexicographically.",
      "\t\t:func:`nth_product` computes the product at sort position *index* without",
      "\t\tcomputing the previous products.",
      "",
      "\t\t\t\t>>> nth_product(8, range(2), range(2), range(2), range(2))",
      "\t\t\t\t(1, 0, 0, 0)",
      "",
      "\t\t``IndexError`` will be raised if the given *index* is invalid.",
      "\t\t\"\"\"",
      "\t\tpools = list(map(tuple, reversed(args)))",
      "\t\tns = list(map(len, pools))",
      "",
      "\t\tc = reduce(mul, ns)",
      "",
      "\t\tif index < 0:",
      "\t\t\t\tindex += c",
      "",
      "\t\tif not 0 <= index < c:",
      "\t\t\t\traise IndexError",
      "",
      "\t\tresult = []",
      "\t\tfor pool, n in zip(pools, ns):",
      "\t\t\t\tresult.append(pool[index % n])",
      "\t\t\t\tindex //= n",
      "",
      "\t\treturn tuple(reversed(result))",
      "",
      "",
      "def nth_permutation(iterable: Iterable[T], r: Optional[int], index: int):",
      "\t\t\"\"\"Equivalent to ``list(permutations(iterable, r))[index]```",
      "",
      "\t\tThe subsequences of *iterable* that are of length *r* where order is",
      "\t\timportant can be ordered lexicographically. :func:`nth_permutation`",
      "\t\tcomputes the subsequence at sort position *index* directly, without",
      "\t\tcomputing the previous subsequences.",
      "",
      "\t\t\t\t>>> nth_permutation('ghijk', 2, 5)",
      "\t\t\t\t('h', 'i')",
      "",
      "\t\t``ValueError`` will be raised If *r* is negative or greater than the length",
      "\t\tof *iterable*.",
      "\t\t``IndexError`` will be raised if the given *index* is invalid.",
      "\t\t\"\"\"",
      "\t\tpool = list(iterable)",
      "\t\tn = len(pool)",
      "",
      "\t\tif r is None or r == n:",
      "\t\t\t\tr, c = n, math.factorial(n)",
      "\t\telif not 0 <= r < n:",
      "\t\t\t\traise ValueError",
      "\t\telse:",
      "\t\t\t\tc = math.perm(n, r)",
      "\t\tassert c > 0\t# factortial(n)>0, and r<n so perm(n,r) is never zero",
      "",
      "\t\tif index < 0:",
      "\t\t\t\tindex += c",
      "",
      "\t\tif not 0 <= index < c:",
      "\t\t\t\traise IndexError",
      "",
      "\t\tresult = [0] * r",
      "\t\tq = index * math.factorial(n) // c if r < n else index",
      "\t\tfor d in range(1, n + 1):",
      "\t\t\t\tq, i = divmod(q, d)",
      "\t\t\t\tif 0 <= n - d < r:",
      "\t\t\t\t\t\tresult[n - d] = i",
      "\t\t\t\tif q == 0:",
      "\t\t\t\t\t\tbreak",
      "",
      "\t\treturn tuple(map(pool.pop, result))",
      "",
      "",
      "def nth_combination(iterable: Iterable[T], r: int, index: int):",
      "\t\t\"\"\"Equivalent to ``list(combinations(iterable, r))[index]``.",
      "",
      "\t\tThe subsequences of *iterable* that are of length *r* can be ordered",
      "\t\tlexicographically. :func:`nth_combination` computes the subsequence at",
      "\t\tsort position *index* directly, without computing the previous",
      "\t\tsubsequences.",
      "",
      "\t\t\t\t>>> nth_combination(range(5), 3, 5)",
      "\t\t\t\t(0, 3, 4)",
      "",
      "\t\t``ValueError`` will be raised If *r* is negative or greater than the length",
      "\t\tof *iterable*.",
      "\t\t``IndexError`` will be raised if the given *index* is invalid.",
      "\t\t\"\"\"",
      "\t\tpool = tuple(iterable)",
      "\t\tn = len(pool)",
      "\t\tif (r < 0) or (r > n):",
      "\t\t\t\traise ValueError",
      "",
      "\t\tc = 1",
      "\t\tk = min(r, n - r)",
      "\t\tfor i in range(1, k + 1):",
      "\t\t\t\tc = c * (n - k + i) // i",
      "",
      "\t\tif index < 0:",
      "\t\t\t\tindex += c",
      "",
      "\t\tif (index < 0) or (index >= c):",
      "\t\t\t\traise IndexError",
      "",
      "\t\tresult = []",
      "\t\twhile r:",
      "\t\t\t\tc, n, r = c * r // n, n - 1, r - 1",
      "\t\t\t\twhile index >= c:",
      "\t\t\t\t\t\tindex -= c",
      "\t\t\t\t\t\tc, n = c * (n - r) // n, n - 1",
      "\t\t\t\tresult.append(pool[-1 - n])",
      "",
      "\t\treturn tuple(result)",
      "",
      "",
      "def nth_combination_with_replacement(iterable: Iterable[T], r: int, index: int):",
      "\t\t\"\"\"Equivalent to",
      "\t\t``list(combinations_with_replacement(iterable, r))[index]``.",
      "",
      "",
      "\t\tThe subsequences with repetition of *iterable* that are of length *r* can",
      "\t\tbe ordered lexicographically. :func:`nth_combination_with_replacement`",
      "\t\tcomputes the subsequence at sort position *index* directly, without",
      "\t\tcomputing the previous subsequences with replacement.",
      "",
      "\t\t\t\t>>> nth_combination_with_replacement(range(5), 3, 5)",
      "\t\t\t\t(0, 1, 1)",
      "",
      "\t\t``ValueError`` will be raised If *r* is negative or greater than the length",
      "\t\tof *iterable*.",
      "\t\t``IndexError`` will be raised if the given *index* is invalid.",
      "\t\t\"\"\"",
      "\t\tpool = tuple(iterable)",
      "\t\tn = len(pool)",
      "\t\tif (r < 0) or (r > n):",
      "\t\t\t\traise ValueError",
      "",
      "\t\tc = math.comb(n + r - 1, r)",
      "",
      "\t\tif index < 0:",
      "\t\t\t\tindex += c",
      "",
      "\t\tif (index < 0) or (index >= c):",
      "\t\t\t\traise IndexError",
      "",
      "\t\tresult = []",
      "\t\ti = 0",
      "\t\twhile r:",
      "\t\t\t\tr -= 1",
      "\t\t\t\twhile n >= 0:",
      "\t\t\t\t\t\tnum_combs = math.comb(n + r - 1, r)",
      "\t\t\t\t\t\tif index < num_combs:",
      "\t\t\t\t\t\t\t\tbreak",
      "\t\t\t\t\t\tn -= 1",
      "\t\t\t\t\t\ti += 1",
      "\t\t\t\t\t\tindex -= num_combs",
      "\t\t\t\tresult.append(pool[i])",
      "",
      "\t\treturn tuple(result)"
    ],
    "description": "more-itertools-combinatoric"
  },
  "Powerset-go": {
    "scope": "go",
    "prefix": "PowerSet",
    "body": [
      "// 遍历子集.",
      "func Powerset(n int, f func(subset []int) bool) {",
      "\tpath := make([]int, 0, n)",
      "\tvar dfs func(int) bool",
      "\tdfs = func(index int) bool {",
      "\t\tif index == n {",
      "\t\t\treturn f(path)",
      "\t\t}",
      "\t\tif dfs(index + 1) {",
      "\t\t\treturn true",
      "\t\t}",
      "\t\tpath = append(path, index)",
      "\t\tif dfs(index + 1) {",
      "\t\t\treturn true",
      "\t\t}",
      "\t\tpath = path[:len(path)-1]",
      "\t\treturn false",
      "\t}",
      "\tdfs(0)",
      "}"
    ],
    "description": "Powerset"
  },
  "Partitions-go": {
    "scope": "go",
    "prefix": "Partitions",
    "body": [
      "// 遍历数组所有的分割方案，按照分割点将数组分割成若干段.",
      "//",
      "//\tPartitions(3, func(splits []int) bool {",
      "//\t\t\tfor i := 0; i < len(splits)-1 ; i++ {",
      "//\t\t\t\t\tfmt.Println(arr[splits[i]:splits[i+1]])",
      "//\t\t\t}",
      "//\t\t\treturn false",
      "//\t})",
      "func Partitions(n int, f func(splits []int) bool) {",
      "\tif n == 0 {",
      "\t\treturn",
      "\t}",
      "\tpath := make([]int, 0, n)",
      "\tpath = append(path, 0)",
      "\tvar dfs func(int) bool",
      "\tdfs = func(index int) bool {",
      "\t\tif index == n-1 {",
      "\t\t\tpath = append(path, n)",
      "\t\t\tstop := f(path)",
      "\t\t\tpath = path[:len(path)-1]",
      "\t\t\treturn stop",
      "\t\t}",
      "\t\tif dfs(index + 1) {",
      "\t\t\treturn true",
      "\t\t}",
      "\t\tpath = append(path, index+1)",
      "\t\tif dfs(index + 1) {",
      "\t\t\treturn true",
      "\t\t}",
      "\t\tpath = path[:len(path)-1]",
      "\t\treturn false",
      "\t}",
      "\tdfs(0)",
      "}"
    ],
    "description": "Partitions"
  },
  "SetPartitions-go": {
    "scope": "go",
    "prefix": "SetPartitions",
    "body": [
      "// 将 n 个元素的集合分成 k 个部分，不允许为空.",
      "func SetPartitions(n, k int, f func(parts [][]int) bool) {",
      "\tif k < 1 {",
      "\t\tpanic(\"Can't partition in a negative or zero number of groups\")",
      "\t}",
      "\tif k > n {",
      "\t\treturn",
      "\t}",
      "\tparts := make([][]int, k)",
      "\tfor i := range parts {",
      "\t\tparts[i] = make([]int, 0, n)",
      "\t}",
      "\tvar dfs func(int, int) bool",
      "\tdfs = func(index, count int) bool {",
      "\t\tif index == n {",
      "\t\t\tif count == k {",
      "\t\t\t\treturn f(parts)",
      "\t\t\t}",
      "\t\t\treturn false",
      "\t\t}",
      "\t\tfor i := 0; i < count; i++ {",
      "\t\t\tparts[i] = append(parts[i], index)",
      "\t\t\tif dfs(index+1, count) {",
      "\t\t\t\treturn true",
      "\t\t\t}",
      "\t\t\tparts[i] = parts[i][:len(parts[i])-1]",
      "\t\t}",
      "\t\tif count < k {",
      "\t\t\tparts[count] = append(parts[count], index)",
      "\t\t\tif dfs(index+1, count+1) {",
      "\t\t\t\treturn true",
      "\t\t\t}",
      "\t\t\tparts[count] = parts[count][:len(parts[count])-1]",
      "\t\t}",
      "\t\treturn false",
      "\t}",
      "\tdfs(0, 0)",
      "}"
    ],
    "description": "SetPartitions"
  },
  "SetPartitionsAll-go": {
    "scope": "go",
    "prefix": "SetPartitionsAll",
    "body": [
      "// 将 n 个元素的集合分成任意个部分.",
      "func SetPartitionsAll(n int, f func(parts [][]int) bool) {",
      "\tparts := make([][]int, n)",
      "\tfor i := range parts {",
      "\t\tparts[i] = make([]int, 0, n)",
      "\t}",
      "\tvar dfs func(int, int) bool",
      "\tdfs = func(index, count int) bool {",
      "\t\tif index == n {",
      "\t\t\treturn f(parts[:count])",
      "\t\t}",
      "\t\tfor i := 0; i < count; i++ {",
      "\t\t\tparts[i] = append(parts[i], index)",
      "\t\t\tif dfs(index+1, count) {",
      "\t\t\t\treturn true",
      "\t\t\t}",
      "\t\t\tparts[i] = parts[i][:len(parts[i])-1]",
      "\t\t}",
      "\t\tparts[count] = append(parts[count], index)",
      "\t\tif dfs(index+1, count+1) {",
      "\t\t\treturn true",
      "\t\t}",
      "\t\tparts[count] = parts[count][:len(parts[count])-1]",
      "\t\treturn false",
      "\t}",
      "\tdfs(0, 0)",
      "}"
    ],
    "description": "SetPartitionsAll"
  },
  "DistinctPermutations": {
    "scope": "go",
    "prefix": "DistinctPermutations",
    "body": [
      "",
      "// 遍历无重复排列.",
      "func DistinctPermutations[T cmp.Ordered](arr []T, r int, f func(perm []T) bool) {",
      "\tif len(arr) == 0 || r < 1 || r > len(arr) {",
      "\t\treturn",
      "\t}",
      "\tarr = append(arr[:0:0], arr...)",
      "\tslices.Sort(arr)",
      "",
      "\tif r == len(arr) {",
      "\t\tfor {",
      "\t\t\tif f(arr) {",
      "\t\t\t\tbreak",
      "\t\t\t}",
      "\t\t\tif !nextPermutation(arr) {",
      "\t\t\t\tbreak",
      "\t\t\t}",
      "\t\t}",
      "\t\treturn",
      "\t}",
      "",
      "\thead, tail := arr[:r:r], arr[r:len(arr):len(arr)]",
      "\tfor len(tail) < len(arr) {",
      "\t\ttail = append(tail, arr[len(arr)-1]) // buf",
      "\t}",
      "\ttailLen := len(arr) - r",
      "\tfor {",
      "\t\tif f(head) {",
      "\t\t\treturn",
      "\t\t}",
      "\t\tpivot := tail[tailLen-1]",
      "\t\ti := r - 1",
      "\t\tfound := false",
      "\t\tfor ; i >= 0; i-- {",
      "\t\t\tif head[i] < pivot {",
      "\t\t\t\tfound = true",
      "\t\t\t\tbreak",
      "\t\t\t}",
      "\t\t\tpivot = head[i]",
      "\t\t}",
      "\t\tif !found {",
      "\t\t\treturn",
      "\t\t}",
      "",
      "\t\tfound = false",
      "\t\tfor j := 0; j < tailLen; j++ {",
      "\t\t\tif tail[j] > head[i] {",
      "\t\t\t\thead[i], tail[j] = tail[j], head[i]",
      "\t\t\t\tfound = true",
      "\t\t\t\tbreak",
      "\t\t\t}",
      "\t\t}",
      "\t\tif !found {",
      "\t\t\tfor j := r - 1; j >= 0; j-- {",
      "\t\t\t\tif head[j] > head[i] {",
      "\t\t\t\t\thead[i], head[j] = head[j], head[i]",
      "\t\t\t\t\tbreak",
      "\t\t\t\t}",
      "\t\t\t}",
      "\t\t}",
      "",
      "\t\tfor j, k := tailLen, r-1; k > i; {",
      "\t\t\ttail[j] = head[k]",
      "\t\t\tj++",
      "\t\t\tk--",
      "\t\t}",
      "\t\tfor j, k := i+1, 0; j < r; {",
      "\t\t\thead[j] = tail[k]",
      "\t\t\tj++",
      "\t\t\tk++",
      "\t\t}",
      "\t\tfor j, k := 0, r-i-1; j < tailLen; {",
      "\t\t\ttail[j] = tail[k]",
      "\t\t\tj++",
      "\t\t\tk++",
      "\t\t}",
      "\t}",
      "}",
      "",
      "// 原地返回下一个字典序的排列.",
      "// 不包含重复排列.",
      "func nextPermutation[T cmp.Ordered](nums []T) bool {",
      "\ti := len(nums) - 1",
      "\tfor i > 0 && nums[i-1] >= nums[i] {",
      "\t\ti--",
      "\t}",
      "\tif i == 0 {",
      "\t\treturn false",
      "\t}",
      "\tlast := i - 1",
      "\tj := len(nums) - 1",
      "\tfor nums[j] <= nums[last] {",
      "\t\tj--",
      "\t}",
      "\tnums[last], nums[j] = nums[j], nums[last]",
      "\tfor i, j := last+1, len(nums)-1; i < j; i, j = i+1, j-1 {",
      "\t\tnums[i], nums[j] = nums[j], nums[i]",
      "\t}",
      "\treturn true",
      "}"
    ],
    "description": "DistinctPermutations"
  },
  "DistinctCombinations": {
    "scope": "go",
    "prefix": "DistinctCombinations",
    "body": [
      "",
      "// 遍历无重复组合.",
      "func DistinctCombinations[T cmp.Ordered](arr []T, r int, f func(comb []T) bool) {",
      "\tif len(arr) == 0 || r < 1 || r > len(arr) {",
      "\t\treturn",
      "\t}",
      "",
      "\tuniqueEverSeen := make([][]int, len(arr))",
      "\tfor i := range arr {",
      "\t\tvar indexes []int",
      "\t\tvisited := make(map[T]struct{})",
      "\t\tfor j := i; j < len(arr); j++ {",
      "\t\t\tif _, has := visited[arr[j]]; has {",
      "\t\t\t\tcontinue",
      "\t\t\t}",
      "\t\t\tvisited[arr[j]] = struct{}{}",
      "\t\t\tindexes = append(indexes, j)",
      "\t\t}",
      "\t\tuniqueEverSeen[i] = indexes",
      "\t}",
      "",
      "\tpath := make([]T, 0, r)",
      "\tvar dfs func(int, int) bool",
      "\tdfs = func(index, count int) bool {",
      "\t\tif count == r {",
      "\t\t\treturn f(path)",
      "\t\t}",
      "\t\tif index == len(arr) {",
      "\t\t\treturn false",
      "\t\t}",
      "\t\tfor _, curIndex := range uniqueEverSeen[index] {",
      "\t\t\tpath = append(path, arr[curIndex])",
      "\t\t\tif dfs(curIndex+1, count+1) {",
      "\t\t\t\treturn true",
      "\t\t\t}",
      "\t\t\tpath = path[:len(path)-1]",
      "\t\t}",
      "\t\treturn false",
      "\t}",
      "\tdfs(0, 0)",
      "}"
    ],
    "description": "DistinctCombinations"
  },
  "toDigit": {
    "scope": "go",
    "prefix": ["toDigit", "digit", "toNum", "stringToNumber"],
    "body": [
      "func toDigit(nums []int) int {",
      "\tres := 0",
      "\tfor _, num := range nums {",
      "\t\tres = res*10 + num",
      "\t}",
      "\treturn res",
      "}",
      "",
      "func toDigitStr(s string) int {",
      "\tres := 0",
      "\tfor _, ch := range s {",
      "\t\tres = res*10 + int(ch-'0')",
      "\t}",
      "\treturn res",
      "}",
      "",
      "func toDigitByte(s []byte) int {",
      "\tres := 0",
      "\tfor _, ch := range s {",
      "\t\tres = res*10 + int(ch-'0')",
      "\t}",
      "\treturn res",
      "}"
    ],
    "description": "toDigit"
  },
  "toDigit-ts": {
    "scope": "typescript",
    "prefix": "toDigit",
    "body": [
      "function toDigit(nums: ArrayLike<number>, start = 0, end = nums.length): number {",
      "\tlet res = 0",
      "\tfor (let i = start; i < end; i++) {",
      "\t\tres = res * 10 + nums[i]",
      "\t}",
      "\treturn res",
      "}",
      "",
      "function toDigitStr(str: string, start = 0, end = str.length): number {",
      "\tlet res = 0",
      "\tfor (let i = start; i < end; i++) {",
      "\t\tres = res * 10 + +str[i]",
      "\t}",
      "\treturn res",
      "}"
    ],
    "description": "toDigit"
  },
  "Batched": {
    "scope": "go",
    "prefix": ["Batched", "batch", "chunked", "chunk"],
    "body": [
      "",
      "// 将 n 个元素分成大小为 size 的批次，最后一个批次可能小于 size.",
      "// 适用于分片处理大量数据的场景.",
      "// 返回两个组的大小和组的个数.",
      "func Batched(n, size int, f func(start, end int)) (size1, count1, size2, count2 int) {",
      "\tif f != nil {",
      "\t\tfor i := 0; i < n; i += size {",
      "\t\t\tf(i, min(i+size, n))",
      "\t\t}",
      "\t}",
      "\tsize1 = size",
      "\tcount1 = n / size",
      "\tsize2 = n % size",
      "\tcount2 = 0",
      "\tif size2 > 0 {",
      "\t\tcount2 = 1",
      "\t}",
      "\treturn",
      "}"
    ],
    "description": "Batched"
  },
  "Distribute": {
    "scope": "go",
    "prefix": "Distribute",
    "body": [
      "// 将 n 个元素分成 groupCount 个组.每个组的大小尽可能均等分配，使得每个组的大小差距不超过1.",
      "// 适用于将任务分配给多个工作线程的场景.",
      "// 返回两个组的大小和组的个数.",
      "func Distribute(n, groupCount int, f func(start, end int)) (size1, count1, size2, count2 int) {",
      "\tq := n / groupCount",
      "\tr := n % groupCount",
      "\tif f != nil {",
      "\t\tstart := 0",
      "\t\tfor i := 0; i < groupCount; i++ {",
      "\t\t\tend := start + q",
      "\t\t\tif i < r {",
      "\t\t\t\tend++",
      "\t\t\t}",
      "\t\t\tf(start, end)",
      "\t\t\tstart = end",
      "\t\t}",
      "\t}",
      "\tsize1 = q + 1",
      "\tcount1 = r",
      "\tsize2 = q",
      "\tcount2 = groupCount - r",
      "\treturn",
      "}"
    ],
    "description": "Distribute"
  },
  "Intersect": {
    "scope": "go",
    "prefix": ["Intersect", "overlap"],
    "body": [
      "// 区间[s1,e1]与区间[s2,e2]的交集长度.",
      "func Intersect(s1, e1, s2, e2 int) int {",
      "\treturn max(0, min(e1, e2)-max(s1, s2))",
      "}"
    ],
    "description": "Intersect"
  },
  "intersect": {
    "scope": "python",
    "prefix": ["intersect", "overlap"],
    "body": [
      "def intersect(s1: int, e1: int, s2: int, e2: int) -> int:",
      "\t\t\"\"\"两个区间相交的长度.\"\"\"",
      "\t\treturn max(0, min(e1, e2) - max(s1, s2))"
    ],
    "description": "intersect"
  },
  "IntervalsIntersection": {
    "scope": "go",
    "prefix": ["IntervalsIntersection", "EnumerateIntervalsIntersection", "区间交集", "区间相交"],
    "body": [
      "// 有序区间列表交集长度.",
      "func IntervalsIntersectionLen(n1 int, f1 func(int) (int, int), n2 int, f2 func(int) (int, int)) int {",
      "\tres := 0",
      "\tleft, right := 0, 0",
      "\tfor left < n1 && right < n2 {",
      "\t\ts1, e1 := f1(left)",
      "\t\ts2, e2 := f2(right)",
      "\t\tif (s1 <= e2 && e2 <= e1) || (s2 <= e1 && e1 <= e2) {",
      "\t\t\tres += min(e1, e2) - max(s1, s2)",
      "\t\t}",
      "\t\tif e1 < e2 {",
      "\t\t\tleft++",
      "\t\t} else {",
      "\t\t\tright++",
      "\t\t}",
      "\t}",
      "\treturn res",
      "}",
      "",
      "// 有序区间列表交集(EnumerateIntersection).",
      "func EnumerateIntervalsIntersection(",
      "\tn1 int, f1 func(int) (int, int), n2 int, f2 func(int) (int, int),",
      "\tf func(left, right, i, j int),",
      ") {",
      "\ti, j := 0, 0",
      "\tfor i < n1 && j < n2 {",
      "\t\ts1, e1 := f1(i)",
      "\t\ts2, e2 := f2(j)",
      "\t\tif (s1 <= e2 && e2 <= e1) || (s2 <= e1 && e1 <= e2) {",
      "\t\t\tf(max(s1, s2), min(e1, e2), i, j)",
      "\t\t}",
      "\t\tif e1 < e2 {",
      "\t\t\ti++",
      "\t\t} else {",
      "\t\t\tj++",
      "\t\t}",
      "\t}",
      "}"
    ],
    "description": "IntervalsIntersection"
  },
  "mergeIntervals": {
    "scope": "python",
    "prefix": ["mergeIntervals", "合并区间", "区间合并"],
    "body": [
      "def mergeIntervals(intervals: List[List[int]]) -> List[List[int]]:",
      "\t\t\"\"\"合并所有重叠的区间，并返回一个不重叠的区间数组.",
      "",
      "\t\t>>> mergeIntervals([[1, 2], [2, 4], [5, 6]])",
      "\t\t[[1, 4], [5, 6]]",
      "\t\t\"\"\"",
      "\t\tif not intervals:",
      "\t\t\t\treturn []",
      "",
      "\t\tintervals = intervals[:]",
      "\t\tintervals.sort(key=lambda x: x[0])",
      "\t\tres = []",
      "\t\tfor interval in intervals:",
      "\t\t\t\tif not res or res[-1][1] < interval[0]:",
      "\t\t\t\t\t\tres.append(interval)",
      "\t\t\t\telse:",
      "\t\t\t\t\t\tres[-1][1] = max(res[-1][1], interval[1])",
      "",
      "\t\treturn res"
    ],
    "description": "mergeIntervals"
  },
  "MergeIntervals-go": {
    "scope": "go",
    "prefix": ["MergeIntervals", "合并区间", "区间合并"],
    "body": [
      "// 合并所有重叠的闭区间，返回一个不重叠的区间列表.",
      "func MergeIntervals(n int32, supplier func(int32) (int, int), consumer func(int, int)) {",
      "\tif n == 0 {",
      "\t\treturn",
      "\t}",
      "\torder := make([]int32, n)",
      "\tfor i := int32(0); i < n; i++ {",
      "\t\torder[i] = i",
      "\t}",
      "\tsort.Slice(order, func(i, j int) bool {",
      "\t\tl1, _ := supplier(order[i])",
      "\t\tl2, _ := supplier(order[j])",
      "\t\treturn l1 < l2",
      "\t})",
      "\tpreL, preR := supplier(order[0])",
      "\tfor _, i := range order[1:] {",
      "\t\tcurL, curR := supplier(i)",
      "\t\tif curL <= preR {",
      "\t\t\tpreR = max(preR, curR)",
      "\t\t} else {",
      "\t\t\tconsumer(preL, preR)",
      "\t\t\tpreL, preR = curL, curR",
      "\t\t}",
      "\t}",
      "\tconsumer(preL, preR)",
      "}",
      "",
      "func max(a, b int) int {",
      "\tif a > b {",
      "\t\treturn a",
      "\t}",
      "\treturn b",
      "}"
    ],
    "description": "MergeIntervals"
  },
  "mergeIntervals-ts": {
    "scope": "typescript",
    "prefix": ["mergeIntervals", "合并区间", "区间合并"],
    "body": [
      "/** 合并所有重叠的闭区间，返回一个不重叠的区间列表. */",
      "function mergeIntervals(",
      "\tn: number,",
      "\tsupplier: (i: number) => { left: number; right: number },",
      "\tconsumer: (newLeft: number, newRight: number) => void",
      "): void {",
      "\tif (n === 0) {",
      "\t\treturn",
      "\t}",
      "\tconst order = Array<number>(n)",
      "\tfor (let i = 0; i < n; i++) order[i] = i",
      "\torder.sort((i, j) => {",
      "\t\tconst l1 = supplier(i).left",
      "\t\tconst l2 = supplier(j).left",
      "\t\treturn l1 - l2",
      "\t})",
      "",
      "\tlet { left: preL, right: preR } = supplier(order[0])",
      "\tfor (let i = 1; i < n; i++) {",
      "\t\tconst { left: curL, right: curR } = supplier(order[i])",
      "\t\tif (curL <= preR) {",
      "\t\t\tpreR = Math.max(preR, curR)",
      "\t\t} else {",
      "\t\t\tconsumer(preL, preR)",
      "\t\t\tpreL = curL",
      "\t\t\tpreR = curR",
      "\t\t}",
      "\t}",
      "\tconsumer(preL, preR)",
      "}",
      ""
    ],
    "description": "mergeIntervals"
  },
  "enumetateConsecutiveIntervals": {
    "scope": "python",
    "prefix": "enumetateConsecutiveIntervals",
    "body": [
      "from typing import Generator, List, Tuple",
      "",
      "",
      "def enumetateConsecutiveIntervals(nums: List[int]) -> Generator[Tuple[int, int, bool], None, None]:",
      "\t\t\"\"\"遍历连续的区间.",
      "",
      "\t\t>>> list(enumetateConsecutiveIntervals([1, 2, 3, 5, 6, 7, 9]))",
      "\t\t[(1, 3, True), (4, 4, False), (5, 7, True), (8, 8, False), (9, 9, True)]",
      "\t\t\"\"\"",
      "\t\tif not nums:",
      "\t\t\t\treturn",
      "\t\ti, n = 0, len(nums)",
      "\t\twhile i < n:",
      "\t\t\t\tstart = i",
      "\t\t\t\twhile i < n - 1 and nums[i] + 1 == nums[i + 1]:",
      "\t\t\t\t\t\ti += 1",
      "\t\t\t\tyield nums[start], nums[i], True",
      "\t\t\t\tif i + 1 < n:",
      "\t\t\t\t\t\tyield nums[i] + 1, nums[i + 1] - 1, False",
      "\t\t\t\ti += 1"
    ],
    "description": "enumetateConsecutiveIntervals"
  },
  "EnumerateConsecutiveIntervals-go": {
    "scope": "go",
    "prefix": "EnumerateConsecutiveIntervals",
    "body": [
      "// 遍历连续区间/合并连续区间.",
      "func EnumerateConsecutiveIntervals(",
      "\tn int32, supplier func(i int32) int,",
      "\tconsumer func(min, max int, isIn bool),",
      ") {",
      "\tif n == 0 {",
      "\t\treturn",
      "\t}",
      "\ti := int32(0)",
      "\tfor i < n {",
      "\t\tstart := i",
      "\t\tfor i < n-1 && supplier(i)+1 == supplier(i+1) {",
      "\t\t\ti++",
      "\t\t}",
      "\t\tconsumer(supplier(start), supplier(i), true)",
      "\t\tif i+1 < n {",
      "\t\t\tconsumer(supplier(i)+1, supplier(i+1)-1, false)",
      "\t\t}",
      "\t\ti++",
      "\t}",
      "}"
    ],
    "description": "EnumerateConsecutiveIntervals"
  },
  "argSort-ts": {
    "scope": "typescript",
    "prefix": ["argSort", "reArrange"],
    "body": [
      "/**",
      " * 将 {@link n} 个元素按照 {@link less} 函数的比较结果排序, 返回排序后的索引数组.",
      " *",
      " * @returns order `order[i]` 表示排序后的第 `i` 个元素在原数组中的索引.",
      " * @example",
      " * ```ts",
      " * const arr = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3]",
      " * const order = argSort(arr.length, (i, j) => arr[i] < arr[j])",
      " * console.log(order) // [1, 3, 0, 9, 6, 2, 4, 8, 7, 5]",
      " * console.log(reArrange(arr, order)) // [1, 1, 2, 3, 3, 4, 5, 5, 6, 9]",
      " * ```",
      " */",
      "function argSort(n: number, less: (i: number, j: number) => boolean): number[] {",
      "\tconst order = Array(n)",
      "\tfor (let i = 0; i < order.length; i++) order[i] = i",
      "\torder.sort((a, b) => (less(a, b) ? -1 : 1))",
      "\treturn order",
      "}",
      "",
      "/**",
      " * 将 {@link arr} 按照 {@link order} 重新排列.",
      " */",
      "function reArrange<T>(arr: T[], order: ArrayLike<number>): T[] {",
      "\tconst res = Array(arr.length)",
      "\tfor (let i = 0; i < res.length; i++) res[i] = arr[order[i]]",
      "\treturn res",
      "}"
    ],
    "description": "argSort"
  },
  "topBit-go": {
    "scope": "go",
    "prefix": ["Topbit32", "Topbit64", "Lowbit32", "Lowbit64"],
    "body": [
      "// 二进制中最高位的1的位置.",
      "// (0, 1, 2, 3, 4) => (-1, 0, 1, 1, 2)",
      "func Topbit32(x uint32) int {",
      "\tif x == 0 {",
      "\t\treturn -1",
      "\t}",
      "\treturn bits.Len32(x) - 1",
      "}",
      "",
      "// 二进制中最高位的1的位置.",
      "// (0, 1, 2, 3, 4) => (-1, 0, 1, 1, 2)",
      "func Topbit64(x uint64) int {",
      "\tif x == 0 {",
      "\t\treturn -1",
      "\t}",
      "\treturn bits.Len64(x) - 1",
      "}",
      "",
      "// 二进制中最低位的1的位置.",
      "// (0, 1, 2, 3, 4) => (-1, 0, 1, 0, 2)",
      "func Lowbit32(x uint32) int {",
      "\tif x == 0 {",
      "\t\treturn -1",
      "\t}",
      "\treturn bits.TrailingZeros32(x)",
      "}",
      "",
      "// 二进制中最低位的1的位置.",
      "// (0, 1, 2, 3, 4) => (-1, 0, 1, 0, 2)",
      "func Lowbit64(x uint64) int {",
      "\tif x == 0 {",
      "\t\treturn -1",
      "\t}",
      "\treturn bits.TrailingZeros64(x)",
      "}"
    ],
    "description": "topBit"
  },
  "topbit-py": {
    "scope": "python",
    "prefix": ["topbit", "lowbit"],
    "body": [
      "def topbit(x: int) -> int:",
      "\t\t\"\"\"二进制中最高位的1的位置.",
      "",
      "\t\t>>> [topbit(x) for x in range(5)]",
      "\t\t[-1, 0, 1, 1, 2]",
      "\t\t\"\"\"",
      "\t\treturn -1 if not x else x.bit_length() - 1",
      "",
      "",
      "def lowbit(x: int) -> int:",
      "\t\t\"\"\"二进制中最低位的1的位置.",
      "",
      "\t\t>>> [lowbit(x) for x in range(5)]",
      "\t\t[-1, 0, 1, 0, 2]",
      "\t\t\"\"\"",
      "\t\treturn -1 if not x else (x & -x).bit_length() - 1"
    ],
    "description": "topbit"
  },
  "SplayTreeBasic": {
    "scope": "go",
    "prefix": "SplayTreeBasic",
    "body": [
      "",
      "type E = int32",
      "",
      "func NewSplayTreeBasic() *SplayTreeBasic {",
      "\treturn &SplayTreeBasic{}",
      "}",
      "",
      "type SplayNode struct {",
      "\trev\t\t bool",
      "\tsize\t\tint32",
      "\tx\t\t\t E",
      "\tp, l, r *SplayNode",
      "}",
      "",
      "type SplayTreeBasic struct{}",
      "",
      "func (st *SplayTreeBasic) NewRoot() *SplayNode {",
      "\treturn nil",
      "}",
      "",
      "func (st *SplayTreeBasic) Build(n int32, f func(i int32) E) *SplayNode {",
      "\tvar dfs func(l, r int32) *SplayNode",
      "\tdfs = func(l, r int32) *SplayNode {",
      "\t\tif l == r {",
      "\t\t\treturn nil",
      "\t\t}",
      "\t\tif r == l+1 {",
      "\t\t\treturn st.NewNode(f(l))",
      "\t\t}",
      "\t\tm := (l + r) >> 1",
      "\t\tlRoot, rRoot := dfs(l, m), dfs(m+1, r)",
      "\t\troot := st.NewNode(f(m))",
      "\t\troot.l, root.r = lRoot, rRoot",
      "\t\tif lRoot != nil {",
      "\t\t\tlRoot.p = root",
      "\t\t}",
      "\t\tif rRoot != nil {",
      "\t\t\trRoot.p = root",
      "\t\t}",
      "\t\tst.nodePushup(root)",
      "\t\treturn root",
      "\t}",
      "\treturn dfs(0, n)",
      "}",
      "",
      "func (st *SplayTreeBasic) Size(n *SplayNode) int32 {",
      "\tif n == nil {",
      "\t\treturn 0",
      "\t}",
      "\treturn n.size",
      "}",
      "",
      "func (st *SplayTreeBasic) Merge(l, r *SplayNode) *SplayNode {",
      "\tif l == nil {",
      "\t\treturn r",
      "\t}",
      "\tif r == nil {",
      "\t\treturn l",
      "\t}",
      "\tst.splayKth(&r, 0)",
      "\tr.l = l",
      "\tl.p = r",
      "\tst.nodePushup(r)",
      "\treturn r",
      "}",
      "",
      "func (st *SplayTreeBasic) Merge3(a, b, c *SplayNode) *SplayNode {",
      "\treturn st.Merge(st.Merge(a, b), c)",
      "}",
      "",
      "func (st *SplayTreeBasic) Merge4(a, b, c, d *SplayNode) *SplayNode {",
      "\treturn st.Merge(st.Merge(st.Merge(a, b), c), d)",
      "}",
      "",
      "func (st *SplayTreeBasic) Split(root *SplayNode, k int32) (*SplayNode, *SplayNode) {",
      "\tif k == 0 {",
      "\t\treturn nil, root",
      "\t}",
      "\tif k == root.size {",
      "\t\treturn root, nil",
      "\t}",
      "\tst.splayKth(&root, k-1)",
      "\tright := root.r",
      "\troot.r = nil",
      "\tright.p = nil",
      "\tst.nodePushup(root)",
      "\treturn root, right",
      "}",
      "",
      "func (st *SplayTreeBasic) Split3(root *SplayNode, l, r int32) (*SplayNode, *SplayNode, *SplayNode) {",
      "\tvar nm, nr *SplayNode",
      "\troot, nr = st.Split(root, r)",
      "\troot, nm = st.Split(root, l)",
      "\treturn root, nm, nr",
      "}",
      "",
      "func (st *SplayTreeBasic) Split4(root *SplayNode, i, j, k int32) (*SplayNode, *SplayNode, *SplayNode, *SplayNode) {",
      "\tvar d *SplayNode",
      "\troot, d = st.Split(root, k)",
      "\ta, b, c := st.Split3(root, i, j)",
      "\treturn a, b, c, d",
      "}",
      "",
      "func (st *SplayTreeBasic) gotoBetween(root **SplayNode, l, r int32) {",
      "\tif l == 0 && r == (*root).size {",
      "\t\treturn",
      "\t}",
      "\tif l == 0 {",
      "\t\tst.splayKth(root, r)",
      "\t\t*root = (*root).l",
      "\t\treturn",
      "\t}",
      "\tif r == (*root).size {",
      "\t\tst.splayKth(root, l-1)",
      "\t\t*root = (*root).r",
      "\t\treturn",
      "\t}",
      "\tst.splayKth(root, r)",
      "\trp := *root",
      "\t(*root) = rp.l",
      "\t(*root).p = nil",
      "\tst.splayKth(root, l-1)",
      "\t(*root).p = rp",
      "\trp.l = *root",
      "\tst.nodePushup(rp)",
      "\t*root = (*root).r",
      "}",
      "",
      "func (st *SplayTreeBasic) EnumerateAll(root *SplayNode, f func(E)) {",
      "\tvar dfs func(*SplayNode)",
      "\tdfs = func(root *SplayNode) {",
      "\t\tif root == nil {",
      "\t\t\treturn",
      "\t\t}",
      "\t\tst.nodePushdown(root)",
      "\t\tdfs(root.l)",
      "\t\tf(st.nodeGet(root))",
      "\t\tdfs(root.r)",
      "\t}",
      "\tdfs(root)",
      "}",
      "",
      "func (st *SplayTreeBasic) GetAll(root *SplayNode) []E {",
      "\tif root == nil {",
      "\t\treturn nil",
      "\t}",
      "\tres := make([]E, 0, root.size)",
      "\tst.EnumerateAll(root, func(v E) { res = append(res, v) })",
      "\treturn res",
      "}",
      "",
      "func (st *SplayTreeBasic) Get(root **SplayNode, k int32) E {",
      "\tst.splayKth(root, k)",
      "\treturn st.nodeGet(*root)",
      "}",
      "",
      "func (st *SplayTreeBasic) Set(root **SplayNode, k int32, x E) {",
      "\tst.splayKth(root, k)",
      "\tst.nodeSet(*root, x)",
      "}",
      "",
      "func (st *SplayTreeBasic) Update(root **SplayNode, k int32, x E) {",
      "\tst.splayKth(root, k)",
      "\tst.nodeSet(*root, x)",
      "}",
      "",
      "func (st *SplayTreeBasic) Reverse(root **SplayNode, l, r int32) {",
      "\tif *root == nil {",
      "\t\treturn",
      "\t}",
      "\tif l < 0 {",
      "\t\tl = 0",
      "\t}",
      "\tif s := (*root).size; r > s {",
      "\t\tr = s",
      "\t}",
      "\tif l >= r {",
      "\t\treturn",
      "\t}",
      "\tst.gotoBetween(root, l, r)",
      "\tst.nodeReverse(*root)",
      "\tst.splay(*root, true)",
      "}",
      "",
      "func (st *SplayTreeBasic) ReverseAll(root *SplayNode) {",
      "\tif root != nil {",
      "\t\tst.nodeReverse(root)",
      "\t}",
      "}",
      "",
      "func (st *SplayTreeBasic) rotate(n *SplayNode) {",
      "\tvar pp, p, c *SplayNode",
      "\tp = n.p",
      "\tpp = p.p",
      "\tif p.l == n {",
      "\t\tc = n.r",
      "\t\tn.r = p",
      "\t\tp.l = c",
      "\t} else {",
      "\t\tc = n.l",
      "\t\tn.l = p",
      "\t\tp.r = c",
      "\t}",
      "\tif pp != nil && pp.l == p {",
      "\t\tpp.l = n",
      "\t}",
      "\tif pp != nil && pp.r == p {",
      "\t\tpp.r = n",
      "\t}",
      "\tn.p = pp",
      "\tp.p = n",
      "\tif c != nil {",
      "\t\tc.p = p",
      "\t}",
      "}",
      "",
      "func (st *SplayTreeBasic) propFromRoot(c *SplayNode) {",
      "\tif c.p == nil {",
      "\t\tst.nodePushdown(c)",
      "\t\treturn",
      "\t}",
      "\tst.propFromRoot(c.p)",
      "\tst.nodePushdown(c)",
      "}",
      "",
      "func (st *SplayTreeBasic) splay(me *SplayNode, propFromRootDone bool) {",
      "\tif !propFromRootDone {",
      "\t\tst.propFromRoot(me)",
      "\t}",
      "\tst.nodePushdown(me)",
      "\tfor me.p != nil {",
      "\t\tp := me.p",
      "\t\tpp := p.p",
      "\t\tif pp == nil {",
      "\t\t\tst.rotate(me)",
      "\t\t\tst.nodePushup(p)",
      "\t\t\tbreak",
      "\t\t}",
      "\t\tsame := (p.l == me && pp.l == p) || (p.r == me && pp.r == p)",
      "\t\tif same {",
      "\t\t\tst.rotate(p)",
      "\t\t\tst.rotate(me)",
      "\t\t} else {",
      "\t\t\tst.rotate(me)",
      "\t\t}",
      "\t\tst.nodePushup(pp)",
      "\t\tst.nodePushup(p)",
      "\t}",
      "\tst.nodePushup(me)",
      "}",
      "",
      "func (st *SplayTreeBasic) splayKth(root **SplayNode, k int32) {",
      "\tfor {",
      "\t\tst.nodePushdown(*root)",
      "\t\tsl := st.Size((*root).l)",
      "\t\tif k == sl {",
      "\t\t\tbreak",
      "\t\t}",
      "\t\tif k < sl {",
      "\t\t\t*root = (*root).l",
      "\t\t} else {",
      "\t\t\tk -= sl + 1",
      "\t\t\t*root = (*root).r",
      "\t\t}",
      "\t}",
      "\tst.splay(*root, true)",
      "}",
      "",
      "// 分离出的左侧节点值满足check函数.",
      "func (st *SplayTreeBasic) SplitMaxRightByValue(root *SplayNode, check func(E) bool) (*SplayNode, *SplayNode) {",
      "\tif root == nil {",
      "\t\treturn nil, nil",
      "\t}",
      "\tc := st.findMaxRightByValue(root, check)",
      "\tif c == nil {",
      "\t\tst.splay(root, true)",
      "\t\treturn nil, root",
      "\t}",
      "\tst.splay(c, true)",
      "\tright := c.r",
      "\tif right == nil {",
      "\t\treturn c, nil",
      "\t}",
      "\tright.p = nil",
      "\tc.r = nil",
      "\tst.nodePushup(c)",
      "\treturn c, right",
      "}",
      "",
      "// 分离出的左侧节点之和与",
      "func (st *SplayTreeBasic) SplitMaxRightByValueAndCount(root *SplayNode, check func(E, int32) bool) (*SplayNode, *SplayNode) {",
      "\tif root == nil {",
      "\t\treturn nil, nil",
      "\t}",
      "\tc := st.findMaxRightByValueAndCount(root, check)",
      "\tif c == nil {",
      "\t\tst.splay(root, true)",
      "\t\treturn nil, root",
      "\t}",
      "\tst.splay(c, true)",
      "\tright := c.r",
      "\tif right == nil {",
      "\t\treturn c, nil",
      "\t}",
      "\tright.p = nil",
      "\tc.r = nil",
      "\tst.nodePushup(c)",
      "\treturn c, right",
      "}",
      "",
      "func (st *SplayTreeBasic) findMaxRightByValue(root *SplayNode, check func(E) bool) *SplayNode {",
      "\tvar lastOk, last *SplayNode",
      "\tfor root != nil {",
      "\t\tlast = root",
      "\t\tst.nodePushdown(root)",
      "\t\tif check(root.x) {",
      "\t\t\tlastOk = root",
      "\t\t\troot = root.r",
      "\t\t} else {",
      "\t\t\troot = root.l",
      "\t\t}",
      "\t}",
      "\tst.splay(last, true)",
      "\treturn lastOk",
      "}",
      "",
      "func (st *SplayTreeBasic) findMaxRightByValueAndCount(root *SplayNode, check func(E, int32) bool) *SplayNode {",
      "\tvar lastOk, last *SplayNode",
      "\tvar n int32",
      "\tfor root != nil {",
      "\t\tlast = root",
      "\t\tst.nodePushdown(root)",
      "\t\tns := st.Size(root.l)",
      "\t\tif check(root.x, n+ns+1) {",
      "\t\t\tlastOk = root",
      "\t\t\tn += ns + 1",
      "\t\t\troot = root.r",
      "\t\t} else {",
      "\t\t\troot = root.l",
      "\t\t}",
      "\t}",
      "\tst.splay(last, true)",
      "\treturn lastOk",
      "}",
      "",
      "// 私有方法需要重写",
      "func (st *SplayTreeBasic) NewNode(x E) *SplayNode {",
      "\treturn &SplayNode{x: x, size: 1}",
      "}",
      "",
      "func (st *SplayTreeBasic) nodePushup(n *SplayNode) {",
      "\tn.size = 1",
      "\tif n.l != nil {",
      "\t\tn.size += n.l.size",
      "\t}",
      "\tif n.r != nil {",
      "\t\tn.size += n.r.size",
      "\t}",
      "}",
      "",
      "func (st *SplayTreeBasic) nodePushdown(n *SplayNode) {",
      "\tif n.rev {",
      "\t\tif left := n.l; left != nil {",
      "\t\t\tleft.rev = !left.rev",
      "\t\t\tleft.l, left.r = left.r, left.l",
      "\t\t}",
      "\t\tif right := n.r; right != nil {",
      "\t\t\tright.rev = !right.rev",
      "\t\t\tright.l, right.r = right.r, right.l",
      "\t\t}",
      "\t\tn.rev = false",
      "\t}",
      "}",
      "",
      "func (st *SplayTreeBasic) nodeGet(n *SplayNode) E {",
      "\treturn n.x",
      "}",
      "",
      "func (st *SplayTreeBasic) nodeSet(n *SplayNode, x E) {",
      "\tn.x = x",
      "\tst.nodePushup(n)",
      "}",
      "",
      "func (st *SplayTreeBasic) nodeReverse(n *SplayNode) {",
      "\tn.l, n.r = n.r, n.l",
      "\tn.rev = !n.rev",
      "}"
    ],
    "description": "SplayTreeBasic"
  },
  "unique2": {
    "scope": "go",
    "prefix": ["Unique2", "Unique"],
    "body": [
      "// Sorts the slice, removes duplicates, and clips the slice.",
      "//",
      "// T: cmp.Ordered",
      "//",
      "//\tallX := []int{3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5}",
      "//\tUnique2(&allX)",
      "//\tsize := len(allX) // 7",
      "//\tnewX := sort.SearchInts(allX, 5) // 4",
      "func Unique2[T int | int32 | uint | uint32](nums *[]T) {",
      "\tvalue := *nums",
      "\tsort.Slice(value, func(i, j int) bool { return value[i] < value[j] })",
      "\tslow := 0",
      "\tfor fast := 1; fast < len(value); fast++ {",
      "\t\tif value[fast] != value[slow] {",
      "\t\t\tslow++",
      "\t\t\tvalue[slow] = value[fast]",
      "\t\t}",
      "\t}",
      "\tvalue = value[: slow+1 : slow+1]",
      "\t*nums = value",
      "}"
    ],
    "description": "Unique2"
  },
  "toString": {
    "scope": "python",
    "prefix": ["toString", "toDigit", "parseInt"],
    "body": [
      "def toString(n: int, base: int) -> List[int]:",
      "\t\t\"\"\"Returns the base representation of n as a string.",
      "",
      "\t\t>>> toString(10, 2)",
      "\t\t[1, 0, 1, 0]",
      "\t\t\"\"\"",
      "\t\tif n == 0:",
      "\t\t\t\treturn []",
      "\t\tres = []",
      "\t\twhile n:",
      "\t\t\t\tres.append(n % base)",
      "\t\t\t\tn //= base",
      "\t\treturn res[::-1]",
      "",
      "",
      "def toDigit(s: List[int], base: int) -> int:",
      "\t\t\"\"\"Returns the integer representation of s in base.",
      "",
      "\t\t>>> toDigit([1, 0, 1, 0], 2)",
      "\t\t10",
      "\t\t\"\"\"",
      "\t\tres = 0",
      "\t\tfor d in s:",
      "\t\t\t\tres = res * base + d",
      "\t\treturn res"
    ],
    "description": "toString"
  },
  "toString-go": {
    "scope": "go",
    "prefix": ["toString", "toDigit", "parseInt"],
    "body": [
      "// Returns the base representation of n as a string.",
      "//",
      "//\ttoString(10, 2) // [1, 0, 1, 0]",
      "func toString(n int, base int) []int {",
      "\tif n == 0 {",
      "\t\treturn nil",
      "\t}",
      "\tres := []int{}",
      "\tfor n != 0 {",
      "\t\tres = append(res, n%base)",
      "\t\tn /= base",
      "\t}",
      "\treturn res",
      "}",
      "",
      "// Returns the integer representation of s in base.",
      "//",
      "//\ttoDigit([1, 0, 1, 0], 2) // 10",
      "func toDigit(s []int, base int) int {",
      "\tres := 0",
      "\tfor _, d := range s {",
      "\t\tres = res*base + d",
      "\t}",
      "\treturn res",
      "}"
    ],
    "description": "toString"
  },
  "SortedList32": {
    "scope": "go",
    "prefix": ["SortedList32"],
    "body": [
      "// 1e5 -> 200, 2e5 -> 400",
      "const _LOAD int32 = 200",
      "",
      "type S = ${1:int}",
      "",
      "var EMPTY S",
      "",
      "// 使用分块+树状数组维护的有序序列.",
      "type SortedList32 struct {",
      "\tless\t\t\t\t\t\t\tfunc(a, b S) bool",
      "\tsize\t\t\t\t\t\t\tint32",
      "\tblocks\t\t\t\t\t\t[][]S",
      "\tmins\t\t\t\t\t\t\t[]S",
      "\ttree\t\t\t\t\t\t\t[]int32",
      "\tshouldRebuildTree bool",
      "}",
      "",
      "func NewSortedList32(less func(a, b S) bool, elements ...S) *SortedList32 {",
      "\telements = append(elements[:0:0], elements...)",
      "\tres := &SortedList32{less: less}",
      "\tsort.Slice(elements, func(i, j int) bool { return less(elements[i], elements[j]) })",
      "\tn := int32(len(elements))",
      "\tblocks := [][]S{}",
      "\tfor start := int32(0); start < n; start += _LOAD {",
      "\t\tend := min32(start+_LOAD, n)",
      "\t\tblocks = append(blocks, elements[start:end:end]) // !各个块互不影响, max参数也需要指定为end",
      "\t}",
      "\tmins := make([]S, len(blocks))",
      "\tfor i, cur := range blocks {",
      "\t\tmins[i] = cur[0]",
      "\t}",
      "\tres.size = n",
      "\tres.blocks = blocks",
      "\tres.mins = mins",
      "\tres.shouldRebuildTree = true",
      "\treturn res",
      "}",
      "",
      "func (sl *SortedList32) Add(value S) *SortedList32 {",
      "\tsl.size++",
      "\tif len(sl.blocks) == 0 {",
      "\t\tsl.blocks = append(sl.blocks, []S{value})",
      "\t\tsl.mins = append(sl.mins, value)",
      "\t\tsl.shouldRebuildTree = true",
      "\t\treturn sl",
      "\t}",
      "",
      "\tpos, index := sl._locRight(value)",
      "",
      "\tsl._updateTree(pos, 1)",
      "\tsl.blocks[pos] = append(sl.blocks[pos][:index], append([]S{value}, sl.blocks[pos][index:]...)...)",
      "\tsl.mins[pos] = sl.blocks[pos][0]",
      "",
      "\t// n -> load + (n - load)",
      "\tif n := int32(len(sl.blocks[pos])); _LOAD+_LOAD < n {",
      "\t\tsl.blocks = append(sl.blocks, nil)",
      "\t\tcopy(sl.blocks[pos+2:], sl.blocks[pos+1:])",
      "\t\tsl.blocks[pos+1] = sl.blocks[pos][_LOAD:]",
      "\t\tsl.blocks[pos] = sl.blocks[pos][:_LOAD:_LOAD]",
      "\t\tsl.mins = append(sl.mins, EMPTY)",
      "\t\tcopy(sl.mins[pos+2:], sl.mins[pos+1:])",
      "\t\tsl.mins[pos+1] = sl.blocks[pos+1][0]",
      "\t\tsl.shouldRebuildTree = true",
      "\t}",
      "",
      "\treturn sl",
      "}",
      "",
      "func (sl *SortedList32) Has(value S) bool {",
      "\tif len(sl.blocks) == 0 {",
      "\t\treturn false",
      "\t}",
      "\tpos, index := sl._locLeft(value)",
      "\treturn index < int32(len(sl.blocks[pos])) && sl.blocks[pos][index] == value",
      "}",
      "",
      "func (sl *SortedList32) Discard(value S) bool {",
      "\tif len(sl.blocks) == 0 {",
      "\t\treturn false",
      "\t}",
      "\tpos, index := sl._locRight(value)",
      "\tif index > 0 && sl.blocks[pos][index-1] == value {",
      "\t\tsl._delete(pos, index-1)",
      "\t\treturn true",
      "\t}",
      "\treturn false",
      "}",
      "",
      "func (sl *SortedList32) Pop(index int32) S {",
      "\tif index < 0 {",
      "\t\tindex += sl.size",
      "\t}",
      "\tif index < 0 || index >= sl.size {",
      "\t\tpanic(\"index out of range\")",
      "\t}",
      "\tpos, startIndex := sl._findKth(index)",
      "\tvalue := sl.blocks[pos][startIndex]",
      "\tsl._delete(pos, startIndex)",
      "\treturn value",
      "}",
      "",
      "func (sl *SortedList32) At(index int32) S {",
      "\tif index < 0 {",
      "\t\tindex += sl.size",
      "\t}",
      "\tif index < 0 || index >= sl.size {",
      "\t\tpanic(\"index out of range\")",
      "\t}",
      "\tpos, startIndex := sl._findKth(index)",
      "\treturn sl.blocks[pos][startIndex]",
      "}",
      "",
      "func (sl *SortedList32) Erase(start, end int32) {",
      "\tsl.Enumerate(start, end, nil, true)",
      "}",
      "",
      "func (sl *SortedList32) Lower(value S) (res S, ok bool) {",
      "\tpos := sl.BisectLeft(value)",
      "\tif pos == 0 {",
      "\t\treturn",
      "\t}",
      "\treturn sl.At(pos - 1), true",
      "}",
      "",
      "func (sl *SortedList32) Higher(value S) (res S, ok bool) {",
      "\tpos := sl.BisectRight(value)",
      "\tif pos == sl.size {",
      "\t\treturn",
      "\t}",
      "\treturn sl.At(pos), true",
      "}",
      "",
      "func (sl *SortedList32) Floor(value S) (res S, ok bool) {",
      "\tpos := sl.BisectRight(value)",
      "\tif pos == 0 {",
      "\t\treturn",
      "\t}",
      "\treturn sl.At(pos - 1), true",
      "}",
      "",
      "func (sl *SortedList32) Ceiling(value S) (res S, ok bool) {",
      "\tpos := sl.BisectLeft(value)",
      "\tif pos == sl.size {",
      "\t\treturn",
      "\t}",
      "\treturn sl.At(pos), true",
      "}",
      "",
      "// 返回第一个大于等于 `value` 的元素的索引/严格小于 `value` 的元素的个数.",
      "func (sl *SortedList32) BisectLeft(value S) int32 {",
      "\tpos, index := sl._locLeft(value)",
      "\treturn sl._queryTree(pos) + index",
      "}",
      "",
      "// 返回第一个严格大于 `value` 的元素的索引/小于等于 `value` 的元素的个数.",
      "func (sl *SortedList32) BisectRight(value S) int32 {",
      "\tpos, index := sl._locRight(value)",
      "\treturn sl._queryTree(pos) + index",
      "}",
      "",
      "func (sl *SortedList32) Count(value S) int32 {",
      "\treturn sl.BisectRight(value) - sl.BisectLeft(value)",
      "}",
      "",
      "func (sl *SortedList32) Clear() {",
      "\tsl.size = 0",
      "\tsl.blocks = sl.blocks[:0]",
      "\tsl.mins = sl.mins[:0]",
      "\tsl.tree = sl.tree[:0]",
      "\tsl.shouldRebuildTree = true",
      "}",
      "",
      "func (sl *SortedList32) ForEach(f func(value S, index int32) bool, reverse bool) {",
      "\tif !reverse {",
      "\t\tcount := int32(0)",
      "\t\tfor i := 0; i < len(sl.blocks); i++ {",
      "\t\t\tblock := sl.blocks[i]",
      "\t\t\tfor j := 0; j < len(block); j++ {",
      "\t\t\t\tif f(block[j], count) {",
      "\t\t\t\t\treturn",
      "\t\t\t\t}",
      "\t\t\t\tcount++",
      "\t\t\t}",
      "\t\t}",
      "\t\treturn",
      "\t}",
      "\tcount := int32(0)",
      "\tfor i := len(sl.blocks) - 1; i >= 0; i-- {",
      "\t\tblock := sl.blocks[i]",
      "\t\tfor j := len(block) - 1; j >= 0; j-- {",
      "\t\t\tif f(block[j], count) {",
      "\t\t\t\treturn",
      "\t\t\t}",
      "\t\t\tcount++",
      "\t\t}",
      "\t}",
      "}",
      "",
      "func (sl *SortedList32) Enumerate(start, end int32, f func(value S), erase bool) {",
      "\tif start < 0 {",
      "\t\tstart = 0",
      "\t}",
      "\tif end > sl.size {",
      "\t\tend = sl.size",
      "\t}",
      "\tif start >= end {",
      "\t\treturn",
      "\t}",
      "",
      "\tpos, startIndex := sl._findKth(start)",
      "\tcount := end - start",
      "\tm := int32(len(sl.blocks))",
      "\tfor ; count > 0 && pos < m; pos++ {",
      "\t\tblock := sl.blocks[pos]",
      "\t\tendIndex := min32(int32(len(block)), startIndex+count)",
      "\t\tif f != nil {",
      "\t\t\tfor j := startIndex; j < endIndex; j++ {",
      "\t\t\t\tf(block[j])",
      "\t\t\t}",
      "\t\t}",
      "\t\tdeleted := endIndex - startIndex",
      "",
      "\t\tif erase {",
      "\t\t\tif deleted == int32(len(block)) {",
      "\t\t\t\t// !delete block",
      "\t\t\t\tsl.blocks = append(sl.blocks[:pos], sl.blocks[pos+1:]...)",
      "\t\t\t\tsl.mins = append(sl.mins[:pos], sl.mins[pos+1:]...)",
      "\t\t\t\tsl.shouldRebuildTree = true",
      "\t\t\t\tpos--",
      "\t\t\t} else {",
      "\t\t\t\t// !delete [index, end)",
      "\t\t\t\tsl._updateTree(pos, -deleted)",
      "\t\t\t\tsl.blocks[pos] = append(sl.blocks[pos][:startIndex], sl.blocks[pos][endIndex:]...)",
      "\t\t\t\tsl.mins[pos] = sl.blocks[pos][0]",
      "\t\t\t}",
      "\t\t\tsl.size -= deleted",
      "\t\t}",
      "",
      "\t\tcount -= deleted",
      "\t\tstartIndex = 0",
      "\t}",
      "}",
      "",
      "func (sl *SortedList32) Slice(start, end int32) []S {",
      "\tif start < 0 {",
      "\t\tstart = 0",
      "\t}",
      "\tif end > sl.size {",
      "\t\tend = sl.size",
      "\t}",
      "\tif start >= end {",
      "\t\treturn nil",
      "\t}",
      "\tcount := end - start",
      "\tres := make([]S, 0, count)",
      "\tpos, index := sl._findKth(start)",
      "\tm := int32(len(sl.blocks))",
      "\tfor ; count > 0 && pos < m; pos++ {",
      "\t\tblock := sl.blocks[pos]",
      "\t\tendPos := min32(int32(len(block)), index+count)",
      "\t\tcurCount := endPos - index",
      "\t\tres = append(res, block[index:endPos]...)",
      "\t\tcount -= curCount",
      "\t\tindex = 0",
      "\t}",
      "\treturn res",
      "}",
      "",
      "func (sl *SortedList32) Range(min, max S) []S {",
      "\tif sl.less(max, min) {",
      "\t\treturn nil",
      "\t}",
      "\tres := []S{}",
      "\tpos := sl._locBlock(min)",
      "\tm := int32(len(sl.blocks))",
      "\tfor i := pos; i < m; i++ {",
      "\t\tblock := sl.blocks[i]",
      "\t\tfor j := 0; j < len(block); j++ {",
      "\t\t\tx := block[j]",
      "\t\t\tif sl.less(max, x) {",
      "\t\t\t\treturn res",
      "\t\t\t}",
      "\t\t\tif !sl.less(x, min) {",
      "\t\t\t\tres = append(res, x)",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "\treturn res",
      "}",
      "",
      "func (sl *SortedList32) Min() S {",
      "\tif sl.size == 0 {",
      "\t\tpanic(\"Min() called on empty SortedList\")",
      "\t}",
      "\treturn sl.mins[0]",
      "}",
      "",
      "func (sl *SortedList32) Max() S {",
      "\tif sl.size == 0 {",
      "\t\tpanic(\"Max() called on empty SortedList\")",
      "\t}",
      "\tlastBlock := sl.blocks[len(sl.blocks)-1]",
      "\treturn lastBlock[len(lastBlock)-1]",
      "}",
      "",
      "func (sl *SortedList32) String() string {",
      "\tsb := strings.Builder{}",
      "\tsb.WriteString(\"SortedList{\")",
      "\tsl.ForEach(func(value S, index int32) bool {",
      "\t\tif index > 0 {",
      "\t\t\tsb.WriteByte(',')",
      "\t\t}",
      "\t\tsb.WriteString(fmt.Sprintf(\"%v\", value))",
      "\t\treturn false",
      "\t}, false)",
      "\tsb.WriteByte('}')",
      "\treturn sb.String()",
      "}",
      "",
      "func (sl *SortedList32) Len() int32 {",
      "\treturn sl.size",
      "}",
      "",
      "func (sl *SortedList32) _delete(pos, index int32) {",
      "\t// !delete element",
      "\tsl.size--",
      "\tsl._updateTree(pos, -1)",
      "\tcopy(sl.blocks[pos][index:], sl.blocks[pos][index+1:])",
      "\tsl.blocks[pos] = sl.blocks[pos][:len(sl.blocks[pos])-1]",
      "\tif len(sl.blocks[pos]) > 0 {",
      "\t\tsl.mins[pos] = sl.blocks[pos][0]",
      "\t\treturn",
      "\t}",
      "",
      "\t// !delete block",
      "\tcopy(sl.blocks[pos:], sl.blocks[pos+1:])",
      "\tsl.blocks = sl.blocks[:len(sl.blocks)-1]",
      "\tcopy(sl.mins[pos:], sl.mins[pos+1:])",
      "\tsl.mins = sl.mins[:len(sl.mins)-1]",
      "\tsl.shouldRebuildTree = true",
      "}",
      "",
      "func (sl *SortedList32) _locLeft(value S) (pos, index int32) {",
      "\tif sl.size == 0 {",
      "\t\treturn",
      "\t}",
      "",
      "\t// find pos",
      "\tleft := int32(-1)",
      "\tright := int32(len(sl.blocks) - 1)",
      "\tfor left+1 < right {",
      "\t\tmid := (left + right) >> 1",
      "\t\tif !sl.less(sl.mins[mid], value) {",
      "\t\t\tright = mid",
      "\t\t} else {",
      "\t\t\tleft = mid",
      "\t\t}",
      "\t}",
      "\tif right > 0 {",
      "\t\tblock := sl.blocks[right-1]",
      "\t\tif !sl.less(block[len(block)-1], value) {",
      "\t\t\tright--",
      "\t\t}",
      "\t}",
      "\tpos = right",
      "",
      "\t// find index",
      "\tcur := sl.blocks[pos]",
      "\tleft = -1",
      "\tright = int32(len(cur))",
      "\tfor left+1 < right {",
      "\t\tmid := (left + right) >> 1",
      "\t\tif !sl.less(cur[mid], value) {",
      "\t\t\tright = mid",
      "\t\t} else {",
      "\t\t\tleft = mid",
      "\t\t}",
      "\t}",
      "",
      "\tindex = right",
      "\treturn",
      "}",
      "",
      "func (sl *SortedList32) _locRight(value S) (pos, index int32) {",
      "\tif sl.size == 0 {",
      "\t\treturn",
      "\t}",
      "",
      "\t// find pos",
      "\tleft := int32(0)",
      "\tright := int32(len(sl.blocks))",
      "\tfor left+1 < right {",
      "\t\tmid := (left + right) >> 1",
      "\t\tif sl.less(value, sl.mins[mid]) {",
      "\t\t\tright = mid",
      "\t\t} else {",
      "\t\t\tleft = mid",
      "\t\t}",
      "\t}",
      "\tpos = left",
      "",
      "\t// find index",
      "\tcur := sl.blocks[pos]",
      "\tleft = -1",
      "\tright = int32(len(cur))",
      "\tfor left+1 < right {",
      "\t\tmid := (left + right) >> 1",
      "\t\tif sl.less(value, cur[mid]) {",
      "\t\t\tright = mid",
      "\t\t} else {",
      "\t\t\tleft = mid",
      "\t\t}",
      "\t}",
      "",
      "\tindex = right",
      "\treturn",
      "}",
      "",
      "func (sl *SortedList32) _locBlock(value S) int32 {",
      "\tleft, right := int32(-1), int32(len(sl.blocks)-1)",
      "\tfor left+1 < right {",
      "\t\tmid := (left + right) >> 1",
      "\t\tif !sl.less(sl.mins[mid], value) {",
      "\t\t\tright = mid",
      "\t\t} else {",
      "\t\t\tleft = mid",
      "\t\t}",
      "\t}",
      "\tif right > 0 {",
      "\t\tblock := sl.blocks[right-1]",
      "\t\tif !sl.less(block[len(block)-1], value) {",
      "\t\t\tright--",
      "\t\t}",
      "\t}",
      "\treturn right",
      "}",
      "",
      "func (sl *SortedList32) _buildTree() {",
      "\tsl.tree = make([]int32, len(sl.blocks))",
      "\tfor i := 0; i < len(sl.blocks); i++ {",
      "\t\tsl.tree[i] = int32(len(sl.blocks[i]))",
      "\t}",
      "\ttree := sl.tree",
      "\tfor i := 0; i < len(tree); i++ {",
      "\t\tj := i | (i + 1)",
      "\t\tif j < len(tree) {",
      "\t\t\ttree[j] += tree[i]",
      "\t\t}",
      "\t}",
      "\tsl.shouldRebuildTree = false",
      "}",
      "",
      "func (sl *SortedList32) _updateTree(index, delta int32) {",
      "\tif sl.shouldRebuildTree {",
      "\t\treturn",
      "\t}",
      "\ttree := sl.tree",
      "\tm := int32(len(tree))",
      "\tfor i := index; i < m; i |= i + 1 {",
      "\t\ttree[i] += delta",
      "\t}",
      "}",
      "",
      "func (sl *SortedList32) _queryTree(end int32) int32 {",
      "\tif sl.shouldRebuildTree {",
      "\t\tsl._buildTree()",
      "\t}",
      "\ttree := sl.tree",
      "\tsum := int32(0)",
      "\tfor end > 0 {",
      "\t\tsum += tree[end-1]",
      "\t\tend &= end - 1",
      "\t}",
      "\treturn sum",
      "}",
      "",
      "func (sl *SortedList32) _findKth(k int32) (pos, index int32) {",
      "\tif k < int32(len(sl.blocks[0])) {",
      "\t\treturn 0, k",
      "\t}",
      "\tlast := int32(len(sl.blocks) - 1)",
      "\tlastLen := int32(len(sl.blocks[last]))",
      "\tif k >= sl.size-lastLen {",
      "\t\treturn last, k + lastLen - sl.size",
      "\t}",
      "\tif sl.shouldRebuildTree {",
      "\t\tsl._buildTree()",
      "\t}",
      "\ttree := sl.tree",
      "\tpos = -1",
      "\tbitLength := bits.Len32(uint32(len(tree)))",
      "\tfor d := bitLength - 1; d >= 0; d-- {",
      "\t\tnext := pos + (1 << d)",
      "\t\tif next < int32(len(tree)) && k >= tree[next] {",
      "\t\t\tpos = next",
      "\t\t\tk -= tree[pos]",
      "\t\t}",
      "\t}",
      "\treturn pos + 1, k",
      "}",
      "",
      "func (sl *SortedList32) _iteratorAt(pos, index int32) *Iterator {",
      "\treturn &Iterator{sl: sl, pos: pos, index: index}",
      "}",
      "",
      "func (sl *SortedList32) IteratorAt(index int32) *Iterator {",
      "\tif index < 0 {",
      "\t\tindex += sl.size",
      "\t}",
      "\tif index < 0 || index >= sl.size {",
      "\t\tpanic(\"Index out of range\")",
      "\t}",
      "\tpos, startIndex := sl._findKth(index)",
      "\treturn sl._iteratorAt(pos, startIndex)",
      "}",
      "",
      "// 返回一个迭代器，指向键值>= value的第一个元素.",
      "func (sl *SortedList32) LowerBound(value S) *Iterator {",
      "\tpos, index := sl._locLeft(value)",
      "\treturn sl._iteratorAt(pos, index)",
      "}",
      "",
      "// 返回一个迭代器，指向键值> value的第一个元素.",
      "func (sl *SortedList32) UpperBound(value S) *Iterator {",
      "\tpos, index := sl._locRight(value)",
      "\treturn sl._iteratorAt(pos, index)",
      "}",
      "",
      "type Iterator struct {",
      "\tsl\t\t*SortedList32",
      "\tpos\t int32",
      "\tindex int32",
      "}",
      "",
      "func (it *Iterator) HasNext() bool {",
      "\tb := it.sl.blocks",
      "\tm := int32(len(b))",
      "\tif it.pos < m-1 {",
      "\t\treturn true",
      "\t}",
      "\treturn it.pos == m-1 && it.index < int32(len(b[it.pos]))-1",
      "}",
      "",
      "func (it *Iterator) Next() {",
      "\tit.index++",
      "\tif it.index == int32(len(it.sl.blocks[it.pos])) {",
      "\t\tit.pos++",
      "\t\tit.index = 0",
      "\t}",
      "}",
      "",
      "func (it *Iterator) HasPrev() bool {",
      "\tif it.pos > 0 {",
      "\t\treturn true",
      "\t}",
      "\treturn it.pos == 0 && it.index > 0",
      "}",
      "",
      "func (it *Iterator) Prev() {",
      "\tit.index--",
      "\tif it.index == -1 {",
      "\t\tit.pos--",
      "\t\tit.index = int32(len(it.sl.blocks[it.pos]) - 1)",
      "\t}",
      "}",
      "",
      "func (it *Iterator) IsBegin() bool {",
      "\treturn it.pos == 0 && it.index == 0",
      "}",
      "",
      "func (it *Iterator) IsEnd() bool {",
      "\tm := int32(len(it.sl.blocks))",
      "\treturn it.pos == m && it.index == 0",
      "}",
      "",
      "// GetMut",
      "func (it *Iterator) Value() S {",
      "\treturn it.sl.blocks[it.pos][it.index]",
      "}",
      "",
      "func (it *Iterator) NextValue() S {",
      "\tnewPos, newIndex := it.pos, it.index",
      "\tnewIndex++",
      "\tif newIndex == int32(len(it.sl.blocks[it.pos])) {",
      "\t\tnewPos++",
      "\t\tnewIndex = 0",
      "\t}",
      "\treturn it.sl.blocks[newPos][newIndex]",
      "}",
      "",
      "func (it *Iterator) PrevValue() S {",
      "\tnewPos, newIndex := it.pos, it.index",
      "\tnewIndex--",
      "\tif newIndex == -1 {",
      "\t\tnewPos--",
      "\t\tnewIndex = int32(len(it.sl.blocks[newPos]) - 1)",
      "\t}",
      "\treturn it.sl.blocks[newPos][newIndex]",
      "}",
      "",
      "func (it *Iterator) ToIndex() int32 {",
      "\tres := it.sl._queryTree(it.pos)",
      "\treturn res + it.index",
      "}",
      "",
      "func (it *Iterator) Copy() *Iterator {",
      "\treturn &Iterator{sl: it.sl, pos: it.pos, index: it.index}",
      "}",
      "",
      "func min(a, b int) int {",
      "\tif a < b {",
      "\t\treturn a",
      "\t}",
      "\treturn b",
      "}",
      "",
      "func max(a, b int) int {",
      "\tif a > b {",
      "\t\treturn a",
      "\t}",
      "\treturn b",
      "}",
      "",
      "func min32(a, b int32) int32 {",
      "\tif a < b {",
      "\t\treturn a",
      "\t}",
      "\treturn b",
      "}",
      "",
      "func max32(a, b int32) int32 {",
      "\tif a > b {",
      "\t\treturn a",
      "\t}",
      "\treturn b",
      "}",
      ""
    ],
    "description": "SortedList32"
  },
  "DiscretizeSpecial": {
    "scope": "go",
    "prefix": ["DiscretizeSpecial", "CompressSpecial", "SpecialId"],
    "body": [
      "// 给定元素0~n-1,对数组中的某些特殊元素进行离散化.",
      "// 返回离散化后的数组id和id对应的值.",
      "// 特殊元素的id为0~len(idToV)-1, 非特殊元素的id为-1.",
      "func DiscretizeSpecial(n int32, isSpecial func(i int32) bool) (vToId []int32, idToV []int32) {",
      "\tvToId = make([]int32, n)",
      "\tidToV = []int32{}",
      "\tptr := int32(0)",
      "\tfor i := int32(0); i < n; i++ {",
      "\t\tif isSpecial(i) {",
      "\t\t\tvToId[i] = ptr",
      "\t\t\tptr++",
      "\t\t\tidToV = append(idToV, i)",
      "\t\t} else {",
      "\t\t\tvToId[i] = -1",
      "\t\t}",
      "\t}",
      "\tidToV = idToV[:len(idToV):len(idToV)]",
      "\treturn",
      "}"
    ],
    "description": "DiscretizeSpecial"
  },
  "discretizeSpecial": {
    "scope": "python",
    "prefix": "discretizeSpecial",
    "body": [
      "from typing import List, Tuple",
      "",
      "",
      "def discretizeSpecial(n: int, isSpecial: List[bool]) -> Tuple[List[int], List[int]]:",
      "\t\t\"\"\"Discretize arr to id array.",
      "",
      "\t\t>>> discretizeSpecial(5, [True, False, True, False, True])",
      "\t\t([0, -1, 1, -1, 2], [0, 2, 4])",
      "\t\t\"\"\"",
      "\t\tvToId = [-1] * n",
      "\t\tidToV = []",
      "\t\tfor i in range(n):",
      "\t\t\t\tif isSpecial[i]:",
      "\t\t\t\t\t\tvToId[i] = len(idToV)",
      "\t\t\t\t\t\tidToV.append(i)",
      "\t\treturn vToId, idToV"
    ],
    "description": "discretizeSpecial"
  },
  "findIndex": {
    "scope": "go",
    "prefix": ["findIndex", "findLastIndex"],
    "body": [
      "func findIndex(n int32, predicate func(index int32) bool) int32 {",
      "\tfor i := int32(0); i < n; i++ {",
      "\t\tif predicate(i) {",
      "\t\t\treturn i",
      "\t\t}",
      "\t}",
      "\treturn -1",
      "}",
      "",
      "func findLastIndex(n int32, predicate func(index int32) bool) int32 {",
      "\tfor i := n - 1; i >= 0; i-- {",
      "\t\tif predicate(i) {",
      "\t\t\treturn i",
      "\t\t}",
      "\t}",
      "\treturn -1",
      "}"
    ],
    "description": "findIndex"
  },
  "findIndex2D": {
    "scope": "go",
    "prefix": ["findIndex2D", "findLastIndex2D"],
    "body": [
      "func findIndex2D(row, col int32, predicate func(i, j int32) bool) (int32, int32) {",
      "\tfor i := int32(0); i < row; i++ {",
      "\t\tfor j := int32(0); j < col; j++ {",
      "\t\t\tif predicate(i, j) {",
      "\t\t\t\treturn i, j",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "\treturn -1, -1",
      "}",
      "",
      "func findLastIndex2D(row, col int32, predicate func(i, j int32) bool) (int32, int32) {",
      "\tfor i := row - 1; i >= 0; i-- {",
      "\t\tfor j := col - 1; j >= 0; j-- {",
      "\t\t\tif predicate(i, j) {",
      "\t\t\t\treturn i, j",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "\treturn -1, -1",
      "}"
    ],
    "description": "findIndex2D"
  },
  "discretizeSpecial-ts": {
    "scope": "typescript",
    "prefix": "discretizeSpecial",
    "body": [
      "/**",
      " * 给定元素 `0 ~ n-1`,对数组中的某些特殊元素进行离散化.",
      " *",
      " * @returns 返回离散化后的数组id和id对应的值.",
      " * 特殊元素的id为`0 ~ len(idToV)-1`, 非特殊元素的id为`-1`.",
      " */",
      "function discretizeSpecial(",
      "\tn: number,",
      "\tisSpecial: (i: number) => boolean",
      "): [vToId: number[], idToV: number[]] {",
      "\tconst vToId = Array<number>(n)",
      "\tconst idToV: number[] = []",
      "\tfor (let i = 0; i < n; i++) {",
      "\t\tif (isSpecial(i)) {",
      "\t\t\tvToId[i] = idToV.length",
      "\t\t\tidToV.push(i)",
      "\t\t} else {",
      "\t\t\tvToId[i] = -1",
      "\t\t}",
      "\t}",
      "\treturn [vToId, idToV]",
      "}"
    ],
    "description": "discretizeSpecial"
  },
  "slices-Equal": {
    "scope": "go",
    "prefix": ["Equal", "EqualFunc"],
    "body": [
      "$1",
      "func Equal[S ~[]E, E comparable](s1, s2 S) bool {",
      "\tif len(s1) != len(s2) {",
      "\t\treturn false",
      "\t}",
      "\tfor i := range s1 {",
      "\t\tif s1[i] != s2[i] {",
      "\t\t\treturn false",
      "\t\t}",
      "\t}",
      "\treturn true",
      "}",
      "",
      "func EqualFunc[S1 ~[]E1, S2 ~[]E2, E1, E2 any](s1 S1, s2 S2, eq func(E1, E2) bool) bool {",
      "\tif len(s1) != len(s2) {",
      "\t\treturn false",
      "\t}",
      "\tfor i, v1 := range s1 {",
      "\t\tv2 := s2[i]",
      "\t\tif !eq(v1, v2) {",
      "\t\t\treturn false",
      "\t\t}",
      "\t}",
      "\treturn true",
      "}"
    ],
    "description": "Equal"
  },
  "cmp-Ordered": {
    "scope": "go",
    "prefix": "Ordered",
    "body": [
      "$1",
      "type Ordered interface {",
      "\t~int | ~int8 | ~int16 | ~int32 | ~int64 |",
      "\t\t~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64 | ~uintptr |",
      "\t\t~float32 | ~float64 |",
      "\t\t~string",
      "}",
      ""
    ],
    "description": "Ordered"
  },
  "slices-Compare": {
    "scope": "go",
    "prefix": ["Compare", "CompareFunc"],
    "body": [
      "$1",
      "type Ordered interface {",
      "\t~int | ~int8 | ~int16 | ~int32 | ~int64 |",
      "\t\t~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64 | ~uintptr |",
      "\t\t~float32 | ~float64 |",
      "\t\t~string",
      "}",
      "",
      "func Compare[S ~[]E, E Ordered](s1, s2 S) int {",
      "\tfor i, v1 := range s1 {",
      "\t\tif i >= len(s2) {",
      "\t\t\treturn +1",
      "\t\t}",
      "\t\tv2 := s2[i]",
      "\t\tif c := cmpCompare(v1, v2); c != 0 {",
      "\t\t\treturn c",
      "\t\t}",
      "\t}",
      "\tif len(s1) < len(s2) {",
      "\t\treturn -1",
      "\t}",
      "\treturn 0",
      "}",
      "",
      "// CompareFunc is like [Compare] but uses a custom comparison function on each",
      "// pair of elements.",
      "// The result is the first non-zero result of cmp; if cmp always",
      "// returns 0 the result is 0 if len(s1) == len(s2), -1 if len(s1) < len(s2),",
      "// and +1 if len(s1) > len(s2).",
      "func CompareFunc[S1 ~[]E1, S2 ~[]E2, E1, E2 any](s1 S1, s2 S2, cmp func(E1, E2) int) int {",
      "\tfor i, v1 := range s1 {",
      "\t\tif i >= len(s2) {",
      "\t\t\treturn +1",
      "\t\t}",
      "\t\tv2 := s2[i]",
      "\t\tif c := cmp(v1, v2); c != 0 {",
      "\t\t\treturn c",
      "\t\t}",
      "\t}",
      "\tif len(s1) < len(s2) {",
      "\t\treturn -1",
      "\t}",
      "\treturn 0",
      "}",
      "",
      "func cmpCompare[T Ordered](x, y T) int {",
      "\tif x < y {",
      "\t\treturn -1",
      "\t}",
      "\tif x > y {",
      "\t\treturn +1",
      "\t}",
      "\treturn 0",
      "}"
    ],
    "description": "Compare"
  },
  "slices-Index": {
    "scope": "go",
    "prefix": ["IndexOf", "IndexOfFunc"],
    "body": [
      "$1",
      "// Index returns the index of the first occurrence of v in s,",
      "// or -1 if not present.",
      "func IndexOf[S ~[]E, E comparable](s S, v E) int32 {",
      "\tn := int32(len(s))",
      "\tfor i := int32(0); i < n; i++ {",
      "\t\tif v == s[i] {",
      "\t\t\treturn i",
      "\t\t}",
      "\t}",
      "\treturn -1",
      "}",
      "",
      "// IndexFunc returns the first index i satisfying f(s[i]),",
      "// or -1 if none do.",
      "func IndexOfFunc[S ~[]E, E any](s S, f func(E) bool) int32 {",
      "\tn := int32(len(s))",
      "\tfor i := int32(0); i < n; i++ {",
      "\t\tif f(s[i]) {",
      "\t\t\treturn i",
      "\t\t}",
      "\t}",
      "\treturn -1",
      "}"
    ],
    "description": "IndexOf"
  },
  "slices-LastIndex": {
    "scope": "go",
    "prefix": ["LastIndexOf", "LastIndexOfFunc"],
    "body": [
      "$1",
      "// LastIndexOf returns the index of the last occurrence of v in s,",
      "// or -1 if not present.",
      "func LastIndexOf[S ~[]E, E comparable](s S, v E) int32 {",
      "\tn := int32(len(s))",
      "\tfor i := n - 1; i >= 0; i-- {",
      "\t\tif v == s[i] {",
      "\t\t\treturn i",
      "\t\t}",
      "\t}",
      "\treturn -1",
      "}",
      "",
      "// LastIndexOfFunc returns the last index i satisfying f(s[i]),",
      "// or -1 if none do.",
      "func LastIndexOfFunc[S ~[]E, E any](s S, f func(E) bool) int32 {",
      "\tn := int32(len(s))",
      "\tfor i := n - 1; i >= 0; i-- {",
      "\t\tif f(s[i]) {",
      "\t\t\treturn i",
      "\t\t}",
      "\t}",
      "\treturn -1",
      "}"
    ],
    "description": "LastIndexOf"
  },
  "slices-Insert": {
    "scope": "go",
    "prefix": "Insert",
    "body": [
      "$1",
      "// Insert inserts the values v... into s at index i,",
      "// !returning the modified slice.",
      "// The elements at s[i:] are shifted up to make room.",
      "// In the returned slice r, r[i] == v[0],",
      "// and r[i+len(v)] == value originally at r[i].",
      "// This function is O(len(s) + len(v)).",
      "func Insert[S ~[]E, E any](s S, i int, v ...E) S {",
      "\tif i < 0 {",
      "\t\ti = 0",
      "\t}",
      "\tif i > len(s) {",
      "\t\ti = len(s)",
      "\t}",
      "",
      "\tm := len(v)",
      "\tif m == 0 {",
      "\t\treturn s",
      "\t}",
      "\tn := len(s)",
      "\tif i == n {",
      "\t\treturn append(s, v...)",
      "\t}",
      "\tif n+m > cap(s) {",
      "\t\ts2 := append(s[:i], make(S, n+m-i)...)",
      "\t\tcopy(s2[i:], v)",
      "\t\tcopy(s2[i+m:], s[i:])",
      "\t\treturn s2",
      "\t}",
      "\ts = s[:n+m]",
      "\tif !overlaps(v, s[i+m:]) {",
      "\t\tcopy(s[i+m:], s[i:])",
      "\t\tcopy(s[i:], v)",
      "\t\treturn s",
      "\t}",
      "\tcopy(s[n:], v)",
      "\trotateRight(s[i:], m)",
      "\treturn s",
      "}",
      "",
      "func overlaps[E any](a, b []E) bool {",
      "\tif len(a) == 0 || len(b) == 0 {",
      "\t\treturn false",
      "\t}",
      "\telemSize := unsafe.Sizeof(a[0])",
      "\tif elemSize == 0 {",
      "\t\treturn false",
      "\t}",
      "\treturn uintptr(unsafe.Pointer(&a[0])) <= uintptr(unsafe.Pointer(&b[len(b)-1]))+(elemSize-1) &&",
      "\t\tuintptr(unsafe.Pointer(&b[0])) <= uintptr(unsafe.Pointer(&a[len(a)-1]))+(elemSize-1)",
      "}",
      "",
      "func rotateLeft[E any](s []E, r int) {",
      "\tfor r != 0 && r != len(s) {",
      "\t\tif r*2 <= len(s) {",
      "\t\t\tswap(s[:r], s[len(s)-r:])",
      "\t\t\ts = s[:len(s)-r]",
      "\t\t} else {",
      "\t\t\tswap(s[:len(s)-r], s[r:])",
      "\t\t\ts, r = s[len(s)-r:], r*2-len(s)",
      "\t\t}",
      "\t}",
      "}",
      "",
      "func rotateRight[E any](s []E, r int) {",
      "\trotateLeft(s, len(s)-r)",
      "}",
      "",
      "func swap[E any](x, y []E) {",
      "\tfor i := 0; i < len(x); i++ {",
      "\t\tx[i], y[i] = y[i], x[i]",
      "\t}",
      "}",
      ""
    ],
    "description": "slices-Insert"
  },
  "slices-Delete": {
    "scope": "go",
    "prefix": ["Delete", "DeleteFunc", "Remove"],
    "body": [
      "$1",
      "func Delete[S ~[]E, E any](s S, i, j int) S {",
      "\tif i < 0 {",
      "\t\ti = 0",
      "\t}",
      "\tif j > len(s) {",
      "\t\tj = len(s)",
      "\t}",
      "\tif i >= j {",
      "\t\treturn s",
      "\t}",
      "",
      "\toldlen := len(s)",
      "\ts = append(s[:i], s[j:]...)",
      "\tclear(s[len(s):oldlen])",
      "\treturn s",
      "}",
      "",
      "func DeleteFunc[S ~[]E, E any](s S, del func(E) bool) S {",
      "\ti := func() int {",
      "\t\tfor i, v := range s {",
      "\t\t\tif del(v) {",
      "\t\t\t\treturn i",
      "\t\t\t}",
      "\t\t}",
      "\t\treturn -1",
      "\t}()",
      "\tif i == -1 {",
      "\t\treturn s",
      "\t}",
      "\tfor j := i + 1; j < len(s); j++ {",
      "\t\tif v := s[j]; !del(v) {",
      "\t\t\ts[i] = v",
      "\t\t\ti++",
      "\t\t}",
      "\t}",
      "\tclear(s[i:])",
      "\treturn s[:i]",
      "}"
    ],
    "description": "Delete"
  },
  "slices-Replace": {
    "scope": "go",
    "prefix": ["Replace", "Splice"],
    "body": [
      "$1",
      "// Replace replaces the elements s[i:j] by the given v, and returns the modified slice.",
      "// !Like JavaScirpt's Array.prototype.splice.",
      "func Replace[S ~[]E, E any](s S, i, j int, v ...E) S {",
      "\tif i < 0 {",
      "\t\ti = 0",
      "\t}",
      "\tif j > len(s) {",
      "\t\tj = len(s)",
      "\t}",
      "\tif i == j {",
      "\t\treturn Insert(s, i, v...)",
      "\t}",
      "\tif j == len(s) {",
      "\t\treturn append(s[:i], v...)",
      "\t}",
      "\ttot := len(s[:i]) + len(v) + len(s[j:])",
      "\tif tot > cap(s) {",
      "\t\ts2 := append(s[:i], make(S, tot-i)...)",
      "\t\tcopy(s2[i:], v)",
      "\t\tcopy(s2[i+len(v):], s[j:])",
      "\t\treturn s2",
      "\t}",
      "\tr := s[:tot]",
      "\tif i+len(v) <= j {",
      "\t\tcopy(r[i:], v)",
      "\t\tcopy(r[i+len(v):], s[j:])",
      "\t\tclear(s[tot:])",
      "\t\treturn r",
      "\t}",
      "\tif !overlaps(r[i+len(v):], v) {",
      "\t\tcopy(r[i+len(v):], s[j:])",
      "\t\tcopy(r[i:], v)",
      "\t\treturn r",
      "\t}",
      "\ty := len(v) - (j - i)",
      "\tif !overlaps(r[i:j], v) {",
      "\t\tcopy(r[i:j], v[y:])",
      "\t\tcopy(r[len(s):], v[:y])",
      "\t\trotateRight(r[i:], y)",
      "\t\treturn r",
      "\t}",
      "\tif !overlaps(r[len(s):], v) {",
      "\t\tcopy(r[len(s):], v[:y])",
      "\t\tcopy(r[i:j], v[y:])",
      "\t\trotateRight(r[i:], y)",
      "\t\treturn r",
      "\t}",
      "\tk := startIdx(v, s[j:])",
      "\tcopy(r[i:], v)",
      "\tcopy(r[i+len(v):], r[i+k:])",
      "\treturn r",
      "}",
      "",
      "func rotateLeft[E any](s []E, r int) {",
      "\tfor r != 0 && r != len(s) {",
      "\t\tif r*2 <= len(s) {",
      "\t\t\tswap(s[:r], s[len(s)-r:])",
      "\t\t\ts = s[:len(s)-r]",
      "\t\t} else {",
      "\t\t\tswap(s[:len(s)-r], s[r:])",
      "\t\t\ts, r = s[len(s)-r:], r*2-len(s)",
      "\t\t}",
      "\t}",
      "}",
      "",
      "func rotateRight[E any](s []E, r int) {",
      "\trotateLeft(s, len(s)-r)",
      "}",
      "",
      "func swap[E any](x, y []E) {",
      "\tfor i := 0; i < len(x); i++ {",
      "\t\tx[i], y[i] = y[i], x[i]",
      "\t}",
      "}",
      "",
      "func overlaps[E any](a, b []E) bool {",
      "\tif len(a) == 0 || len(b) == 0 {",
      "\t\treturn false",
      "\t}",
      "\telemSize := unsafe.Sizeof(a[0])",
      "\tif elemSize == 0 {",
      "\t\treturn false",
      "\t}",
      "\treturn uintptr(unsafe.Pointer(&a[0])) <= uintptr(unsafe.Pointer(&b[len(b)-1]))+(elemSize-1) &&",
      "\t\tuintptr(unsafe.Pointer(&b[0])) <= uintptr(unsafe.Pointer(&a[len(a)-1]))+(elemSize-1)",
      "}",
      "",
      "func startIdx[E any](haystack, needle []E) int {",
      "\tp := &needle[0]",
      "\tfor i := range haystack {",
      "\t\tif p == &haystack[i] {",
      "\t\t\treturn i",
      "\t\t}",
      "\t}",
      "\tpanic(\"needle not found\")",
      "}",
      "",
      "func Insert[S []E, E any](s S, i int, v ...E) S {",
      "\tif i < 0 {",
      "\t\ti = 0",
      "\t}",
      "\tif i > len(s) {",
      "\t\ti = len(s)",
      "\t}",
      "",
      "\tm := len(v)",
      "\tif m == 0 {",
      "\t\treturn s",
      "\t}",
      "\tn := len(s)",
      "\tif i == n {",
      "\t\treturn append(s, v...)",
      "\t}",
      "\tif n+m > cap(s) {",
      "\t\ts2 := append(s[:i], make(S, n+m-i)...)",
      "\t\tcopy(s2[i:], v)",
      "\t\tcopy(s2[i+m:], s[i:])",
      "\t\treturn s2",
      "\t}",
      "\ts = s[:n+m]",
      "\tif !overlaps(v, s[i+m:]) {",
      "\t\tcopy(s[i+m:], s[i:])",
      "\t\tcopy(s[i:], v)",
      "\t\treturn s",
      "\t}",
      "\tcopy(s[n:], v)",
      "\trotateRight(s[i:], m)",
      "\treturn s",
      "}",
      ""
    ],
    "description": "Replace"
  },
  "slices-Clone": {
    "scope": "go",
    "prefix": ["Copy", "Clone"],
    "body": [
      "$1",
      "// Shallow clone.",
      "func Clone[S ~[]E, E any](s S) S {",
      "\treturn append(s[:0:0], s...)",
      "}"
    ],
    "description": "Clone"
  },
  "slices-Compact": {
    "scope": "go",
    "prefix": ["Compact", "CompactFunc", "Dedup"],
    "body": [
      "$1",
      "// !Like Rust's Vec::dedup.",
      "func Compact[S ~[]E, E comparable](s S) S {",
      "\tif len(s) < 2 {",
      "\t\treturn s",
      "\t}",
      "\ti := 1",
      "\tfor k := 1; k < len(s); k++ {",
      "\t\tif s[k] != s[k-1] {",
      "\t\t\tif i != k {",
      "\t\t\t\ts[i] = s[k]",
      "\t\t\t}",
      "\t\t\ti++",
      "\t\t}",
      "\t}",
      "\tclear(s[i:])",
      "\treturn s[:i]",
      "}",
      "",
      "// !Like Rust's Vec::dedup_by.",
      "func CompactFunc[S ~[]E, E any](s S, eq func(E, E) bool) S {",
      "\tif len(s) < 2 {",
      "\t\treturn s",
      "\t}",
      "\ti := 1",
      "\tfor k := 1; k < len(s); k++ {",
      "\t\tif !eq(s[k], s[k-1]) {",
      "\t\t\tif i != k {",
      "\t\t\t\ts[i] = s[k]",
      "\t\t\t}",
      "\t\t\ti++",
      "\t\t}",
      "\t}",
      "\tclear(s[i:])",
      "\treturn s[:i]",
      "}"
    ],
    "description": "Compact"
  },
  "slices-Grow": {
    "scope": "go",
    "prefix": "Grow",
    "body": [
      "// After Grow(n), at least n elements can be appended to the slice without another allocation.",
      "func Grow[S ~[]E, E any](s S, n int) S {",
      "\tif n < 0 {",
      "\t\treturn s",
      "\t}",
      "\tif n -= cap(s) - len(s); n > 0 {",
      "\t\ts = append(s[:cap(s)], make([]E, n)...)[:len(s)]",
      "\t}",
      "\treturn s",
      "}"
    ],
    "description": "grow"
  },
  "slices-Clip": {
    "scope": "go",
    "prefix": "Clip",
    "body": [
      "// Clip removes unused capacity from the slice, returning s[:len(s):len(s)].",
      "func Clip[S ~[]E, E any](s S) S {",
      "\treturn s[:len(s):len(s)]",
      "}"
    ],
    "description": "Clip"
  },
  "slices-Rotate": {
    "scope": "go",
    "prefix": ["RotateLeft", "RotateRight"],
    "body": [
      "// rotateLeft rotates b left by n spaces.",
      "// s_final[i] = s_orig[i+r], wrapping around.",
      "func RotateLeft[E any](s []E, r int) {",
      "\tn := len(s)",
      "\tif n == 0 {",
      "\t\treturn",
      "\t}",
      "\tif r > n {",
      "\t\tr %= n",
      "\t}",
      "\tfor r != 0 && r != len(s) {",
      "\t\tif r*2 <= len(s) {",
      "\t\t\tswap(s[:r], s[len(s)-r:])",
      "\t\t\ts = s[:len(s)-r]",
      "\t\t} else {",
      "\t\t\tswap(s[:len(s)-r], s[r:])",
      "\t\t\ts, r = s[len(s)-r:], r*2-len(s)",
      "\t\t}",
      "\t}",
      "}",
      "",
      "func RotateRight[E any](s []E, r int) {",
      "\tn := len(s)",
      "\tif n == 0 {",
      "\t\treturn",
      "\t}",
      "\tif r > n {",
      "\t\tr %= n",
      "\t}",
      "\tRotateLeft(s, len(s)-r)",
      "}",
      "",
      "func swap[E any](x, y []E) {",
      "\tfor i := 0; i < len(x); i++ {",
      "\t\tx[i], y[i] = y[i], x[i]",
      "\t}",
      "}"
    ],
    "description": "Rotate"
  },
  "slices-Concat": {
    "scope": "go",
    "prefix": "Concat",
    "body": [
      "// Concat returns a new slice concatenating the passed in slices.",
      "func Concat[S ~[]E, E any](slices ...S) S {",
      "\tsize := 0",
      "\tfor _, s := range slices {",
      "\t\tsize += len(s)",
      "\t}",
      "\tnewslice := grow[S](nil, size)",
      "\tfor _, s := range slices {",
      "\t\tnewslice = append(newslice, s...)",
      "\t}",
      "\treturn newslice",
      "}",
      "",
      "func grow[S ~[]E, E any](s S, n int) S {",
      "\tif n < 0 {",
      "\t\treturn s",
      "\t}",
      "\tif n -= cap(s) - len(s); n > 0 {",
      "\t\ts = append(s[:cap(s)], make([]E, n)...)[:len(s)]",
      "\t}",
      "\treturn s",
      "}"
    ],
    "description": "Concat"
  },
  "constraints": {
    "scope": "go",
    "prefix": ["constraints", "Signed", "Unsigned", "Integer", "Float", "Complex", "Ordered"],
    "body": [
      "$1",
      "// Signed is a constraint that permits any signed integer type.",
      "// If future releases of Go add new predeclared signed integer types,",
      "// this constraint will be modified to include them.",
      "type Signed interface {",
      "\t~int | ~int8 | ~int16 | ~int32 | ~int64",
      "}",
      "",
      "// Unsigned is a constraint that permits any unsigned integer type.",
      "// If future releases of Go add new predeclared unsigned integer types,",
      "// this constraint will be modified to include them.",
      "type Unsigned interface {",
      "\t~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64 | ~uintptr",
      "}",
      "",
      "// Integer is a constraint that permits any integer type.",
      "// If future releases of Go add new predeclared integer types,",
      "// this constraint will be modified to include them.",
      "type Integer interface {",
      "\tSigned | Unsigned",
      "}",
      "",
      "// Float is a constraint that permits any floating-point type.",
      "// If future releases of Go add new predeclared floating-point types,",
      "// this constraint will be modified to include them.",
      "type Float interface {",
      "\t~float32 | ~float64",
      "}",
      "",
      "// Complex is a constraint that permits any complex numeric type.",
      "// If future releases of Go add new predeclared complex numeric types,",
      "// this constraint will be modified to include them.",
      "type Complex interface {",
      "\t~complex64 | ~complex128",
      "}",
      "",
      "// Ordered is a constraint that permits any ordered type: any type",
      "// that supports the operators < <= >= >.",
      "// If future releases of Go add new ordered types,",
      "// this constraint will be modified to include them.",
      "type Ordered interface {",
      "\tInteger | Float | ~string",
      "}",
      ""
    ],
    "description": "constraints"
  },
  "slices-MinMax": {
    "scope": "go",
    "prefix": ["Mins", "Maxs"],
    "body": [
      "$1",
      "type Ordered interface {",
      "\t~int | ~int8 | ~int16 | ~int32 | ~int64 |",
      "\t\t~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64 | ~uintptr |",
      "\t\t~float32 | ~float64 |",
      "\t\t~string",
      "}",
      "",
      "func Mins[S ~[]E, E Ordered](x S) E {",
      "\tif len(x) < 1 {",
      "\t\tpanic(\"slices.Min: empty list\")",
      "\t}",
      "\tm := x[0]",
      "\tfor i := 1; i < len(x); i++ {",
      "\t\tif x[i] < m {",
      "\t\t\tm = x[i]",
      "\t\t}",
      "\t}",
      "\treturn m",
      "}",
      "",
      "func Maxs[S ~[]E, E Ordered](x S) E {",
      "\tif len(x) < 1 {",
      "\t\tpanic(\"slices.Max: empty list\")",
      "\t}",
      "\tm := x[0]",
      "\tfor i := 1; i < len(x); i++ {",
      "\t\tif x[i] > m {",
      "\t\t\tm = x[i]",
      "\t\t}",
      "\t}",
      "\treturn m",
      "}"
    ],
    "description": "MinMax"
  },
  "SlidingWindowContainsAll-go": {
    "scope": "go",
    "prefix": "SlidingWindowContainsAll",
    "body": [
      "$1",
      "// 支持新增元素、删除元素、快速判断容器内是否包含了指定的所有元素.",
      "type SlidingWindowContainsAll[T comparable] struct {",
      "\tmissingCount int32",
      "\tmissing\t\t\tmap[T]int32",
      "}",
      "",
      "func NewSlidingWindowContainsAll[T comparable](n int32, supplier func(i int32) T) *SlidingWindowContainsAll[T] {",
      "\tmissing := make(map[T]int32)",
      "\tfor i := int32(0); i < n; i++ {",
      "\t\tmissing[supplier(i)]++",
      "\t}",
      "\tmissingCount := int32(len(missing))",
      "\treturn &SlidingWindowContainsAll[T]{missingCount: missingCount, missing: missing}",
      "}",
      "",
      "func (s *SlidingWindowContainsAll[T]) Add(v T) bool {",
      "\tif pre, has := s.missing[v]; !has {",
      "\t\treturn false",
      "\t} else {",
      "\t\ts.missing[v] = pre - 1",
      "\t\tif pre == 1 {",
      "\t\t\ts.missingCount--",
      "\t\t}",
      "\t\treturn true",
      "\t}",
      "}",
      "",
      "func (s *SlidingWindowContainsAll[T]) Discard(v T) bool {",
      "\tif pre, has := s.missing[v]; !has {",
      "\t\treturn false",
      "\t} else {",
      "\t\ts.missing[v] = pre + 1",
      "\t\tif pre == 0 {",
      "\t\t\ts.missingCount++",
      "\t\t}",
      "\t\treturn true",
      "\t}",
      "}",
      "",
      "func (s *SlidingWindowContainsAll[T]) ContainsAll() bool {",
      "\treturn s.missingCount == 0",
      "}"
    ],
    "description": "SlidingWindowContainsAll"
  },
  "SlidingWindowContainsAll-py": {
    "scope": "python",
    "prefix": "SlidingWindowContainsAll",
    "body": [
      "$1",
      "class SlidingWindowContainsAll:",
      "\t\t\"\"\"",
      "\t\t支持新增元素、删除元素、快速判断容器内是否包含了指定的所有元素.",
      "\t\t\"\"\"",
      "",
      "\t\t__slots__ = \"_missingCount\", \"_missing\"",
      "",
      "\t\tdef __init__(self, supplier):",
      "\t\t\t\tself._missing = dict()",
      "\t\t\t\tfor v in supplier:",
      "\t\t\t\t\t\tself._missing[v] = self._missing.get(v, 0) + 1",
      "\t\t\t\tself._missingCount = len(self._missing)",
      "",
      "\t\tdef add(self, v) -> bool:",
      "\t\t\t\tc = self._missing.get(v, None)",
      "\t\t\t\tif c is None:",
      "\t\t\t\t\t\treturn False",
      "\t\t\t\tself._missing[v] = c - 1",
      "\t\t\t\tif c == 1:",
      "\t\t\t\t\t\tself._missingCount -= 1",
      "\t\t\t\treturn True",
      "",
      "\t\tdef discard(self, v) -> bool:",
      "\t\t\t\tc = self._missing.get(v, None)",
      "\t\t\t\tif c is None:",
      "\t\t\t\t\t\treturn False",
      "\t\t\t\tself._missing[v] = c + 1",
      "\t\t\t\tif c == 0:",
      "\t\t\t\t\t\tself._missingCount += 1",
      "\t\t\t\treturn True",
      "",
      "\t\tdef containsAll(self) -> bool:",
      "\t\t\t\treturn self._missingCount == 0"
    ],
    "description": "SlidingWindowContainsAll"
  },
  "SlidingWindowContainsAll-ts": {
    "scope": "typescript",
    "prefix": "SlidingWindowContainsAll",
    "body": [
      "class SlidingWindowContainsAll<T> {",
      "\tprivate _missingCount: number",
      "\tprivate readonly _missing: Map<T, number>",
      "",
      "\tconstructor(n: number, supplier: (i: number) => T) {",
      "\t\tthis._missing = new Map()",
      "\t\tfor (let i = 0; i < n; i++) {",
      "\t\t\tconst v = supplier(i)",
      "\t\t\tthis._missing.set(v, (this._missing.get(v) || 0) + 1)",
      "\t\t}",
      "\t\tthis._missingCount = this._missing.size",
      "\t}",
      "",
      "\tadd(v: T): boolean {",
      "\t\tconst c = this._missing.get(v)",
      "\t\tif (c === undefined) return false",
      "\t\tthis._missing.set(v, c - 1)",
      "\t\tif (c === 1) this._missingCount--",
      "\t\treturn true",
      "\t}",
      "",
      "\tdiscard(v: T): boolean {",
      "\t\tconst c = this._missing.get(v)",
      "\t\tif (c === undefined) return false",
      "\t\tthis._missing.set(v, c + 1)",
      "\t\tif (c === 0) this._missingCount++",
      "\t\treturn true",
      "\t}",
      "",
      "\tcontainsAll(): boolean {",
      "\t\treturn this._missingCount === 0",
      "\t}",
      "}"
    ],
    "description": "SlidingWindowContainsAll"
  },
  "vowel-py": {
    "scope": "python",
    "prefix": "vowel",
    "body": [
      "VOWEL = \"aeiou\"",
      "",
      "",
      "def isVowel(c: str) -> bool:",
      "\t\treturn c == \"a\" or c == \"e\" or c == \"i\" or c == \"o\" or c == \"u\"",
      "",
      "",
      "def isConsonant(c: str) -> bool:",
      "\t\treturn not isVowel(c)"
    ],
    "description": "vowel"
  },
  "vowel-go": {
    "scope": "go",
    "prefix": "vowel",
    "body": [
      "const VOWEL = \"aeiou\"",
      "",
      "func isVowel(c byte) bool {",
      "\treturn c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'",
      "}"
    ],
    "description": "vowel"
  }
}
