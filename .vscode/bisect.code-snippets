{
  // Place your js-algorithm 工作区 snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and
  // description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope
  // is left empty or omitted, the snippet gets applied to all languages. The prefix is what is
  // used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
  // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders.
  // Placeholders with the same ids are connected.
  // Example:
  "最左二分": {
    "scope": "python",
    "prefix": "bisect1",
    "body": [
      "def check(mid: int) -> bool:",
      "  res = 0",
      "  for num in nums:",
      "    res += num // mid",
      "  return res >= k",
      "",
      "left, right = 0, int(1e18)",
      "ok = False",
      "while left <= right:",
      "  mid = (left + right) // 2",
      "  if check(mid):",
      "    right = mid - 1",
      "    ok = True",
      "  else:",
      "    left = mid + 1",
      "return left"
    ],
    "description": "最左二分"
  },
  "最右二分": {
    "scope": "python",
    "prefix": "bisect2",
    "body": [
      "def check(mid: int) -> bool:",
      "  res = 0",
      "  for num in nums:",
      "    res += num // mid",
      "  return res >= k",
      "",
      "left, right = 1, int(1e18)",
      "ok = False",
      "while left <= right:",
      "  mid = (left + right) // 2",
      "  if check(mid):",
      "    left = mid + 1",
      "    ok = True",
      "  else:",
      "    right = mid - 1",
      "return right"
    ],
    "description": "最右二分"
  },
  "reArrange-py": {
    "scope": "python",
    "prefix": "rearrange",
    "body": [
      "def rearrange(A, order: List[int]):",
      "  '''将数组按照order里的顺序重新排序.'''",
      "  res = [None] * len(A)",
      "  for i in range(len(order)):",
      "    res[i] = A[order[i]]",
      "  return res"
    ],
    "description": "将数组按照order里的顺序重新排序."
  },
  "第k小的数,k从1开始": {
    "scope": "python",
    "prefix": "bisectKth",
    "body": [
      "def countNGT(mid: int) -> int:",
      "  '''有多少个不超过mid的候选'''",
      "  res = 0",
      "  return res",
      "",
      "left, right = 0, int(1e18)",
      "while left <= right:",
      "  mid = (left + right) // 2",
      "  if countNGT(mid) < k:",
      "    left = mid + 1",
      "  else:",
      "    right = mid - 1",
      "return left"
    ],
    "description": "二分查找第k小的数,k从1开始"
  },
  "遍历子集": {
    "scope": "typescript,typescriptreact",
    "prefix": ["subset", "enumerateSubset", "枚举子集", "子集"],
    "body": [
      "/**",
      " * 遍历子集.",
      " * @param copy 是否复制子集.",
      " * @complexity O(2^n), 2^27(1.3e8) => 1.1s.",
      " */",
      "function enumerateSubset<T>(",
      "  nums: ArrayLike<T>,",
      "  callback: (subset: T[]) => void,",
      "  copy = false",
      "): void {",
      "  const n = nums.length",
      "  dfs(0, [])",
      "  function dfs(index: number, path: T[]) {",
      "    if (index === n) {",
      "      callback(copy ? path.slice() : path)",
      "      return",
      "    }",
      "    dfs(index + 1, path)",
      "    path.push(nums[index])",
      "    dfs(index + 1, path)",
      "    path.pop()",
      "  }",
      "}"
    ],
    "description": "遍历子集"
  },
  "前后缀分解": {
    "scope": "python",
    "prefix": "makeDp",
    "body": [
      "from typing import List",
      "def makeDp(seq: List[int], rev=True) -> List[int]:",
      "    n = len(seq)",
      "    dp = [0] * (n + 1)",
      "    for i in range(n):",
      "        cur = seq[i]",
      "        # your code here",
      "    return dp",
      "",
      "pre, suf = makeDp(nums, False), makeDp(nums[::-1])[::-1]",
      "res = 0",
      "for i in range(len(pre)):  # 枚举分割点",
      "    res += pre[i] * suf[i]"
    ],
    "description": "前后缀分解,适用于dp逻辑复杂的情况"
  },
  "记忆化dfsIndexRemain": {
    "scope": "python",
    "prefix": "dfsIndexRemain",
    "body": [
      "@lru_cache(None)",
      "def dfs(index: int, remain: int) -> int:",
      "  if remain < 0:",
      "    return 0",
      "  if index == n:",
      "    return 1 if remain == 0 else 0",
      "",
      "  res = 0",
      "  return res",
      "",
      "res = dfs(0, k)",
      "dfs.cache_clear()",
      "return res"
    ],
    "description": "将区间[0,n)分成 k 组的最小代价"
  },
  // !dp[k][j]=min(dp[k-1][i]+f(i,j)) (0<=i<j<=n)
  "dp数组dfsIndexRemain2": {
    "scope": "python",
    "prefix": "dfsIndexRemain",
    "body": [
      " # !dp[k][j]=min(dp[k-1][i]+f(i,j)) (0<=i<j<=n)",
      " # !f(i,j): 左闭右开区间[i,j)的代价(0<=i<j<=n)",
      " dp = [0] + [f(0, j) for j in range(1, n + 1)]  # 分成1组时的代价",
      " for _ in range(2, k + 1):",
      "     ndp = [INF] * (n + 1)",
      "     for j in range(1, n + 1):",
      "         for i in range(j):",
      "             ndp[j] = min(ndp[j], dp[i] + f(i, j))",
      "     dp = ndp",
      " return dp[n]"
    ],
    "description": "将区间[0,n)分成 k 组的最小代价"
  },
  "将区间[0,n)分成k组的最小代价": {
    "scope": "go",
    "prefix": "dfsIndexRemain",
    "body": [
      "const INF int = 1e18",
      "// !f(i,j): 左闭右开区间[i,j)的代价(0<=i<j<=n)",
      "func offlineDpMin(k, n int, f func(i, j int) int) int {",
      " dp := make([]int, n+1)",
      " for j := 1; j <= n; j++ {",
      "  dp[j] = f(0, j)",
      " }",
      " for k_ := 2; k_ <= k; k_++ {",
      "  ndp := make([]int, n+1)",
      "  for i := 0; i <= n; i++ {",
      "   ndp[i] = INF",
      "  }",
      "  for j := 1; j <= n; j++ {",
      "   for i := 0; i < j; i++ {",
      "    cand := dp[i] + f(i, j)",
      "    if cand < ndp[j] {",
      "     ndp[j] = cand",
      "    }",
      "   }",
      "  }",
      "  dp = ndp",
      " }",
      " return dp[n]",
      "}",
      "",
      "// !f(i,j): 左闭右开区间[i,j)的代价(0<=i<j<=n)",
      "func offlineDpMax(k, n int, f func(i, j int) int) int {",
      " dp := make([]int, n+1)",
      " for j := 1; j <= n; j++ {",
      "  dp[j] = f(0, j)",
      " }",
      " for k_ := 2; k_ <= k; k_++ {",
      "  ndp := make([]int, n+1)",
      "  for i := 0; i <= n; i++ {",
      "   ndp[i] = -INF",
      "  }",
      "  for j := 1; j <= n; j++ {",
      "   for i := 0; i < j; i++ {",
      "    cand := dp[i] + f(i, j)",
      "    if cand > ndp[j] {",
      "     ndp[j] = cand",
      "    }",
      "   }",
      "  }",
      "  dp = ndp",
      " }",
      " return dp[n]",
      "}"
    ],
    "description": "将区间[0,n)分成k组的最小代价"
  },
  "记忆化dfsIndex": {
    "scope": "python",
    "prefix": "dfsIndex",
    "body": [
      "@lru_cache(None)",
      "def dfs(index: int) -> int:",
      "    if index == n:",
      "        return 0",
      "",
      "    res = INF",
      "    curSum = 0",
      "    for i in range(index, len(nums)):",
      "        ...",
      "        cand = dfs(i + 1) + curSum",
      "        res = cand if cand < res else res",
      "    return res",
      "",
      "",
      "n = len(nums)",
      "res = dfs(0)",
      "dfs.cache_clear()",
      "return res"
    ],
    "description": "将区间[0,n)分成任意组的最小代价"
  },
  "dfs记录路径": {
    "scope": "python",
    "prefix": "dfsPath",
    "body": [
      "def dfs(cur: int) -> None:",
      "  nonlocal res",
      "  if visited[cur]:",
      "    return",
      "  visited[cur] = True",
      "  path.append(cur)",
      "  res += 1",
      "  for next in adjList[cur]:",
      "   dfs(next)",
      "  visited[cur] = False",
      "  path.pop()",
      "",
      "path = []",
      "visited = [False] * n",
      "res = 0",
      "dfs(start)"
    ]
  },
  "dfs回溯-py": {
    "scope": "python",
    "prefix": "dfsBacktrack",
    "body": [
      "from collections import defaultdict",
      "from typing import DefaultDict, List",
      "",
      "def dfsBt(pos: int, path: List[int], counter: DefaultDict[int,int]) -> None:",
      "  if pos == n:",
      "    nonlocal res",
      "    res += 1",
      "    return",
      "  dfsBt(pos + 1, path, counter)",
      "  cur = nums[pos]",
      "  if counter[cur - k] == 0 and counter[cur + k] == 0:",
      "    counter[cur] += 1",
      "    path.append(cur)",
      "    dfsBt(pos + 1, path, counter)",
      "    counter[cur] -= 1",
      "    path.pop()",
      "",
      "n = len(nums)",
      "res = 0",
      "dfsBt(0, [], defaultdict(int))"
    ],
    "description": "dfs回溯"
  },
  "dfs回溯-ts": {
    "scope": "ts,typescript,typescriptreact",
    "prefix": "dfsBacktrack",
    "body": [
      "const n = nums.length",
      "let res = 0",
      "dfsBt(0, [], new Map<number, number>())",
      "return res",
      "function dfsBt(pos: number, path: number[], counter: Map<number, number>): void {",
      "  if (pos === n) {",
      "    res++",
      "    return",
      "  }",
      "  dfsBt(pos + 1, path, counter)",
      "  const cur = nums[pos]",
      "  if ((counter.get(cur - k) || 0) === 0 && (counter.get(cur + k) || 0) === 0) {",
      "    path.push(cur)",
      "    counter.set(cur, (counter.get(cur) || 0) + 1)",
      "    dfsBt(pos + 1, path, counter)",
      "    path.pop()",
      "    counter.set(cur, (counter.get(cur) || 0) - 1)",
      "  }",
      "}"
    ],
    "description": "dfs回溯"
  },
  "子序列匹配": {
    "scope": "python",
    "prefix": "isSubsequence",
    "body": [
      "from typing import Sequence, Any",
      "def isSubsequence(longer: Sequence[Any], shorter: Sequence[Any]) -> bool:",
      "    '''判断shorter是否是longer的子序列'''",
      "    if len(shorter) > len(longer):",
      "        return False",
      "    if len(shorter) == 0:",
      "        return True",
      "    i, j = 0, 0",
      "    while i < len(longer) and j < len(shorter):",
      "        if longer[i] == shorter[j]:",
      "            j += 1",
      "            if j == len(shorter):",
      "              return True",
      "        i += 1",
      "    return False"
    ]
  },
  "二叉树转无向图": {
    "scope": "python",
    "prefix": "treeToGraph1",
    "body": [
      "from typing import List, Optional, Tuple",
      "",
      "class TreeNode:",
      "    def __init__(self, val=0, left=None, right=None):",
      "        self.val = val",
      "        self.left = left",
      "        self.right = right",
      "",
      "def treeToGraph1(",
      "    root: Optional[\"TreeNode\"],",
      ") -> Tuple[List[List[int]], List[Tuple[int, int]], List[int]]:",
      "    \"\"\"二叉树转无向图,返回邻接表,边列表,结点值列表\"\"\"",
      "    def dfs(root: Optional[\"TreeNode\"]) -> int:",
      "        if not root:",
      "            return -1",
      "        nonlocal globalId",
      "        values.append(root.val)",
      "        curId = globalId",
      "        globalId += 1",
      "        if root.left:",
      "            childId = dfs(root.left)",
      "            edges.append((curId, childId))",
      "        if root.right:",
      "            childId = dfs(root.right)",
      "            edges.append((curId, childId))",
      "        return curId",
      "",
      "    globalId = 0  # 0 - n-1",
      "    edges = []",
      "    values = []",
      "    dfs(root)",
      "",
      "    n = len(values)",
      "    adjList = [[] for _ in range(n)]",
      "    for u, v in edges:",
      "        adjList[u].append(v)",
      "        adjList[v].append(u)",
      "    return adjList, edges, values"
    ],
    "description": "二叉树转无向图"
  },
  "n叉树转无向图": {
    "scope": "python",
    "prefix": "treeToGraph2",
    "body": [
      "from typing import List, Optional, Tuple",
      "",
      "class Node:",
      "    def __init__(self, val=None, children=None):",
      "        self.val = val",
      "        self.children = children if children is not None else []",
      "",
      "def treeToGraph2(",
      "    root: Optional[\"Node\"],",
      ") -> Tuple[List[List[int]], List[Tuple[int, int]], List[int]]:",
      "    \"\"\"n叉树转无向图,返回邻接表,边列表,结点值列表\"\"\"",
      "    def build(root: Optional[\"Node\"]) -> int:",
      "        if not root:",
      "            return -1",
      "        nonlocal globalId",
      "        values.append(root.val)",
      "        curId = globalId",
      "        globalId += 1",
      "        for next in root.children:",
      "            nextId = build(next)",
      "            edges.append((curId, nextId))",
      "        return curId",
      "",
      "    globalId = 0  # 0 - n-1",
      "    edges = []",
      "    values = []",
      "    build(root)",
      "",
      "    n = len(values)",
      "    adjList = [[] for _ in range(n)]",
      "    for u, v in edges:",
      "        adjList[u].append(v)",
      "        adjList[v].append(u)",
      "    return adjList, edges, values"
    ]
  },
  "unique": {
    "scope": "go,golang",
    "prefix": "unique",
    "body": [
      "func unique(nums []int) []int {",
      " visited := make(map[int]struct{})",
      " newNums := []int{}",
      " for _, v := range nums {",
      "\t if _, ok := visited[v]; !ok {",
      "\t\t visited[v] = struct{}{}",
      "\t\t newNums = append(newNums, v)",
      "\t }",
      " }",
      " return newNums",
      "}"
    ],
    "description": "unique"
  },
  "go-记忆化dfs": {
    "scope": "go,golang",
    "prefix": "dfsIndexRemain",
    "body": [
      "memo := [1e5 + 10][100]int{}",
      "for i1 := 0; i1 < 1e5+10; i1++ {",
      " for i2 := 0; i2 < 100; i2++ {",
      "   memo[i1][i2] = -1",
      " }",
      "}",
      "",
      "var dfs func(index, remain int) int",
      "dfs = func(index, remain int) int {",
      " if remain < 0 {",
      " return 0",
      " }",
      " if index == n {",
      " if remain == 0 {",
      " return 1",
      " }",
      " return 0",
      " }",
      "",
      " if cand := memo[index][remain]; cand != -1 {",
      " return cand",
      " }",
      "",
      " res := 0",
      " for i := 0; i <= 9; i++ {",
      " res += dfs(index+1, remain-i)",
      " }",
      "",
      " memo[index][remain] = res",
      " return res",
      "}",
      "",
      "return dfs(0, k)"
    ],
    "description": "记忆化dfs"
  },
  "go-记忆化dfs2": {
    "scope": "go,golang",
    "prefix": "dfsIndexVisited",
    "body": [
      "memo := [20][1 << 20]int{}",
      "for i := 0; i < 20; i++ {",
      " for j := 0; j < (1 << 20); j++ {",
      "   memo[i][j] = -1",
      " }",
      "}",
      "var dfs func(index int, visited int) int",
      "dfs = func(index int, visited int) int {",
      " if visited == (1<<len(need))-1 {",
      " return 0",
      " }",
      " if memo[index][visited] != -1 {",
      " return memo[index][visited]",
      " }",
      " res := INF",
      " for next := 0; next < len(need); next++ {",
      " if visited&(1<<next) == 0 {",
      " res = min(res, dist[index][next]+dfs(next, visited|(1<<next)))",
      " }",
      " }",
      " memo[index][visited] = res",
      " return res",
      "}"
    ],
    "description": "记忆化dfs2"
  },
  "go-minMax": {
    "scope": "go,golang",
    "prefix": ["min", "max"],
    "body": [
      "func min(a, b int) int {",
      "  if a < b {",
      "    return a",
      "  }",
      "  return b",
      "}",
      "",
      "func max(a, b int) int {",
      "  if a > b {",
      "    return a",
      "  }",
      "  return b",
      "}",
      "",
      "func mins(nums ...int) int {",
      "  res := nums[0]",
      "  for _, num := range nums {",
      "    if num < res {",
      "      res = num",
      "    }",
      "  }",
      "  return res",
      "}",
      "",
      "func maxs(nums ...int) int {",
      "  res := nums[0]",
      "  for _, num := range nums {",
      "    if num > res {",
      "      res = num",
      "    }",
      "  }",
      "  return res",
      "}"
    ],
    "description": "minMax"
  },
  "python-minmax": {
    "scope": "python",
    "prefix": "minmax",
    "body": [
      "def max(x, y):",
      "    if x > y:",
      "        return x",
      "    return y",
      "",
      "def min(x, y):",
      "    if x < y:",
      "        return x",
      "    return y",
      "",
      "def maxs(seq):",
      "    res = seq[0]",
      "    for i in range(1, len(seq)):",
      "        if seq[i] > res:",
      "            res = seq[i]",
      "    return res",
      "",
      "def mins(seq):",
      "    res = seq[0]",
      "    for i in range(1, len(seq)):",
      "        if seq[i] < res:",
      "            res = seq[i]",
      "    return res"
    ],
    "description": "python手写minmax"
  },

  "状压dp": {
    "scope": "python",
    "prefix": "dfsIndexVisited",
    "body": [
      "@lru_cache(None)",
      "def dfs(index: int, visited: int) -> int:",
      "    if index == n:",
      "        return 1",
      "    res = 0",
      "    for next in range(n):",
      "        if visited & (1 << next):",
      "            continue",
      "        if check():",
      "            res += dfs(index + 1, visited | 1 << next)",
      "    return res",
      "",
      "",
      "res = dfs(0, 0)",
      "dfs.cache_clear()",
      "return res"
    ],
    "description": "状压dp"
  },
  "dp": {
    "scope": "python",
    "prefix": "dpIndexRemain",
    "body": [
      "# dp[count][index]表示前index个字符分成count个子串的方案数",
      "dp = [[0] * (n + 1) for _ in range(k + 1)]",
      "dp[0][0] = 1",
      "",
      "for c in range(1, k + 1):  # 分c组",
      "  dpSum = [0] * (n + 1)",
      "  for i in range(1, n + 1):  # 前i个数字",
      "    dpSum[i] = dpSum[i - 1] + (dp[c - 1][i - 1])",
      "    dpSum[i] %= MOD",
      "  for i in range(1, n + 1):",
      "    dp[c][i] = dpSum[max(0, i - minLength + 1)]  # i-length+1 个数的和",
      "",
      "return dp[k][n]"
    ],
    "description": "dp[count][index]表示前index个字符分成count个子串的方案数"
  },
  "求组合数": {
    "scope": "python",
    "prefix": ["comb", "enumeration", "Enumeration"],
    "body": [
      "class Enumeration:",
      "    __slots__ = (\"_fac\", \"_ifac\", \"_inv\", \"_mod\")",
      "    def __init__(self, size: int, mod: int) -> None:",
      "        self._mod = mod",
      "        self._fac = [1]",
      "        self._ifac = [1]",
      "        self._inv = [1]",
      "        self._expand(size)",
      "    def fac(self, k: int) -> int:",
      "        self._expand(k)",
      "        return self._fac[k]",
      "    def ifac(self, k: int) -> int:",
      "        self._expand(k)",
      "        return self._ifac[k]",
      "    def inv(self, k: int) -> int:",
      "        '''模逆元'''",
      "        self._expand(k)",
      "        return self._inv[k]",
      "    def C(self, n: int, k: int) -> int:",
      "        if n < 0 or k < 0 or n < k:",
      "            return 0",
      "        mod = self._mod",
      "        return self.fac(n) * self.ifac(k) % mod * self.ifac(n - k) % mod",
      "    def P(self, n: int, k: int) -> int:",
      "        if n < 0 or k < 0 or n < k:",
      "            return 0",
      "        mod = self._mod",
      "        return self.fac(n) * self.ifac(n - k) % mod",
      "    def H(self, n: int, k: int) -> int:",
      "        '''可重复选取元素的组合数'''",
      "        if n == 0:",
      "            return 1 if k == 0 else 0",
      "        return self.C(n + k - 1, k)",
      "    def put(self, n: int, k: int) -> int:",
      "        '''n个相同的球放入k个不同的盒子(盒子可放任意个球)的方案数.'''",
      "        return self.C(n + k - 1, n)",
      "    def catalan(self, n: int) -> int:",
      "        '''卡特兰数'''",
      "        return self.C(2 * n, n) * self.inv(n + 1) % self._mod",
      "    def _expand(self, size: int) -> None:",
      "        size = min(size, self._mod - 1)",
      "        if len(self._fac) < size + 1:",
      "            mod = self._mod",
      "            preSize = len(self._fac)",
      "            diff = size + 1 - preSize",
      "            self._fac += [1] * diff",
      "            self._ifac += [1] * diff",
      "            self._inv += [1] * diff",
      "            for i in range(preSize, size + 1):",
      "                self._fac[i] = self._fac[i - 1] * i % mod",
      "            self._ifac[size] = pow(self._fac[size], mod - 2, mod)  # !modInv",
      "            for i in range(size - 1, preSize - 1, -1):",
      "                self._ifac[i] = self._ifac[i + 1] * (i + 1) % mod",
      "            for i in range(preSize, size + 1):",
      "                self._inv[i] = self._ifac[i] * self._fac[i - 1] % mod"
    ],
    "description": "求组合数"
  },
  "golang求组合数": {
    "scope": "go,golang",
    "prefix": ["comb", "enumeration", "Enumeration"],
    "body": [
      "var E *Enumeration",
      "func init() {",
      "  const SIZE int = 1e6 + 10",
      "  const MOD int = 1e9 + 7",
      "  E = NewEnumeration(SIZE, MOD)",
      "}",
      "type Enumeration struct {",
      "  fac, ifac, inv []int",
      "  mod            int",
      "}",
      "// 模数为质数时的组合数计算.",
      "func NewEnumeration(initSize, mod int) *Enumeration {",
      "  res := &Enumeration{",
      "    fac:  make([]int, 1, initSize+1),",
      "    ifac: make([]int, 1, initSize+1),",
      "    inv:  make([]int, 1, initSize+1),",
      "    mod:  mod,",
      "  }",
      "  res.fac[0] = 1",
      "  res.ifac[0] = 1",
      "  res.inv[0] = 1",
      "  res.expand(initSize)",
      "  return res",
      "}",
      "// 阶乘.",
      "func (e *Enumeration) Fac(k int) int {",
      "  e.expand(k)",
      "  return e.fac[k]",
      "}",
      "// 阶乘逆元.",
      "func (e *Enumeration) Ifac(k int) int {",
      "  e.expand(k)",
      "  return e.ifac[k]",
      "}",
      "// 模逆元.",
      "func (e *Enumeration) Inv(k int) int {",
      "  e.expand(k)",
      "  return e.inv[k]",
      "}",
      "// 组合数.",
      "func (e *Enumeration) C(n, k int) int {",
      "  if n < 0 || k < 0 || n < k {",
      "    return 0",
      "  }",
      "  return e.Fac(n) * e.Ifac(k) % e.mod * e.Ifac(n-k) % e.mod",
      "}",
      "// 排列数.",
      "func (e *Enumeration) P(n, k int) int {",
      "  if n < 0 || k < 0 || n < k {",
      "    return 0",
      "  }",
      "  return e.Fac(n) * e.Ifac(n-k) % e.mod",
      "}",
      "// 可重复选取元素的组合数.",
      "func (e *Enumeration) H(n, k int) int {",
      "  if n == 0 {",
      "    if k == 0 {",
      "      return 1",
      "    }",
      "    return 0",
      "  }",
      "  return e.C(n+k-1, k)",
      "}",
      "// n个相同的球放入k个不同的盒子(盒子可放任意个球)的方案数.",
      "func (e *Enumeration) Put(n, k int) int {",
      "  return e.C(n+k-1, n)",
      "}",
      "// 卡特兰数.",
      "func (e *Enumeration) Catalan(n int) int {",
      "  return e.C(2*n, n) * e.Inv(n+1) % e.mod",
      "}",
      "func (e *Enumeration) expand(size int) {",
      "  if upper := e.mod - 1; size > upper {",
      "    size = upper",
      "  }",
      "  if len(e.fac) < size+1 {",
      "    mod := e.mod",
      "    preSize := len(e.fac)",
      "    diff := size + 1 - preSize",
      "    e.fac = append(e.fac, make([]int, diff)...)",
      "    e.ifac = append(e.ifac, make([]int, diff)...)",
      "    e.inv = append(e.inv, make([]int, diff)...)",
      "    for i := preSize; i < size+1; i++ {",
      "      e.fac[i] = e.fac[i-1] * i % mod",
      "    }",
      "    e.ifac[size] = Pow(e.fac[size], mod-2, mod)  // !modInv",
      "    for i := size - 1; i >= preSize; i-- {",
      "      e.ifac[i] = e.ifac[i+1] * (i+1) % mod",
      "    }",
      "    for i := preSize; i < size+1; i++ {",
      "      e.inv[i] = e.ifac[i] * e.fac[i-1] % mod",
      "    }",
      "  }",
      "}",
      "func Pow(base, exp, mod int) int {",
      "  base %= mod",
      "  res := 1",
      "  for ; exp > 0; exp >>= 1 {",
      "    if exp&1 == 1 {",
      "      res = res * base % mod",
      "    }",
      "    base = base * base % mod",
      "  }",
      "  return res"
    ],
    "description": "golang求组合数"
  },
  "groupby": {
    "scope": "python",
    "prefix": "groupby",
    "body": ["groups = [(char, len(list(group))) for char, group in groupby($0)]"],
    "description": "groupby分组"
  },
  "preSum": {
    "scope": "python",
    "prefix": "preSum",
    "body": ["preSum = [0] + list(accumulate($1nums))"],
    "description": "preSum前缀和"
  },
  "preSum记录前缀和个数": {
    "scope": "python",
    "prefix": "preSum",
    "body": [
      "if k == 0: # 注意有时需要特判和为0",
      "    ...",
      "preSum = defaultdict(int, {0: 1})  # 如果记录索引就是{0: -1}",
      "res, curSum = 0, 0",
      "for i, num in enumerate(nums):",
      "    curSum += num",
      "    if curSum - k in preSum:",
      "        res += preSum[curSum - k]",
      "    preSum[curSum] += 1",
      "return res"
    ],
    "description": "preSum记录前缀和个数,子数组不能为空,空需要特判"
  },
  "preMin": {
    "scope": "python",
    "prefix": "preMin",
    "body": [
      "preMin = [-INF] + $1nums[:]",
      "for i in range(1, len(preMin)):",
      "    if preMin[i] > preMin[i - 1]:",
      "        preMin[i] = preMin[i - 1]"
    ],
    "description": "前缀最小值"
  },
  "preMax": {
    "scope": "python",
    "prefix": "preMax",
    "body": [
      "preMax = [-INF] + $1nums[:]",
      "for i in range(1, len(preMax)):",
      "    if preMax[i] < preMax[i - 1]:",
      "        preMax[i] = preMax[i - 1]"
    ],
    "description": "前缀最大值"
  },
  "sufSum": {
    "scope": "python",
    "prefix": "sufSum",
    "body": ["sufSum = ([0] + list(accumulate($1nums[::-1])))[::-1]"],
    "description": "sufSum后缀和"
  },
  "sufMin": {
    "scope": "python",
    "prefix": "sufMin",
    "body": [
      "sufMin = $1nums[:] + [INF]",
      "for i in range(len(sufMin) - 2, -1, -1):",
      "    if sufMin[i] > sufMin[i + 1]:",
      "        sufMin[i] = sufMin[i + 1]"
    ],
    "description": "后缀最小值"
  },
  "sufMax": {
    "scope": "python",
    "prefix": "sufMax",
    "body": [
      "sufMax = $1nums[:] + [-INF]",
      "for i in range(len(sufMax) - 2, -1, -1):",
      "    if sufMax[i] < sufMax[i + 1]:",
      "        sufMax[i] = sufMax[i + 1]"
    ],
    "description": "后缀最大值"
  },
  "readline": {
    "scope": "python",
    "prefix": "stdin",
    "body": [
      "import sys",
      "",
      "sys.setrecursionlimit(int(1e6))",
      // AtCoderの入力データでは通常、末尾にも改行が入ります
      "input = lambda: sys.stdin.readline().rstrip('\\r\\n')",
      "MOD = 998244353",
      "INF = int(4e18)",
      "",
      "if __name__ == '__main__':",
      "    $1",
      ""
      // 不要把逻辑放在main函数中执行,这会在pypy3中变慢
      // "def main() -> None:",
      // "    $1",
      // "",
      // "",
      // "if __name__ == '__main__':",
      // "    if os.environ.get('USERNAME', ' ') == 'caomeinaixi':",
      // "        while True:",
      // "            main()",
      // "    else:",
      // "        main()"
    ],
    "description": "更快的读入"
  },
  "topoSort": {
    "scope": "python",
    "prefix": "topoSort",
    "body": [
      "from typing import List",
      "from collections import deque",
      "",

      "def hasCycle(n: int, adjList: List[List[int]], directed=True) -> bool:",
      "\t\t\"\"\"拓扑排序判环.\"\"\"",
      "\t\tif directed:",
      "\t\t\t\tdeg = [0] * n",
      "\t\t\t\tfor i in range(n):",
      "\t\t\t\t\t\tfor j in adjList[i]:",
      "\t\t\t\t\t\t\t\tdeg[j] += 1",
      "\t\telse:",
      "\t\t\t\tdeg = [len(adj) for adj in adjList]",
      "",
      "\t\tstartDeg = 0 if directed else 1",
      "\t\tqueue = deque([v for v in range(n) if deg[v] == startDeg])",
      "\t\tcount = 0",
      "\t\twhile queue:",
      "\t\t\t\tcur = queue.popleft()",
      "\t\t\t\tcount += 1",
      "\t\t\t\tfor next in adjList[cur]:",
      "\t\t\t\t\t\tdeg[next] -= 1",
      "\t\t\t\t\t\tif deg[next] == startDeg:",
      "\t\t\t\t\t\t\t\tqueue.append(next)",
      "\t\treturn count < n",
      "",
      "",
      "def topoSort(n: int, adjList: List[List[int]], directed=True) -> Tuple[List[int], bool]:",
      "\t\t\"\"\"求图的拓扑排序.\"\"\"",
      "\t\tif directed:",
      "\t\t\t\tdeg = [0] * n",
      "\t\t\t\tfor i in range(n):",
      "\t\t\t\t\t\tfor j in adjList[i]:",
      "\t\t\t\t\t\t\t\tdeg[j] += 1",
      "\t\telse:",
      "\t\t\t\tdeg = [len(adj) for adj in adjList]",
      "",
      "\t\tstartDeg = 0 if directed else 1",
      "\t\tqueue = deque([v for v in range(n) if deg[v] == startDeg])",
      "\t\tres = []",
      "\t\twhile queue:",
      "\t\t\t\tcur = queue.popleft()",
      "\t\t\t\tres.append(cur)",
      "\t\t\t\tfor next in adjList[cur]:",
      "\t\t\t\t\t\tdeg[next] -= 1",
      "\t\t\t\t\t\tif deg[next] == startDeg:",
      "\t\t\t\t\t\t\t\tqueue.append(next)",
      "",
      "\t\tif len(res) != n:",
      "\t\t\t\treturn [], False",
      "\t\treturn res, True"
    ],
    "description": "拓扑排序"
  },

  "dfs序": {
    "scope": "python",
    "prefix": "dfs序",
    "body": [
      "def dfs(cur: int, pre: int) -> None:",
      "    nonlocal dfsId",
      "    ins[cur] = dfsId",
      "    for next in adjList[cur]:",
      "        if next != pre:",
      "            depth[next] = depth[cur] + 1",
      "            dfs(next, cur)",
      "    outs[cur] = dfsId",
      "    dfsId += 1",
      "",
      "ins, outs, dfsId = [0] * (n + 10), [0] * (n + 10), 1",
      "depth = [0] * (n + 10)",
      "dfs(0, -1)",
      "",
      "newNums = [0] * n",
      "for i in range(n):",
      "    id = outs[i] - 1",
      "    newNums[id] = nums[i]",
      "for i in range(len(queries)):",
      "    queryRoot = queries[i]",
      "    left = ins[queryRoot]",
      "    right = outs[queryRoot]"
    ],
    "description": "dfs序"
  },
  "dfs序-new": {
    "scope": "python",
    "prefix": ["dfs序-new", "dfsOrder"],
    "body": [
      "lid, rid = [0] * n, [0] * n",
      "dfn = 0",
      "",
      "",
      "def dfs(cur: int, pre: int) -> None:",
      "\t\tnonlocal dfn",
      "\t\tlid[cur] = dfn",
      "\t\tdfn += 1",
      "\t\tfor next_ in tree[cur]:",
      "\t\t\t\tif next_ != pre:",
      "\t\t\t\t\t\tdfs(next_, cur)",
      "\t\trid[cur] = dfn",
      "",
      "",
      "dfs(0, -1)",
      "# data[lid[i]] = values[i]"
    ],
    "description": "dfs序-new"
  },
  "golangdfs序": {
    "scope": "go,golang",
    "prefix": "dfs序",
    "body": [
      "ins, outs, dfsId := make([]int, n+5), make([]int, n+5), 1",
      "depth := make([]int, n+5)",
      "var dfsOrder func(cur, pre int)",
      "dfsOrder = func(cur, pre int) {",
      "  ins[cur] = dfsId",
      "  for _, next := range adjList[cur] {",
      "    if next != pre {",
      "      depth[next] = depth[cur] + 1",
      "      dfsOrder(next, cur)",
      "    }",
      "  }",
      "  outs[cur] = dfsId",
      "  dfsId += 1",
      "}",
      "dfsOrder(0, -1)",
      "newNums := make([]int, n)",
      "for i := 0; i < n; i++ {",
      "  id := outs[i] - 1",
      "  newNums[id] = nums[i]",
      "}"
    ],
    "description": "golang dfs序"
  },
  "golang-dfs序-new": {
    "scope": "go,golang",
    "prefix": "dfs序-new",
    "body": [
      "\tlid, rid := make([]int, n), make([]int, n)",
      "\tdfn := 0",
      "\tvar dfs func(cur, pre int)",
      "\tdfs = func(cur, pre int) {",
      "\t\tlid[cur] = dfn",
      "\t\tdfn++",
      "\t\tfor _, next := range tree[cur] {",
      "\t\t\tif next != pre {",
      "\t\t\t\tdfs(next, cur)",
      "\t\t\t}",
      "\t\t}",
      "\t\trid[cur] = dfn",
      "\t}",
      "\tdfs(0, -1)",
      "\t// data[lid[i]] = values[i]"
    ],
    "description": "golang-dfs序-new"
  },
  "预处理每个点上下左右连续1的长度": {
    "scope": "python",
    "prefix": "updownleftright",
    "body": [
      "up = [[0] * COL for _ in range(ROW)]",
      "down = [[0] * COL for _ in range(ROW)]",
      "left = [[0] * COL for _ in range(ROW)]",
      "right = [[0] * COL for _ in range(ROW)]",
      "for r in range(ROW):",
      "    for c in range(COL):",
      "        if (r, c) not in bad:",
      "            up[r][c] = up[r - 1][c] + 1 if r else 1",
      "            left[r][c] = left[r][c - 1] + 1 if c else 1",
      "        if (ROW - 1 - r, COL - 1 - c) not in bad:",
      "            down[ROW - 1 - r][COL - 1 - c] = down[ROW - r][COL - 1 - c] + 1 if r else 1",
      "            right[ROW - 1 - r][COL - 1 - c] = right[ROW - 1 - r][COL - c] + 1 if c else 1"
    ],
    "description": "预处理每个点上下左右连续1的长度"
  },
  "treeDp": {
    "scope": "python",
    "prefix": "treeDp",
    "body": [
      "def dfs(cur: int, pre: int) -> int:",
      "    subCount = 1",
      "    for next in adjList[cur]:",
      "        if next == pre:",
      "            continue",
      "        subCount += dfs(next, cur)",
      "        # 处理当前子树的值",
      "    # 回溯，向上返回所有子树的结果",
      "    return subCount",
      "",
      "adjList = [[] for _ in range(n)]",
      "for u, v in edges:",
      "    adjList[u].append(v)",
      "    adjList[v].append(u)",
      "",
      "dfs(0, -1)"
    ],
    "description": "treeDp"
  },
  "treeDfs": {
    "scope": "python",
    "prefix": "treeDfs",
    "body": [
      "\t\t\t\t@lru_cache(None)",
      "\t\t\t\tdef dfs(cur: int, pre: int, ok: bool) -> int:",
      "\t\t\t\t\t\tif len(adjList[cur]) == 1 and pre != -1:\t# 叶子节点",
      "\t\t\t\t\t\t\t\treturn 0",
      "",
      "\t\t\t\t\t\tnexts = [next_ for next_ in adjList[cur] if next_ != pre]",
      "\t\t\t\t\t\tif ok:",
      "\t\t\t\t\t\t\t\t...",
      "",
      "\t\t\t\t\t\tres1 = 0",
      "\t\t\t\t\t\tres2 = 0",
      "\t\t\t\t\t\treturn max(res1, res2)",
      "",
      "\t\t\t\tn = len(values)",
      "\t\t\t\tadjList = [[] for _ in range(n)]",
      "\t\t\t\tfor u, v in edges:",
      "\t\t\t\t\t\tadjList[u].append(v)",
      "\t\t\t\t\t\tadjList[v].append(u)",
      "",
      "\t\t\t\tres = dfs(0, -1, False)",
      "\t\t\t\tdfs.cache_clear()",
      "\t\t\t\treturn res"
    ],
    "description": "treeDfs"
  },
  "Graph Type": {
    "scope": "python",
    "prefix": "Graph",
    "body": [
      "from typing import Iterable, Mapping, Sequence, TypeVar, Union",
      "",
      "T = TypeVar('T')",
      "AdjList = Sequence[Iterable[T]]",
      "AdjMap = Mapping[T, Iterable[T]]",
      "Graph = Union[AdjList[T], AdjMap[T]]"
    ],
    "description": "Graph Type"
  },
  "Weighted Graph Type": {
    "scope": "python",
    "prefix": "Graph Weighted",
    "body": [
      "from typing import Iterable, List, Mapping, Sequence, Tuple, TypeVar, Union",
      "",
      "T = TypeVar('T')",
      "ListWG = Sequence[Iterable[Tuple[T, int]]]",
      "DictWG = Mapping[T, Iterable[Tuple[T, int]]]",
      "WG = Union[ListWG[T], DictWG[T]]"
    ],
    "description": "Weighted Graph Type"
  },
  "邻接表adjList": {
    "scope": "python",
    "prefix": "adjList",
    "body": ["adjList = [[] for _ in range(n)]"],
    "description": "邻接表adjList"
  },
  "邻接表adjList-ts": {
    "scope": "typescript",
    "prefix": "adjList",
    "body": ["const adjList: number[][] = Array(n)", "for (let i = 0; i < n; i++) adjList[i] = []"],
    "description": "邻接表adjList"
  },
  "邻接表adjMap": {
    "scope": "python",
    "prefix": "adjMap",
    "body": ["adjMap = defaultdict(lambda: defaultdict(lambda: INF))"],
    "description": "邻接表adjMap"
  },
  "定长滑窗": {
    "scope": "python",
    "prefix": "window1",
    "body": [
      "n = len(nums)",
      "res, curSum = INF, 0",
      "for right in range(n):",
      "    curSum += nums[right]",
      "    if right >= k:",
      "        curSum -= nums[right - k]",
      "    if right >= k - 1:",
      "        res = min(res, curSum)",
      "return res"
    ],
    "description": "定长滑窗"
  },
  "定长滑窗-ts": {
    "scope": "typescript",
    "prefix": "window1",
    "body": [
      "let res = INF",
      "let curSum = 0",
      "for (let right = 0; right < n; right++) {",
      "    curSum += nums[right]",
      "    if (right >= k) {",
      "        curSum -= nums[right - k]",
      "    }",
      "    if (right >= k - 1) {",
      "        res = Math.min(res, curSum)",
      "    }",
      "}",
      "return res"
    ],
    "description": "定长滑窗"
  },
  "不定长滑窗": {
    "scope": "python",
    "prefix": "window2",
    "body": [
      "res, left, n = 0, 0, len(nums)",
      "curSum = 0",
      "for right in range(n):",
      "    curSum += nums[right]",
      "    while left <= right and $1:",
      "        curSum -= nums[left]",
      "        left += 1",
      "    res = max(res, right - left + 1)",
      "return res"
    ],
    "description": "不定长滑窗"
  },
  "不定长滑窗-ts": {
    "scope": "typescript",
    "prefix": "window2",
    "body": [
      "let res = 0",
      "let left = 0",
      "let curSum = 0",
      "for (let right = 0; right < n; right++) {",
      "    curSum += arr[right]",
      "    while (left <= right && curSum > target) {",
      "        curSum -= arr[left]",
      "        left++",
      "    }",
      "    res += right - left + 1",
      "}",
      "return res"
    ],
    "description": "不定长滑窗"
  },
  "前后缀滑窗": {
    "scope": "python",
    "prefix": "window3",
    "body": [
      "first = [INF] * (n + 1)  # 每个前缀长度对应的右边界",
      "right = 0",
      "for left, v in enumerate(pre):",
      "    while right < len(suf) and suf[right]$1:",
      "        right += 1",
      "    if right < len(suf) and suf[right]$2:",
      "        first[left] = right",
      "for left in range(len(first)):",
      "           ...                 "
    ],
    "description": [
      "前后缀滑窗",
      "枚举前缀长度left,求出第一个满足条件的后缀位置right(pre长度为n+1)",
      "不存在时为INF"
    ]
  },
  "dijkstra求最短路Map": {
    "scope": "python",
    "prefix": "dijkstraMap",
    "body": [
      "from typing import List, Mapping",
      "from collections import defaultdict",
      "from heapq import heappop, heappush",
      "",
      "def dijkstra(n: int, adjMap: Mapping[int, Mapping[int, int]], start: int) -> List[int]:",
      "    dist = [INF] * n",
      "    dist[start] = 0",
      "    pq = [(0, start)]",
      "",
      "    while pq:",
      "        curDist, cur = heappop(pq)",
      "        if dist[cur] < curDist:",
      "            continue",
      "        for next in adjMap[cur]:",
      "            cand = dist[cur] + adjMap[cur][next]",
      "            if cand < dist[next]:",
      "                dist[next] = cand",
      "                heappush(pq, (dist[next], next))",
      "    return dist",
      "adjMap = defaultdict(lambda: defaultdict(lambda: INF))",
      "for u, v, w in edges:",
      "    adjMap[u][v] = min(adjMap[u][v], w)",
      "    adjMap[v][u] = min(adjMap[v][u], w)",
      "",
      ""
    ],
    "description": "dijkstra求最短路"
  },
  "dijkstra求最短路List": {
    "scope": "python",
    "prefix": "dijkstraList",
    "body": [
      //   from typing import List, Sequence, Tuple
      // from heapq import heappop, heappush
      // def dijkstra(n: int, adjList: Sequence[Sequence[Tuple[int, int]]], start: int) -> List[int]:
      //     dist = [INF] * n
      //     dist[start] = 0
      //     pq = [(0, start)]
      //     while pq:
      //         curDist, cur = heappop(pq)
      //         if dist[cur] < curDist:
      //             continue
      //         for next, weight in adjList[cur]:
      //             cand = dist[cur] + weight
      //             if cand < dist[next]:
      //                 dist[next] = cand
      //                 heappush(pq, (dist[next], next))
      //     return dist
      "from typing import List, Sequence, Tuple",
      "from heapq import heappop, heappush",
      "",
      "def dijkstra(n: int, adjList: Sequence[Sequence[Tuple[int, int]]], start: int) -> List[int]:",
      "    dist = [INF] * n",
      "    dist[start] = 0",
      "    pq = [(0, start)]",
      "",
      "    while pq:",
      "        curDist, cur = heappop(pq)",
      "        if dist[cur] < curDist:",
      "            continue",
      "        for next, weight in adjList[cur]:",
      "            cand = dist[cur] + weight",
      "            if cand < dist[next]:",
      "                dist[next] = cand",
      "                heappush(pq, (dist[next], next))",
      "    return dist",
      "",
      "adjList = [[] for _ in range(n)]",
      "for u, v, w in edges:",
      "    adjList[u].append((v, w))",
      "    adjList[v].append((u, w))",
      ""
    ],
    "description": "dijkstra求最短路"
  },
  "bfs求最短路": {
    "scope": "python",
    "prefix": "bfs",
    "body": [
      "from collections import deque",
      "",
      "",
      "def bfs(start: int, adjList: List[List[int]]) -> List[int]:",
      "    n = len(adjList)",
      "    dist = [INF] * n",
      "    dist[start] = 0",
      "    queue = deque([start])",
      "    while queue:",
      "        cur = queue.popleft()",
      "        for next in adjList[cur]:",
      "            cand = dist[cur] + 1",
      "            if cand < dist[next]:",
      "                dist[next] = cand",
      "                queue.append(next)",
      "    return dist"
    ],
    "description": "bfs求最短路"
  },
  "bfs求某层的结点": {
    "scope": "python",
    "prefix": "bfsDepth",
    "body": [
      "from collections import deque",
      "from typing import List",
      "",
      "def bfsDepth(adjList: List[List[int]], start: int, dist: int) -> List[int]:",
      "    '''返回距离start为dist的结点'''",
      "    if dist < 0:",
      "        return []",
      "    if dist == 0:",
      "        return [start]",
      "    queue = deque([start])",
      "    visited = set([start])",
      "    todo = dist",
      "    while queue and todo > 0:",
      "        len_ = len(queue)",
      "        for _ in range(len_):",
      "            cur = queue.popleft()",
      "            for next in adjList[cur]:",
      "                if next not in visited:",
      "                    visited.add(next)",
      "                    queue.append(next)",
      "        todo -= 1",
      "    return list(queue)"
    ],
    "description": "bfs求某层的结点"
  },

  "并查集数组": {
    "scope": "python",
    "prefix": ["UnionFindArray", "并查集数组"],
    "body": [
      "class UnionFindArray:",
      "\t\t\"\"\"元素是0-n-1的并查集写法,不支持动态添加",
      "",
      "\t\t初始化的连通分量个数 为 n",
      "\t\t\"\"\"",
      "",
      "\t\t__slots__ = (\"n\", \"part\", \"_parent\", \"_rank\")",
      "",
      "\t\tdef __init__(self, n: int):",
      "\t\t\t\tself.n = n",
      "\t\t\t\tself.part = n",
      "\t\t\t\tself._parent = list(range(n))",
      "\t\t\t\tself._rank = [1] * n",
      "",
      "\t\tdef find(self, x: int) -> int:",
      "\t\t\t\twhile self._parent[x] != x:",
      "\t\t\t\t\t\tself._parent[x] = self._parent[self._parent[x]]",
      "\t\t\t\t\t\tx = self._parent[x]",
      "\t\t\t\treturn x",
      "",
      "\t\tdef union(self, x: int, y: int) -> bool:",
      "\t\t\t\t\"\"\"按秩合并.\"\"\"",
      "\t\t\t\trootX = self.find(x)",
      "\t\t\t\trootY = self.find(y)",
      "\t\t\t\tif rootX == rootY:",
      "\t\t\t\t\t\treturn False",
      "\t\t\t\tif self._rank[rootX] > self._rank[rootY]:",
      "\t\t\t\t\t\trootX, rootY = rootY, rootX",
      "\t\t\t\tself._parent[rootX] = rootY",
      "\t\t\t\tself._rank[rootY] += self._rank[rootX]",
      "\t\t\t\tself.part -= 1",
      "\t\t\t\treturn True",
      "",
      "\t\tdef unionTo(self, child: int, parent: int) -> bool:",
      "\t\t\t\t\"\"\"定向合并.将child的父节点设置为parent.\"\"\"",
      "\t\t\t\trootX = self.find(child)",
      "\t\t\t\trootY = self.find(parent)",
      "\t\t\t\tif rootX == rootY:",
      "\t\t\t\t\t\treturn False",
      "\t\t\t\tself._parent[rootX] = rootY",
      "\t\t\t\tself._rank[rootY] += self._rank[rootX]",
      "\t\t\t\tself.part -= 1",
      "\t\t\t\treturn True",
      "",
      "\t\tdef unionWithCallback(self, x: int, y: int, f: Callable[[int, int], None]) -> bool:",
      "\t\t\t\t\"\"\"",
      "\t\t\t\tf: 合并后的回调函数, 入参为 (big, small)",
      "\t\t\t\t\"\"\"",
      "\t\t\t\trootX = self.find(x)",
      "\t\t\t\trootY = self.find(y)",
      "\t\t\t\tif rootX == rootY:",
      "\t\t\t\t\t\treturn False",
      "\t\t\t\tif self._rank[rootX] > self._rank[rootY]:",
      "\t\t\t\t\t\trootX, rootY = rootY, rootX",
      "\t\t\t\tself._parent[rootX] = rootY",
      "\t\t\t\tself._rank[rootY] += self._rank[rootX]",
      "\t\t\t\tself.part -= 1",
      "\t\t\t\tf(rootY, rootX)",
      "\t\t\t\treturn True",
      "",
      "\t\tdef isConnected(self, x: int, y: int) -> bool:",
      "\t\t\t\treturn self.find(x) == self.find(y)",
      "",
      "\t\tdef getGroups(self) -> DefaultDict[int, List[int]]:",
      "\t\t\t\tgroups = defaultdict(list)",
      "\t\t\t\tfor key in range(self.n):",
      "\t\t\t\t\t\troot = self.find(key)",
      "\t\t\t\t\t\tgroups[root].append(key)",
      "\t\t\t\treturn groups",
      "",
      "\t\tdef getRoots(self) -> List[int]:",
      "\t\t\t\treturn list(set(self.find(key) for key in self._parent))",
      "",
      "\t\tdef getSize(self, x: int) -> int:",
      "\t\t\t\treturn self._rank[self.find(x)]",
      "",
      "\t\tdef __repr__(self) -> str:",
      "\t\t\t\treturn \"\\n\".join(f\"{root}: {member}\" for root, member in self.getGroups().items())",
      "",
      "\t\tdef __len__(self) -> int:",
      "\t\t\t\treturn self.part",
      ""
    ],
    "description": "并查集数组"
  },
  "通用的并查集": {
    "scope": "python",
    "prefix": ["UnionFindMap", "并查集"],
    "body": [
      "from collections import defaultdict",
      "from typing import DefaultDict, Generic, Hashable, Iterable, List, Optional, TypeVar",
      "",
      "",
      "T = TypeVar('T', bound=Hashable)",
      "",
      "",
      "class UnionFindMap(Generic[T]):",
      "    '''当元素不是数组index时(例如字符串),更加通用的并查集写法,支持动态添加'''",
      "",
      "    __slots__ = ('part', '_parent', '_rank')",
      "",
      "    def __init__(self, iterable: Optional[Iterable[T]] = None):",
      "        self.part = 0",
      "        self._parent = dict()",
      "        self._rank = dict()",
      "        for item in iterable or []:",
      "            self.add(item)",
      "",
      "    def union(self, key1: T, key2: T) -> bool:",
      "        '''rank一样时 默认key2作为key1的父节点'''",
      "        root1 = self.find(key1)",
      "        root2 = self.find(key2)",
      "        if root1 == root2:",
      "            return False",
      "        if self._rank[root1] > self._rank[root2]:",
      "            root1, root2 = root2, root1",
      "        self._parent[root1] = root2",
      "        self._rank[root2] += self._rank[root1]",
      "        self.part -= 1",
      "        return True",
      "",
      "    def find(self, key: T) -> T:",
      "        if key not in self._parent:",
      "            self.add(key)",
      "            return key",
      "",
      "        while self._parent.get(key, key) != key:",
      "            self._parent[key] = self._parent[self._parent[key]]",
      "            key = self._parent[key]",
      "        return key",
      "",
      "    def isConnected(self, key1: T, key2: T) -> bool:",
      "        return self.find(key1) == self.find(key2)",
      "",
      "    def getRoots(self) -> List[T]:",
      "        return list(set(self.find(key) for key in self._parent))",
      "",
      "    def getGroups(self) -> DefaultDict[T, List[T]]:",
      "        groups = defaultdict(list)",
      "        for key in self._parent:",
      "            root = self.find(key)",
      "            groups[root].append(key)",
      "        return groups",
      "",
      "    def add(self, key: T) -> bool:",
      "        if key in self._parent:",
      "            return False",
      "        self._parent[key] = key",
      "        self._rank[key] = 1",
      "        self.part += 1",
      "        return True",
      "",
      "    def __repr__(self) -> str:",
      "        return '\\n'.join(f'{root}: {member}' for root, member in self.getGroups().items())",
      "",
      "    def __len__(self) -> int:",
      "        return self.part",
      "",
      "    def __contains__(self, key: T) -> bool:",
      "        return key in self._parent",
      "",
      "",
      "class UnionFindArray:",
      "    '''元素是0-n-1的并查集写法,不支持动态添加",
      "",
      "    初始化的连通分量个数 为 n",
      "    '''",
      "",
      "    __slots__ = ('n', 'part', '_parent', '_rank')",
      "",
      "    def __init__(self, n: int):",
      "        self.n = n",
      "        self.part = n",
      "        self._parent = list(range(n))",
      "        self._rank = [1] * n",
      "",
      "    def find(self, x: int) -> int:",
      "        while self._parent[x] != x:",
      "            self._parent[x] = self._parent[self._parent[x]]",
      "            x = self._parent[x]",
      "        return x",
      "",
      "    def union(self, x: int, y: int) -> bool:",
      "        '''rank一样时 默认key2作为key1的父节点'''",
      "        rootX = self.find(x)",
      "        rootY = self.find(y)",
      "        if rootX == rootY:",
      "            return False",
      "        if self._rank[rootX] > self._rank[rootY]:",
      "            rootX, rootY = rootY, rootX",
      "        self._parent[rootX] = rootY",
      "        self._rank[rootY] += self._rank[rootX]",
      "        self.part -= 1",
      "        return True",
      "",
      "    def isConnected(self, x: int, y: int) -> bool:",
      "        return self.find(x) == self.find(y)",
      "",
      "    def getGroups(self) -> DefaultDict[int, List[int]]:",
      "        groups = defaultdict(list)",
      "        for key in range(self.n):",
      "            root = self.find(key)",
      "            groups[root].append(key)",
      "        return groups",
      "",
      "    def getRoots(self) -> List[int]:",
      "        return list(set(self.find(key) for key in self._parent))",
      "",
      "    def __repr__(self) -> str:",
      "        return '\\n'.join(f'{root}: {member}' for root, member in self.getGroups().items())",
      "",
      "    def __len__(self) -> int:",
      "        return self.part",
      "",
      "",
      "class UnionFindMap2(Generic[T]):",
      "    '''不自动合并 需要手动add添加元素'''",
      "",
      "    __slots__ = ('part', '_parent', '_rank')",
      "",
      "    def __init__(self, iterable: Optional[Iterable[T]] = None):",
      "        self.part = 0",
      "        self._parent = dict()",
      "        self._rank = defaultdict(lambda: 1)",
      "        for item in iterable or []:",
      "            self.add(item)",
      "",
      "    def add(self, key: T) -> 'UnionFindMap2[T]':",
      "        if key in self._parent:",
      "            return self",
      "        self._parent[key] = key",
      "        self._rank[key] = 1",
      "        self.part += 1",
      "        return self",
      "",
      "    def union(self, key1: T, key2: T) -> bool:",
      "        '''rank一样时 默认key2作为key1的父节点'''",
      "        root1 = self.find(key1)",
      "        root2 = self.find(key2)",
      "        if root1 == root2 or root1 not in self._parent or root2 not in self._parent:",
      "            return False",
      "        if self._rank[root1] > self._rank[root2]:",
      "            root1, root2 = root2, root1",
      "        self._parent[root1] = root2",
      "        self._rank[root2] += self._rank[root1]",
      "        self.part -= 1",
      "        return True",
      "",
      "    def find(self, key: T) -> T:",
      "        '''此处不自动add'''",
      "        if key not in self._parent:",
      "            return key",
      "",
      "        if key != self._parent[key]:",
      "            root = self.find(self._parent[key])",
      "            self._parent[key] = root",
      "        return self._parent[key]",
      "",
      "    def isConnected(self, key1: T, key2: T) -> bool:",
      "        if key1 not in self._parent or key2 not in self._parent:",
      "            return False",
      "        return self.find(key1) == self.find(key2)",
      "",
      "    def getRoots(self) -> List[T]:",
      "        return list(set(self.find(key) for key in self._parent))",
      "",
      "    def getGroups(self) -> DefaultDict[T, List[T]]:",
      "        groups = defaultdict(list)",
      "        for key in self._parent:",
      "            root = self.find(key)",
      "            groups[root].append(key)",
      "        return groups",
      "",
      "    def __repr__(self) -> str:",
      "        return '\\n'.join(f'{root}: {member}' for root, member in self.getGroups().items())",
      "",
      "    def __len__(self) -> int:",
      "        return self.part",
      "",
      "    def __contains__(self, key: T) -> bool:",
      "        return key in self._parent",
      "",
      "",
      "class UnionFindGraph:",
      "    '''并查集维护无向图每个连通块的边数和顶点数'''",
      "",
      "    __slots__ = ('n', 'part', '_parent', 'vertex', 'edge')",
      "",
      "    def __init__(self, n: int):",
      "        self.n = n",
      "        self.part = n",
      "        self._parent = list(range(n))",
      "        self.vertex = [1] * n  # 每个联通块的顶点数",
      "        self.edge = [0] * n  # 每个联通块的边数",
      "",
      "    def find(self, x: int) -> int:",
      "        while x != self._parent[x]:",
      "            self._parent[x] = self._parent[self._parent[x]]",
      "            x = self._parent[x]",
      "        return x",
      "",
      "    def union(self, x: int, y: int) -> bool:",
      "        rootX = self.find(x)",
      "        rootY = self.find(y)",
      "        if rootX == rootY:",
      "            self.edge[rootX] += 1  # 两个顶点已经在同一个连通块了,这个连通块的边数+1",
      "            return False",
      "        if self.vertex[rootX] > self.vertex[rootY]:",
      "            rootX, rootY = rootY, rootX",
      "        self._parent[rootX] = rootY",
      "        self.vertex[rootY] += self.vertex[rootX]",
      "        self.edge[rootY] += self.edge[rootX] + 1",
      "        self.part -= 1",
      "        return True",
      "",
      "    def isConnected(self, x: int, y: int) -> bool:",
      "        return self.find(x) == self.find(y)",
      "",
      "    def getGroups(self) -> DefaultDict[int, List[int]]:",
      "        groups = defaultdict(list)",
      "        for key in range(self.n):",
      "            root = self.find(key)",
      "            groups[root].append(key)",
      "        return groups",
      "",
      "    def getRoots(self) -> List[int]:",
      "        return list(set(self.find(i) for i in range(self.n)))",
      "",
      "    def __repr__(self) -> str:",
      "        return '\\n'.join(f'{root}: {member}' for root, member in self.getGroups().items())",
      "",
      "    def __len__(self) -> int:",
      "        return self.part"
    ],
    "description": "通用的并查集"
  },
  "SortedList计数": {
    "scope": "python",
    "prefix": ["BITSortedList", "SortedList计数"],
    "body": [
      "from sortedcontainers import SortedList",
      "",
      "def queryRange(left: int, right: int) -> int:",
      "    '''求[left, right]闭区间内的元素个数'''",
      "    if left > right:",
      "        return 0",
      "    return sl.bisect_right(right) - sl.bisect_left(left)",
      "",
      "def query(right: int) -> int:",
      "    '''求(-∞,right]区间内的元素个数'''",
      "    return sl.bisect_right(right)",
      "",
      "sl = SortedList()"
    ],
    "description": "SortedList区间计数"
  },
  "python的BITArray": {
    "scope": "python",
    "prefix": "BITArray",
    "body": [
      "from typing import List, Sequence, Union",
      "",
      "class BITArray:",
      "    '''Point Add Range Sum, 0-indexed.'''",
      "",
      "    @staticmethod",
      "    def _build(sequence: Sequence[int]) -> List[int]:",
      "        tree = [0] * (len(sequence) + 1)",
      "        for i in range(1, len(tree)):",
      "            tree[i] += sequence[i - 1]",
      "            parent = i + (i & -i)",
      "            if parent < len(tree):",
      "                tree[parent] += tree[i]",
      "        return tree",
      "",
      "    __slots__ = ('_n', '_tree')",
      "",
      "    def __init__(self, lenOrSequence: Union[int, Sequence[int]]):",
      "        if isinstance(lenOrSequence, int):",
      "            self._n = lenOrSequence",
      "            self._tree = [0] * (lenOrSequence + 1)",
      "        else:",
      "            self._n = len(lenOrSequence)",
      "            self._tree = self._build(lenOrSequence)",
      "",
      "    def add(self, index: int, delta: int) -> None:",
      "        index += 1",
      "        while index <= self._n:",
      "            self._tree[index] += delta",
      "            index += index & -index",
      "",
      "    def query(self, right: int) -> int:",
      "        '''Query sum of [0, right).'''",
      "        if right > self._n:",
      "            right = self._n",
      "        res = 0",
      "        while right > 0:",
      "            res += self._tree[right]",
      "            right -= right & -right",
      "        return res",
      "",
      "    def queryRange(self, left: int, right: int) -> int:",
      "        '''Query sum of [left, right).'''",
      "        return self.query(right) - self.query(left)",
      "",
      "    def __len__(self) -> int:",
      "        return self._n",
      "",
      "    def __repr__(self) -> str:",
      "        nums = []",
      "        for i in range(1, self._n + 1):",
      "            nums.append(self.queryRange(i, i + 1))",
      "        return f'BITArray({nums})'"
    ],
    "description": "python的BITArray"
  },

  "ts的BITArray": {
    "scope": "typescript,typescriptreact",
    "prefix": "BITArray",
    "body": [
      "/**",
      " * Point add range sum, 0-indexed.",
      " */",
      "class BITArray {",
      "\t/**",
      "\t * Build a tree from an array-like object using dp.",
      "\t * O(n) time.",
      "\t */",
      "\tprivate static _buildTree(arr: ArrayLike<number>): Float64Array {",
      "\t\tconst tree = new Float64Array(arr.length + 1)",
      "\t\tfor (let i = 1; i < tree.length; i++) {",
      "\t\t\ttree[i] += arr[i - 1]",
      "\t\t\tconst parent = i + (i & -i)",
      "\t\t\tif (parent < tree.length) tree[parent] += tree[i]",
      "\t\t}",
      "\t\treturn tree",
      "\t}",
      "",
      "\treadonly length: number",
      "\tprivate readonly _tree: Float64Array",
      "",
      "\t/**",
      "\t * 指定长度或者从类数组建立树状数组.",
      "\t *",
      "\t * @warning",
      "\t * !如果需要使用`值域树状数组`，需要在构造函数中传入`长度n(值域1-n)`而不是类数组.",
      "\t */",
      "\tconstructor(lengthOrArrayLike: number | ArrayLike<number>) {",
      "\t\tif (typeof lengthOrArrayLike === 'number') {",
      "\t\t\tthis.length = lengthOrArrayLike",
      "\t\t\tthis._tree = new Float64Array(lengthOrArrayLike + 1)",
      "\t\t} else {",
      "\t\t\tthis.length = lengthOrArrayLike.length",
      "\t\t\tthis._tree = BITArray._buildTree(lengthOrArrayLike)",
      "\t\t}",
      "\t}",
      "",
      "\t/**",
      "\t * Add delta to the element at index.",
      "\t * @param index 0 <= index < {@link length}",
      "\t */",
      "\tadd(index: number, delta: number): void {",
      "\t\tindex++",
      "\t\tfor (let i = index; i <= this.length; i += i & -i) {",
      "\t\t\tthis._tree[i] += delta",
      "\t\t}",
      "\t}",
      "",
      "\t/**",
      "\t * Query the sum of [0, end).",
      "\t */",
      "\tquery(end: number): number {",
      "\t\tif (end > this.length) end = this.length",
      "\t\tlet res = 0",
      "\t\tfor (let i = end; i > 0; i &= i - 1) {",
      "\t\t\tres += this._tree[i]",
      "\t\t}",
      "\t\treturn res",
      "\t}",
      "",
      "\t/**",
      "\t * Query the sum of [start, end).",
      "\t */",
      "\tqueryRange(start: number, end: number): number {",
      "\t\treturn this.query(end) - this.query(start)",
      "\t}",
      "",
      "\ttoString(): string {",
      "\t\tconst sb: string[] = []",
      "\t\tsb.push('BITArray: [')",
      "\t\tfor (let i = 1; i < this._tree.length; i++) {",
      "\t\t\tsb.push(String(this.queryRange(i, i + 1)))",
      "\t\t\tif (i < this._tree.length - 1) sb.push(', ')",
      "\t\t}",
      "\t\tsb.push(']')",
      "\t\treturn sb.join('')",
      "\t}",
      "}"
    ],
    "description": "ts的BITArray"
  },
  "树状数组单点修改区间查询": {
    "scope": "python",
    "prefix": "BIT1",
    "body": [
      "class BIT1:",
      "    '''单点修改'''",
      "",
      "    __slots__ = 'size', 'bit', 'tree'",
      "",
      "    def __init__(self, n: int):",
      "        self.size = n + 5",
      "        self.bit = n.bit_length()",
      "        self.tree = dict()",
      "",
      "    def add(self, index: int, delta: int) -> None:",
      "        index += 1",
      "        while index <= self.size:",
      "            self.tree[index] = self.tree.get(index, 0) + delta",
      "            index += index & -index",
      "",
      "    def query(self, right: int) -> int:",
      "        '''Query sum of [0, right).'''",
      "        if right > self.size:",
      "            right = self.size",
      "        res = 0",
      "        while right > 0:",
      "            res += self.tree.get(right, 0)",
      "            right -= right & -right",
      "        return res",
      "",
      "    def queryRange(self, left: int, right: int) -> int:",
      "        '''Query sum of [left, right).'''",
      "        return self.query(right) - self.query(left)",
      "",
      "    def bisectLeft(self, k: int) -> int:",
      "        '''返回第一个前缀和大于等于k的位置pos",
      "        0 <= pos <= self.size'''",
      "        curSum, pos = 0, 0",
      "        for i in range(self.bit, -1, -1):",
      "            nextPos = pos + (1 << i)",
      "            if nextPos <= self.size and curSum + self.tree.get(nextPos, 0) < k:",
      "                pos = nextPos",
      "                curSum += self.tree.get(pos, 0)",
      "        return pos",
      "",
      "    def bisectRight(self, k: int) -> int:",
      "        '''返回第一个前缀和大于k的位置pos",
      "        0 <= pos <= self.size'''",
      "        curSum, pos = 0, 0",
      "        for i in range(self.bit, -1, -1):",
      "            nextPos = pos + (1 << i)",
      "            if nextPos <= self.size and curSum + self.tree.get(nextPos, 0) <= k:",
      "                pos = nextPos",
      "                curSum += self.tree.get(pos, 0)",
      "        return pos",
      "",
      "    def __repr__(self) -> str:",
      "        arr = []",
      "        for i in range(self.size):",
      "            arr.append(self.queryRange(i, i + 1))",
      "        return str(arr)",
      "",
      "    def __len__(self) -> int:",
      "        return self.size"
    ],
    "description": "树状数组单点修改区间查询"
  },
  "树状数组区间修改区间查询": {
    "scope": "python",
    "prefix": "BIT2",
    "body": [
      "class BIT2:",
      "    '''范围修改,0-indexed'''",
      "    __slots__ = 'size', '_tree1', '_tree2'",
      "",
      "    def __init__(self, n: int):",
      "        self.size = n + 5",
      "        self._tree1 = dict()",
      "        self._tree2 = dict()",
      "",
      "    def add(self, left: int, right: int, delta: int) -> None:",
      "        '''区间[left, right)加delta.'''",
      "        right -= 1",
      "        self._add(left, delta)",
      "        self._add(right + 1, -delta)",
      "",
      "    def query(self, left: int, right: int) -> int:",
      "        '''区间[left, right)的和.'''",
      "        right -= 1",
      "        return self._query(right) - self._query(left - 1)",
      "",
      "    def _add(self, index: int, delta: int) -> None:",
      "        index += 1",
      "        rawIndex = index",
      "        while index <= self.size:",
      "            self._tree1[index] = self._tree1.get(index, 0) + delta",
      "            self._tree2[index] = self._tree2.get(index, 0) + (rawIndex - 1) * delta",
      "            index += index & -index",
      "",
      "    def _query(self, index: int) -> int:",
      "        index += 1",
      "        if index > self.size:",
      "            index = self.size",
      "        rawIndex = index",
      "        res = 0",
      "        while index > 0:",
      "            res += rawIndex * self._tree1.get(index, 0) - self._tree2.get(index, 0)",
      "            index &= index - 1",
      "        return res",
      "",
      "    def __repr__(self) -> str:",
      "        arr = []",
      "        for i in range(self.size):",
      "            arr.append(self.query(i, i + 1))",
      "        return str(arr)",
      "",
      "    def __len__(self) -> int:",
      "        return self.size"
    ],
    "description": "树状数组区间修改区间查询"
  },
  "埃氏筛-py": {
    "scope": "python",
    "prefix": ["埃氏筛", "EratosthenesSieve", "筛法"],
    "body": [
      "from collections import Counter",
      "from typing import List",
      "",
      "",
      "class EratosthenesSieve:",
      "    '''埃氏筛'''",
      "",
      "    __slots__ = '_minPrime'  # 每个数的最小质因数",
      "",
      "    def __init__(self, maxN: int):",
      "        '''预处理 O(nloglogn)'''",
      "        minPrime = list(range(maxN + 1))",
      "        upper = int(maxN**0.5) + 1",
      "        for i in range(2, upper):",
      "            if minPrime[i] < i:",
      "                continue",
      "            for j in range(i * i, maxN + 1, i):",
      "                if minPrime[j] == j:",
      "                    minPrime[j] = i",
      "        self._minPrime = minPrime",
      "",
      "    def isPrime(self, n: int) -> bool:",
      "        if n < 2:",
      "            return False",
      "        return self._minPrime[n] == n",
      "",
      "    def getPrimeFactors(self, n: int) -> 'Counter[int]':",
      "        '''求n的质因数分解 O(logn)'''",
      "        res, f = Counter(), self._minPrime",
      "        while n > 1:",
      "            m = f[n]",
      "            res[m] += 1",
      "            n //= m",
      "        return res",
      "",
      "    def getPrimes(self) -> List[int]:",
      "        return [x for i, x in enumerate(self._minPrime) if i >= 2 and i == x]"
    ],
    "description": "埃氏筛"
  },
  "埃氏筛-ts": {
    "scope": "typescript",
    "prefix": ["埃氏筛", "EratosthenesSieve", "筛法"],
    "body": [
      "/**",
      " * 埃氏筛.",
      " */",
      "class EratosthenesSieve {",
      "  /**",
      "   * 每个数的最小质因子.",
      "   */",
      "  private readonly minPrime: Uint32Array",
      "  private readonly _max: number",
      "  constructor(max: number) {",
      "    const minPrime = new Uint32Array(max + 1)",
      "    for (let i = 0; i <= max; i++) minPrime[i] = i",
      "    const upper = ~~Math.sqrt(max)",
      "    for (let i = 2; i <= upper; i++) {",
      "      if (minPrime[i] < i) continue",
      "      for (let j = i * i; j <= max; j += i) {",
      "        if (minPrime[j] === j) minPrime[j] = i",
      "      }",
      "    }",
      "    this.minPrime = minPrime",
      "    this._max = max",
      "  }",
      "  isPrime(n: number): boolean {",
      "    return n >= 2 && this.minPrime[n] === n",
      "  }",
      "  getPrimeFactors(n: number): ReadonlyMap<number, number> {",
      "    const f = this.minPrime",
      "    const res = new Map<number, number>()",
      "    while (n > 1) {",
      "      const p = f[n]",
      "      res.set(p, (res.get(p) || 0) + 1)",
      "      n /= p",
      "    }",
      "    return res",
      "  }",
      "  getPrimes(n = this._max): readonly number[] {",
      "    const res: number[] = []",
      "    for (let i = 2; i <= n; i++) {",
      "      if (i === this.minPrime[i]) res.push(i)",
      "    }",
      "    return res",
      "  }",
      "}"
    ],
    "description": "埃氏筛"
  },
  "链表转换": {
    "scope": "python",
    "prefix": "linkedListToArray",
    "body": [
      "class ListNode:",
      "    def __init__(self, val=0, next=None):",
      "        self.val = val",
      "        self.next = next",
      "",
      "",
      "def arrayToLinkedList(nums):",
      "    dummy = ListNode(0)",
      "    p = dummy",
      "    for num in nums:",
      "        p.next = ListNode(num)",
      "        p = p.next",
      "    return dummy.next",
      "",
      "",
      "def linkedListToArray(head):",
      "    nums = []",
      "    p = head",
      "    while p:",
      "        nums.append(p.val)",
      "        p = p.next",
      "    return nums"
    ],
    "description": "链表转数组/数组转链表"
  },
  "等差数列求和": {
    "scope": "python",
    "prefix": ["等差数列求和", "arithmeticSum", "dengchashulie"],
    "body": [
      "def arithmeticSum1(first: int, last: int, diff: int) -> int:",
      "    '''等差数列求和 first:首项 last:末项 diff:公差'''",
      "    item = (last - first) // diff + 1",
      "    return item * (first + last) // 2",
      "",
      "def arithmeticSum2(first: int, diff: int, item: int) -> int:",
      "    '''等差数列求和 first:首项 diff:公差 item:项数'''",
      "    last = first + (item - 1) * diff",
      "    return item * (first + last) // 2"
    ],
    "description": "等差数列求和"
  },
  "tsInput": {
    "scope": "typescript,typescriptreact",
    "prefix": "useInput",
    "body": [
      "import * as fs from 'fs'",
      "import { resolve } from 'path'",
      "",
      "function useInput(path?: string) {",
      "  let data: string",
      "  if (path) {",
      "    data = fs.readFileSync(resolve(__dirname, path), 'utf8')",
      "  } else {",
      "    data = fs.readFileSync(process.stdin.fd, 'utf8')",
      "  }",
      "",
      "  const lines = data.split(/\\r\\n|\\r|\\n/)",
      "  let lineId = 0",
      "  const input = (): string => lines[lineId++]",
      "",
      "  return {",
      "    input",
      "  }",
      "}"
    ],
    "description": "tsInput"
  },
  "bisect1": {
    "scope": "typescript,typescriptreact",
    "prefix": "bisect1",
    "body": [
      "let left = 0",
      "let right = 2e15",
      "let ok = false",
      "while (left <= right) {",
      "  const mid = Math.floor((left + right) / 2)",
      "  if (check(mid)) {",
      "    right = mid - 1",
      "    ok = true",
      "  } else {",
      "    left = mid + 1",
      "  }",
      "}",
      "",
      "return left",
      "",
      "function check(mid: number): boolean {",
      "  return true",
      "}"
    ],
    "description": "最右二分"
  },
  "bisect1-golang": {
    "scope": "go,golang",
    "prefix": "bisect1",
    "body": [
      "check := func(mid int) bool {",
      "  return true",
      "}",
      "left, right := 0, int(1e18)",
      "for left <= right {",
      "  mid := (left + right) / 2",
      "  if check(mid) {",
      "    right = mid - 1",
      "  } else {",
      "    left = mid + 1",
      "  }",
      "}",
      "return left"
    ],
    "description": "最左二分"
  },
  "bisect2-golang": {
    "scope": "go,golang",
    "prefix": "bisect2",
    "body": [
      "check := func(mid int) bool {",
      "  return true",
      "}",
      "left, right := 1, int(1e18)",
      "for left <= right {",
      "  mid := (left + right) / 2",
      "  if check(mid) {",
      "    left = mid + 1",
      "  } else {",
      "    right = mid - 1",
      "  }",
      "}",
      "return right"
    ],
    "description": "最右二分"
  },
  "bisect2": {
    "scope": "typescript,typescriptreact",
    "prefix": "bisect2",
    "body": [
      "let left = 1",
      "let right = 2e15",
      "let ok = false",
      "while (left <= right) {",
      "  const mid = Math.floor((left + right) / 2)",
      "  if (check(mid)) {",
      "    left = mid + 1",
      "    ok = true",
      "  } else {",
      "    right = mid - 1",
      "  }",
      "}",
      "",
      "return right",
      "",
      "function check(mid: number): boolean {",
      "  return true",
      "}"
    ],
    "description": "最右二分"
  },
  "bisectKth": {
    "scope": "typescript,typescriptreact",
    "prefix": "bisectKth",
    "body": [
      "let left = 0",
      "let right = 4e15",
      "while (left <= right) {",
      "  const mid = (left + right) >> 1",
      "  if (countNGT(mid) < k) {",
      "    left = mid + 1",
      "  } else {",
      "    right = mid - 1",
      "  }",
      "}",
      "return left",
      "",
      "// 不超过mid的答案个数",
      "function countNGT(mid: number): number {",
      "  return 0",
      "}"
    ],
    "description": "二分答案查找第k小,k从1开始"
  },
  "bisectKth-go": {
    "scope": "go,golang",
    "prefix": "bisectKth",
    "body": [
      "// 不超过mid的答案个数",
      "countNGT := func(mid int) int {",
      "  return 0",
      "}",
      "left, right := 0, int(1e18)",
      "for left <= right {",
      "  mid := (left + right) / 2",
      "  if countNGT(mid) < k {",
      "    left = mid + 1",
      "  } else {",
      "    right = mid - 1",
      "  }",
      "}",
      "return left"
    ],
    "description": "二分答案查找第k小,k从1开始"
  },
  "生成大数组测试用例": {
    "scope": "typescript,typescriptreact",
    "prefix": ["bigArray"],
    "body": [
      "const getBig = (len = 1e5): number[] => {",
      "  const big = Array(len)",
      "  for (let i = 0; i < len; i++) {",
      "    big[i] = ~~(Math.random() * 2e9) - 1e9",
      "  }",
      "  return big",
      "}"
    ],
    "description": "生成大数组测试用例"
  },
  "dfsOrder": {
    "scope": "typescript,typescriptreact",
    "prefix": "dfsOrder",
    "body": [
      "const ins = new Uint32Array(n + 10) // 子树中最小的结点序号,const left = ins[removeRoot]",
      "const outs = new Uint32Array(n + 10) // 子树中最大的结点序号,即自己的id,const right = outs[removeRoot]",
      "const depth = new Uint32Array(n + 10) // 深度 根节点深度为0",
      "let dfsId = 1",
      "dfsOrder(root, -1, 0)",
      "",
      "for (let i = 0; i < queries.length; i++) {",
      "  const queryRoot = queries[i]",
      "  const left = ins[queryRoot]",
      "  const right = outs[queryRoot]",
      "}",
      "",
      "function dfsOrder(cur: number, pre: number, dep: number): void {",
      "  ins[cur] = dfsId",
      "  for (let i = 0; i < tree[cur].length; i++) {",
      "    const next = tree[cur][i]",
      "    if (next === pre) continue",
      "    dfsOrder(next, cur, dep + 1)",
      "  }",
      "  outs[cur] = dfsId",
      "  depth[dfsId] = dep",
      "  dfsId++",
      "}"
    ],
    "description": "树的dfs序"
  },
  "dfsOrder-new": {
    "scope": "typescript,typescriptreact",
    "prefix": "dfsOrder-new",
    "body": [
      "const lid = new Uint32Array(n)",
      "const rid = new Uint32Array(n)",
      "let dfn = 0",
      "const dfs = (cur: number, pre: number): void => {",
      "\tlid[cur] = dfn",
      "\tdfn++",
      "\ttree[cur].forEach(next_ => {",
      "\t\tif (next_ !== pre) {",
      "\t\t\tdfs(next_, cur)",
      "\t\t}",
      "\t})",
      "\trid[cur] = dfn",
      "}",
      "dfs(0, -1)",
      "",
      "\t// data[lid[i]] = values[i]"
    ],
    "description": "dfs序"
  },
  "input": {
    "scope": "go,golang",
    "prefix": "input",
    "body": [
      // "const INF int = int(1e18)",
      // "const MOD int = 998244353",
      // "",
      "in := bufio.NewReader(os.Stdin)",
      "out := bufio.NewWriter(os.Stdout)",
      "defer out.Flush()",
      "",
      "var n int",
      "fmt.Fscan(in, &n)"
    ],
    "description": "golang input"
  },
  "go-bisectLeft": {
    "scope": "go,golang",
    "prefix": "bisectLeft",
    "body": [
      "func bisectLeft(nums []int, target int) int {",
      "  left, right := 0, len(nums) - 1",
      "  for left <= right {",
      "    mid := (left + right) >> 1",
      "    if nums[mid] < target {",
      "      left = mid + 1",
      "    } else {",
      "      right = mid - 1",
      "    }",
      "  }",
      "  return left",
      "}"
    ],
    "description": "bisectLeft"
  },
  "go-bisectRight": {
    "scope": "go,golang",
    "prefix": "bisectRight",
    "body": [
      "func bisectRight(nums []int, target int) int {",
      "  left, right := 0, len(nums) - 1",
      "  for left <= right {",
      "    mid := (left + right) >> 1",
      "    if nums[mid] <= target {",
      "      left = mid + 1",
      "    } else {",
      "      right = mid - 1",
      "    }",
      "  }",
      "  return left",
      "}"
    ],
    "description": "bisectRight"
  },

  "golang快速幂1": {
    "scope": "go,golang",
    "prefix": "pow",
    "body": [
      "func Pow(base, exp, mod int) int {",
      "  base %= mod",
      "  res := 1 % mod",
      "  for ; exp > 0; exp >>= 1 {",
      "    if exp&1 == 1 {",
      "      res = res * base % mod",
      "    }",
      "    base = base * base % mod",
      "  }",
      "  return res",
      "}"
    ],
    "description": "golang快速幂1"
  },
  "golang快速幂2": {
    "scope": "go,golang",
    "prefix": ["pow", "exgcd", "modInv"],
    "body": [
      "func Pow(base, exp, mod int) int {",
      "  if exp == -1 {",
      "    return modInv(base, mod)",
      "  }",
      "",
      "  base %= mod",
      "  res := 1 % mod",
      "  for ; exp > 0; exp >>= 1 {",
      "    if exp&1 == 1 {",
      "      res = res * base % mod",
      "    }",
      "    base = base * base % mod",
      "  }",
      "  return res",
      "}",
      "",
      "func exgcd(a, b int) (gcd, x, y int) {",
      "  if b == 0 {",
      "    return a, 1, 0",
      "  }",
      "  gcd, y, x = exgcd(b, a%b)",
      "  y -= a / b * x",
      "  return",
      "}",
      "",
      "// 注意模为1时不存在逆元",
      "func modInv(a, mod int) int {",
      "  gcd, x, _ := exgcd(a, mod)",
      "  if gcd != 1 {",
      "    panic(fmt.Sprintf(\"no inverse element for %d\", a))",
      "  }",
      "  return (x%mod + mod) % mod",
      "}"
    ],
    "description": "golang快速幂2"
  },
  "golang ModInt": {
    "scope": "go,golang",
    "prefix": ["modint", "ModInt"],
    "body": [
      "const MOD = 998244353",
      "type ModInt int64",
      "func (m ModInt) Add(x ModInt) ModInt {",
      " return (m + x).mod()",
      "}",
      "func (m *ModInt) IAdd(x ModInt) {",
      " *m = m.Add(x)",
      "}",
      "func (m ModInt) Sub(x ModInt) ModInt {",
      " return (m - x).mod()",
      "}",
      "func (m *ModInt) ISub(x ModInt) {",
      " *m = m.Sub(x)",
      "}",
      "func (m ModInt) Mul(x ModInt) ModInt {",
      " return (m * x).mod()",
      "}",
      "func (m *ModInt) IMul(x ModInt) {",
      " *m = m.Mul(x)",
      "}",
      "func (m ModInt) Div(x ModInt) ModInt {",
      " return m.Mul(x.Inv())",
      "}",
      "func (m *ModInt) IDiv(x ModInt) {",
      " *m = m.Div(x)",
      "}",
      "func (m ModInt) Pow(n ModInt) ModInt {",
      " m = m.mod()",
      " p := ModInt(1)",
      " for n > 0 {",
      " if n&1 == 1 {",
      " p.IMul(m)",
      " }",
      " m.IMul(m)",
      " n >>= 1",
      " }",
      " return p",
      "}",
      "func (m ModInt) Inv() ModInt {",
      " return m.Pow(ModInt(0).Sub(2))",
      "}",
      "func (m ModInt) mod() ModInt {",
      " m %= MOD",
      " if m < 0 {",
      " m += MOD",
      " }",
      " return m",
      "}"
    ],
    "description": "golang ModInt"
  },
  "golang快读": {
    "scope": "go,golang",
    "prefix": ["io", "input"],
    "body": [
      "package main",
      "import (",
      "  \"bufio\"",
      "  \"fmt\"",
      "  stdio \"io\"",
      "  \"os\"",
      "  \"strconv\"",
      ")",
      "// from https://atcoder.jp/users/ccppjsrb",
      "var io *Iost",
      "type Iost struct {",
      "  Scanner *bufio.Scanner",
      "  Writer  *bufio.Writer",
      "}",
      "func NewIost(fp stdio.Reader, wfp stdio.Writer) *Iost {",
      "  const BufSize = 2000005",
      "  scanner := bufio.NewScanner(fp)",
      "  scanner.Split(bufio.ScanWords)",
      "  scanner.Buffer(make([]byte, BufSize), BufSize)",
      "  return &Iost{Scanner: scanner, Writer: bufio.NewWriter(wfp)}",
      "}",
      "func (io *Iost) Text() string {",
      "  if !io.Scanner.Scan() {",
      "    panic(\"scan failed\")",
      "  }",
      "  return io.Scanner.Text()",
      "}",
      "func (io *Iost) Atoi(s string) int                 { x, _ := strconv.Atoi(s); return x }",
      "func (io *Iost) Atoi64(s string) int64             { x, _ := strconv.ParseInt(s, 10, 64); return x }",
      "func (io *Iost) Atof64(s string) float64           { x, _ := strconv.ParseFloat(s, 64); return x }",
      "func (io *Iost) NextInt() int                      { return io.Atoi(io.Text()) }",
      "func (io *Iost) NextInt64() int64                  { return io.Atoi64(io.Text()) }",
      "func (io *Iost) NextFloat64() float64              { return io.Atof64(io.Text()) }",
      "func (io *Iost) Print(x ...interface{})            { fmt.Fprint(io.Writer, x...) }",
      "func (io *Iost) Printf(s string, x ...interface{}) { fmt.Fprintf(io.Writer, s, x...) }",
      "func (io *Iost) Println(x ...interface{})          { fmt.Fprintln(io.Writer, x...) }",
      "  ",
      "func main() {",
      "  in := os.Stdin",
      "  out := os.Stdout",
      "  io = NewIost(in, out)",
      "  defer func() {",
      "    io.Writer.Flush()",
      "  }()",
      "  ",
      "  ",
      " }"
    ],
    "description": "golang快读"
  },
  "golang线段树单点修改区间查询": {
    "scope": "go,golang",
    "prefix": ["seg"],
    "body": [
      "const INF int = 1e18",
      "// PointSetRangeMin",
      "$1",
      "type E = int",
      "func (*SegmentTree) e() E        { return INF }",
      "func (*SegmentTree) op(a, b E) E { return min(a, b) }",
      "func min(a, b int) int {",
      " if a < b {",
      "  return a",
      " }",
      " return b",
      "}",
      "func max(a, b int) int {",
      " if a > b {",
      "  return a",
      " }",
      " return b",
      "}",
      "type SegmentTree struct {",
      " n, size int",
      " seg     []E",
      "}",
      "func NewSegmentTree(n int, f func(int) E) *SegmentTree {",
      "\tres := &SegmentTree{}",
      "\tsize := 1",
      "\tfor size < n {",
      "\t\tsize <<= 1",
      "\t}",
      "\tseg := make([]E, size<<1)",
      "\tfor i := range seg {",
      "\t\tseg[i] = res.e()",
      "\t}",
      "\tfor i := 0; i < n; i++ {",
      "\t\tseg[i+size] = f(i)",
      "\t}",
      "\tfor i := size - 1; i > 0; i-- {",
      "\t\tseg[i] = res.op(seg[i<<1], seg[i<<1|1])",
      "\t}",
      "\tres.n = n",
      "\tres.size = size",
      "\tres.seg = seg",
      "\treturn res",
      "}",
      "func NewSegmentTreeFrom(leaves []E) *SegmentTree {",
      " res := &SegmentTree{}",
      " n := len(leaves)",
      " size := 1",
      " for size < n {",
      "  size <<= 1",
      " }",
      " seg := make([]E, size<<1)",
      " for i:= range seg {",
      "  seg[i] = res.e()",
      " }",
      " for i := 0; i < n; i++ {",
      "  seg[i+size] = leaves[i]",
      " }",
      " for i := size - 1; i > 0; i-- {",
      "  seg[i] = res.op(seg[i<<1], seg[i<<1|1])",
      " }",
      " res.n = n",
      " res.size = size",
      " res.seg = seg",
      " return res",
      "}",
      "func (st *SegmentTree) Get(index int) E {",
      " if index < 0 || index >= st.n {",
      "  return st.e()",
      " }",
      " return st.seg[index+st.size]",
      "}",
      "func (st *SegmentTree) Set(index int, value E) {",
      " if index < 0 || index >= st.n {",
      "  return",
      " }",
      " index += st.size",
      " st.seg[index] = value",
      " for index >>= 1; index > 0; index >>= 1 {",
      "  st.seg[index] = st.op(st.seg[index<<1], st.seg[index<<1|1])",
      " }",
      "}",
      "func (st *SegmentTree) Update(index int, value E) {",
      " if index < 0 || index >= st.n {",
      "  return",
      " }",
      " index += st.size",
      " st.seg[index] = st.op(st.seg[index], value)",
      " for index >>= 1; index > 0; index >>= 1 {",
      "  st.seg[index] = st.op(st.seg[index<<1], st.seg[index<<1|1])",
      " }",
      "}",
      "// [start, end)",
      "func (st *SegmentTree) Query(start, end int) E {",
      " if start < 0 {",
      "  start = 0",
      " }",
      " if end > st.n {",
      "  end = st.n",
      " }",
      " if start >= end {",
      "  return st.e()",
      " }",
      " leftRes, rightRes := st.e(), st.e()",
      " start += st.size",
      " end += st.size",
      " for start < end {",
      "  if start&1 == 1 {",
      "   leftRes = st.op(leftRes, st.seg[start])",
      "   start++",
      "  }",
      "  if end&1 == 1 {",
      "   end--",
      "   rightRes = st.op(st.seg[end], rightRes)",
      "  }",
      "  start >>= 1",
      "  end >>= 1",
      " }",
      " return st.op(leftRes, rightRes)",
      "}",
      "func (st *SegmentTree) QueryAll() E { return st.seg[1] }",
      "func (st *SegmentTree) GetAll() []E {",
      " res := make([]E, st.n)",
      " copy(res, st.seg[st.size:st.size+st.n])",
      " return res",
      "}",
      "// 二分查询最大的 right 使得切片 [left:right] 内的值满足 predicate",
      "func (st *SegmentTree) MaxRight(left int, predicate func(E) bool) int {",
      " if left == st.n {",
      "  return st.n",
      " }",
      " left += st.size",
      " res := st.e()",
      " for {",
      "  for left&1 == 0 {",
      "   left >>= 1",
      "  }",
      "  if !predicate(st.op(res, st.seg[left])) {",
      "   for left < st.size {",
      "    left <<= 1",
      "    if tmp := st.op(res, st.seg[left]); predicate(tmp) {",
      "     res = tmp",
      "     left++",
      "    }",
      "   }",
      "   return left - st.size",
      "  }",
      "  res = st.op(res, st.seg[left])",
      "  left++",
      "  if (left & -left) == left {",
      "   break",
      "  }",
      " }",
      " return st.n",
      "}",
      "// 二分查询最小的 left 使得切片 [left:right] 内的值满足 predicate",
      "func (st *SegmentTree) MinLeft(right int, predicate func(E) bool) int {",
      " if right == 0 {",
      "  return 0",
      " }",
      " right += st.size",
      " res := st.e()",
      " for {",
      "  right--",
      "  for right > 1 && right&1 == 1 {",
      "   right >>= 1",
      "  }",
      "  if !predicate(st.op(st.seg[right], res)) {",
      "   for right < st.size {",
      "    right = right<<1 | 1",
      "    if tmp := st.op(st.seg[right], res); predicate(tmp) {",
      "     res = tmp",
      "     right--",
      "    }",
      "   }",
      "   return right + 1 - st.size",
      "  }",
      "  res = st.op(st.seg[right], res)",
      "  if right&-right == right {",
      "    break",
      "  }",
      " }",
      " return 0",
      "}"
    ],
    "description": "golang线段树单点修改区间查询"
  },
  "golang线段树区间修改单点查询": {
    "scope": "go,golang",
    "prefix": ["segDual"],
    "body": [
      "",
      "// RangeAssignPointGet",
      "",
      "type Id = int",
      "",
      "const COMMUTATIVE = false",
      "",
      "func (*SegmentTreeDual) id() Id\t\t\t\t\t\t\t\t { return 0 }",
      "func (*SegmentTreeDual) composition(f, g Id) Id { return f }",
      "",
      "type SegmentTreeDual struct {",
      "\tn\t\t\t\t\t\tint",
      "\tsize, height int",
      "\tlazy\t\t\t\t []Id",
      "\tunit\t\t\t\t Id",
      "}",
      "",
      "func NewSegmentTreeDual(n int) *SegmentTreeDual {",
      "\tres := &SegmentTreeDual{}",
      "\tsize := 1",
      "\theight := 0",
      "\tfor size < n {",
      "\t\tsize <<= 1",
      "\t\theight++",
      "\t}",
      "\tlazy := make([]Id, 2*size)",
      "\tunit := res.id()",
      "\tfor i := 0; i < 2*size; i++ {",
      "\t\tlazy[i] = unit",
      "\t}",
      "\tres.n = n",
      "\tres.size = size",
      "\tres.height = height",
      "\tres.lazy = lazy",
      "\tres.unit = unit",
      "\treturn res",
      "}",
      "func (seg *SegmentTreeDual) Get(index int) Id {",
      "\tindex += seg.size",
      "\tfor i := seg.height; i > 0; i-- {",
      "\t\tseg.propagate(index >> i)",
      "\t}",
      "\treturn seg.lazy[index]",
      "}",
      "func (seg *SegmentTreeDual) GetAll() []Id {",
      "\tfor i := 0; i < seg.size; i++ {",
      "\t\tseg.propagate(i)",
      "\t}",
      "\tres := make([]Id, seg.n)",
      "\tcopy(res, seg.lazy[seg.size:seg.size+seg.n])",
      "\treturn res",
      "}",
      "func (seg *SegmentTreeDual) Update(left, right int, value Id) {",
      "\tif left < 0 {",
      "\t\tleft = 0",
      "\t}",
      "\tif right > seg.n {",
      "\t\tright = seg.n",
      "\t}",
      "\tif left >= right {",
      "\t\treturn",
      "\t}",
      "\tleft += seg.size",
      "\tright += seg.size",
      "\tif !COMMUTATIVE {",
      "\t\tfor i := seg.height; i > 0; i-- {",
      "\t\t\tif (left>>i)<<i != left {",
      "\t\t\t\tseg.propagate(left >> i)",
      "\t\t\t}",
      "\t\t\tif (right>>i)<<i != right {",
      "\t\t\t\tseg.propagate((right - 1) >> i)",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "\tfor left < right {",
      "\t\tif left&1 > 0 {",
      "\t\t\tseg.lazy[left] = seg.composition(value, seg.lazy[left])",
      "\t\t\tleft++",
      "\t\t}",
      "\t\tif right&1 > 0 {",
      "\t\t\tright--",
      "\t\t\tseg.lazy[right] = seg.composition(value, seg.lazy[right])",
      "\t\t}",
      "\t\tleft >>= 1",
      "\t\tright >>= 1",
      "\t}",
      "}",
      "func (seg *SegmentTreeDual) propagate(k int) {",
      "\tif seg.lazy[k] != seg.unit {",
      "\t\tseg.lazy[k<<1] = seg.composition(seg.lazy[k], seg.lazy[k<<1])",
      "\t\tseg.lazy[k<<1|1] = seg.composition(seg.lazy[k], seg.lazy[k<<1|1])",
      "\t\tseg.lazy[k] = seg.unit",
      "\t}",
      "}",
      "func (st *SegmentTreeDual) String() string {",
      "\tvar buf bytes.Buffer",
      "\tbuf.WriteByte('[')",
      "\tfor i := 0; i < st.n; i++ {",
      "\t\tif i > 0 {",
      "\t\t\tbuf.WriteByte(' ')",
      "\t\t}",
      "\t\tbuf.WriteString(fmt.Sprint(st.Get(i)))",
      "\t}",
      "\tbuf.WriteByte(']')",
      "\treturn buf.String()",
      "}",
      ""
    ],
    "description": "golang线段树区间修改单点查询"
  },
  "golang线段树lazy": {
    "scope": "go,golang",
    "prefix": ["segLazy"],
    "body": [
      "const INF = 1e18",
      "",
      "// RangeAssignRangeSumMin",
      "$1",
      "type E = struct { sum, size, min int }",
      "type Id = int",
      "",
      "func (*LazySegTree) e() E   { return E{min: INF} }",
      "func (*LazySegTree) id() Id { return INF }",
      "func (*LazySegTree) op(left, right E) E {",
      "  return E{left.sum + right.sum, left.size + right.size, min(left.min, right.min)}",
      "}",
      "func (*LazySegTree) mapping(f Id, g E) E {",
      "  if f == INF {",
      "    return g",
      "  }",
      "  return E{f * g.size, g.size, f}",
      "}",
      "func (*LazySegTree) composition(f, g Id) Id {",
      "  if f == INF {",
      "    return g",
      "  }",
      "  return f",
      "}",
      "func min(a, b int) int {",
      "  if a < b {",
      "    return a",
      "  }",
      "  return b",
      "}",
      "func max(a, b int) int {",
      "  if a < b {",
      "    return b",
      "  }",
      "  return a",
      "}",
      "",
      "",
      "",
      "// !template",
      "type LazySegTree struct {",
      "  n    int",
      "  size int",
      "  log  int",
      "  data []E",
      "  lazy []Id",
      "}",
      "",
      "func NewLazySegTree(n int, f func(int) E) *LazySegTree {",
      "\ttree := &LazySegTree{}",
      "\ttree.n = n",
      "\ttree.log = int(bits.Len(uint(n - 1)))",
      "\ttree.size = 1 << tree.log",
      "\ttree.data = make([]E, tree.size<<1)",
      "\ttree.lazy = make([]Id, tree.size)",
      "\tfor i := range tree.data {",
      "\t\ttree.data[i] = tree.e()",
      "\t}",
      "\tfor i := range tree.lazy {",
      "\t\ttree.lazy[i] = tree.id()",
      "\t}",
      "\tfor i := 0; i < n; i++ {",
      "\t\ttree.data[tree.size+i] = f(i)",
      "\t}",
      "\tfor i := tree.size - 1; i >= 1; i-- {",
      "\t\ttree.pushUp(i)",
      "\t}",
      "\treturn tree",
      "}",
      "",
      "func NewLazySegTreeFrom(leaves []E) *LazySegTree {",
      "  tree := &LazySegTree{}",
      "  n := len(leaves)",
      "  tree.n = n",
      "  tree.log = int(bits.Len(uint(n - 1)))",
      "  tree.size = 1 << tree.log",
      "  tree.data = make([]E, tree.size<<1)",
      "  tree.lazy = make([]Id, tree.size)",
      "  for i := range tree.data {",
      "    tree.data[i] = tree.e()",
      "  }",
      "  for i := range tree.lazy {",
      "    tree.lazy[i] = tree.id()",
      "  }",
      "  for i := 0; i < n; i++ {",
      "    tree.data[tree.size+i] = leaves[i]",
      "  }",
      "  for i := tree.size - 1; i >= 1; i-- {",
      "    tree.pushUp(i)",
      "  }",
      "  return tree",
      "}",
      "// 查询切片[left:right]的值",
      "//   0<=left<=right<=len(tree.data)",
      "func (tree *LazySegTree) Query(left, right int) E {",
      "  if left < 0 {",
      "    left = 0",
      "  }",
      "  if right > tree.n {",
      "    right = tree.n",
      "  }",
      "  if left >= right {",
      "    return tree.e()",
      "  }",
      "  left += tree.size",
      "  right += tree.size",
      "  for i := tree.log; i >= 1; i-- {",
      "    if ((left >> i) << i) != left {",
      "      tree.pushDown(left >> i)",
      "    }",
      "    if ((right >> i) << i) != right {",
      "      tree.pushDown((right - 1) >> i)",
      "    }",
      "  }",
      "  sml, smr := tree.e(), tree.e()",
      "  for left < right {",
      "    if left&1 != 0 {",
      "      sml = tree.op(sml, tree.data[left])",
      "      left++",
      "    }",
      "    if right&1 != 0 {",
      "      right--",
      "      smr = tree.op(tree.data[right], smr)",
      "    }",
      "    left >>= 1",
      "    right >>= 1",
      "  }",
      "  return tree.op(sml, smr)",
      "}",
      "func (tree *LazySegTree) QueryAll() E {",
      "  return tree.data[1]",
      "}",
      "func (tree *LazySegTree) GetAll() []E {",
      " res := make([]E, tree.n)",
      " copy(res, tree.data[tree.size:tree.size+tree.n])",
      " return res",
      "}",
      "",
      "// 更新切片[left:right]的值",
      "//   0<=left<=right<=len(tree.data)",
      "func (tree *LazySegTree) Update(left, right int, f Id) {",
      "  if left < 0 {",
      "    left = 0",
      "  }",
      "  if right > tree.n {",
      "    right = tree.n",
      "  }",
      "  if left >= right {",
      "    return",
      "  }",
      "  left += tree.size",
      "  right += tree.size",
      "  for i := tree.log; i >= 1; i-- {",
      "    if ((left >> i) << i) != left {",
      "      tree.pushDown(left >> i)",
      "    }",
      "    if ((right >> i) << i) != right {",
      "      tree.pushDown((right - 1) >> i)",
      "    }",
      "  }",
      "  l2, r2 := left, right",
      "  for left < right {",
      "    if left&1 != 0 {",
      "      tree.propagate(left, f)",
      "      left++",
      "    }",
      "    if right&1 != 0 {",
      "      right--",
      "      tree.propagate(right, f)",
      "    }",
      "    left >>= 1",
      "    right >>= 1",
      "  }",
      "  left = l2",
      "  right = r2",
      "  for i := 1; i <= tree.log; i++ {",
      "    if ((left >> i) << i) != left {",
      "      tree.pushUp(left >> i)",
      "    }",
      "    if ((right >> i) << i) != right {",
      "      tree.pushUp((right - 1) >> i)",
      "    }",
      "  }",
      "}",
      "",
      "// 二分查询最小的 left 使得切片 [left:right] 内的值满足 predicate",
      "func (tree *LazySegTree) MinLeft(right int, predicate func(data E) bool) int {",
      "  if right == 0 {",
      "    return 0",
      "  }",
      "  right += tree.size",
      "  for i := tree.log; i >= 1; i-- {",
      "    tree.pushDown((right - 1) >> i)",
      "  }",
      "  res := tree.e()",
      "  for {",
      "    right--",
      "    for right > 1 && right&1 != 0 {",
      "      right >>= 1",
      "    }",
      "    if !predicate(tree.op(tree.data[right], res)) {",
      "      for right < tree.size {",
      "        tree.pushDown(right)",
      "        right = right<<1|1",
      "        if tmp := tree.op(tree.data[right], res); predicate(tmp) {",
      "          res = tmp",
      "          right--",
      "        }",
      "      }",
      "      return right + 1 - tree.size",
      "    }",
      "    res = tree.op(tree.data[right], res)",
      "    if (right & -right) == right {",
      "      break",
      "    }",
      "  }",
      "  return 0",
      "}",
      "",
      "// 二分查询最大的 right 使得切片 [left:right] 内的值满足 predicate",
      "func (tree *LazySegTree) MaxRight(left int, predicate func(data E) bool) int {",
      "  if left == tree.n {",
      "    return tree.n",
      "  }",
      "  left += tree.size",
      "  for i := tree.log; i >= 1; i-- {",
      "    tree.pushDown(left >> i)",
      "  }",
      "  res := tree.e()",
      "  for {",
      "    for left&1 == 0 {",
      "      left >>= 1",
      "    }",
      "    if !predicate(tree.op(res, tree.data[left])) {",
      "      for left < tree.size {",
      "        tree.pushDown(left)",
      "        left<<=1",
      "        if tmp := tree.op(res, tree.data[left]); predicate(tmp) {",
      "          res = tmp",
      "          left++",
      "        }",
      "      }",
      "      return left - tree.size",
      "    }",
      "    res = tree.op(res, tree.data[left])",
      "    left++",
      "    if (left & -left) == left {",
      "      break",
      "    }",
      "  }",
      "  return tree.n",
      "}",
      "",
      "// 单点查询(不需要 pushUp/op 操作时使用)",
      "func (tree *LazySegTree) Get(index int) E {",
      "  index += tree.size",
      "  for i := tree.log; i >= 1; i-- {",
      "    tree.pushDown(index >> i)",
      "  }",
      "  return tree.data[index]",
      "}",
      "// 单点赋值",
      "func (tree *LazySegTree) Set(index int, e E) {",
      "  index += tree.size",
      "  for i := tree.log; i >= 1; i-- {",
      "    tree.pushDown(index >> i)",
      "  }",
      "  tree.data[index] = e",
      "  for i := 1; i <= tree.log; i++ {",
      "    tree.pushUp(index >> i)",
      "  }",
      "}",
      "",
      "func (tree *LazySegTree) pushUp(root int) {",
      "  tree.data[root] = tree.op(tree.data[root<<1], tree.data[root<<1|1])",
      "}",
      "func (tree *LazySegTree) pushDown(root int) {",
      "  if tree.lazy[root] != tree.id() {",
      "    tree.propagate(root<<1, tree.lazy[root])",
      "    tree.propagate(root<<1|1, tree.lazy[root])",
      "    tree.lazy[root] = tree.id()",
      "  }",
      "}",
      "func (tree *LazySegTree) propagate(root int, f Id) {",
      "  tree.data[root] = tree.mapping(f, tree.data[root])",
      "  // !叶子结点不需要更新lazy",
      "  if root < tree.size {",
      "    tree.lazy[root] = tree.composition(f, tree.lazy[root])",
      "  }",
      "}",
      "",
      "func (tree *LazySegTree) String() string {",
      "  var sb []string",
      "  sb = append(sb, \"[\")",
      "  for i := 0; i < tree.n; i++ {",
      "    if i != 0 {",
      "      sb = append(sb, \", \")",
      "    }",
      "    sb = append(sb, fmt.Sprintf(\"%v\", tree.Get(i)))",
      "  }",
      "  sb = append(sb, \"]\")",
      "  return strings.Join(sb, \"\")",
      "}"
    ],
    "description": "golang线段树lazy"
  },
  "golang线段树动态开点": {
    "scope": "go,golang",
    "prefix": ["segDynamic"],
    "body": [
      "// PointAddRangeSum",
      "$1",
      "type E = int",
      "func e() E { return 0 }",
      "func op(a, b E) E { return a + b }",
      "type DynamicSegTreeSparse struct {",
      "  L, R       int",
      "  persistent bool",
      "  unit       E",
      "}",
      "type SegNode struct {",
      "  idx     int",
      "  l, r    *SegNode",
      "  x, prod E",
      "}",
      "// 指定 [left,right) 区间建立动态开点线段树.",
      "func NewDynamicSegTreeSparse(left, right int, persistent bool) *DynamicSegTreeSparse {",
      "  return &DynamicSegTreeSparse{",
      "    L: left,",
      "    R: right,",
      "    persistent: persistent,",
      "    unit: e(),",
      "  }",
      "}",
      "func (ds *DynamicSegTreeSparse) NewRoot() *SegNode { return nil }",
      "// 查询区间 [left, right).",
      "// L<=left<=right<=R",
      "func (ds *DynamicSegTreeSparse) Query(root *SegNode, left, right int) E {",
      "  if left == right {",
      "    return ds.unit",
      "  }",
      "  x := ds.unit",
      "  ds._queryRec(root, ds.L, ds.R, left, right, &x)",
      "  return x",
      "}",
      "func (ds *DynamicSegTreeSparse) QueryAll(root *SegNode) E {",
      "  return ds.Query(root, ds.L, ds.R)",
      "}",
      "// L<=index<R",
      "func (ds *DynamicSegTreeSparse) Set(root *SegNode, index int, value E) *SegNode {",
      "  return ds._setRec(root, ds.L, ds.R, index, value)",
      "}",
      "func (ds *DynamicSegTreeSparse) Get(root *SegNode, index int) E {",
      "  return ds._getRec(root, index)",
      "}",
      "// L<=left<R",
      "func (ds *DynamicSegTreeSparse) Update(root *SegNode, index int, value E) *SegNode {",
      "  return ds._updateRec(root, ds.L, ds.R, index, value)",
      "}",
      "// 二分查询最小的 left 使得切片 [left:right] 内的值满足 check.",
      "// L<=right<=R",
      "func (ds *DynamicSegTreeSparse) MinLeft(root *SegNode, right int, check func(E) bool) int {",
      "  x := ds.unit",
      "  return ds._minLeftRec(root, ds.L, ds.R, right, check, &x)",
      "}",
      "// 二分查询最大的 right 使得切片 [left:right] 内的值满足 check.",
      "// L<=left<=R",
      "func (ds *DynamicSegTreeSparse) MaxRight(root *SegNode, left int, check func(E) bool) int {",
      "  x := ds.unit",
      "  return ds._maxRightRec(root, ds.L, ds.R, left, check, &x)",
      "}",
      "func (ds *DynamicSegTreeSparse) GetAll(root *SegNode) []struct {",
      "  index int",
      "  value E",
      "} {",
      "  res := make([]struct {",
      "    index int",
      "    value E",
      "  }, 0)",
      "  ds._getAllRec(root, &res)",
      "  return res",
      "}",
      "func (ds *DynamicSegTreeSparse) _pushUp(node *SegNode) {",
      "  node.prod = node.x",
      "  if node.l != nil {",
      "    node.prod = op(node.l.prod, node.prod)",
      "  }",
      "  if node.r != nil {",
      "    node.prod = op(node.prod, node.r.prod)",
      "  }",
      "}",
      "func (ds *DynamicSegTreeSparse) _newNode(idx int, x E) *SegNode {",
      "  return &SegNode{idx: idx, x: x, prod: x}",
      "}",
      "func (ds *DynamicSegTreeSparse) _copyNode(node *SegNode) *SegNode {",
      "  if node == nil || !ds.persistent {",
      "    return node",
      "  }",
      "  return &SegNode{idx: node.idx, l: node.l, r: node.r, x: node.x, prod: node.prod}",
      "}",
      "func (ds *DynamicSegTreeSparse) _setRec(root *SegNode, l, r, i int, x E) *SegNode {",
      "  if root == nil {",
      "    root = ds._newNode(i, x)",
      "    return root",
      "  }",
      "  root = ds._copyNode(root)",
      "  if root.idx == i {",
      "    root.x = x",
      "    ds._pushUp(root)",
      "    return root",
      "  }",
      "  m := (l + r) >> 1",
      "  if i < m {",
      "    if root.idx < i {",
      "      root.idx, i = i, root.idx",
      "      root.x, x = x, root.x",
      "    }",
      "    root.l = ds._setRec(root.l, l, m, i, x)",
      "  } else {",
      "    if i < root.idx {",
      "      root.idx, i = i, root.idx",
      "      root.x, x = x, root.x",
      "    }",
      "    root.r = ds._setRec(root.r, m, r, i, x)",
      "  }",
      "  ds._pushUp(root)",
      "  return root",
      "}",
      "func (ds *DynamicSegTreeSparse) _updateRec(root *SegNode, l, r, i int, x E) *SegNode {",
      "  if root == nil {",
      "    root = ds._newNode(i, x)",
      "    return root",
      "  }",
      "  root = ds._copyNode(root)",
      "  if root.idx == i {",
      "    root.x = op(root.x, x)",
      "    ds._pushUp(root)",
      "    return root",
      "  }",
      "  m := (l + r) >> 1",
      "  if i < m {",
      "    if root.idx < i {",
      "      root.idx, i = i, root.idx",
      "      root.x, x = x, root.x",
      "    }",
      "    root.l = ds._updateRec(root.l, l, m, i, x)",
      "  } else {",
      "    if i < root.idx {",
      "      root.idx, i = i, root.idx",
      "      root.x, x = x, root.x",
      "    }",
      "    root.r = ds._updateRec(root.r, m, r, i, x)",
      "  }",
      "  ds._pushUp(root)",
      "  return root",
      "}",
      "func (ds *DynamicSegTreeSparse) _queryRec(root *SegNode, l, r, ql, qr int, x *E) {",
      "  ql = max(ql, l)",
      "  qr = min(qr, r)",
      "  if ql >= qr || root == nil {",
      "    return",
      "  }",
      "  if l == ql && r == qr {",
      "    *x = op(*x, root.prod)",
      "    return",
      "  }",
      "  m := (l + r) >> 1",
      "  ds._queryRec(root.l, l, m, ql, qr, x)",
      "  if ql <= root.idx && root.idx < qr {",
      "    *x = op(*x, root.x)",
      "  }",
      "  ds._queryRec(root.r, m, r, ql, qr, x)",
      "}",
      "func (ds *DynamicSegTreeSparse) _minLeftRec(root *SegNode, l, r, qr int, check func(E) bool, x *E) int {",
      "  if root == nil || qr <= l {",
      "    return ds.L",
      "  }",
      "  if check(op(root.prod, *x)) {",
      "    *x = op(root.prod, *x)",
      "    return ds.L",
      "  }",
      "  m := (l + r) >> 1",
      "  k := ds._minLeftRec(root.r, m, r, qr, check, x)",
      "  if k != ds.L {",
      "    return k",
      "  }",
      "  if root.idx < qr {",
      "    *x = op(root.x, *x)",
      "    if !check(*x) {",
      "      return root.idx + 1",
      "    }",
      "  }",
      "  return ds._minLeftRec(root.l, l, m, qr, check, x)",
      "}",
      "func (ds *DynamicSegTreeSparse) _maxRightRec(root *SegNode, l, r, ql int, check func(E) bool, x *E) int {",
      "  if root == nil || r <= ql {",
      "    return ds.R",
      "  }",
      "  if check(op(*x, root.prod)) {",
      "    *x = op(*x, root.prod)",
      "    return ds.R",
      "  }",
      "  m := (l + r) >> 1",
      "  k := ds._maxRightRec(root.l, l, m, ql, check, x)",
      "  if k != ds.R {",
      "    return k",
      "  }",
      "  if ql <= root.idx {",
      "    *x = op(*x, root.x)",
      "    if !check(*x) {",
      "      return root.idx",
      "    }",
      "  }",
      "  return ds._maxRightRec(root.r, m, r, ql, check, x)",
      "}",
      "func (ds *DynamicSegTreeSparse) _getAllRec(root *SegNode, res *[]struct {",
      "  index int",
      "  value E",
      "}) {",
      "  if root == nil {",
      "    return",
      "  }",
      "  ds._getAllRec(root.l, res)",
      "  *res = append(*res, struct {",
      "    index int",
      "    value E",
      "  }{root.idx, root.x})",
      "  ds._getAllRec(root.r, res)",
      "}",
      "func (ds *DynamicSegTreeSparse) _getRec(root *SegNode, idx int) E {",
      "  if root == nil {",
      "    return ds.unit",
      "  }",
      "  if idx == root.idx {",
      "    return root.x",
      "  }",
      "  if idx < root.idx {",
      "    return ds._getRec(root.l, idx)",
      "  }",
      "  return ds._getRec(root.r, idx)",
      "}",
      "func min(a, b int) int {",
      "  if a < b {",
      "    return a",
      "  }",
      "  return b",
      "}",
      "func max(a, b int) int {",
      "  if a > b {",
      "    return a",
      "  }",
      "  return b",
      "}"
    ],
    "description": "golang线段树动态开点,区间查询,单点修改"
  },
  "golang线段树动态开点lazy": {
    "scope": "go,golang",
    "prefix": ["segDynamicLazy"],
    "body": [
      "// RangeAssignRangeSum",
      "$1",
      "type E = int",
      "type Id = int",
      "func e1() E                { return 0 }",
      "func e2(left, right int) E { return 0 } // default query value",
      "func id() Id               { return -1 }",
      "func op(a, b E) E          { return a + b }",
      "func mapping(f Id, g E, size int) E {",
      " if f == -1 {",
      " return g",
      " }",
      " return f * size",
      "}",
      "func composition(f, g Id) Id {",
      " if f == -1 {",
      " return g",
      " }",
      " return f",
      "}",
      "type DynamicSegTreeLazy struct {",
      "  L, R       int",
      "  persistent bool",
      "  dataUnit   E",
      "  lazyUnit   Id",
      "}",
      "type SegNode struct {",
      "  l, r *SegNode",
      "  x    E",
      "  lazy Id",
      "}",
      "func NewDynamicSegTreeLazy(left, right int, persistent bool) *DynamicSegTreeLazy {",
      "  return &DynamicSegTreeLazy{",
      "    L:          left,",
      "    R:          right,",
      "    persistent: persistent,",
      "    dataUnit:   e1(),",
      "    lazyUnit:   id(),",
      "  }",
      "}",
      "func (ds *DynamicSegTreeLazy) NewRoot() *SegNode {",
      "  return &SegNode{x: e2(ds.L, ds.R), lazy: ds.lazyUnit}",
      "}",
      "func (ds *DynamicSegTreeLazy) Build(nums []E) *SegNode {",
      "  return ds._buildRec(0, len(nums), nums)",
      "}",
      "// L<=left<=right<=R",
      "func (ds *DynamicSegTreeLazy) Query(root *SegNode, left, right int) E {",
      "  if left == right {",
      "    return ds.dataUnit",
      "  }",
      "  x := ds.dataUnit",
      "  ds._queryRec(root, ds.L, ds.R, left, right, &x, ds.lazyUnit)",
      "  return x",
      "}",
      "func (ds *DynamicSegTreeLazy) QueryAll(root *SegNode) E {",
      "  return root.x",
      "}",
      "// L<=index<R",
      "func (ds *DynamicSegTreeLazy) Set(root *SegNode, index int, value E) *SegNode {",
      "  return ds._setRec(root, ds.L, ds.R, index, value)",
      "}",
      "// L<=left<R",
      "func (ds *DynamicSegTreeLazy) Update(root *SegNode, index int, value E) *SegNode {",
      "  return ds._updateRec(root, ds.L, ds.R, index, value)",
      "}",
      "// L<=left<=right<=R",
      "func (ds *DynamicSegTreeLazy) UpdateRange(root *SegNode, left, right int, lazy Id) *SegNode {",
      "  if left == right {",
      "    return root",
      "  }",
      "  return ds._updateRangeRec(root, ds.L, ds.R, left, right, lazy)",
      "}",
      "// 二分查询最大的 right 使得切片 [left:right] 内的值满足 check.",
      "// L<=right<=R",
      "func (ds *DynamicSegTreeLazy) MinLeft(root *SegNode, right int, check func(E) bool) int {",
      "  x := ds.dataUnit",
      "  return ds._minLeftRec(root, ds.L, ds.R, right, check, &x)",
      "}",
      "// 二分查询最小的 left 使得切片 [left:right] 内的值满足 check.",
      "// L<=left<=R",
      "func (ds *DynamicSegTreeLazy) MaxRight(root *SegNode, left int, check func(E) bool) int {",
      "  x := ds.dataUnit",
      "  return ds._maxRightRec(root, ds.L, ds.R, left, check, &x)",
      "}",
      "func (ds *DynamicSegTreeLazy) GetAll(root *SegNode) []E {",
      "  res := make([]E, 0, ds.R-ds.L)",
      "  ds._getAllRec(root, ds.L, ds.R, &res, ds.lazyUnit)",
      "  return res",
      "}",
      "func (ds *DynamicSegTreeLazy) _newNode(left, right int) *SegNode {",
      "return &SegNode{x: e2(left, right), lazy: ds.lazyUnit}",
      "}",
      "",
      "func (ds *DynamicSegTreeLazy) _newNodeWithValue(x E) *SegNode {",
      "return &SegNode{x: x, lazy: ds.lazyUnit}",
      "}",
      "",
      "func (ds *DynamicSegTreeLazy) _copyNode(node *SegNode) *SegNode {",
      "if node == nil || !ds.persistent {",
      "return node",
      "}",
      "return &SegNode{l: node.l, r: node.r, x: node.x, lazy: node.lazy}",
      "}",
      "",
      "func (ds *DynamicSegTreeLazy) _pushDown(node *SegNode, l, r int) {",
      "m := (l + r) >> 1",
      "if node.lazy == ds.lazyUnit {",
      "return",
      "}",
      "if node.l == nil {",
      "node.l = ds._newNode(l, m)",
      "} else {",
      "node.l = ds._copyNode(node.l)",
      "}",
      "node.l.x = mapping(node.lazy, node.l.x, m-l)",
      "node.l.lazy = composition(node.lazy, node.l.lazy)",
      "if node.r == nil {",
      "node.r = ds._newNode(m, r)",
      "} else {",
      "node.r = ds._copyNode(node.r)",
      "}",
      "node.r.x = mapping(node.lazy, node.r.x, r-m)",
      "node.r.lazy = composition(node.lazy, node.r.lazy)",
      "node.lazy = ds.lazyUnit",
      "}",
      "func (ds *DynamicSegTreeLazy) _buildRec(left, right int, nums []E) *SegNode {",
      "if left == right {",
      "return nil",
      "}",
      "if right == left+1 {",
      "return ds._newNodeWithValue(nums[left])",
      "}",
      "mid := (left + right) >> 1",
      "lRoot := ds._buildRec(left, mid, nums)",
      "rRoot := ds._buildRec(mid, right, nums)",
      "x := op(lRoot.x, rRoot.x)",
      "root := ds._newNodeWithValue(x)",
      "root.l = lRoot",
      "root.r = rRoot",
      "return root",
      "}",
      "",
      "func (ds *DynamicSegTreeLazy) _setRec(root *SegNode, l, r, i int, x E) *SegNode {",
      "if l == r-1 {",
      "root = ds._copyNode(root)",
      "root.x = x",
      "root.lazy = ds.lazyUnit",
      "return root",
      "}",
      "ds._pushDown(root, l, r)",
      "m := (l + r) >> 1",
      "if root.l == nil {",
      "root.l = ds._newNode(l, m)",
      "}",
      "if root.r == nil {",
      "root.r = ds._newNode(m, r)",
      "}",
      "root = ds._copyNode(root)",
      "if i < m {",
      "root.l = ds._setRec(root.l, l, m, i, x)",
      "} else {",
      "root.r = ds._setRec(root.r, m, r, i, x)",
      "}",
      "root.x = op(root.l.x, root.r.x)",
      "return root",
      "}",
      "",
      "func (ds *DynamicSegTreeLazy) _updateRec(root *SegNode, l, r, i int, x E) *SegNode {",
      "if l == r-1 {",
      "root = ds._copyNode(root)",
      "root.x = op(root.x, x)",
      "root.lazy = ds.lazyUnit",
      "return root",
      "}",
      "ds._pushDown(root, l, r)",
      "m := (l + r) >> 1",
      "if root.l == nil {",
      "root.l = ds._newNode(l, m)",
      "}",
      "if root.r == nil {",
      "root.r = ds._newNode(m, r)",
      "}",
      "root = ds._copyNode(root)",
      "if i < m {",
      "root.l = ds._updateRec(root.l, l, m, i, x)",
      "} else {",
      "root.r = ds._updateRec(root.r, m, r, i, x)",
      "}",
      "root.x = op(root.l.x, root.r.x)",
      "return root",
      "}",
      "",
      "func (ds *DynamicSegTreeLazy) _queryRec(root *SegNode, l, r, ql, qr int, x *E, lazy Id) {",
      "ql = max(ql, l)",
      "qr = min(qr, r)",
      "if ql >= qr {",
      "return",
      "}",
      "if root == nil {",
      "*x = op(*x, mapping(lazy, e2(ql, qr), qr-ql))",
      "return",
      "}",
      "if l == ql && r == qr {",
      "*x = op(*x, mapping(lazy, root.x, r-l))",
      "return",
      "}",
      "m := (l + r) >> 1",
      "lazy = composition(lazy, root.lazy)",
      "ds._queryRec(root.l, l, m, ql, qr, x, lazy)",
      "ds._queryRec(root.r, m, r, ql, qr, x, lazy)",
      "}",
      "",
      "func (ds *DynamicSegTreeLazy) _updateRangeRec(root *SegNode, l, r, ql, qr int, lazy Id) *SegNode {",
      "if root == nil {",
      "root = ds._newNode(l, r)",
      "}",
      "ql = max(ql, l)",
      "qr = min(qr, r)",
      "if ql >= qr {",
      "return root",
      "}",
      "if l == ql && r == qr {",
      "root = ds._copyNode(root)",
      "root.x = mapping(lazy, root.x, r-l)",
      "root.lazy = composition(lazy, root.lazy)",
      "return root",
      "}",
      "ds._pushDown(root, l, r)",
      "m := (l + r) >> 1",
      "root = ds._copyNode(root)",
      "root.l = ds._updateRangeRec(root.l, l, m, ql, qr, lazy)",
      "root.r = ds._updateRangeRec(root.r, m, r, ql, qr, lazy)",
      "root.x = op(root.l.x, root.r.x)",
      "return root",
      "}",
      "",
      "func (ds *DynamicSegTreeLazy) _minLeftRec(root *SegNode, l, r, qr int, check func(E) bool, x *E) int {",
      "if qr <= l {",
      "return l",
      "}",
      "if root == nil {",
      "root = ds._newNode(l, r)",
      "}",
      "qr = min(qr, r)",
      "if r == qr && check(op(root.x, *x)) {",
      "*x = op(root.x, *x)",
      "return l",
      "}",
      "if r == l+1 {",
      "return r",
      "}",
      "ds._pushDown(root, l, r)",
      "m := (l + r) >> 1",
      "k := ds._minLeftRec(root.r, m, r, qr, check, x)",
      "if m < k {",
      "return k",
      "}",
      "return ds._minLeftRec(root.l, l, m, qr, check, x)",
      "}",
      "",
      "func (ds *DynamicSegTreeLazy) _maxRightRec(root *SegNode, l, r, ql int, check func(E) bool, x *E) int {",
      "if r <= ql {",
      "return r",
      "}",
      "if root == nil {",
      "root = ds._newNode(l, r)",
      "}",
      "ql = max(ql, l)",
      "if l == ql && check(op(*x, root.x)) {",
      "*x = op(*x, root.x)",
      "return r",
      "}",
      "if r == l+1 {",
      "return l",
      "}",
      "ds._pushDown(root, l, r)",
      "m := (l + r) >> 1",
      "k := ds._maxRightRec(root.l, l, m, ql, check, x)",
      "if m > k {",
      "return k",
      "}",
      "return ds._maxRightRec(root.r, m, r, ql, check, x)",
      "}",
      "",
      "func (ds *DynamicSegTreeLazy) _getAllRec(root *SegNode, l, r int, res *[]E, lazy Id) {",
      "if root == nil {",
      "root = ds._newNode(l, r)",
      "}",
      "if r-l == 1 {",
      "*res = append(*res, mapping(lazy, root.x, 1))",
      "return",
      "}",
      "m := (l + r) >> 1",
      "lazy = composition(lazy, root.lazy)",
      "ds._getAllRec(root.l, l, m, res, lazy)",
      "ds._getAllRec(root.r, m, r, res, lazy)",
      "}",
      "",
      "func min(a, b int) int {",
      "if a < b {",
      "return a",
      "}",
      "return b",
      "}",
      "",
      "func max(a, b int) int {",
      "if a > b {",
      "return a",
      "}",
      "return b",
      "}"
    ],
    "description": "golang线段树动态开点lazy,区间查询,区间修改"
  },
  "golang离散化(紧离散)": {
    "scope": "go,golang",
    "prefix": ["sortedSet", "discretizeCompressed"],
    "body": [
      "// (紧)离散化.",
      "//",
      "//\toffset: 离散化的起始值偏移量.",
      "//",
      "//\tgetRank: 给定一个数，返回它的排名`(offset ~ offset + count)`.",
      "//\tcount: 离散化(去重)后的元素个数.",
      "func DiscretizeCompressed(nums []int, offset int) (getRank func(value int) int, getValue func(rank int) int, count int) {",
      "\tset := make(map[int]struct{}, len(nums))",
      "\tfor _, v := range nums {",
      "\t\tset[v] = struct{}{}",
      "\t}",
      "\tcount = len(set)",
      "\trank := make([]int, 0, count)",
      "\tfor v := range set {",
      "\t\trank = append(rank, v)",
      "\t}",
      "\tsort.Ints(rank)",
      "\tmp := make(map[int]int, count)",
      "\tfor i, v := range rank {",
      "\t\tmp[v] = i + offset",
      "\t}",
      "\tgetRank = func(v int) int { return mp[v] }",
      "\tgetValue = func(r int) int { return rank[r-offset] }",
      "\tcount = len(nums)",
      "\treturn",
      "}"
    ],
    "description": "golang离散化"
  },
  "golang离散化2(松离散)": {
    "scope": "go,golang",
    "prefix": ["sortedSet", "discretizeSparse"],
    "body": [
      "",
      "// (松)离散化.",
      "//",
      "//\toffset: 离散化的起始值偏移量.",
      "//",
      "//\tgetRank: 给定一个数，返回它的排名`(offset ~ offset + count)`.",
      "//\tcount: 离散化(去重)后的元素个数.",
      "func DiscretizeSparse(nums []int, offset int) (getRank func(int) int, count int) {",
      "\tset := make(map[int]struct{})",
      "\tfor _, v := range nums {",
      "\t\tset[v] = struct{}{}",
      "\t}",
      "\tcount = len(set)",
      "\tallNums := make([]int, 0, count)",
      "\tfor k := range set {",
      "\t\tallNums = append(allNums, k)",
      "\t}",
      "\tsort.Ints(allNums)",
      "\tgetRank = func(x int) int { return sort.SearchInts(allNums, x) + offset }",
      "\treturn",
      "}"
    ],
    "description": "golang离散化2(松离散)"
  },
  "ts离散化(松离散)": {
    "scope": "ts,typescript",
    "prefix": ["sortedSet", "discretizeSparse"],
    "body": [
      "/**",
      " * (松)离散化.",
      " * @param offset 离散化后的排名偏移量.",
      " * @returns",
      " * - getRank: 给定一个数,返回它的排名`(offset ~ offset + count)`.",
      " * - count: 离散化(去重)后的元素个数.",
      " */",
      "function discretizeSparse(",
      "\tnums: number[],",
      "\toffset = 0",
      "): [getRank: (num: number) => number, count: number] {",
      "\tconst allNums = [...new Set(nums)].sort((a, b) => a - b)",
      "",
      "\t// bisect_left",
      "\tconst getRank = (num: number): number => {",
      "\t\tlet left = 0",
      "\t\tlet right = allNums.length - 1",
      "\t\twhile (left <= right) {",
      "\t\t\tconst mid = (left + right) >>> 1",
      "\t\t\tif (allNums[mid] >= num) {",
      "\t\t\t\tright = mid - 1",
      "\t\t\t} else {",
      "\t\t\t\tleft = mid + 1",
      "\t\t\t}",
      "\t\t}",
      "\t\treturn left + offset",
      "\t}",
      "\treturn [getRank, allNums.length]",
      "}"
    ],
    "description": "ts离散化(松离散)"
  },
  "ts离散化2(紧离散)": {
    "scope": "ts,typescript",
    "prefix": ["sortedSet", "discretizeCompressed"],
    "body": [
      "/**",
      " * (紧)离散化.",
      " * @param offset 离散化后的排名偏移量.",
      " * @returns",
      " * - getRank: 给定一个数,返回它的排名`(offset ~ offset + count)`.",
      " * - count: 离散化(去重)后的元素个数.",
      " */",
      "function discretizeCompressed(nums: number[], offset = 0): [getRank: (num: number) => number, getValue: (rank: number) => number, count: number] {",
      "\tconst allNums = [...new Set(nums)].sort((a, b) => a - b)",
      "\tconst mp = new Map<number, number>()",
      "\tfor (let index = 0; index < allNums.length; index++) mp.set(allNums[index], index + offset)",
      "\tconst getRank = (num: number) => mp.get(num)!",
      "\tconst getValue = (rank: number) => allNums[rank - offset]",
      "\treturn [getRank, getValue, allNums.length]",
      "}"
    ],
    "description": "ts离散化2(紧离散)"
  },
  "gcd": {
    "scope": "go,golang",
    "prefix": "gcd",
    "body": [
      "func gcd(a, b int) int {",
      "  for b != 0 {",
      "    a, b = b, a%b",
      "  }",
      "  return a",
      "}"
    ],
    "description": "golang最大公约数"
  },
  "binaryGcd": {
    "scope": "go,golang",
    "prefix": ["gcd", "binaryGcd"],
    "body": [
      "func binaryGcd(a, b int) int {",
      "  // 取绝对值",
      "  x, y := a, b",
      "  if x < 0 {",
      "    x = -x",
      "  }",
      "  if y < 0 {",
      "    y = -y",
      "  }",
      "  if x == 0 || y == 0 {",
      "    return x + y",
      "  }",
      "  n := bits.TrailingZeros(uint(x))",
      "  m := bits.TrailingZeros(uint(y))",
      "  x >>= n",
      "  y >>= m",
      "  for x != y {",
      "    d := bits.TrailingZeros(uint(x - y))",
      "    f := x > y",
      "    var c int",
      "    if f {",
      "      c = x",
      "    } else {",
      "      c = y",
      "    }",
      "    if !f {",
      "      y = x",
      "    }",
      "    x = (c - y) >> d",
      "  }",
      "  return x << min(n, m)",
      "}",
      "func min(a, b int) int {",
      "  if a < b {",
      "    return a",
      "  }",
      "  return b",
      "}"
    ],
    "description": "golang binaryGcd"
  },
  "Monoid-Affine": {
    "scope": "go,golang",
    "prefix": ["affine", "仿射变换", "monoid-affine"],
    "body": [
      "const MOD int = 1e9 + 7",
      "type E = struct{ mul, add int }",
      "const IS_COMMUTATIVE = false        // 仿射变换群不满足交换律",
      "func e() E          { return E{1, 0} }",
      "func op(e1, e2 E) E { return E{e1.mul * e2.mul % MOD, (e1.add*e2.mul + e2.add) % MOD} }"
    ],
    "description": "仿射变换"
  },
  "affine": {
    "scope": "go,golang",
    "prefix": "affine",
    "body": [
      "",
      "const INF int = 1e18",
      "",
      "const MOD int = 998244353",
      "",
      "type E = struct{ mul, add int }",
      "",
      "const IS_COMMUTATIVE = false // 仿射变换群不满足交换律",
      "func e() E {",
      "\treturn E{1, 0}",
      "}",
      "func op(e1, e2 E) E {",
      "\treturn E{e1.mul * e2.mul % MOD, (e1.add*e2.mul + e2.add) % MOD}",
      "}",
      "func inv(e E) E { // 仿射变换逆元",
      "\tmul, add := e.mul, e.add",
      "\tmul = modPow(mul, MOD-2, MOD) // modInv of mul",
      "\treturn E{mul, mul * (MOD - add) % MOD}",
      "}",
      "func pow(e E, x int) E {",
      "\tres := E{1, 0}",
      "\tfor x > 0 {",
      "\t\tif x&1 == 1 {",
      "\t\t\tres = op(res, e)",
      "\t\t}",
      "\t\te = op(e, e)",
      "\t\tx >>= 1",
      "\t}",
      "\treturn res",
      "}",
      "func eval(e E, x int) int {",
      "\treturn (e.mul*x + e.add) % MOD",
      "}",
      "",
      "func modPow(x, n, mod int) int {",
      "\tres := 1",
      "\tfor n > 0 {",
      "\t\tif n&1 == 1 {",
      "\t\t\tres = res * x % mod",
      "\t\t}",
      "\t\tx = x * x % mod",
      "\t\tn >>= 1",
      "\t}",
      "\treturn res",
      "}"
    ],
    "description": "affine"
  },
  "Monoid-Sum": {
    "scope": "go,golang",
    "prefix": ["Monoid-Sum"],
    "body": [
      "type E = struct{ sum, size int }",
      "type Id = int",
      "",
      "func e() E                   { return E{0, 0} }",
      "func id() Id                 { return 0 }",
      "func op(e1, e2 E) E          { return E{e1.sum + e2.sum, e1.size + e2.size} }",
      "func mapping(f Id, g E) E    { return E{g.sum + f*g.size, g.size} }",
      "func composition(f, g Id) Id { return f + g }"
    ]
  },
  "argSort": {
    "scope": "go,golang",
    "prefix": ["argSort"],
    "body": [
      "func argSort(nums []int) []int {",
      "  order := make([]int, len(nums))",
      "  for i := range order {",
      "    order[i] = i",
      "  }",
      "  sort.Slice(order, func(i, j int) bool { return nums[order[i]] < nums[order[j]] })",
      "  return order",
      "}"
    ],
    "description": "将0-n-1按照nums的值排序"
  },
  "reArrange": {
    "scope": "go,golang",
    "prefix": ["reArrange"],
    "body": [
      "func reArrage(nums []int, order []int) []int {",
      "  res := make([]int, len(order))",
      "  for i := range order {",
      "    res[i] = nums[order[i]]",
      "  }",
      "  return res",
      "}"
    ],
    "description": "将nums按照order的顺序重新排列"
  },
  "bisectLeft": {
    "scope": "go,golang",
    "prefix": ["bisectLeft"],
    "body": [
      "func bisectLeft(nums []int, x, left, right int) int {",
      "  for left <= right {",
      "    mid := (left + right) >> 1",
      "    if nums[mid] < x {",
      "      left = mid + 1",
      "    } else {",
      "      right = mid - 1",
      "    }",
      "  }",
      "  return left",
      "}"
    ],
    "description": "二分查找左边界,相当于sort.SearchInts或者lowerBound"
  },
  "bisectRight": {
    "scope": "go,golang",
    "prefix": ["bisectRight"],
    "body": [
      "func bisectRight(nums []int, x, left, right int) int {",
      "  for left <= right {",
      "    mid := (left + right) >> 1",
      "    if nums[mid] <= x {",
      "      left = mid + 1",
      "    } else {",
      "      right = mid - 1",
      "    }",
      "  }",
      "  return left",
      "}"
    ],
    "description": "二分查找右边界,相当于upperBound"
  },
  "遍历区间的距离": {
    "scope": "python",
    "prefix": ["调头距离", "calDist"],
    "body": [
      "def calDist(start: int, left: int, right: int) -> int:",
      "  '''从start出发,遍历[leftMost,rightMost]区间的最短距离(最多调头一次)'''",
      "  leftMax = max(0, start - left)",
      "  rightMax = max(0, right - start)",
      "  return min(2 * leftMax + rightMax, 2 * rightMax + leftMax)"
    ],
    "description": "遍历区间的距离"
  },
  "斐波那契数列第k项": {
    "scope": "python",
    "prefix": ["斐波那契数列第k项", "fibonacci"],
    "body": [
      "def kthFibonacci(k: int) -> int:",
      "  '''斐波那契数列前k(0-indexed)项:0,1,1,2,3,5...'''",
      "  f, res = (0, 1), (1, 0)",
      "  while k:",
      "    a, b = f",
      "    c, d = res",
      "    if k & 1:",
      "      res = ((a * c + b * d) % MOD, (b * c + (a + b) * d) % MOD)",
      "    f = ((a * a + b * b) % MOD, (b * (a + a + b)) % MOD)",
      "    k >>= 1",
      "  return res[1]"
    ],
    "description": "斐波那契数列第k项"
  },

  "forSubset": {
    "scope": "typescript",
    "prefix": ["forSubset", "subset"],
    "body": [
      "const state = 0b1101",
      "for (let g1 = state; ~g1; g1 = g1 === 0 ? -1 : (g1 - 1) & state) {",
      "  if (g1 === state || g1 === 0) continue",
      "  const g2 = state ^ g1",
      "  console.log(g1.toString(2), g2.toString(2))",
      "}"
    ],
    "description": "forSubset枚举某个状态的所有子集(子集的子集)"
  },
  "forSubset-go": {
    "scope": "go,golang",
    "prefix": ["forSubset", "subset"],
    "body": [
      "state := 0b1101",
      "for g1 := state; g1 >= 0; {",
      "  if g1 == state || g1 == 0 { // 排除空集和全集",
      "    g1--",
      "    continue",
      "  }",
      "  g2 := state ^ g1",
      "  fmt.Println(g1, g2)",
      "  if g1 == 0 {",
      "    g1 = -1",
      "  } else {",
      "    g1 = (g1 - 1) & state",
      "  }",
      "}"
    ],
    "description": "forSubset枚举某个状态的所有子集(子集的子集)"
  },
  "forSubset-py": {
    "scope": "python",
    "prefix": ["forSubset", "subset"],
    "body": [
      "state = 0b1101",
      "g1 = state",
      "while g1 >= 0:",
      "    if g1 == state or g1 == 0:  # 跳过空集和全集",
      "        g1 -= 1",
      "        continue",
      "    g2 = g1 ^ state",
      "    print(bin(g1)[2:], bin(g2)[2:])",
      "    g1 = -1 if g1 == 0 else (g1 - 1) & state"
    ],
    "description": "forSubset枚举某个状态的所有子集(子集的子集)"
  },
  "enumerateBits": {
    "scope": "python",
    "prefix": ["enumerateBits"],
    "body": [
      "state = 0b1101",
      "while state > 0:",
      "    bit = (state & -state).bit_length() - 1",
      "    print(bit)  # 0, 2, 3",
      "    state ^= 1 << bit"
    ],
    "description": "enumerateBits遍历一个二进制数的所有1所在的位"
  },
  "区间 [0,right] 内模mod与k同余的数的个数": {
    "scope": "python",
    "prefix": ["modCount"],
    "body": [
      "def modCount(right: int, k: int, mod: int) -> int:",
      "  '''区间 [0,right] 内模mod与k同余的数的个数'''",
      "  assert 0 <= k < mod",
      "  return (right - k + mod) // mod"
    ],
    "description": "区间 [0,right] 内模mod与k同余的数的个数"
  },
  "isPrime-py": {
    "scope": "python",
    "prefix": ["isPrime"],
    "body": [
      "def isPrime(n: int) -> bool:",
      "  '''判断n是否为质数'''",
      "  if n < 2:",
      "    return False",
      "  for i in range(2, int(n ** 0.5) + 1):",
      "    if n % i == 0:",
      "      return False",
      "  return True"
    ],
    "description": "O(sqrt(n))判断n是否为质数"
  },
  "isPrime-ts": {
    "scope": "typescript",
    "prefix": ["isPrime"],
    "body": [
      "function isPrime(n: number): boolean {",
      "  if (n < 2) return false",
      "  const upper = ~~Math.sqrt(n)",
      "  for (let i = 2; i < upper + 1; i++) {",
      "    if (n % i === 0) return false",
      "  }",
      "  return true"
    ],
    "description": "O(sqrt(n))判断n是否为质数"
  },
  "isPrime-go": {
    "scope": "go,golang",
    "prefix": ["isPrime"],
    "body": [
      "func isPrime(n int) bool {",
      "  if n < 2 {",
      "    return false",
      "  }",
      "  upper := int(math.Sqrt(float64(n)))",
      "  for i := 2; i < upper+1; i++ {",
      "    if n%i == 0 {",
      "      return false",
      "    }",
      "  }",
      "  return true",
      "}"
    ],
    "description": "O(sqrt(n))判断n是否为质数"
  },
  "productWithoutOne": {
    "scope": "python",
    "prefix": ["productWithoutOne"],
    "body": [
      "from typing import Callable, List, TypeVar",
      "",
      "T = TypeVar('T')",
      "",
      "def productWithoutOne(nums: List[T], e: Callable[[], T], op: Callable[[T, T], T]) -> List[T]:",
      "    '''除自身以外数组的乘积.'''",
      "    n = len(nums)",
      "    res = [e() for _ in range(n)]",
      "    for i in range(n - 1):",
      "        res[i + 1] = op(res[i], nums[i])",
      "    x = e()",
      "    for i in range(n - 1, -1, -1):",
      "        res[i] = op(res[i], x)",
      "        x = op(nums[i], x)",
      "    return res"
    ],
    "description": "除自身以外数组的乘积"
  },
  "productWithoutOne-go": {
    "scope": "go,golang",
    "prefix": ["productWithoutOne"],
    "body": [
      "type E = int",
      "",
      "// 除自身以外数组的乘积.",
      "func productWithoutOne(nums []int, e func() int, op func(int, int) int) []int {",
      "  n := len(nums)",
      "  res := make([]int, n)",
      "  for i := 0; i < n-1; i++ {",
      "    res[i+1] = op(res[i], nums[i])",
      "  }",
      "  x := e()",
      "  for i := n - 1; i >= 0; i-- {",
      "    res[i] = op(res[i], x)",
      "    x = op(nums[i], x)",
      "  }",
      "  return res",
      "}"
    ],
    "description": "除自身以外数组的乘积"
  },
  "id-python": {
    "prefix": ["id", "getId"],
    "scope": "python",
    "body": [
      "def id(o: object) -> int:",
      "  '''获取对象的唯一标识id'''",
      "  res = pool.get(o, -1)",
      "  if res != -1:",
      "    return res",
      "  cur = len(pool)",
      "  pool[o] = cur",
      "  return cur",
      "pool = dict()"
    ],
    "description": "获取对象的唯一标识id"
  },
  "id-dict-python": {
    "prefix": ["id", "getId"],
    "scope": "python",
    "body": [
      "from typing import Generic, Optional, TypeVar",
      "V = TypeVar('V')",
      "class Dictionary(Generic[V]):",
      "  '''获取对象唯一标识的字典.'''",
      "  __slots__ = '_valueToId', '_idToValue'",
      "  def __init__(self):",
      "    self._valueToId = dict()",
      "    self._idToValue = []",
      "  def id(self, value: V) -> int:",
      "    res = self._valueToId.get(value, None)",
      "    if res is not None:",
      "      return res",
      "    id_ = len(self._idToValue)",
      "    self._idToValue.append(value)",
      "    self._valueToId[value] = id_",
      "    return id_",
      "  def value(self, id_: int) -> Optional[V]:",
      "    if id_ < 0 or id_ >= len(self._idToValue):",
      "      return None",
      "    return self._idToValue[id_]",
      "  def __contains__(self, v: int) -> bool:",
      "    return v in self._valueToId",
      "  def __len__(self) -> int:",
      "    return len(self._idToValue)"
    ],
    "description": "获取对象的唯一标识id"
  },
  "id-typescript": {
    "prefix": ["id", "getId"],
    "scope": "typescript",
    "body": [
      "const pool = new Map<unknown, number>()",
      "function id(o: unknown): number {",
      "  const res = pool.get(o)",
      "  if (res !== void 0) return res",
      "  const cur = pool.size",
      "  pool.set(o, cur)",
      "  return cur",
      "}"
    ],
    "description": "获取对象的唯一标识id"
  },
  "id-dict-typescript": {
    "prefix": ["id", "getId"],
    "scope": "typescript",
    "body": [
      "/**",
      " * A dictionary that maps values to unique ids.",
      " */",
      "class Dictionary<V> {",
      "  private readonly _valueToId = new Map<V, number>()",
      "  private readonly _idToValue: V[] = []",
      "",
      "  id(value: V): number {",
      "    const res = this._valueToId.get(value)",
      "    if (res !== void 0) return res",
      "    const id = this._idToValue.length",
      "    this._idToValue.push(value)",
      "    this._valueToId.set(value, id)",
      "    return id",
      "  }",
      "",
      "  value(id: number): V | undefined {",
      "    if (id < 0 || id >= this._idToValue.length) return void 0",
      "    return this._idToValue[id]",
      "  }",
      "",
      "  has(value: V): boolean {",
      "    return this._valueToId.has(value)",
      "  }",
      "",
      "  get size(): number {",
      "    return this._idToValue.length",
      "  }",
      "}"
    ],
    "description": "获取对象的唯一标识id"
  },
  "id-golang": {
    "prefix": ["id", "getId"],
    "scope": "go,golang",
    "body": [
      "var _pool = make(map[interface{}]int)",
      "func id(o interface{}) int {",
      "  if v, ok := _pool[o]; ok {",
      "    return v",
      "  }",
      "  v := len(_pool)",
      "  _pool[o] = v",
      "  return v",
      "}"
    ],
    "description": "获取对象的唯一标识id"
  },
  "id-dict-golang": {
    "prefix": ["id", "getId"],
    "scope": "go,golang",
    "body": [
      "type V = int",
      "type Dictionary struct {",
      "  _idToValue []V",
      "  _valueToId map[V]int",
      "}",
      "// A dictionary that maps values to unique ids.",
      "func NewDictionary() *Dictionary {",
      "  return &Dictionary{",
      "    _valueToId: map[V]int{},",
      "  }",
      "}",
      "func (d *Dictionary) Id(value V) int {",
      "  res, ok := d._valueToId[value]",
      "  if ok {",
      "    return res",
      "  }",
      "  id := len(d._idToValue)",
      "  d._idToValue = append(d._idToValue, value)",
      "  d._valueToId[value] = id",
      "  return id",
      "}",
      "func (d *Dictionary) Value(id int) V {",
      "  return d._idToValue[id]",
      "}",
      "func (d *Dictionary) Has(value V) bool {",
      "  _, ok := d._valueToId[value]",
      "  return ok",
      "}",
      "func (d *Dictionary) Size() int {",
      "  return len(d._idToValue)",
      "}"
    ],
    "description": "获取对象的唯一标识id"
  },
  "genSplits-py": {
    "prefix": ["splits", "genSplits"],
    "scope": "python",
    "body": [
      "from typing import Generator, Sequence, List, TypeVar",
      "",
      "T = TypeVar('T')",
      "",
      "def genSplits(arr: Sequence[T]) -> Generator[List[Sequence[T]], None, None]:",
      "    '''遍历序列所有的分割方案.'''",
      "    if not arr:",
      "        return",
      "    n = len(arr)",
      "    for state in range(1 << (n - 1)):  # 枚举n-1个分割点",
      "        preSplit = 0",
      "        cur = []",
      "        for i in range(n - 1):",
      "            if state & (1 << i):",
      "                cur.append(arr[preSplit : i + 1])",
      "                preSplit = i + 1",
      "        cur.append(arr[preSplit:])",
      "        yield cur"
    ],
    "description": "遍历序列所有的分割方案"
  },
  "enumerateSplits-ts": {
    "prefix": ["splits", "enumerateSplits"],
    "scope": "typescript",
    "body": [
      "/**",
      " * 遍历数组所有的分割方案.",
      " */",
      "function enumerateSplits<T>(arr: T[], f: (splits: T[][]) => void): void {",
      "  if (!arr.length) return",
      "  const n = arr.length",
      "  for (let state = 0; state < 1 << (n - 1); state++) {",
      "    let preSplit = 0",
      "    const cur: T[][] = []",
      "    for (let i = 0; i < n - 1; i++) {",
      "      if (state & (1 << i)) {",
      "        cur.push(arr.slice(preSplit, i + 1))",
      "        preSplit = i + 1",
      "      }",
      "    }",
      "    cur.push(arr.slice(preSplit))",
      "    f(cur)",
      "  }",
      "}"
    ],
    "description": "遍历数组所有的分割方案"
  },
  "genSplits-ts": {
    "prefix": ["splits", "genSplits"],
    "scope": "typescript",
    "body": [
      "/**",
      " * 遍历数组所有的分割方案.",
      " */",
      "function* genSplits<T>(arr: T[]): Generator<T[][]> {",
      "  if (!arr.length) return",
      "  const n = arr.length",
      "  for (let state = 0; state < 1 << (n - 1); state++) {",
      "    let preSplit = 0",
      "    const cur: T[][] = []",
      "    for (let i = 0; i < n - 1; i++) {",
      "      if (state & (1 << i)) {",
      "        cur.push(arr.slice(preSplit, i + 1))",
      "        preSplit = i + 1",
      "      }",
      "    }",
      "    cur.push(arr.slice(preSplit))",
      "    yield cur",
      "  }",
      "}"
    ],
    "description": "遍历数组所有的分割方案"
  },
  "enumerateGroup-go": {
    "prefix": ["groupBy", "enumerateGroup"],
    "scope": "go,golang",
    "body": [
      "// 遍历连续相同元素的分组.相当于python中的`itertools.groupby`.",
      "func EnumerateGroup(arr []interface{}, f func(group []interface{}, start, end int)) {",
      "  ptr := 0",
      "  n := len(arr)",
      "  for ptr < n {",
      "    leader := arr[ptr]",
      "    group := []interface{}{leader}",
      "    start := ptr",
      "    ptr++",
      "    for ptr < n && arr[ptr] == leader {",
      "      group = append(group, arr[ptr])",
      "      ptr++",
      "    }",
      "    f(group, start, ptr)",
      "  }",
      "}"
    ],
    "description": "遍历连续相同元素的分组.相当于python中的`itertools.groupby`."
  },
  "enumerateGroup-ts": {
    "prefix": ["groupBy", "enumerateGroup"],
    "scope": "typescript",
    "body": [
      "/**",
      " * 遍历连续相同元素的分组.",
      " * @alias groupBy",
      " * @example",
      " * ```ts",
      " * const list = [1, 1, 2, 3, 3, 4, 4, 5, 5, 5]",
      " * enumerateGroup(list, group => console.log(group)) // [1, 1], [2], [3, 3], [4, 4], [5, 5, 5]",
      " * ```",
      " */",
      "function enumerateGroup<T>(",
      "  arr: ArrayLike<T>,",
      "  f: (group: T[], start: number, end: number) => void",
      "): void {",
      "  const n = arr.length",
      "  let ptr = 0",
      "  while (ptr < n) {",
      "    const leader = arr[ptr]",
      "    const group = [leader]",
      "    const start = ptr",
      "    ptr++",
      "    while (ptr < n && arr[ptr] === leader) {",
      "      group.push(arr[ptr])",
      "      ptr++",
      "    }",
      "    f(group, start, ptr)",
      "  }",
      "}"
    ],
    "description": "遍历连续相同元素的分组.相当于python中的`itertools.groupby`."
  },
  "go-DefaultDict": {
    "scope": "go,golang",
    "prefix": ["DefaultDict", "GetOrDefault"],
    "body": [
      "type K = int",
      "type V = int",
      "",
      "func GetOrDefault(dict map[K]V, key K, defaultValue V) V {",
      "\tif v, ok := dict[key]; ok {",
      "\t\treturn v",
      "\t}",
      "\treturn defaultValue",
      "}",
      ""
    ],
    "description": "go-DefaultDict"
  },
  "UnionFind": {
    "scope": "go,golang",
    "prefix": ["UnionFind", "并查集数组"],
    "body": [
      "",
      "type UnionFindArray struct {",
      "\t// 连通分量的个数",
      "\tPart int",
      "\tn\t\tint",
      "\tdata []int",
      "}",
      "",
      "func NewUnionFindArray(n int) *UnionFindArray {",
      "\tdata := make([]int, n)",
      "\tfor i := 0; i < n; i++ {",
      "\t\tdata[i] = -1",
      "\t}",
      "\treturn &UnionFindArray{",
      "\t\tPart: n,",
      "\t\tn:\t\tn,",
      "\t\tdata: data,",
      "\t}",
      "}",
      "",
      "// 按秩合并.",
      "func (ufa *UnionFindArray) Union(key1, key2 int) bool {",
      "\troot1, root2 := ufa.Find(key1), ufa.Find(key2)",
      "\tif root1 == root2 {",
      "\t\treturn false",
      "\t}",
      "\tif ufa.data[root1] > ufa.data[root2] {",
      "\t\troot1 ^= root2",
      "\t\troot2 ^= root1",
      "\t\troot1 ^= root2",
      "\t}",
      "\tufa.data[root1] += ufa.data[root2]",
      "\tufa.data[root2] = root1",
      "\tufa.Part--",
      "\treturn true",
      "}",
      "func (ufa *UnionFindArray) UnionWithCallback(key1, key2 int, cb func(big, small int)) bool {",
      "\troot1, root2 := ufa.Find(key1), ufa.Find(key2)",
      "\tif root1 == root2 {",
      "\t\treturn false",
      "\t}",
      "\tif ufa.data[root1] > ufa.data[root2] {",
      "\t\troot1 ^= root2",
      "\t\troot2 ^= root1",
      "\t\troot1 ^= root2",
      "\t}",
      "\tufa.data[root1] += ufa.data[root2]",
      "\tufa.data[root2] = root1",
      "\tufa.Part--",
      "\tif cb != nil {",
      "\t\tcb(root1, root2)",
      "\t}",
      "\treturn true",
      "}",
      "",
      "func (ufa *UnionFindArray) Find(key int) int {",
      "\tif ufa.data[key] < 0 {",
      "\t\treturn key",
      "\t}",
      "\tufa.data[key] = ufa.Find(ufa.data[key])",
      "\treturn ufa.data[key]",
      "}",
      "",
      "func (ufa *UnionFindArray) IsConnected(key1, key2 int) bool {",
      "\treturn ufa.Find(key1) == ufa.Find(key2)",
      "}",
      "",
      "func (ufa *UnionFindArray) GetSize(key int) int {",
      "\treturn -ufa.data[ufa.Find(key)]",
      "}",
      "",
      "func (ufa *UnionFindArray) GetGroups() map[int][]int {",
      "\tgroups := make(map[int][]int)",
      "\tfor i := 0; i < ufa.n; i++ {",
      "\t\troot := ufa.Find(i)",
      "\t\tgroups[root] = append(groups[root], i)",
      "\t}",
      "\treturn groups",
      "}",
      "",
      "func (ufa *UnionFindArray) String() string {",
      "\tsb := []string{\"UnionFindArray:\"}",
      "\tgroups := ufa.GetGroups()",
      "\tkeys := make([]int, 0, len(groups))",
      "\tfor k := range groups {",
      "\t\tkeys = append(keys, k)",
      "\t}",
      "\tsort.Ints(keys)",
      "\tfor _, root := range keys {",
      "\t\tmember := groups[root]",
      "\t\tcur := fmt.Sprintf(\"%d: %v\", root, member)",
      "\t\tsb = append(sb, cur)",
      "\t}",
      "\tsb = append(sb, fmt.Sprintf(\"Part: %d\", ufa.Part))",
      "\treturn strings.Join(sb, \"\\n\")",
      "}",
      "",
      "//",
      "//",
      "var _pool = make(map[interface{}]int)",
      "",
      "func id(o interface{}) int {",
      "\tif v, ok := _pool[o]; ok {",
      "\t\treturn v",
      "\t}",
      "\tv := len(_pool)",
      "\t_pool[o] = v",
      "\treturn v",
      "}",
      "",
      "type UnionFindMap struct {",
      "\tPart int",
      "\tdata map[int]int",
      "}",
      "",
      "func NewUnionFindMap() *UnionFindMap {",
      "\treturn &UnionFindMap{",
      "\t\tdata: make(map[int]int),",
      "\t}",
      "}",
      "",
      "func (ufm *UnionFindMap) Union(key1, key2 int) bool {",
      "\troot1, root2 := ufm.Find(key1), ufm.Find(key2)",
      "\tif root1 == root2 {",
      "\t\treturn false",
      "\t}",
      "\tif ufm.data[root1] > ufm.data[root2] {",
      "\t\troot1 ^= root2",
      "\t\troot2 ^= root1",
      "\t\troot1 ^= root2",
      "\t}",
      "\tufm.data[root1] += ufm.data[root2]",
      "\tufm.data[root2] = root1",
      "\tufm.Part--",
      "\treturn true",
      "}",
      "func (ufm *UnionFindMap) UnionWithCallback(key1, key2 int, cb func(big, small int)) bool {",
      "\troot1, root2 := ufm.Find(key1), ufm.Find(key2)",
      "\tif root1 == root2 {",
      "\t\treturn false",
      "\t}",
      "\tif ufm.data[root1] > ufm.data[root2] {",
      "\t\troot1 ^= root2",
      "\t\troot2 ^= root1",
      "\t\troot1 ^= root2",
      "\t}",
      "\tufm.data[root1] += ufm.data[root2]",
      "\tufm.data[root2] = root1",
      "\tufm.Part--",
      "\tif cb != nil {",
      "\t\tcb(root1, root2)",
      "\t}",
      "\treturn true",
      "}",
      "",
      "func (ufm *UnionFindMap) Find(key int) int {",
      "\tif _, ok := ufm.data[key]; !ok {",
      "\t\tufm.Add(key)",
      "\t\treturn key",
      "\t}",
      "\tif ufm.data[key] < 0 {",
      "\t\treturn key",
      "\t}",
      "\tufm.data[key] = ufm.Find(ufm.data[key])",
      "\treturn ufm.data[key]",
      "}",
      "",
      "func (ufm *UnionFindMap) IsConnected(key1, key2 int) bool {",
      "\treturn ufm.Find(key1) == ufm.Find(key2)",
      "}",
      "",
      "func (ufm *UnionFindMap) GetSize(key int) int {",
      "\treturn -ufm.data[ufm.Find(key)]",
      "}",
      "",
      "func (ufm *UnionFindMap) GetGroups() map[int][]int {",
      "\tgroups := make(map[int][]int)",
      "\tfor k := range ufm.data {",
      "\t\troot := ufm.Find(k)",
      "\t\tgroups[root] = append(groups[root], k)",
      "\t}",
      "\treturn groups",
      "}",
      "",
      "func (ufm *UnionFindMap) Has(key int) bool {",
      "\t_, ok := ufm.data[key]",
      "\treturn ok",
      "}",
      "",
      "func (ufm *UnionFindMap) Add(key int) bool {",
      "\tif _, ok := ufm.data[key]; ok {",
      "\t\treturn false",
      "\t}",
      "\tufm.data[key] = -1",
      "\tufm.Part++",
      "\treturn true",
      "}",
      "",
      "func (ufm *UnionFindMap) String() string {",
      "\tsb := []string{\"UnionFindMap:\"}",
      "\tgroups := ufm.GetGroups()",
      "\tkeys := make([]int, 0, len(groups))",
      "\tfor k := range groups {",
      "\t\tkeys = append(keys, k)",
      "\t}",
      "\tsort.Ints(keys)",
      "\tfor _, root := range keys {",
      "\t\tmember := groups[root]",
      "\t\tcur := fmt.Sprintf(\"%d: %v\", root, member)",
      "\t\tsb = append(sb, cur)",
      "\t}",
      "\tsb = append(sb, fmt.Sprintf(\"Part: %d\", ufm.Part))",
      "\treturn strings.Join(sb, \"\\n\")",
      "}",
      ""
    ],
    "description": "UnionFind"
  },

  "子数组计数": {
    "scope": "python",
    "prefix": ["subarray", "countSubarray"],
    "body": [
      "n = len(nums)",
      "res = 0",
      "for left in range(n):",
      "\t\tcur = []",
      "\t\tfor right in range(left, n):",
      "\t\t\t\t..."
    ],
    "description": "子数组计数"
  },
  "子数组计数-golang": {
    "scope": "go,golang",
    "prefix": ["subarray", "countSubarray"],
    "body": [
      "\tn := len(nums)",
      "\tres := 0",
      "\tfor left := 0; left < n; left++ {",
      "\t\tcur := []int{}",
      "\t\tfor right := left; right < n; right++ {",
      "",
      "\t\t}",
      "\t}"
    ],
    "description": "子数组计数"
  },
  "子数组计数-ts": {
    "scope": "typescript",
    "prefix": ["subarray", "countSubarray"],
    "body": [
      "const n = nums.length",
      "let res = 0",
      "for (let left = 0; left < n; left++) {",
      "\tconst cur = []",
      "\tfor (let right = left; right < n; right++) {",
      "\t\t//",
      "\t}",
      "}",
      ""
    ],
    "description": "子数组计数-ts"
  },
  "bfsGrid": {
    "scope": "python",
    "prefix": "bfsGrid",
    "body": [
      "",
      "from typing import List, Tuple",
      "from collections import deque",
      "",
      "DIR4 = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "INF = int(1e18)",
      "",
      "",
      "def bfsGrid(row: int, col: int, starts: List[Tuple[int, int]]) -> List[List[int]]:",
      "\t\t\"\"\"网格图bfs, 返回每个格子到起点的最短距离.\"\"\"",
      "\t\tdist = [[INF] * col for _ in range(row)]",
      "\t\tqueue = deque(starts)",
      "\t\tfor x, y in starts:",
      "\t\t\t\tdist[x][y] = 0",
      "",
      "\t\twhile queue:",
      "\t\t\t\tlen_ = len(queue)",
      "\t\t\t\tfor _ in range(len_):",
      "\t\t\t\t\t\tcurX, curY = queue.popleft()",
      "\t\t\t\t\t\tfor dx, dy in DIR4:",
      "\t\t\t\t\t\t\t\tnextX, nextY = curX + dx, curY + dy",
      "\t\t\t\t\t\t\t\tcand = dist[curX][curY] + 1",
      "\t\t\t\t\t\t\t\tif 0 <= nextX < row and 0 <= nextY < col and cand < dist[nextX][nextY]:",
      "\t\t\t\t\t\t\t\t\t\tdist[nextX][nextY] = cand",
      "\t\t\t\t\t\t\t\t\t\tqueue.append((nextX, nextY))",
      "",
      "\t\treturn dist"
    ],
    "description": "网格图bfs"
  },
  "distOnCircle": {
    "scope": "python",
    "prefix": ["distOnCycle", "distOnCircle", "环上两点距离"],
    "body": [
      "def distOnCycle(n: int, i: int, j: int) -> int:",
      "\t\t\"\"\"环上两点距离.\"\"\"",
      "\t\tcand1, cand2 = abs(i - j), n - abs(i - j)",
      "\t\treturn cand1 if cand1 < cand2 else cand2"
    ],
    "description": "环上两点距离"
  },
  "distOnCircle-golang": {
    "scope": "go,golang",
    "prefix": ["distOnCycle", "distOnCircle", "环上两点距离"],
    "body": [
      "\t// 环上两点距离.",
      "\tfunc distOnCycle(n, i, j int) int {",
      "\t\tcand1 := abs(i - j)",
      "\t\tcand2 := n - cand1",
      "\t\tif cand1 < cand2 {",
      "\t\t\t\treturn cand1",
      "\t\t}",
      "\t\treturn cand2",
      "\t}"
    ],
    "description": "环上两点距离"
  },
  "distOnCircle-ts": {
    "scope": "typescript",
    "prefix": ["distOnCycle", "distOnCircle", "环上两点距离"],
    "body": [
      "// 环上两点距离.",
      "function distOnCycle(n: number, i: number, j: number): number {",
      "\tconst cand1 = Math.abs(i - j)",
      "\tconst cand2 = n - cand1",
      "\treturn Math.min(cand1, cand2)",
      "}"
    ],
    "description": "环上两点距离"
  },
  "埃氏筛-go": {
    "scope": "go",
    "prefix": ["埃氏筛", "EratosthenesSieve"],
    "body": [
      "",
      "var E *eratosthenesSieve",
      "",
      "func init() {",
      "\tE = newEratosthenesSieve(1e5 + 10)",
      "}",
      "",
      "// 埃氏筛",
      "type eratosthenesSieve struct {",
      "\tminPrime []int",
      "}",
      "",
      "func newEratosthenesSieve(maxN int) *eratosthenesSieve {",
      "\tminPrime := make([]int, maxN+1)",
      "\tfor i := range minPrime {",
      "\t\tminPrime[i] = i",
      "\t}",
      "\tupper := int(math.Sqrt(float64(maxN))) + 1",
      "\tfor i := 2; i < upper; i++ {",
      "\t\tif minPrime[i] < i {",
      "\t\t\tcontinue",
      "\t\t}",
      "\t\tfor j := i * i; j <= maxN; j += i {",
      "\t\t\tif minPrime[j] == j {",
      "\t\t\t\tminPrime[j] = i",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "\treturn &eratosthenesSieve{minPrime}",
      "}",
      "",
      "func (es *eratosthenesSieve) IsPrime(n int) bool {",
      "\tif n < 2 {",
      "\t\treturn false",
      "\t}",
      "\treturn es.minPrime[n] == n",
      "}",
      "",
      "func (es *eratosthenesSieve) GetPrimeFactors(n int) map[int]int {",
      "\tres := make(map[int]int)",
      "\tfor n > 1 {",
      "\t\tm := es.minPrime[n]",
      "\t\tres[m]++",
      "\t\tn /= m",
      "\t}",
      "\treturn res",
      "}",
      "",
      "func (es *eratosthenesSieve) GetPrimes() []int {",
      "\tres := []int{}",
      "\tfor i, x := range es.minPrime {",
      "\t\tif i >= 2 && i == x {",
      "\t\t\tres = append(res, x)",
      "\t\t}",
      "\t}",
      "\treturn res",
      "}"
    ]
  },

  "rangeFreq-ts": {
    "scope": "typescript",
    "prefix": ["rangeFreq", "queryRangeFreq", "rangeCount", "countRange"],
    "body": [
      "/**",
      " * 查询区间`[start, end)`中值为`value`的元素个数.",
      " */",
      "function rangeFreq<T>(arr: ArrayLike<T>): (start: number, end: number, value: T) => number {",
      "\tconst mp = new Map<T, number[]>()",
      "\tfor (let i = 0; i < arr.length; i++) {",
      "\t\tconst v = arr[i]",
      "\t\tif (!mp.has(v)) mp.set(v, [])",
      "\t\tmp.get(v)!.push(i)",
      "\t}",
      "",
      "\tconst bisectLeft = (nums: ArrayLike<number>, target: number): number => {",
      "\t\tlet left = 0",
      "\t\tlet right = nums.length - 1",
      "\t\twhile (left <= right) {",
      "\t\t\tconst mid = (left + right) >> 1",
      "\t\t\tif (nums[mid] < target) left = mid + 1",
      "\t\t\telse right = mid - 1",
      "\t\t}",
      "\t\treturn left",
      "\t}",
      "",
      "\tconst bisectRight = (nums: ArrayLike<number>, target: number): number => {",
      "\t\tlet left = 0",
      "\t\tlet right = nums.length - 1",
      "\t\twhile (left <= right) {",
      "\t\t\tconst mid = (left + right) >> 1",
      "\t\t\tif (nums[mid] <= target) left = mid + 1",
      "\t\t\telse right = mid - 1",
      "\t\t}",
      "\t\treturn left",
      "\t}",
      "",
      "\treturn (start: number, end: number, value: T): number => {",
      "\t\tconst pos = mp.get(value)",
      "\t\tif (!pos) return 0",
      "\t\treturn bisectRight(pos, end - 1) - bisectLeft(pos, start)",
      "\t}",
      "}",
      ""
    ]
  },

  "BITArray-go": {
    "scope": "go",
    "prefix": "BITArray",
    "body": [
      "",
      "// !Point Add Range Sum, 0-based.",
      "type BITArray struct {",
      "\tn\t\t int",
      "\ttotal int",
      "\tdata\t[]int",
      "}",
      "",
      "func NewBitArray(n int) *BITArray {",
      "\tres := &BITArray{n: n, data: make([]int, n)}",
      "\treturn res",
      "}",
      "",
      "func NewBitArrayFrom(n int, f func(i int) int) *BITArray {",
      "\ttotal := 0",
      "\tdata := make([]int, n)",
      "\tfor i := 0; i < n; i++ {",
      "\t\tdata[i] = f(i)",
      "\t\ttotal += data[i]",
      "\t}",
      "\tfor i := 1; i <= n; i++ {",
      "\t\tj := i + (i & -i)",
      "\t\tif j <= n {",
      "\t\t\tdata[j-1] += data[i-1]",
      "\t\t}",
      "\t}",
      "\treturn &BITArray{n: n, total: total, data: data}",
      "}",
      "",
      "func (b *BITArray) Add(index int, v int) {",
      "\tb.total += v",
      "\tfor index++; index <= b.n; index += index & -index {",
      "\t\tb.data[index-1] += v",
      "\t}",
      "}",
      "",
      "// [0, end).",
      "func (b *BITArray) QueryPrefix(end int) int {",
      "\tif end > b.n {",
      "\t\tend = b.n",
      "\t}",
      "\tres := 0",
      "\tfor ; end > 0; end -= end & -end {",
      "\t\tres += b.data[end-1]",
      "\t}",
      "\treturn res",
      "}",
      "",
      "// [start, end).",
      "func (b *BITArray) QueryRange(start, end int) int {",
      "\tif start < 0 {",
      "\t\tstart = 0",
      "\t}",
      "\tif end > b.n {",
      "\t\tend = b.n",
      "\t}",
      "\tif start >= end {",
      "\t\treturn 0",
      "\t}",
      "\tif start == 0 {",
      "\t\treturn b.QueryPrefix(end)",
      "\t}",
      "\tpos, neg := 0, 0",
      "\tfor end > start {",
      "\t\tpos += b.data[end-1]",
      "\t\tend &= end - 1",
      "\t}",
      "\tfor start > end {",
      "\t\tneg += b.data[start-1]",
      "\t\tstart &= start - 1",
      "\t}",
      "\treturn pos - neg",
      "}",
      "",
      "func (b *BITArray) QueryAll() int {",
      "\treturn b.total",
      "}",
      "",
      "func (b *BITArray) MaxRight(check func(index, preSum int) bool) int {",
      "\ti := 0",
      "\ts := 0",
      "\tk := 1",
      "\tfor 2*k <= b.n {",
      "\t\tk *= 2",
      "\t}",
      "\tfor k > 0 {",
      "\t\tif i+k-1 < b.n {",
      "\t\t\tt := s + b.data[i+k-1]",
      "\t\t\tif check(i+k, t) {",
      "\t\t\t\ti += k",
      "\t\t\t\ts = t",
      "\t\t\t}",
      "\t\t}",
      "\t\tk >>= 1",
      "\t}",
      "\treturn i",
      "}",
      "",
      "// 0/1 树状数组查找第 k(0-based) 个1的位置.",
      "// UpperBound.",
      "func (b *BITArray) Kth(k int) int {",
      "\treturn b.MaxRight(func(index, preSum int) bool { return preSum <= k })",
      "}",
      "",
      "func (b *BITArray) String() string {",
      "\tsb := []string{}",
      "\tfor i := 0; i < b.n; i++ {",
      "\t\tsb = append(sb, fmt.Sprintf(\"%d\", b.QueryRange(i, i+1)))",
      "\t}",
      "\treturn fmt.Sprintf(\"BitArray: [%v]\", strings.Join(sb, \", \"))",
      "}",
      ""
    ]
  },
  "基环树找环": {
    "scope": "python",
    "prefix": ["基环树找环", "cyclePartition", "竞赛图找环"],
    "body": [
      "from collections import deque",
      "from typing import Iterable, List, Mapping, Sequence, Tuple, Union",
      "",
      "",
      "SequenceGraph = Sequence[Iterable[int]]",
      "MappingGraph = Mapping[int, Iterable[int]]",
      "Graph = Union[SequenceGraph, MappingGraph]",
      "",
      "",
      "def cyclePartition(",
      "\t\tn: int, graph: Graph, directed: bool",
      ") -> Tuple[List[List[int]], List[bool], List[int], List[int]]:",
      "\t\t\"\"\"返回基环树森林的环分组信息(环的大小>=2)以及每个点在拓扑排序中的最大深度.",
      "",
      "\t\tArgs:",
      "\t\t\t\t- n: 图的节点数.",
      "\t\t\t\t- graph: 图的邻接表表示.",
      "\t\t\t\t- directed: 图是否有向.",
      "",
      "\t\tReturns:",
      "\t\t\t\t- groups: 环分组,每个环的大小>=2.",
      "\t\t\t\t- inCycle: 每个点是否在环中.",
      "\t\t\t\t- belong: 每个点所在的环的编号.如果不在环中,则为-1.",
      "\t\t\t\t- depth: 每个点在拓扑排序中的最大深度,最外层的点深度为0.",
      "\t\t\"\"\"",
      "",
      "\t\tdef max(a: int, b: int) -> int:",
      "\t\t\t\treturn a if a > b else b",
      "",
      "\t\tdeg = [0] * n",
      "\t\tif directed:",
      "\t\t\t\tfor u in range(n):",
      "\t\t\t\t\t\tfor v in graph[u]:",
      "\t\t\t\t\t\t\t\tdeg[v] += 1",
      "\t\telse:",
      "\t\t\t\tfor u in range(n):",
      "\t\t\t\t\t\tfor v in graph[u]:",
      "\t\t\t\t\t\t\t\tif u < v:",
      "\t\t\t\t\t\t\t\t\t\tdeg[u] += 1",
      "\t\t\t\t\t\t\t\t\t\tdeg[v] += 1",
      "",
      "\t\tstartDeg = 0 if directed else 1",
      "\t\tqueue = deque([i for i in range(n) if deg[i] == startDeg])",
      "\t\tvisited = [False] * n",
      "\t\tdepth = [0] * n",
      "\t\twhile queue:",
      "\t\t\t\tcur = queue.popleft()",
      "\t\t\t\tvisited[cur] = True",
      "\t\t\t\tfor next_ in graph[cur]:",
      "\t\t\t\t\t\tdepth[next_] = max(depth[next_], depth[cur] + 1)",
      "\t\t\t\t\t\tdeg[next_] -= 1",
      "\t\t\t\t\t\tif deg[next_] == startDeg:",
      "\t\t\t\t\t\t\t\tqueue.append(next_)",
      "",
      "\t\tdef dfs(cur: int, path: List[int]) -> None:",
      "\t\t\t\tif visited[cur]:",
      "\t\t\t\t\t\treturn",
      "\t\t\t\tvisited[cur] = True",
      "\t\t\t\tpath.append(cur)",
      "\t\t\t\tfor next in graph[cur]:",
      "\t\t\t\t\t\tdfs(next, path)",
      "",
      "\t\tgroups = []",
      "\t\tfor i in range(n):",
      "\t\t\t\tif visited[i]:",
      "\t\t\t\t\t\tcontinue",
      "\t\t\t\tpath = []",
      "\t\t\t\tdfs(i, path)",
      "\t\t\t\tgroups.append(path)",
      "",
      "\t\tinCycle, belong = [False] * n, [-1] * n",
      "\t\tfor gid, group in enumerate(groups):",
      "\t\t\t\tfor node in group:",
      "\t\t\t\t\t\tinCycle[node] = True",
      "\t\t\t\t\t\tbelong[node] = gid",
      "",
      "\t\treturn groups, inCycle, belong, depth"
    ]
  },
  "多源bfs": {
    "scope": "python",
    "prefix": "bfsMultiStart",
    "body": [
      "def bfsMultiStart(starts: Iterable[int], adjList: List[List[int]]) -> List[int]:",
      "\t\t\"\"\"多源bfs\"\"\"",
      "\t\tn = len(adjList)",
      "\t\tdist = [INF] * n",
      "\t\tqueue = deque(starts)",
      "\t\tfor start in starts:",
      "\t\t\t\tdist[start] = 0",
      "\t\twhile queue:",
      "\t\t\t\tcur = queue.popleft()",
      "\t\t\t\tfor next in adjList[cur]:",
      "\t\t\t\t\t\tcand = dist[cur] + 1",
      "\t\t\t\t\t\tif cand < dist[next]:",
      "\t\t\t\t\t\t\t\tdist[next] = cand",
      "\t\t\t\t\t\t\t\tqueue.append(next)",
      "\t\treturn dist"
    ],
    "description": "多源bfs"
  },
  "bfs求路径": {
    "scope": "python",
    "prefix": "bfsPath",
    "body": [
      "def bfsPath(",
      "\t\tn: int, adjList: Sequence[Sequence[int]], start: int, end: int",
      ") -> Tuple[int, List[int]]:",
      "\t\t\"\"\"bfs求出起点到end的(最短距离,路径).时间复杂度O(V+E)\"\"\"",
      "\t\tdist = [INF] * n",
      "\t\tdist[start] = 0",
      "\t\tqueue = deque([start])",
      "\t\tpre = [-1] * n",
      "",
      "\t\twhile queue:",
      "\t\t\t\tcur = queue.popleft()",
      "\t\t\t\tfor next in adjList[cur]:",
      "\t\t\t\t\t\tcand = dist[cur] + 1",
      "\t\t\t\t\t\tif cand < dist[next]:",
      "\t\t\t\t\t\t\t\tdist[next] = cand",
      "\t\t\t\t\t\t\t\tpre[next] = cur",
      "\t\t\t\t\t\t\t\tqueue.append(next)",
      "",
      "\t\tif dist[end] == INF:",
      "\t\t\t\treturn INF, []",
      "",
      "\t\tpath = []",
      "\t\tcur = end",
      "\t\twhile pre[cur] != -1:",
      "\t\t\t\tpath.append(cur)",
      "\t\t\t\tcur = pre[cur]",
      "\t\tpath.append(start)",
      "\t\treturn dist[end], path[::-1]"
    ],
    "description": "bfs求路径"
  },
  "bfs求最短路-golaang": {
    "scope": "go",
    "prefix": ["bfs", "bfsPath", "bfsMultiStart", "bfsDepth", "bfsGrid"],
    "body": [
      "",
      "const INF int = 1e18",
      "",
      "// bfs求最无权图短路.",
      "func Bfs(start int, adjList [][]int) []int {",
      "\tn := len(adjList)",
      "\tdist := make([]int, n)",
      "\tfor i := range dist {",
      "\t\tdist[i] = INF",
      "\t}",
      "\tdist[start] = 0",
      "\tqueue := []int{start}",
      "\tfor len(queue) > 0 {",
      "\t\tcur := queue[0]",
      "\t\tqueue = queue[1:]",
      "\t\tfor _, next := range adjList[cur] {",
      "\t\t\tcand := dist[cur] + 1",
      "\t\t\tif cand < dist[next] {",
      "\t\t\t\tdist[next] = cand",
      "\t\t\t\tqueue = append(queue, next)",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "\treturn dist",
      "}",
      "",
      "// 多源bfs.",
      "func BfsMultiStart(starts []int, adjList [][]int) []int {",
      "\tn := len(adjList)",
      "\tdist := make([]int, n)",
      "\tfor i := range dist {",
      "\t\tdist[i] = INF",
      "\t}",
      "\tqueue := append(starts[:0:0], starts...)",
      "\tfor _, start := range starts {",
      "\t\tdist[start] = 0",
      "\t}",
      "\tfor len(queue) > 0 {",
      "\t\tcur := queue[0]",
      "\t\tqueue = queue[1:]",
      "\t\tfor _, next := range adjList[cur] {",
      "\t\t\tcand := dist[cur] + 1",
      "\t\t\tif cand < dist[next] {",
      "\t\t\t\tdist[next] = cand",
      "\t\t\t\tqueue = append(queue, next)",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "\treturn dist",
      "}",
      "",
      "// bfs求起点到终点的最短距离和路径.",
      "func BfsPath(n int, adjList [][]int, start int, end int) (res int, path []int) {",
      "\tdist := make([]int, n)",
      "\tfor i := range dist {",
      "\t\tdist[i] = INF",
      "\t}",
      "\tdist[start] = 0",
      "\tqueue := []int{start}",
      "\tpre := make([]int, n)",
      "\tfor i := range pre {",
      "\t\tpre[i] = -1",
      "\t}",
      "\tfor len(queue) > 0 {",
      "\t\tcur := queue[0]",
      "\t\tqueue = queue[1:]",
      "\t\tfor _, next := range adjList[cur] {",
      "\t\t\tcand := dist[cur] + 1",
      "\t\t\tif cand < dist[next] {",
      "\t\t\t\tdist[next] = cand",
      "\t\t\t\tpre[next] = cur",
      "\t\t\t\tqueue = append(queue, next)",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "\tif dist[end] == INF {",
      "\t\treturn INF, []int{}",
      "\t}",
      "\tcur := end",
      "\tfor pre[cur] != -1 {",
      "\t\tpath = append(path, cur)",
      "\t\tcur = pre[cur]",
      "\t}",
      "\tpath = append(path, start)",
      "\tfor i := 0; i < len(path)/2; i++ {",
      "\t\tpath[i], path[len(path)-1-i] = path[len(path)-1-i], path[i]",
      "\t}",
      "\treturn dist[end], path",
      "}",
      "",
      "// 返回距离start为dist的结点.",
      "func BfsDepth(n int, adjList [][]int, start int, dist int) []int {",
      "\tif dist < 0 {",
      "\t\treturn []int{}",
      "\t}",
      "\tif dist == 0 {",
      "\t\treturn []int{start}",
      "\t}",
      "\tqueue := []int{start}",
      "\tvisited := make([]bool, n)",
      "\ttodo := dist",
      "\tfor len(queue) > 0 && todo > 0 {",
      "\t\tlen_ := len(queue)",
      "\t\tfor i := 0; i < len_; i++ {",
      "\t\t\tcur := queue[0]",
      "\t\t\tqueue = queue[1:]",
      "\t\t\tfor _, next := range adjList[cur] {",
      "\t\t\t\tif !visited[next] {",
      "\t\t\t\t\tvisited[next] = true",
      "\t\t\t\t\tqueue = append(queue, next)",
      "\t\t\t\t}",
      "\t\t\t}",
      "\t\t}",
      "\t\ttodo--",
      "\t}",
      "\treturn queue",
      "}",
      "",
      "// 网格图bfs, 返回每个格子到起点的最短距离.",
      "func BfsGrid(row int, col int, starts [][]int) [][]int {",
      "\tDIR4 := [][]int{{-1, 0}, {1, 0}, {0, -1}, {0, 1}}",
      "\tdist := make([][]int, row)",
      "\tfor i := range dist {",
      "\t\tdist[i] = make([]int, col)",
      "\t\tfor j := range dist[i] {",
      "\t\t\tdist[i][j] = INF",
      "\t\t}",
      "\t}",
      "\tqueue := append(starts[:0:0], starts...)",
      "\tfor _, start := range starts {",
      "\t\tdist[start[0]][start[1]] = 0",
      "\t}",
      "\tfor len(queue) > 0 {",
      "\t\tlen_ := len(queue)",
      "\t\tfor i := 0; i < len_; i++ {",
      "\t\t\tcurX, curY := queue[0][0], queue[0][1]",
      "\t\t\tqueue = queue[1:]",
      "\t\t\tfor _, dir := range DIR4 {",
      "\t\t\t\tnextX, nextY := curX+dir[0], curY+dir[1]",
      "\t\t\t\tcand := dist[curX][curY] + 1",
      "\t\t\t\tif 0 <= nextX && nextX < row && 0 <= nextY && nextY < col && cand < dist[nextX][nextY] {",
      "\t\t\t\t\tdist[nextX][nextY] = cand",
      "\t\t\t\t\tqueue = append(queue, []int{nextX, nextY})",
      "\t\t\t\t}",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "\treturn dist",
      "}",
      ""
    ],
    "description": "bfs"
  },
  "diff差分-python": {
    "scope": "python",
    "prefix": ["DiffArray", "DiffMap"],
    "body": [
      "from bisect import bisect_right",
      "from collections import defaultdict",
      "from itertools import accumulate",
      "from typing import List",
      "",
      "",
      "class DiffArray:",
      "\t\t\"\"\"差分维护区间修改，区间查询.\"\"\"",
      "",
      "\t\t__slots__ = (\"_diff\", \"_dirty\")",
      "",
      "\t\tdef __init__(self, n: int) -> None:",
      "\t\t\t\tself._diff = [0] * (n + 1)",
      "\t\t\t\tself._dirty = False",
      "",
      "\t\tdef add(self, start: int, end: int, delta: int) -> None:",
      "\t\t\t\t\"\"\"区间 `[start,end)` 加上 `delta`.\"\"\"",
      "\t\t\t\tif start < 0:",
      "\t\t\t\t\t\tstart = 0",
      "\t\t\t\tif end >= len(self._diff):",
      "\t\t\t\t\t\tend = len(self._diff) - 1",
      "\t\t\t\tif start >= end:",
      "\t\t\t\t\t\treturn",
      "\t\t\t\tself._dirty = True",
      "\t\t\t\tself._diff[start] += delta",
      "\t\t\t\tself._diff[end] -= delta",
      "",
      "\t\tdef build(self) -> None:",
      "\t\t\t\tif self._dirty:",
      "\t\t\t\t\t\tself._diff = list(accumulate(self._diff))",
      "\t\t\t\t\t\tself._dirty = False",
      "",
      "\t\tdef get(self, pos: int) -> int:",
      "\t\t\t\t\"\"\"查询下标 `pos` 处的值.\"\"\"",
      "\t\t\t\tself.build()",
      "\t\t\t\treturn self._diff[pos]",
      "",
      "\t\tdef getAll(self) -> List[int]:",
      "\t\t\t\tself.build()",
      "\t\t\t\treturn self._diff[:-1]",
      "",
      "",
      "class DiffMap:",
      "\t\t\"\"\"差分维护区间修改，单点查询.\"\"\"",
      "",
      "\t\t__slots__ = (\"_diff\", \"_preSum\", \"_sortedKeys\", \"_dirty\")",
      "",
      "\t\tdef __init__(self) -> None:",
      "\t\t\t\tself._diff = defaultdict(int)",
      "\t\t\t\tself._sortedKeys = []",
      "\t\t\t\tself._preSum = []",
      "\t\t\t\tself._dirty = False",
      "",
      "\t\tdef add(self, start: int, end: int, delta: int) -> None:",
      "\t\t\t\t\"\"\"区间 `[start,end)` 加上 `delta`.\"\"\"",
      "\t\t\t\tif start >= end:",
      "\t\t\t\t\t\treturn",
      "\t\t\t\tself._dirty = True",
      "\t\t\t\tself._diff[start] += delta",
      "\t\t\t\tself._diff[end] -= delta",
      "",
      "\t\tdef build(self) -> None:",
      "\t\t\t\tif self._dirty:",
      "\t\t\t\t\t\tself._sortedKeys = sorted(self._diff)",
      "\t\t\t\t\t\tself._preSum = [0] + list(accumulate(self._diff[key] for key in self._sortedKeys))",
      "\t\t\t\t\t\tself._dirty = False",
      "",
      "\t\tdef get(self, pos: int) -> int:",
      "\t\t\t\t\"\"\"查询下标 `pos` 处的值.\"\"\"",
      "\t\t\t\tself.build()",
      "\t\t\t\treturn self._preSum[bisect_right(self._sortedKeys, pos)]",
      "",
      "",
      "if __name__ == \"__main__\":",
      "\t\t# 2251. 花期内花的数目",
      "\t\t# https://leetcode.cn/problems/number-of-flowers-in-full-bloom/description/",
      "",
      "\t\tclass Solution:",
      "\t\t\t\tdef fullBloomFlowers(self, flowers: List[List[int]], people: List[int]) -> List[int]:",
      "\t\t\t\t\t\tdiff = DiffMap()",
      "\t\t\t\t\t\tfor left, right in flowers:",
      "\t\t\t\t\t\t\t\tdiff.add(left, right + 1, 1)",
      "\t\t\t\t\t\treturn [diff.get(p) for p in people]",
      ""
    ]
  },
  "diff差分-golang": {
    "scope": "go",
    "prefix": ["DiffArray", "DiffMap"],
    "body": [
      "",
      "type DiffArray struct {",
      "\tdiff\t[]int",
      "\tdirty bool",
      "}",
      "",
      "func NewDiffArray(n int) *DiffArray {",
      "\treturn &DiffArray{",
      "\t\tdiff: make([]int, n+1),",
      "\t}",
      "}",
      "",
      "func (d *DiffArray) Add(start, end, delta int) {",
      "\tif start < 0 {",
      "\t\tstart = 0",
      "\t}",
      "\tif end >= len(d.diff) {",
      "\t\tend = len(d.diff) - 1",
      "\t}",
      "\tif start >= end {",
      "\t\treturn",
      "\t}",
      "\td.dirty = true",
      "\td.diff[start] += delta",
      "\td.diff[end] -= delta",
      "}",
      "",
      "func (d *DiffArray) Build() {",
      "\tif d.dirty {",
      "\t\tpreSum := make([]int, len(d.diff))",
      "\t\tfor i := 1; i < len(d.diff); i++ {",
      "\t\t\tpreSum[i] = preSum[i-1] + d.diff[i]",
      "\t\t}",
      "\t\td.diff = preSum",
      "\t\td.dirty = false",
      "\t}",
      "}",
      "",
      "func (d *DiffArray) Get(pos int) int {",
      "\td.Build()",
      "\treturn d.diff[pos]",
      "}",
      "",
      "func (d *DiffArray) GetAll() []int {",
      "\td.Build()",
      "\treturn d.diff[:len(d.diff)-1]",
      "}",
      "",
      "type DiffMap struct {",
      "\tdiff\t\t\t map[int]int",
      "\tsortedKeys []int",
      "\tpreSum\t\t []int",
      "\tdirty\t\t\tbool",
      "}",
      "",
      "func NewDiffMap() *DiffMap {",
      "\treturn &DiffMap{",
      "\t\tdiff: make(map[int]int),",
      "\t}",
      "}",
      "",
      "func (d *DiffMap) Add(start, end, delta int) {",
      "\tif start >= end {",
      "\t\treturn",
      "\t}",
      "\td.dirty = true",
      "\td.diff[start] += delta",
      "\td.diff[end] -= delta",
      "}",
      "",
      "func (d *DiffMap) Build() {",
      "\tif d.dirty {",
      "\t\td.sortedKeys = make([]int, 0, len(d.diff))",
      "\t\tfor key := range d.diff {",
      "\t\t\td.sortedKeys = append(d.sortedKeys, key)",
      "\t\t}",
      "\t\tsort.Ints(d.sortedKeys)",
      "\t\td.preSum = make([]int, len(d.sortedKeys)+1)",
      "\t\tfor i, key := range d.sortedKeys {",
      "\t\t\td.preSum[i+1] = d.preSum[i] + d.diff[key]",
      "\t\t}",
      "\t\td.dirty = false",
      "\t}",
      "}",
      "",
      "func (d *DiffMap) Get(pos int) int {",
      "\td.Build()",
      "\treturn d.preSum[sort.SearchInts(d.sortedKeys, pos+1)]",
      "}"
    ],
    "description": "差分"
  },
  "PreSumSuffixSum-python": {
    "scope": "python",
    "prefix": ["PreSumSuffixSum", "suffixSum", "preSum"],
    "body": [
      "from typing import Callable, Generic, List, Sequence, TypeVar",
      "",
      "",
      "T = TypeVar(\"T\")",
      "",
      "",
      "class PreSumSuffixSum(Generic[T]):",
      "\t\t__slots__ = (\"_e\", \"_op\", \"_preSum\", \"_suffixSum\")",
      "",
      "\t\tdef __init__(self, seq: Sequence[T], e: Callable[[], T], op: Callable[[T, T], T]) -> None:",
      "\t\t\t\tself._e = e",
      "\t\t\t\tself._op = op",
      "\t\t\t\tn = len(seq)",
      "\t\t\t\tpreSum: List[T] = [None] * (n + 1)\t# type: ignore",
      "\t\t\t\tsuffixSum: List[T] = [None] * (n + 1)\t# type: ignore",
      "\t\t\t\tpreSum[0] = e()",
      "\t\t\t\tsuffixSum[n] = e()",
      "\t\t\t\tfor i in range(n):",
      "\t\t\t\t\t\tpreSum[i + 1] = op(preSum[i], seq[i])",
      "\t\t\t\t\t\tsuffixSum[n - i - 1] = op(suffixSum[n - i], seq[n - i - 1])",
      "\t\t\t\tself._preSum = preSum",
      "\t\t\t\tself._suffixSum = suffixSum",
      "",
      "\t\tdef preSum(self, end: int) -> T:",
      "\t\t\t\t\"\"\"查询前缀[0,end)的和.\"\"\"",
      "\t\t\t\tif end < 0:",
      "\t\t\t\t\t\treturn self._e()",
      "\t\t\t\tif end >= len(self._preSum):",
      "\t\t\t\t\t\treturn self._preSum[-1]",
      "\t\t\t\treturn self._preSum[end]",
      "",
      "\t\tdef suffixSum(self, start: int) -> T:",
      "\t\t\t\t\"\"\"查询后缀[start,n)的和.\"\"\"",
      "\t\t\t\tif start < 0:",
      "\t\t\t\t\t\treturn self._suffixSum[0]",
      "\t\t\t\tif start >= len(self._suffixSum):",
      "\t\t\t\t\t\treturn self._e()",
      "\t\t\t\treturn self._suffixSum[start]"
    ],
    "description": "前缀后缀和"
  },
  "PreSumSuffixSum-golang": {
    "scope": "go",
    "prefix": ["PreSumSuffixSum", "suffixSum", "preSum"],
    "body": [
      "",
      "type E = int",
      "",
      "type PreSumSuffixSum struct {",
      "\tpreSum\t\t[]E",
      "\tsuffixSum []E",
      "\te\t\t\t\t func() E",
      "}",
      "",
      "func NewPreSumSuffixSum(arr []E, e func() E, op func(a, b E) E) *PreSumSuffixSum {",
      "\tn := len(arr)",
      "\tpreSum, suffixSum := make([]E, n+1), make([]E, n+1)",
      "\tpreSum[0] = e()",
      "\tsuffixSum[n] = e()",
      "\tfor i := 0; i < n; i++ {",
      "\t\tpreSum[i+1] = op(preSum[i], arr[i])",
      "\t\tsuffixSum[n-i-1] = op(suffixSum[n-i], arr[n-i-1])",
      "\t}",
      "\treturn &PreSumSuffixSum{preSum: preSum, suffixSum: suffixSum, e: e}",
      "}",
      "",
      "// 查询前缀 `[0,end)` 的和.",
      "func (p *PreSumSuffixSum) PreSum(end int) E {",
      "\tif end < 0 {",
      "\t\treturn p.e()",
      "\t}",
      "\tif end >= len(p.preSum) {",
      "\t\treturn p.preSum[len(p.preSum)-1]",
      "\t}",
      "\treturn p.preSum[end]",
      "}",
      "",
      "// 查询后缀 `[start,n)` 的和.",
      "func (p *PreSumSuffixSum) SuffixSum(start int) E {",
      "\tif start < 0 {",
      "\t\treturn p.suffixSum[0]",
      "\t}",
      "\tif start >= len(p.suffixSum) {",
      "\t\treturn p.e()",
      "\t}",
      "\treturn p.suffixSum[start]",
      "}"
    ],
    "description": "前缀后缀和"
  },
  "BisectInsort": {
    "scope": "go",
    "prefix": ["BisectInsort", "InsortRight"],
    "body": [
      "// bisect.insort/bisect.insortRight in python.",
      "func BisectInsort(nums *[]int, insertion int) {",
      "\tpos := BisectRight(*nums, insertion)",
      "\t*nums = append(*nums, 0)",
      "\tcopy((*nums)[pos+1:], (*nums)[pos:])",
      "\t(*nums)[pos] = insertion",
      "}",
      "",
      "var InsortRight = BisectInsort"
    ],
    "description": "bisect.insort/bisect.insortRight in python."
  },
  "离散化-python": {
    "scope": "python",
    "prefix": ["discretize", "sortedSet"],
    "body": [
      "from bisect import bisect_left",
      "from typing import Callable, List, Tuple",
      "",
      "",
      "def discretizeCompressed(nums: List[int], offset=0) -> Tuple[Callable[[int], int], int]:",
      "\t\t\"\"\"紧离散化.",
      "",
      "\t\tArgs:",
      "\t\t\t\t- nums: 原数组.",
      "\t\t\t\t- offset: 离散化的起始值偏移量.",
      "",
      "\t\tReturns:",
      "\t\t\t\t- getRank: 给定一个数,返回它的排名(offset ~ offset + count).",
      "\t\t\t\t- count: 离散化(去重)后的元素个数.",
      "\t\t\"\"\"",
      "\t\tallNums = sorted(set(nums))",
      "\t\trank = {num: i + offset for i, num in enumerate(allNums)}",
      "\t\treturn lambda x: rank[x], len(allNums)",
      "",
      "",
      "def discretizeSparse(nums: List[int], offset=0) -> Tuple[Callable[[int], int], int]:",
      "\t\t\"\"\"松离散化.",
      "",
      "\t\tArgs:",
      "\t\t\t\t- nums: 原数组.",
      "\t\t\t\t- offset: 离散化的起始值偏移量.",
      "",
      "\t\tReturns:",
      "\t\t\t\t- getRank: 给定一个数,返回它的排名(offset ~ offset + count).",
      "\t\t\t\t- count: 离散化(去重)后的元素个数.",
      "\t\t\"\"\"",
      "\t\tallNums = sorted(set(nums))",
      "\t\treturn lambda x: bisect_left(allNums, x) + offset, len(allNums)",
      ""
    ],
    "description": "离散化"
  },
  "getFactors-go": {
    "scope": "go",
    "prefix": "getFactors",
    "body": [
      "",
      "// 返回 n 的所有因子. O(n^0.5).",
      "func GetFactors(n int) []int {",
      "\tif n <= 0 {",
      "\t\treturn nil",
      "\t}",
      "\tsmall := []int{}",
      "\tbig := []int{}",
      "\tupper := int(math.Sqrt(float64(n)))",
      "\tfor f := 1; f <= upper; f++ {",
      "\t\tif n%f == 0 {",
      "\t\t\tsmall = append(small, f)",
      "\t\t\tbig = append(big, n/f)",
      "\t\t}",
      "\t}",
      "\tif small[len(small)-1] == big[len(big)-1] {",
      "\t\tbig = big[:len(big)-1]",
      "\t}",
      "\tfor i, j := 0, len(big)-1; i < j; i, j = i+1, j-1 {",
      "\t\tbig[i], big[j] = big[j], big[i]",
      "\t}",
      "\tres := append(small, big...)",
      "\treturn res",
      "}"
    ],
    "description": "获取某个数的所有因子"
  },
  "getFactors-python": {
    "scope": "python",
    "prefix": "getFactors",
    "body": [
      "def getFactors(n: int) -> List[int]:",
      "\t\t\"\"\"n 的所有因数 O(sqrt(n))\"\"\"",
      "\t\tif n <= 0:",
      "\t\t\t\treturn []",
      "\t\tsmall, big = [], []",
      "\t\tupper = int(n**0.5) + 1",
      "\t\tfor i in range(1, upper):",
      "\t\t\t\tif n % i == 0:",
      "\t\t\t\t\t\tsmall.append(i)",
      "\t\t\t\t\t\tif i != n // i:",
      "\t\t\t\t\t\t\t\tbig.append(n // i)",
      "\t\treturn small + big[::-1]"
    ],
    "description": "获取某个数的所有因子"
  },
  "INF-js": {
    "scope": "javascript,typescript",
    "prefix": "INF",
    "body": ["const INF = 2e9 // !超过int32使用2e15"],
    "description": "INF"
  },
  "freqCounter-py": {
    "scope": "python",
    "prefix": "freqCounter",
    "body": ["freqCounter = Counter(Counter(nums).values()) # len(freqCounter) <= sqrt(n)"],
    "description": "数组元素频率的Counter"
  },
  "freqCounter-ts": {
    "scope": "javascript,typescript",
    "prefix": "freqCounter",
    "body": [
      "\tconst tmpCounter = new Map<number, number>()",
      "\tnums.forEach(v => tmpCounter.set(v, (tmpCounter.get(v) || 0) + 1))",
      "\tconst freq = [...tmpCounter.values()]",
      "\tconst freqCounter = new Map<number, number>()  // len(freqCounter) <= sqrt(n)",
      "\tfreq.forEach(v => freqCounter.set(v, (freqCounter.get(v) || 0) + 1))"
    ],
    "description": "数组元素频率的Counter"
  },
  "freqCounter-go": {
    "scope": "go",
    "prefix": "freqCounter",
    "body": [
      "\ttmpCounter := make(map[int]int)",
      "\tfor _, v := range nums {",
      "\t\ttmpCounter[v]++",
      "\t}",
      "\tfreq := make([]int, 0, len(tmpCounter))",
      "\tfor _, v := range tmpCounter {",
      "\t\tfreq = append(freq, v)",
      "\t}",
      "\tfreqCounter := make(map[int]int, len(freq))  // len(freqCounter) <= sqrt(n)",
      "\tfor _, v := range freq {",
      "\t\tfreqCounter[v]++",
      "\t}"
    ],
    "description": "数组元素频率的Counter"
  },
  "counter-ts": {
    "scope": "typescript",
    "prefix": "counter",
    "body": [
      "\t\tconst counter = new Map<number, number>()",
      "\t\tnums.forEach(v => counter.set(v, (counter.get(v) || 0) + 1))"
    ],
    "description": "counter计数"
  },
  "counter-go": {
    "scope": "go",
    "prefix": "counter",
    "body": [
      "\\counter := make(map[int]int)",
      "\tfor _, v := range nums {",
      "\t\\counter[v]++",
      "\t}"
    ],
    "description": "counter计数"
  },
  "rangeFreq-python": {
    "scope": "python",
    "prefix": "rangeFreq",
    "body": [
      "from bisect import bisect_left",
      "from collections import defaultdict",
      "from typing import Callable, List, TypeVar",
      "",
      "V = TypeVar(\"V\")",
      "",
      "",
      "def rangeFreq(arr: List[V]) -> Callable[[int, int, V], int]:",
      "\t\t\"\"\"返回一个函数,用于查询arr[start:end]内value的频率.\"\"\"",
      "\t\tmp = defaultdict(list)",
      "\t\tfor i, v in enumerate(arr):",
      "\t\t\t\tmp[v].append(i)",
      "",
      "\t\tdef query(start: int, end: int, value: V) -> int:",
      "\t\t\t\tif start < 0:",
      "\t\t\t\t\t\tstart = 0",
      "\t\t\t\tif end > len(arr):",
      "\t\t\t\t\t\tend = len(arr)",
      "\t\t\t\tif start >= end:",
      "\t\t\t\t\t\treturn 0",
      "\t\t\t\tif value not in mp:",
      "\t\t\t\t\t\treturn 0",
      "\t\t\t\telse:",
      "\t\t\t\t\t\treturn bisect_left(mp[value], end) - bisect_left(mp[value], start)",
      "",
      "\t\treturn query",
      ""
    ],
    "description": "区间频率"
  },
  "rangeFreq-golang": {
    "scope": "go",
    "prefix": "rangeFreq",
    "body": [
      "type V = int",
      "",
      "func RangeFreq(arr []V) func(start, end int, value V) int {",
      "\tmp := make(map[V][]int)",
      "\tfor i, v := range arr {",
      "\t\tmp[v] = append(mp[v], i)",
      "\t}",
      "",
      "\treturn func(start, end int, value V) int {",
      "\t\tif start < 0 {",
      "\t\t\tstart = 0",
      "\t\t}",
      "\t\tif end > len(arr) {",
      "\t\t\tend = len(arr)",
      "\t\t}",
      "\t\tif start >= end {",
      "\t\t\treturn 0",
      "\t\t}",
      "",
      "\t\tif indexes, ok := mp[value]; !ok {",
      "\t\t\treturn 0",
      "\t\t} else {",
      "\t\t\treturn sort.SearchInts(indexes, end) - sort.SearchInts(indexes, start)",
      "\t\t}",
      "\t}",
      "}"
    ],
    "description": "静态区间频率查询"
  },
  "floyd-go": {
    "scope": "go",
    "prefix": "floyd",
    "body": [
      "const INF int = 1e18",
      "",
      "func Floyd(n int, edges [][3]int, directed bool) [][]int {",
      "\tdist := make([][]int, n)",
      "\tfor i := 0; i < n; i++ {",
      "\t\tdist[i] = make([]int, n)",
      "\t\tfor j := 0; j < n; j++ {",
      "\t\t\tdist[i][j] = INF",
      "\t\t}",
      "\t\tdist[i][i] = 0",
      "\t}",
      "",
      "\tfor _, road := range edges {",
      "\t\tu, v, w := road[0], road[1], road[2]",
      "\t\tdist[u][v] = min(w, dist[u][v])",
      "\t\tif !directed {",
      "\t\t\tdist[v][u] = min(w, dist[v][u])",
      "\t\t}",
      "\t}",
      "",
      "\tfor k := 0; k < n; k++ {",
      "\t\tfor i := 0; i < n; i++ {",
      "\t\t\tif dist[i][k] == INF {",
      "\t\t\t\tcontinue",
      "\t\t\t}",
      "\t\t\tfor j := 0; j < n; j++ {",
      "\t\t\tif dist[k][j] == INF {",
      "\t\t\t\tcontinue",
      "\t\t\t}",
      "\t\t\t\tdist[i][j] = min(dist[i][j], dist[i][k]+dist[k][j])",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "",
      "\treturn dist",
      "}",
      "",
      "func min(a, b int) int {",
      "\tif a <= b {",
      "\t\treturn a",
      "\t}",
      "\treturn b",
      "}"
    ],
    "description": "floyd求全源最短路"
  },
  "floyd-python": {
    "scope": "python",
    "prefix": "floyd",
    "body": [
      "from typing import List",
      "",
      "",
      "INF = int(1e20)",
      "",
      "",
      "def floyd(n: int, edges: List[List[int]], directed: bool) -> List[List[int]]:",
      "\t\t\"\"\"",
      "\t\tFloyd 求多源最短路",
      "\t\t\"\"\"",
      "",
      "\t\tdef min2(a: int, b: int) -> int:",
      "\t\t\t\treturn a if a < b else b",
      "",
      "\t\tdist = [[INF] * n for _ in range(n)]",
      "\t\tfor i in range(n):",
      "\t\t\t\tdist[i][i] = 0",
      "",
      "\t\tfor u, v, w in edges:",
      "\t\t\t\tdist[u][v] = min2(dist[u][v], w)",
      "\t\t\t\tif not directed:",
      "\t\t\t\t\t\tdist[v][u] = min2(dist[v][u], w)",
      "",
      "\t\tfor k in range(n):",
      "\t\t\t\tfor i in range(n):",
      "\t\t\t\t\t\tif dist[i][k] == INF:",
      "\t\t\t\t\t\t\t\tcontinue",
      "\t\t\t\t\t\tfor j in range(n):",
      "\t\t\t\t\t\t\t\tif dist[k][j] == INF:",
      "\t\t\t\t\t\t\t\t\t\tcontinue",
      "\t\t\t\t\t\t\t\tcand = dist[i][k] + dist[k][j]",
      "\t\t\t\t\t\t\t\tdist[i][j] = cand if dist[i][j] > cand else dist[i][j]",
      "\t\treturn dist"
    ],
    "description": "floyd求全源最短路"
  },
  "max2": {
    "scope": "python",
    "prefix": "max2",
    "body": ["def max2(a: int, b: int) -> int:", "\t\treturn a if a > b else b", ""],
    "description": "max2"
  },
  "min2": {
    "scope": "python",
    "prefix": "min2",
    "body": ["def min2(a: int, b: int) -> int:", "\t\treturn a if a < b else b"],
    "description": "min2"
  },
  "getKth-py": {
    "scope": "python",
    "prefix": "getKth",
    "body": [
      "from typing import Callable",
      "",
      "",
      "def getKth0(left: int, right: int, countNgt: Callable[[int], int], kth: int) -> int:",
      "\t\t\"\"\"",
      "\t\t给定二分答案的区间[left,right], 求第kth小的答案.",
      "\t\tcountNgt: 答案不超过mid时, 满足条件的个数.",
      "\t\tkth从0开始.",
      "\t\t\"\"\"",
      "\t\twhile left <= right:",
      "\t\t\t\tmid = left + (right - left) // 2",
      "\t\t\t\tif countNgt(mid) <= kth:",
      "\t\t\t\t\t\tleft = mid + 1",
      "\t\t\t\telse:",
      "\t\t\t\t\t\tright = mid - 1",
      "\t\treturn right + 1",
      "",
      "",
      "def getKth1(left: int, right: int, countNgt: Callable[[int], int], kth: int) -> int:",
      "\t\t\"\"\"",
      "\t\t给定二分答案的区间[left,right], 求第kth小的答案.",
      "\t\tcountNgt: 答案不超过mid时, 满足条件的个数.",
      "\t\tkth从1开始.",
      "\t\t\"\"\"",
      "\t\twhile left <= right:",
      "\t\t\t\tmid = left + (right - left) // 2",
      "\t\t\t\tif countNgt(mid) < kth:",
      "\t\t\t\t\t\tleft = mid + 1",
      "\t\t\t\telse:",
      "\t\t\t\t\t\tright = mid - 1",
      "\t\treturn left",
      "",
      "",
      "EPS = 1e-12",
      "",
      "",
      "def getKth0Float64(left: float, right: float, countNgt: Callable[[float], int], kth: int) -> float:",
      "\t\t\"\"\"",
      "\t\t给定二分答案的区间[left,right], 求第kth小的答案.",
      "\t\tcountNgt: 答案不超过mid时, 满足条件的个数.",
      "\t\tkth从0开始.",
      "\t\t\"\"\"",
      "\t\twhile left <= right:",
      "\t\t\t\tmid = left + (right - left) / 2",
      "\t\t\t\tif countNgt(mid) <= kth:",
      "\t\t\t\t\t\tleft = mid + EPS",
      "\t\t\t\telse:",
      "\t\t\t\t\t\tright = mid - EPS",
      "\t\treturn right + EPS",
      "",
      "",
      "def getKth1Float64(left: float, right: float, countNgt: Callable[[float], int], kth: int) -> float:",
      "\t\t\"\"\"",
      "\t\t给定二分答案的区间[left,right], 求第kth小的答案.",
      "\t\tcountNgt: 答案不超过mid时, 满足条件的个数.",
      "\t\tkth从1开始.",
      "\t\t\"\"\"",
      "\t\twhile left <= right:",
      "\t\t\t\tmid = left + (right - left) / 2",
      "\t\t\t\tif countNgt(mid) < kth:",
      "\t\t\t\t\t\tleft = mid + EPS",
      "\t\t\t\telse:",
      "\t\t\t\t\t\tright = mid - EPS",
      "\t\treturn left"
    ],
    "description": "getKth"
  },
  "getKth-go": {
    "scope": "go",
    "prefix": "getKth",
    "body": [
      "",
      "// 给定二分答案的区间[left,right]，求第kth小的答案.",
      "// countNgt: 答案不超过mid时，满足条件的个数.",
      "// kth从0开始.",
      "func GetKth0(left int, right int, countNgt func(mid int) int, kth int) int {",
      "\tfor left <= right {",
      "\t\tmid := left + (right-left)>>1",
      "\t\tif countNgt(mid) <= kth {",
      "\t\t\tleft = mid + 1",
      "\t\t} else {",
      "\t\t\tright = mid - 1",
      "\t\t}",
      "\t}",
      "\treturn right + 1",
      "}",
      "",
      "// 给定二分答案的区间[left,right]，求第kth小的答案.",
      "// countNgt: 答案不超过mid时，满足条件的个数.",
      "// kth从1开始.",
      "func GetKth1(left int, right int, countNgt func(mid int) int, kth int) int {",
      "\tfor left <= right {",
      "\t\tmid := left + (right-left)>>1",
      "\t\tif countNgt(mid) < kth {",
      "\t\t\tleft = mid + 1",
      "\t\t} else {",
      "\t\t\tright = mid - 1",
      "\t\t}",
      "\t}",
      "\treturn left",
      "}",
      "",
      "const EPS = 1e-12",
      "",
      "// 给定二分答案的区间[left,right]，求第kth小的答案.",
      "// countNgt: 答案不超过mid时，满足条件的个数.",
      "// kth从0开始.",
      "func GetKth0Float64(left float64, right float64, countNgt func(mid float64) int, kth int) float64 {",
      "\tfor left <= right {",
      "\t\tmid := left + (right-left)/2",
      "\t\tif countNgt(mid) <= kth {",
      "\t\t\tleft = mid + EPS",
      "\t\t} else {",
      "\t\t\tright = mid - EPS",
      "\t\t}",
      "\t}",
      "\treturn right + EPS",
      "}",
      "",
      "// 给定二分答案的区间[left,right]，求第kth小的答案.",
      "// countNgt: 答案不超过mid时，满足条件的个数.",
      "// kth从1开始.",
      "func GetKth1Float64(left float64, right float64, countNgt func(mid float64) int, kth int) float64 {",
      "\tfor left <= right {",
      "\t\tmid := left + (right-left)/2",
      "\t\tif countNgt(mid) < kth {",
      "\t\t\tleft = mid + EPS",
      "\t\t} else {",
      "\t\t\tright = mid - EPS",
      "\t\t}",
      "\t}",
      "\treturn left",
      "}"
    ],
    "description": "getKth"
  },
  "dijkstra-go": {
    "scope": "go",
    "prefix": "dijkstra",
    "body": [
      "",
      "const INF int = 1e18",
      "",
      "type Neighbor struct{ to, weight int }",
      "",
      "func Dijkstra(n int, adjList [][]Neighbor, start int) (dist []int) {",
      "\tdist = make([]int, n)",
      "\tfor i := range dist {",
      "\t\tdist[i] = INF",
      "\t}",
      "\tdist[start] = 0",
      "",
      "\tpq := nhp(func(a, b H) int {",
      "\t\treturn a.dist - b.dist",
      "\t}, []H{{start, 0}})",
      "",
      "\tfor pq.Len() > 0 {",
      "\t\tcurNode := pq.Pop()",
      "\t\tcur, curDist := curNode.node, curNode.dist",
      "\t\tif curDist > dist[cur] {",
      "\t\t\tcontinue",
      "\t\t}",
      "",
      "\t\tfor _, edge := range adjList[cur] {",
      "\t\t\tnext, weight := edge.to, edge.weight",
      "\t\t\tif cand := curDist + weight; cand < dist[next] {",
      "\t\t\t\tdist[next] = cand",
      "\t\t\t\tpq.Push(H{next, cand})",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "",
      "\treturn",
      "}",
      "",
      "type H = struct{ node, dist int }",
      "",
      "// Should return a number:",
      "//",
      "//\tnegative , if a < b",
      "//\tzero\t\t , if a == b",
      "//\tpositive , if a > b",
      "type Comparator = func(a, b H) int",
      "",
      "func nhp(comparator Comparator, nums []H) *Heap {",
      "\tnums = append(nums[:0:0], nums...)",
      "\theap := &Heap{comparator: comparator, data: nums}",
      "\theap.heapify()",
      "\treturn heap",
      "}",
      "",
      "type Heap struct {",
      "\tdata\t\t\t []H",
      "\tcomparator Comparator",
      "}",
      "",
      "func (h *Heap) Push(value H) {",
      "\th.data = append(h.data, value)",
      "\th.pushUp(h.Len() - 1)",
      "}",
      "",
      "func (h *Heap) Pop() (value H) {",
      "\tif h.Len() == 0 {",
      "\t\treturn",
      "\t}",
      "",
      "\tvalue = h.data[0]",
      "\th.data[0] = h.data[h.Len()-1]",
      "\th.data = h.data[:h.Len()-1]",
      "\th.pushDown(0)",
      "\treturn",
      "}",
      "",
      "func (h *Heap) Peek() (value H) {",
      "\tif h.Len() == 0 {",
      "\t\treturn",
      "\t}",
      "\tvalue = h.data[0]",
      "\treturn",
      "}",
      "",
      "func (h *Heap) Len() int { return len(h.data) }",
      "",
      "func (h *Heap) heapify() {",
      "\tn := h.Len()",
      "\tfor i := (n >> 1) - 1; i > -1; i-- {",
      "\t\th.pushDown(i)",
      "\t}",
      "}",
      "",
      "func (h *Heap) pushUp(root int) {",
      "\tfor parent := (root - 1) >> 1; parent >= 0 && h.comparator(h.data[root], h.data[parent]) < 0; parent = (root - 1) >> 1 {",
      "\t\th.data[root], h.data[parent] = h.data[parent], h.data[root]",
      "\t\troot = parent",
      "\t}",
      "}",
      "",
      "func (h *Heap) pushDown(root int) {",
      "\tn := h.Len()",
      "\tfor left := (root<<1 + 1); left < n; left = (root<<1 + 1) {",
      "\t\tright := left + 1",
      "\t\tminIndex := root",
      "",
      "\t\tif h.comparator(h.data[left], h.data[minIndex]) < 0 {",
      "\t\t\tminIndex = left",
      "\t\t}",
      "",
      "\t\tif right < n && h.comparator(h.data[right], h.data[minIndex]) < 0 {",
      "\t\t\tminIndex = right",
      "\t\t}",
      "",
      "\t\tif minIndex == root {",
      "\t\t\treturn",
      "\t\t}",
      "",
      "\t\th.data[root], h.data[minIndex] = h.data[minIndex], h.data[root]",
      "\t\troot = minIndex",
      "\t}",
      "}",
      ""
    ],
    "description": "dijkstra"
  },
  "random-go": {
    "scope": "go",
    "prefix": "random",
    "body": [
      "type Random struct {",
      "\tseed\t\t uint64",
      "\thashBase uint64",
      "}",
      "",
      "func NewRandom() *Random\t\t\t\t\t\t\t\t { return &Random{seed: uint64(time.Now().UnixNano()/2 + 1)} }",
      "func NewRandomWithSeed(seed int) *Random { return &Random{seed: uint64(seed)} }",
      "",
      "func (r *Random) Rng() uint64 {",
      "\tr.seed ^= r.seed << 7",
      "\tr.seed ^= r.seed >> 9",
      "\treturn r.seed",
      "}",
      "",
      "func (r *Random) Next() uint64 { return r.Rng() }",
      "",
      "func (r *Random) RngWithMod(mod int) uint64 { return r.Rng() % uint64(mod) }",
      "",
      "// [left, right]",
      "func (r *Random) RandInt(min, max int) uint64 { return uint64(min) + r.Rng()%(uint64(max-min+1)) }",
      "",
      "// [start:stop:step]",
      "func (r *Random) RandRange(start, stop int, step int) uint64 {",
      "\twidth := stop - start",
      "\t// Fast path.",
      "\tif step == 1 {",
      "\t\treturn uint64(start) + r.Rng()%uint64(width)",
      "\t}",
      "\tvar n uint64",
      "\tif step > 0 {",
      "\t\tn = uint64((width + step - 1) / step)",
      "\t} else {",
      "\t\tn = uint64((width + step + 1) / step)",
      "\t}",
      "\treturn uint64(start) + uint64(step)*(r.Rng()%n)",
      "}",
      "",
      "// FastShuffle",
      "func (r *Random) Shuffle(nums []int) {",
      "\tfor i := range nums {",
      "\t\trand := r.RandInt(0, i)",
      "\t\tnums[i], nums[rand] = nums[rand], nums[i]",
      "\t}",
      "}",
      "",
      "func (r *Random) Sample(nums []int, k int) []int {",
      "\tnums = append(nums[:0:0], nums...)",
      "\tr.Shuffle(nums)",
      "\treturn nums[:k]",
      "}",
      "",
      "// 元组哈希",
      "func (r *Random) HashPair(a, b int) uint64 {",
      "\tif r.hashBase == 0 {",
      "\t\tr.hashBase = r.Rng()",
      "\t}",
      "\treturn uint64(a)*r.hashBase + uint64(b)",
      "}",
      "",
      "func (r *Random) GetHashBase1D(nums []int) []uint64 {",
      "\thashBase := make([]uint64, len(nums))",
      "\tfor i := range hashBase {",
      "\t\thashBase[i] = r.Rng()",
      "\t}",
      "\treturn hashBase",
      "}",
      "",
      "func (r *Random) GetHashBase2D(nums [][]int) [][]uint64 {",
      "\thashBase := make([][]uint64, len(nums))",
      "\tfor i := range hashBase {",
      "\t\thashBase[i] = make([]uint64, len(nums[i]))",
      "\t\tfor j := range hashBase[i] {",
      "\t\t\thashBase[i][j] = r.Rng()",
      "\t\t}",
      "\t}",
      "\treturn hashBase",
      "}"
    ],
    "description": "random"
  },
  "UnionFindArraySimple": {
    "scope": "python",
    "prefix": "UnionFindArraySimple",
    "body": [
      "class UnionFindArraySimple:",
      "\t\t__slots__ = (\"part\", \"n\", \"_data\")",
      "",
      "\t\tdef __init__(self, n: int):",
      "\t\t\t\tself.part = n",
      "\t\t\t\tself.n = n",
      "\t\t\t\tself._data = [-1] * n",
      "",
      "\t\tdef union(self, key1: int, key2: int) -> bool:",
      "\t\t\t\troot1, root2 = self.find(key1), self.find(key2)",
      "\t\t\t\tif root1 == root2:",
      "\t\t\t\t\t\treturn False",
      "\t\t\t\tif self._data[root1] > self._data[root2]:",
      "\t\t\t\t\t\troot1, root2 = root2, root1",
      "\t\t\t\tself._data[root1] += self._data[root2]",
      "\t\t\t\tself._data[root2] = root1",
      "\t\t\t\tself.part -= 1",
      "\t\t\t\treturn True",
      "",
      "\t\tdef find(self, key: int) -> int:",
      "\t\t\t\tif self._data[key] < 0:",
      "\t\t\t\t\t\treturn key",
      "\t\t\t\tself._data[key] = self.find(self._data[key])",
      "\t\t\t\treturn self._data[key]",
      "",
      "\t\tdef getSize(self, key: int) -> int:",
      "\t\t\t\treturn -self._data[self.find(key)]"
    ],
    "description": "UnionFindArraySimple"
  },
  "UnionFindArraySimple-golang": {
    "scope": "go",
    "prefix": "UnionFindArraySimple",
    "body": [
      "type UnionFindArraySimple struct {",
      "\tPart int",
      "\tn\t\tint",
      "\tdata []int32",
      "}",
      "",
      "func NewUnionFindArraySimple(n int) *UnionFindArraySimple {",
      "\tdata := make([]int32, n)",
      "\tfor i := 0; i < n; i++ {",
      "\t\tdata[i] = -1",
      "\t}",
      "\treturn &UnionFindArraySimple{Part: n, n: n, data: data}",
      "}",
      "",
      "func (u *UnionFindArraySimple) Union(key1 int, key2 int) bool {",
      "\troot1, root2 := u.Find(key1), u.Find(key2)",
      "\tif root1 == root2 {",
      "\t\treturn false",
      "\t}",
      "\tif u.data[root1] > u.data[root2] {",
      "\t\troot1, root2 = root2, root1",
      "\t}",
      "\tu.data[root1] += u.data[root2]",
      "\tu.data[root2] = int32(root1)",
      "\tu.Part--",
      "\treturn true",
      "}",
      "",
      "func (u *UnionFindArraySimple) Find(key int) int {",
      "\tif u.data[key] < 0 {",
      "\t\treturn key",
      "\t}",
      "\tu.data[key] = int32(u.Find(int(u.data[key])))",
      "\treturn int(u.data[key])",
      "}",
      "",
      "func (u *UnionFindArraySimple) GetSize(key int) int {",
      "\treturn int(-u.data[u.Find(key)])",
      "}",
      ""
    ],
    "description": "UnionFindArraySimple"
  },
  "UnionFindMapSimple": {
    "scope": "go",
    "prefix": "UnionFindMapSimple",
    "body": [
      "",
      "type UnionFindMapSimple struct {",
      "\tPart int",
      "\tdata map[int32]int32",
      "}",
      "",
      "func NewUnionFindMap() *UnionFindMapSimple {",
      "\treturn &UnionFindMapSimple{",
      "\t\tdata: make(map[int32]int32),",
      "\t}",
      "}",
      "",
      "func (ufm *UnionFindMapSimple) Union(key1, key2 int) bool {",
      "\troot1, root2 := int32(ufm.Find(key1)), int32(ufm.Find(key2))",
      "\tif root1 == root2 {",
      "\t\treturn false",
      "\t}",
      "\tif ufm.data[root1] > ufm.data[root2] {",
      "\t\troot1, root2 = root2, root1",
      "\t}",
      "\tufm.data[root1] += ufm.data[root2]",
      "\tufm.data[root2] = root1",
      "\tufm.Part--",
      "\treturn true",
      "}",
      "",
      "func (ufm *UnionFindMapSimple) Find(key int) int {",
      "\tkey32 := int32(key)",
      "\tif _, ok := ufm.data[key32]; !ok {",
      "\t\tufm.Add(key)",
      "\t\treturn key",
      "\t}",
      "\tif ufm.data[key32] < 0 {",
      "\t\treturn key",
      "\t}",
      "\tufm.data[key32] = int32(ufm.Find(int(ufm.data[key32])))",
      "\treturn int(ufm.data[key32])",
      "}",
      "",
      "func (ufm *UnionFindMapSimple) GetSize(key int) int {",
      "\treturn int(-ufm.data[int32(ufm.Find(key))])",
      "}",
      "",
      "func (ufm *UnionFindMapSimple) Add(key int) bool {",
      "\tkey32 := int32(key)",
      "\tif _, ok := ufm.data[key32]; ok {",
      "\t\treturn false",
      "\t}",
      "\tufm.data[key32] = -1",
      "\tufm.Part++",
      "\treturn true",
      "}"
    ],
    "description": "UnionFindMapSimple"
  },
  "UnionFindMapSimple-python": {
    "scope": "python",
    "prefix": "UnionFindMapSimple",
    "body": [
      "class UnionFindMapSimple:",
      "\t\t__slots__ = (\"part\", \"_data\")",
      "",
      "\t\tdef __init__(self):",
      "\t\t\t\tself.part = 0",
      "\t\t\t\tself._data = dict()",
      "",
      "\t\tdef add(self, key: int) -> None:",
      "\t\t\t\tif key in self._data:",
      "\t\t\t\t\t\treturn",
      "\t\t\t\tself._data[key] = -1",
      "\t\t\t\tself.part += 1",
      "",
      "\t\tdef union(self, key1: int, key2: int) -> bool:",
      "\t\t\t\troot1, root2 = self.find(key1), self.find(key2)",
      "\t\t\t\tif root1 == root2:",
      "\t\t\t\t\t\treturn False",
      "\t\t\t\tif self._data[root1] > self._data[root2]:",
      "\t\t\t\t\t\troot1, root2 = root2, root1",
      "\t\t\t\tself._data[root1] += self._data[root2]",
      "\t\t\t\tself._data[root2] = root1",
      "\t\t\t\tself.part -= 1",
      "\t\t\t\treturn True",
      "",
      "\t\tdef find(self, key: int) -> int:",
      "\t\t\t\tif key not in self._data:",
      "\t\t\t\t\t\tself.add(key)",
      "\t\t\t\t\t\treturn key",
      "\t\t\t\tif self._data[key] < 0:",
      "\t\t\t\t\t\treturn key",
      "\t\t\t\tself._data[key] = self.find(self._data[key])",
      "\t\t\t\treturn self._data[key]",
      "",
      "\t\tdef getSize(self, key: int) -> int:",
      "\t\t\t\treturn -self._data[self.find(key)]",
      ""
    ],
    "description": "UnionFindMapSimple"
  }
}
