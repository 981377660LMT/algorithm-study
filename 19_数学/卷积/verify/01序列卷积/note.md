# 01 序列卷积

0. zip 乘积可以通过翻转一个序列变为卷积形式

```python
a[i]*b[i] for i in range(n)   # zip按位操作

b = b[::-1]   # 翻转b
a[i]*b[n-1-i] for i in range(n)   # 翻转b后变为卷积形式
```

1. 注意到 01 序列(bool 序列)的乘积就是按位与
   根据与操作的性质
   `(a & b) + (a | b) = a + b`
   `(a & b) << 1 + (a ^ b) = a + b`
   按位或/异或可以通过与运算(乘积)来变成卷积形式

2. 假设 A 和 B 长为 n, 那么卷积后的序列长为 n+n-1，记为 C
   将 B 翻转后, 与 A 卷积, 得到 C
   对于 C[i]，需要结合题意分析这一项的含义(从哪些 pair 中得到的)
3. `1*1=1, 1*0=0, 0*0=0`
   通过卷积只能求出(1,1)对子的个数
   如果要求出(1,0)对子的个数,需要翻转序列求出(0,0)的对子个数,再用总对子数相减

- 因为 01 序列卷积后不会超过 998244353(因为最多为 n),所以可以用 ntt 模 998244353 的卷积模板来加速
