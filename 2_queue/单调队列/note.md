单调队列解决：有长度限制的最大`子序列和`问题：
主要用于`解决滑动窗口类问题`的数据结构，即，`在长度为 n 的序列中，求每个长度为 m 的区间的区间最值`。
也可以辅助 dp
`如果只需要求某段区间的最大最小值，那么使用单调队列即可，不必使用堆`

queue 存数组索引
i - k >= queue.head 需要删除头了
i >= k - 1 需要开始添加了
i 这个位置的最佳得分其实是前面[i-k,i-1]区间最大值加 nums[i]

子数组方法:

1. 前缀和 (看到子数组就想到前缀和/dp)
   `325. 和等于 k 的最长子数组长度`
2. 普通的滑动窗口
   `209. 长度最小的子数组`
3. 单调双端队列
   `862. 和至少为 K 的最短子数组`

   单减的双端单调队列 队首可以维持最大值 起到最大堆的作用

**1499. 满足不等式的最大值.py**
当使用堆来维护有序的子序列/子数组时，考虑使用单调队列
每次搜索到一个新的 point，我们可以通过单调队列，`直接取出之前的点中target的最大值`。不过，`每次取出元素前，我们需要检验一下，这个元素的 x 值是否满足限制条件。`

```Python
queue = deque()
res = -0x7FFFFFFF

for x, y in points:
   # 1. 过期的数据
   while queue and queue[0][1] < x - k:
         queue.popleft()

   # 2.更新结果
   if queue:
         res = max(res, queue[0][0] + x + y)

   # 3.入队
   while queue and queue[-1][0] <= y - x:
         queue.pop()
   queue.append((y - x, x))
```
