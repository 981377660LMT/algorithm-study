# ts-algorithm

| 数据规模 | 算法可接受时间复杂度 |
| -------- | -------------------- |
| <= 10    | O(n!)                |
| <= 20    | O(2^n)               |
| <= 100   | O(n^4)               |
| <= 500   | O(n^3)               |
| <= 2500  | O(n^2)               |
| <= 10^6  | O(nlogn)             |
| <= 10^7  | O(n)                 |
| <= 10^14 | O(sqrt(n))           |
| -        | O(logn)              |

待完善

0. 字符串
1. 数组
   - 数组是存放在连续内存空间上的相同类型数据的集合。
   - 在 JavaScript 中，可以在数组中保存不同类型值，可以越界访问数组，并且数组可以动态增长，不像其它语言，例如 C，创建的时候要决定数组的大小，如果数组满了，就要重新申请内存空间。
2. 栈
   - 应用场景:十进制转二进制，判断字符串括号是否有效，函数调用堆栈
   - 单调栈适合的题目是求解**下一个大于 xxx 或者下一个小于 xxx** 这种题目
   - Stack over flow :函数的临时变量是存储在栈区;没有出口的递归调用栈会超出最大深度
   - Maximum call stack size exceeded
3. 队列
   - 处理广度优先遍历(树:层序遍历/图:无权图的最短路径)
   - 优先队列(每个元素有优先级，优先级高的先出队:操作系统任务调度)
   - 应用场景:JS 异步中的任务队列，计算最近请求次数
4. 链表(有时候直接用首部 Node 来表示链表)

   - 基本操作:遍历/插入/删除
   - 基本方法:虚拟 dummy,穿针引线(p1p2),快慢指针,先穿再排再判空
   - 元素储存不连续，用 next 连在一起
   - 应用场景:JS 异步中的任务队列，计算最近请求次数，原型链，循环找节点父元素
   - 4 个基本方法:

   1. 建立 newNode 最后返回 newNode.next(**设立链表的虚拟头节点**)
      链表问题首先我们看返回值，**如果返回值不是原本链表的头的话，我们可以使用虚拟节点。**
   2. 使用 headP1=head1 headP2=head2 指针来操作,移动链表需要用指针(**穿针引线**)
   3. 快慢指针寻找中间/第 n 位元素
   4. 先穿再排再判空

      **数组读，链表写**
      基本操作:遍历链表/删除节点/**获取 json 某个节点值**

   ```JS
   const json = {
   a: { b: { c: 1 } },
   d: { e: 2 },
   }

   const path = ['a', 'b', 'c']

   // 与遍历链表异曲同工
   let p: { [k: string]: any } = json
   path.forEach(key => {
   p = p[key]
   })

   console.log(p)

   ```

   - | 操作       | 单链表 | 双链表 |
     | ---------- | ------ | ------ |
     | append     | 1      | 1      |
     | appendleft | 1      | 1      |
     | remove     | n      | 1      |
     | find       | n      | 1      |

     - 画图/注意边界条件/类比数组
     - 链表的价值就在于其不必要求物理内存的连续性，以及对插入和删除的友好

5. 集合
   - 应用场景:JS 异步中的任务队列，计算最近请求次数
   - 由于二分搜索树不能 insert 相同元素，所以可以用来实现集合
   - 查找**有无**
   - 有序集合(搜索树实现)与无序集合(哈希表实现)
   - 客户 ip 统计
   - 词汇量统计
6. 字典
   - 保存状态
   - js 的 map 是有序字典 => LRU
   - 查找**对应关系**
7. 树(分层数据抽象模型)

   - Object+Array
   - 递归的中止条件(没有则会报栈溢出)+递归过程
   - 遍历方法 dfs(大多数情况) bfs(层序遍历)
   - 递归 (最长同值路径，相同的树，验证树的某些性质等...)
   - 应用场景:DOM 树，级联选择，树形控件
     深度优先遍历 JSON
   - 如果想要在遍历时对节点**产生副作用**，需要再 dfs 中**传递 root 的引用**(例如 antd 添加 key,为每个节点添加 children)

     ```TS
     interface Dict<V = any> {
     [key: string]: V
     }

     // 深度优先
     const json = {
     a: { b: { c: 1 } },
     d: [1, 2],
     }

     const dfs = (n: Dict, memo: string[] = []) => {
     console.log(n, memo)
     Object.keys(n).forEach(k => dfs(n[k], memo.concat(k)))
     }

     dfs(json)
     export {}

     ```

     - 关于递归:尽量少维护全局状态，把状态作为递归参数传递到递归内部，每层递归自己维护当前层的状态
     - 完全二叉树:除了最后一层都满了，最后一层所有节点都在最左侧(堆就是完全二叉树)
     - 满二叉树: 所有层的结点数都满了
     - **二叉搜索树(BST)**:每个结点的键值大于左孩子，小于右孩子；左右孩子同理
       基本操作(logn):插入/查找/删除/最大最小/前驱后继/某个元素的排名/第 k 大小元素
       **中序遍历**可以得到递增的序列
     - **平衡二叉树(AVL)**是对二叉搜索树的优化；二叉搜索树在极端条件下会退化为链表(logn=>n)
     - 完全随机的数据，普通的二分搜索树很好(不平衡)
     - 读多写少的数据，AVL 树很好
     - 读少写多的数据，红黑树很好(红黑树牺牲了平衡性)
     - **红黑树**的统计性能更优(crud)
     - java 中的 treemap 和 treeset 基于红黑树实现

8. 图
   - 二元关系，道路航班
   - Object+Array **map 实现的邻接矩阵，邻接表,入度数组**
   - 深度优先广度优先 dfs bfs(queue)
   - 邻接矩阵 number[][],邻接表 Map<number,numner[]>
9. 堆
   - 特殊的完全二叉树(完全填满，最后一层从左向右填充)
   - 最大堆/最小堆
   - 数组表示堆
   - 位置为 index 的左侧子节点的位置是 `2*index+1`
   - 位置为 index 的侧右子节点的位置是 `2*index+2`
   - 父节点位置为`(index-1)/2`
   - 作用:时间复杂度 O(1)找出第 K 个最大最小值
   - 第 K 个最大元素就是 K 位高手里最弱的哪一个(最小堆堆顶) 时间复杂度 `k*log(n)`
   - **堆化操作(heapify)的时间复杂度是 O(N)**
10. 排序算法 (方法:先写一轮，再写多轮)
    js 本身的 sort 复杂度 nlog(n)
    基础:冒泡/选择/插入/希尔
    高阶:归并/堆/快排

在 V8 引擎中， 7.0 版本之前，数组长度小于 10 时， Array.prototype.sort() 使用的是插入排序，否则用快速排序。
在 V8 引擎 7.0 版本之后就舍弃了快速排序，**因为它不是稳定的排序算法**，**在最坏情况下，时间复杂度会降级到 O(n2)**。
而是采用了一种混合排序的算法：**TimSort** 。

这种功能算法最初用于 Python 语言中，严格地说它不属于以上 10 种排序算法中的任何一种，属于一种混合排序算法：
在数据量小的子数组中使用插入排序，然后再将有序的子数组进行归并排序，时间复杂度为 O(nlogn) 。

- 冒泡 n^2
- 选择 n^2
- 插入 n^2
- 归并 `n*log(n)` 火狐浏览器
- 快速 `n*log(n)`
  记得添加边界条件

```JS
if (arr.length <= 1) return arr
```

topK 问题解法:
快速排序 O(n) 要求数据一次性给出 (见对应文件夹)
堆(优先队列)O(nlogk) 但是数据很大/数据是流时 用堆可以实时更新 (维护容量为 k 的最大最小堆)

**只有归并排序要 O(n)空间复杂度，其他算法都可以原地完成**
**快排/堆排序/归并排序中只有归并是稳定的**(需要 mergeTwo 过程不移动相等的元素)

当数据量小于 10 时，使用插入排序(**稳定的**)优化归并排序

如果元素是一维的，稳定性没有意义
如果元素位置关系到其他属性，稳定性才有意义

1.  搜索算法(找下标)

    - 顺序搜索 n
    - 二分搜索 log(n) 前提是数组有序

2.  分治思想:递归解决小问题 eg:归并排序 快速排序 反转二叉树 判断二叉树的性质
    - 分
    - 递归
    - 合

```JS
对于数的递归：
// 递归的终点
  if (!t1 && !t2) return true
```

12. 动态规划

    - 初始化 dp 数组(**dp 的维度**取决于状态个数)
    - 构建状态转移方程
    - 空间复杂度的优化:如果第 i 行元素只依赖于 i-1 行的元素，可以不用整个数组而是只用一行

13. 贪心算法:期盼局部最优达到全局最优,但是并不一定全局最优 分饼干，买股票

    - 珍珑棋局
    - 构造数列递推式
    - an algorithm makes the optimal choice **at each step as going forward**.

14. 回溯算法(BackTrace):渐进式解决问题
    - 回溯法是暴力解法的一个主要实现手段/是**经典**人工智能的基础
    - 树形问题
    - 遇到岔路：走一条**路**没走通，走回来
    - 剪枝:预先排除不必要的路径
    - 递归模拟所有的路
    - 例子:输出全排列
    - 可以引入 **memo** 来辅助回溯
    - 如果最后保存结果到数组中，需要在 bt 完之后 **pop**,并且注意 bt 的终点需要**浅拷贝**
