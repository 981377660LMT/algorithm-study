每天坚持复习 20 道，在评论区/题解区留下自己的解法

#1001 **网格照明**  
困难
1 <= N <= 10^9 骗人的数据，哈希表就可以了，因为灯泡分布很稀疏
0 <= lamps.length <= 20000
`Counter 计数行列对角线斜对角线`

#1003 **检查替换后的词是否有效**  
中等
`stack 消消乐`

#1004 **最大连续 1 的个数 III**  
中等
`最大连续1模型`

#1005 **K 次取反后最大化的数组和**  
简单
`贪心，按绝对值排序`

#1006 **笨阶乘**  
中等
`递归`

#1007 **行相等的最少多米诺旋转**  
中等
`看cand元素是否在每列里都有`

#1008 **前序遍历构造二叉搜索树**  
中等
`shift找到根，然后filter左右递归`

#1009 **十进制整数的反码**  
简单
求二进制表示的反码所对应的十进制整数。
`即求11111..11与原数的异或；求1111..11需要用(1<<(32-clz))-1`

#1010 **总持续时间可被 60 整除的歌曲**  
中等
`利用-mod60首尾配对`

#1011 **在 D 天内送达包裹的能力**  
中等
`最左能力二分`

#1012 **至少有 1 位重复的数字**  
困难
给定正整数 N，返回小于等于 N 且具有至少 1 位重复数字的正整数的个数。
这题好难
类似于`902.最大为 N 的数字组合`
`cand 小于n位，等于n位两种情况讨论；等于n位时注意最后判断能不能取到与上限相等，能就+1`

#1013 **将数组分成和相等的三个部分**  
简单
`遍历，寻找切分点,记录sum与hit次数`

#1014 **最佳观光组合**  
中等
求 values[i] + values[j] + i - j 最大值
`变形条件，即 左(dp前项)A[i]+i和右(dp当前项)A[j]-j两部分和最大值，维护两个变量即可`

#1015 **可被 K 整除的最小整数**  
中等
找出可以被 K 整除的、仅包含数字 1 的最小正整数 N。
`找 k 次，必定有两个模相等；如果模再次出现且还没找到模 0，那么返回-1`

#1016 **子串能表示从 1 到 N 数字的二进制串**  
中等
1 <= N <= 10^9 吓人的数据
`从 n到n//2 检查即可 不合理就返回 注意总会提前返回 `

#1017 **负二进制转换 ok**  
中等
`divmod 即可 注意div要取负数`

#1018 **可被 5 整除的二进制前缀 okk**  
简单
`前缀注意取模5，否则超出范围`

#1019 **链表中的下一个更大节点 okk**  
中等
`单调栈，遍历时记录索引，最后处理栈里的剩余元素`

#1021 **删除最外层的括号**  
简单
`用level控制进入res的条件`

#1023 **驼峰式匹配**  
中等
`有点像判断子序列；使用hit来记录匹配的位置`

#1024 **视频拼接**  
中等
`跳跃游戏模型，将[start,end]转换成每个start点处的最大跳跃距离`

#1025 **除数博弈**  
简单
`偶数时先手必胜:谁轮到N=2时谁就会赢`
`也可n^2 dp`

#1026 **节点与其祖先之间的最大差值**  
中等
`dfs后序，返回min和max；叶子结点返回[Infinity,-Infinity]`

#1027 **最长等差数列**  
中等
给定一个整数数组 A，返回 A 中最长等差`子序列`的长度。
`字典作为dp结构，dp[(i, diff)] = dp[(j, diff)] + 1`
等差子数组呢?
`检查nums[i] - nums[i - 1] === nums[i - 1] - nums[i - 2]即可`

#1028 **从先序遍历还原二叉树**  
困难
`字典的key为深度，value为结点`
关键是想到**用 map 存某个高度的结点**
`上一个遍历到的比自己深度浅1的节点必为自己的父节点`

#1029 **两地调度**  
中等
`贪心，按照两种选择的差排序`

#1030 **距离顺序排列矩阵单元格**  
简单
`按距离计数排序`

#1031 **两个非重叠子数组的最大和**  
中等
`以i为结尾dp;讨论 first 在前还是 second 在前，dp滚动更新 first/second维护取前面的最大值`

#1032 **字符流**  
困难
`反向插入前缀树`

#1033 **移动石子直到连续**  
中等
`整理顺序:[a, b, c] = [a, b, c].sort((a, b) => a - b)`
`若a、c任一与b差值小于等于2，则可一步到位;最慢是a和c全部一步一步往中间靠拢`

#1034 **边界着色**  
中等
`bfs找到边界: not (0 <= nx < m and 0 <= ny < n and grid[nx][ny] == originalColor)，将边界点加入待处理的数组里`

#1035 **不相交的线**  
中等
`最长公共子序列`

#1036 **逃离大迷宫**  
困难
`障碍的最大数量小于等于200 所以如果`bfs 层数`大于障碍数200 则说明障碍没有包围这个点`

#1037 **有效的回旋镖**  
简单
`三点共线=>叉乘为0`

#1038 **把二叉搜索树转换为累加树**  
中等
`先dfs到最右，然后处理逻辑,然后dfs左`

#1039 **多边形三角剖分的最低得分**  
中等
`区间dfs；dfs的返回条件为range(l,r)中l>=r`

#1040 **移动石子直到连续 II**  
中等
todo

#1041 **困于环中的机器人**  
中等
`向右旋转 e^(-pi/2) dx, dy = dy, -dx `
`向左旋转 e^(pi/2) dx, dy = -dy, dx`
`永远无法离开：回到原点或者不在原点，方向改变`

#1042 **不邻接植花**  
中等
`建图，直接取与邻接边颜色的差集 res[i] = ({1, 2, 3, 4} - {res[j] for j in adjList[i]}).pop() `

#1043 **分隔数组以得到最大和**  
中等
`dfs(index)加cache记忆化搜索`

#1044 **最长重复子串**  
困难
`二分答案+RK算法，取模使用bigint`

#1046 **最后一块石头的重量**  
简单
`大顶堆，有两个就继续pop`

#1047 **删除字符串中的所有相邻重复项**  
简单
`相邻字符串删除用栈`

#1048 **最长字符串链**  
中等
1 <= words.length <= 1000
`dp，defaultdict存储；枚举删除点`

#1049 **最后一块石头的重量 II**  
中等
`01背包问题`

#1052 **爱生气的书店老板**  
中等
`i>=k 减去左端点 arr[i-k] `
`i>=k-1 更新答案res`

#1053 **交换一次的先前排列**  
中等
`类似于prev_permutation`

#1054 **距离相等的条形码**  
中等
`按照most_common排序，左右分成两半，前一半长度不少于后一半，交叉插入数组`

#1055 **形成字符串的最短路径**  
中等
`hit循环双指针`

#1056 **易混淆数**  
简单
`查字典`

#1057 **校园自行车分配**  
中等
`选出m*n对备选，然后排序+配对`

#1058 **最小化舍入误差以满足目标**  
中等
`两地调度;比较abs(min-cur)-abs(max-cur)的值`

#1059 **从始点到终点的所有路径**  
中等
`1.终点不能有邻居2.叶子节点必须是终点3.不能有环`
`注意回溯时解除visited`

#1060 **有序数组中的缺失元素**  
中等
`missed = nums[mid] - nums[0] - mid`

#1061 **按字典序排列最小的等效字符串**  
中等
`每次合并时保留字典序小的根`

#1062 **最长重复子串**  
中等
`二分答案+RK`

#1063 **有效子数组的数目**  
困难
`统计每个元素作为最小值向右延伸的长度`
`单调栈本身的长度就是题意里数组的个数`

#1064 **不动点**  
简单
`相等时更新res,right左移`

#1065 **字符串的索引对**  
简单
`枚举text端点，前缀树search切片`

#1066 **校园自行车分配 II**  
中等
1 <= workers.length <= bikes.length <= 10
`状压`

#1071 **字符串的最大公因子**  
简单
`先判断是否循环节一样；再取长度的gcd`

#1072 **按列翻转得到最大值等行数**  
中等
`如果两个行是可以通过翻转相同的列达到全行相同，那么就要满足，要么它们全等，要么它们相反(异或为1)。`
`如何记录行的state?每行的元素和行开头异或` 011 和 100 是相等的

#1073 **负二进制数相加**  
中等
`注意carry取负div`

#1074 **元素和为目标值的子矩阵数量**  
困难
1 <= matrix.length <= 100 n^3
`pre[i][j] = matrix[i - 1][j - 1] + pre[i - 1][j] + pre[i][j - 1] - pre[i - 1][j - 1]`

#1078 **Bigram 分词**  
简单
`判断arr[i]与arr[i+1]是否与target相等`

#1079 **活字印刷**  
中等
`dfs(path,remain) 只要路径不为空，就加入res`

#1080 **根到叶路径上的不足节点**  
中等
`删除结点，利用dummy；后序遍历，利用下面的结果操作root.left和root.right`

#1087 **花括号展开**  
中等
`isExpandMode控制`

#1088 **易混淆数 II**  
困难
1 <= N <= 10^9
`dfs`

#1089 **复写零**  
简单
`逆向处理`

#1090 **受标签影响的最大值**  
中等
`排序大值在前，遍历并计数`

#1092 **最短公共超序列**  
困难
`LCS变形，dp存字符串；然后遍历LCS,双指针不断找公共字符，merge`

#1094 **拼车**  
中等
`上车下车模型`

#1095 **山脉数组中查找目标值**  
困难
`先找顶峰，然后在左右两段有序数组继续二分`

#1096 **花括号展开 II**  
困难
`双list res,cur；stack用来暂时存储计算结果`

#1099 **小于 K 的两数之和**  
简单
`排序+双指针`

#1100 **长度为 K 的无重复字符子串**  
中等
`定长滑窗注意i>=k和i>=k-1两个时机`
