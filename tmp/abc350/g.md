abc350g-Mediator
https://atcoder.jp/contests/abc350/tasks/abc350_g

1. lct，最容易的解法
2. 操作分块
   https://atcoder.jp/contests/abc350/editorial/9821
   操作分成 B 批，每批操作内：
   - 预处理：bfs 处理出这一批之前每个点的父结点、并查集合并这一批之前边
   - 修改：邻接表加邻居、保存边
   - 查询：
     如果 u,v 在这一批之前已经在同一个连通块中，那么答案候选人为 u 的父结点或者 v 的父结点，已经预处理出；
     否则，遍历这一批操作内所有新加的边，找到可能作为 u 和 v 公共邻居的点。
3. 按照点的度数进行根号分治
   https://atcoder.jp/contests/abc350/editorial/9829
   更新：小点更新对邻居暴力更新，大点更新时只记录这条边.
   查询：如果邻居中有记录，则返回，否则遍历大点查询.
4. 并查集+启发式合并(TODO，没看懂)
   https://atcoder.jp/contests/abc350/editorial/9822
   始终维护为一个有向森林，我们发现并查集只能维护根，但只要用启发式合并，同时暴力在小块中 dfs，就能维护好这个结构
   **加边时动态更新某个分组中所有点的父结点信息，启发式保证每个点被更新的次数不超过 logn 次**
   `这个技巧能否推广到一般场景？每次并查集合并后，都可以对整个小的分组进行某种更新`
5. bitset 经典空间优化
   O(n^2/w) => 1e10/64 个 uint64 => 1200MB

   - 修改：采用`邻接表+bitset`保存邻居(空间限制导致不能只用 bitset)
     邻居少时直接存为邻接表，邻居超过阈值后邻接表自动转换成 bitset.
   - 查询：
     u,v 都是大点 => bitset 求交集
     u 是小点，v 是大点 => 遍历 u 的邻居，查询 v 的 bitset
     u,v 都是小点 => 邻接表 set 求交集

   和 java HashMap 超过阈值，链表转成红黑树异曲同工
