import sys

sys.setrecursionlimit(int(1e6))
input = lambda: sys.stdin.readline().rstrip("\r\n")
MOD = 998244353
INF = int(4e18)
# この問題は インタラクティブな問題（あなたが作成したプログラムとジャッジプログラムが標準入出力を介して対話を行う形式の問題）です。

# 1 から
# N の番号がついた
# N 本のジュースがあります。 このうちちょうど
# 1 本が腐っていることが判明しました。 そのジュースを微量でも飲むと、翌日お腹を壊してしまいます。

# 高橋君は翌日までに腐ったジュースを特定しなければなりません。 高橋君はそのために必要な最小の数の友人を呼び、それぞれに
# N 本のジュースのうちの一部を振る舞うことにしました。 各友人には何本でもジュースを与えることができ、各ジュースは何人の友人にでも与えることができます。

# 呼ぶ友人の数とジュースの与え方を出力して、翌日に各友人がお腹を壊したかどうかの情報を受け取り、腐ったジュースの番号を出力してください。
# 这是一个交互式问题，你需要编写一个程序与评判程序进行交互。有编号为1到N的N瓶果汁，其中恰好有一瓶已经确定是坏的。如果喝了这瓶果汁，第二天就会拉肚子。高桥君必须在第二天之前确定哪瓶果汁是坏的。他决定召集最少数量的朋友，给他们每人分一部分的N瓶果汁。他可以给每个朋友任意数量的果汁，每瓶果汁也可以给任意数量的朋友。

# 你需要输出召集的朋友数量和分配果汁的方式，然后接收第二天每个朋友是否拉肚子的信息，最后输出坏果汁的编号。

# 限制条件：

# N是整数，2≤N≤100
# 输入输出： 这是一个交互式问题，你需要编写一个程序与评判程序进行交互。在交互开始之前，评判会秘密选择一个坏果汁的编号X，范围在1到N之间。你不会知道X的值，而且在交互过程中，X的值可能会在不违反限制条件和之前的输出的情况下改变。

# 首先，评判会给出N。 然后，你需要输出召集的朋友数量M，并换行。 接下来，你需要进行M次输出，每次输出都包括给第i个朋友的果汁数量Ki和这些果汁的编号（按升序排列）Ai,1，Ai,2，...，Ai,Ki。你需要按以下格式输出，并换行：Ki Ai,1 Ai,2 ... Ai,Ki 然后，评判会给出每个朋友第二天是否拉肚子的信息，这是一个由0和1组成的长度为M的字符串S。 对于i=1,2,…,M，当且仅当S的第i个字符为1时，表示第i个朋友拉肚子。 然后，你需要输出坏果汁的编号X'，并换行。 然后，你需要立即结束程序。 如果你输出的M是确定坏果汁所需的最少朋友数量，且你输出的X'与坏果汁的编号X一致，那么你的答案就是正确的。
if __name__ == "__main__":
    N = int(input())
    M = (N - 1).bit_length()

    # def query() -> int:
    #     row1, row2, col1, col2 = row1 + 1, row2 + 1, col1 + 1, col2 + 1
    #     print(f"? {row1} {row2} {col1} {col2}", flush=True)
    #     return int(input())
    print(M, flush=True)

    def output(row: int, col: int) -> None:
        row, col = row + 1, col + 1
        print(f"! {row} {col}", flush=True)
