// 给定整数 n 和 k, 将 1 到 n 的这 n 个整数按字典序排列之后, 求其中的第 k 个数
// 求字典序第 m 个数， 就是求这棵树的前序遍历的第 m 个节点。问题转化为求完全十叉树的前序遍历的第 m 个数。

// 0. 越往右边越大,右边比下面大,只有下面走完了才会走到右边;9开头的已经非常大了
// 1.如果当前节点的前缀是 x ，那么其第一个子节点（就是最小的子节点）是 x * 10，第二个就是 x * 10 + 1
// 2.深入到子节点就是 x * 10。
// 3.跳过所有孩子节点，直接到兄弟节点就是 x + 1。
// 重点是如何计算给定节点的孩子节点的个数
const findKthNumber = (n: number, k: number) => {
  // 求出在大小为n的字典树中 到相同层次的邻居节点需要的步数
  // 一直往下直到下不去了,到底再往右到底,再往上回来一步就到了兄弟节点
  // 例如:from 10  to 11 n 166时可知from与n不在同一层 需要下去
  const countStep = (n: number, n1: number, n2: number) => {
    let step = 0
    while (n1 <= n) {
      // 比如n是195的情况195到100有96个数
      // n2-n1 是一般情况
      // (n+1-n1)表示正一行字典树没有满 到尽头了
      // 向右或向下走
      step += Math.min(n2, n + 1) - n1

      n1 *= 10
      n2 *= 10
    }
    return step
  }

  let cur = 1
  // 剩余移动步数
  k--
  while (k > 0) {
    // cur + 1表示兄弟节点
    const step = countStep(n, cur, cur + 1)

    if (step <= k) {
      // 需要的移动步数小于等于k 移动到兄弟节点(从1到2,或者从10到11这种)
      k -= step
      cur++
    } else {
      // 移到兄弟节点需要的移动步数大于k,向下移动一步再看(从1到10这种)
      k--
      cur *= 10
    }
  }

  return cur
}

console.log(findKthNumber(11, 4))

export default 1
// 对于 n=11, m=4, 按字典序排列依次为 1, 10, 11, 2, 3, 4, 5, 6, 7, 8, 9, 因此第 4 个数是 2.
