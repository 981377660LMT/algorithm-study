# 「说透低代码」专栏笔记补充

虽然现在行业大会多数都有低代码专题，但以演讲形式分享低代码的实现经验实在太有限，也**不成体系**。对于低代码这样复杂、综合的系统来说，50 分钟左右的分享实在是杯水车薪，只能展示一些碎片化的知识内容，学习成本很高。而且不同业务背景对应不同的实施策略，有时甚至是矛盾的，**不明就里只会越听越迷糊**。
![image](https://user-images.githubusercontent.com/45849137/202834936-471d8a3c-ef3b-48c2-ba43-3394b085012c.png)

## 认知基础与架构策略

- [ 01 ｜低代码平台到底是什么样的？](https://time.geekbang.org/column/article/494558)
  低代码工具指代规模较小、成熟度较低的低代码实现，而低代码平台则指代规模较大、功能较完善、程度较高的低代码实现。 - 代码维度分类：纯(pro)代码、低(low)代码、无(no)代码 - 输出 APP 类型分类：流程驱动型、表单驱动型、模型(ORM)驱动型、BI 分析类型
  ![image](https://user-images.githubusercontent.com/45849137/202835730-fe2baa3c-e360-4b86-acf7-66271f98287c.png)

- [ 02 ｜低代码到底是银弹，还是行业毒瘤？ ](https://time.geekbang.org/column/article/495328)
  存在即合理。
  脱离业务谈架构的都是耍流氓。同样的，脱离业务谈低代码的也是耍流氓。
  1. 营销活动这种快上快下，用完就扔的业务类型适合
  2. 面向 B 端场景下的代码生成，无动画、UI 高要求，但对数据处理逻辑这块有通用性的地方，比较适合。
- [ 03 ｜低代码的天花板：一个完备的低代码平台应该具备哪些条件？ ](https://time.geekbang.org/column/article/496043)
  1. 低代码平台要有一个足够强大的编译器（代码生成器）。
  2. 平缓的学习曲线、自动化、可以抄作业、提供视频形式的教材、出问题或者有疑问时能在第一时间得到帮助。
  3. 与基础设施和谐相处。
  4. D2C、UX 设计、APP 开发能力、自动化测试、版本管理、生产环境监控
- [ 04 ｜演进策略：先发展通用能力还是先满足业务需求？ ](https://time.geekbang.org/column/article/496839)
  三个阶段：MVP 阶段、成熟期、超越期。
  **优先发展通用能力。坚持优先发展通用能力不动摇。**
  **在可能要扩展的地方留出充分的扩展能力，在必须做通用的地方坚持彻底的解耦。**
- [ 05 ｜基础设施 ：启动低代码平台研发之前，你需要有什么家底？ ](https://time.geekbang.org/column/article/497779)
  **Web 组件库**是 Web 应用的最重要基础设施，没有之一。
  在开始打造低代码平台之前，请先确认你手里已经拥有一套值得托付的组件库。
  组件库要求：

  - 自主可控
  - 封装程度高
    常见的组件的封装方式

    1. `数据驱动模式`，这种模式的关键特征是组件将 HTML/CSS 彻底封装到其内部，`只暴露出一些属性对外提供配置入口`。这样的封装方式对低代码平台的代码生成器是非常友好的。我们应该优先挑选具有这种 API 特征的组件集，自行实现时也需要采用这样的封装方法。
    2. `模板驱动封装方式`,典型特征是 HTML 部分非常复杂，数据、样式、状态都几乎在 HTML 模板里实现。它`直接将 HTML 模板当做一种 API 暴露给应用`，因此应用可以按需改造 HTML 模板，灵活实现特定功能。也就是说，它具有更强的定制性，这方面是数据驱动类型组件所不具备的能力。

  - 功能强大

    1. 至少包含 50 个以上的原子组件和容器类组件才能基本覆盖完整日常所需
    2. 具有良好的视图悬浮 (popover) 功能封装和多层视图叠加管理能力。低代码编辑器往往有密集的配置入口，许多配置项需要就地弹出气泡甚至多级气泡来承载，避免打断当前的开发工作；
    3. 数据采集类的组件（文本框、数字框、下拉选择等）必须`对表单友好`，这样才能更容易实现出表单类页面；
    4. 对常用功能要有统一封装，在 Angular 里称为`指令` Directive，特点是这些功能可以“外挂”到任何普通 dom 节点、组件节点上，实现功能扩展。比如，像任意视图下拉、上传功能、多功能徽标、下拉多级菜单、拖拽功能等功能都值得封装。
    5. 一个符号图标库，这个不一定非要自己做，但必须要有。

  - 皮肤(主题)深度定制能力（可选）

## 核心功能开发 (布局、交互、数据 三部曲）

- [ 06 ｜踏出新手村便遭遇大 Boss：如何架构低代码的引擎？ ](https://time.geekbang.org/column/article/498769)
  - `生成应用代码`是这一切的基础
    作者对代码生成器与编辑器的关系划分了四个 level。
    - level1 简单拖拽，像玩具。拖拽只是低代码平台起步的一种方式。
    - level2 与编辑器耦合严重。工具和业务耦合严重。平台和应用是可以实现解耦的。耦合严重的编辑器，负担太重，难以走得更远。
    - level3：代码生成器与编辑器同等地位(**引入了协议层解耦**)。**一个比较好的实现方式是将它做成一个命令行，可以在 shell 终端里跑。** 命令行的好处很多，主要很容易与 DevOps 流水线结合使用，或者实现各种自动化。应用跑一下命令行就可以生成一份可以独立运行的代码出来，这样你爱放哪运行都与编辑器无关了。当然，让应用实现一套完整的编译协议是不合理的。我们可以在编译协议层里加入部分实现，这样应用在定制时就可以**只覆盖少数不适合的实现**，复用大部分的已有实现，这样可以大大减轻应用定制的工作量和难度。市场上的成功案例都是协议优先，核心稳定，欢迎合作共赢。
    - level4：具有良好的插件系统与生态。需要抽象出编译流程的各个时机（可称为编译**生命周期**），以及对各个时机具备的可扩展点加以规范(发布订阅)，从而形成一套完备的插件开发能力。
  - 生成代码总体流程
- [ 07 ｜结构化代码生成法：代码如何生成代码？](https://time.geekbang.org/column/article/499824)
  其实`结构化代码生成法`创造代码的过程和你我日常写代码的过程，是一样的。
  就像一位有强迫症的程序员，规定先写变量声明，再写构造函数,...
  计算机非常擅长读写结构化数据，因为结构化数据没有二义性。
- [ 08 ｜布局编辑器：如何做到鱼和熊掌兼得？ ](https://time.geekbang.org/column/article/500747)
  靠单一的布局器是无法同时获得效率和通用能力的。所以，我们很容易想到可以采用`组合`的方式，兼顾高效率和通用能力。

  **四种布局器:**

  - **网格** 要求设计稿中，任何两个组件间的距离和尺寸必须是 **8px** 的整数倍。
    ![image](https://user-images.githubusercontent.com/45849137/202838722-7f0327a8-3541-4fcd-9b5d-f48a69ecd874.png)
  - **卡片** 水平盒子+竖直盒子覆盖二维平面
  - **表单** 数据驱动表单
  - **流程编排** 简单地说就是开发一些流程审批类的 App 时，直接用它当做顶层布局器，然后各个流程环节配合使用表单等其他布局器，可以实现非常高效率的 App 开发效果。

- [ 09 ｜属性编辑器：如何解除 Web 组件属性与编辑器的耦合？ ](https://time.geekbang.org/column/article/501746)
  解耦组件和编译器，靠协议规范，基于协议实现扩展机制。
  协议可以理解为是一些抽象基类和接口、是一些 API 的描述。
- [ 14 ｜编辑历史：是对 Git 做改造，还是另辟蹊径？ ](https://time.geekbang.org/column/article/506846)

## 平台功能扩展

- [ 15 ｜低代码平台应该优先覆盖应用研发生命周期中的哪些功能？](https://time.geekbang.org/column/article/507839)
  ![image](https://user-images.githubusercontent.com/45849137/202840546-123c812e-3c95-483b-9739-09344c370be9.png)
- [ 16 ｜扩展与定制：如何实现插件系统并形成生态圈？ ](https://time.geekbang.org/column/article/507839)
  当第一个 if 出现的时候，低代码平台的架构腐化就开始了，当再也 if 不下去的时候，已经病入膏肓。

  如何设计和实现一个插件系统。我们可以从 SDK 的提取方法、可扩展的功能建议、插件二次开发和 manifest 设计，以及插件生命周期管理这几个方面来考虑。
  通常来说，SDK 主要包括：

  - 接口和类型定义。
  - 基类的定义。
  - 调试工具和构建 & 部署脚本。
  - 辅助性、功能性工具类。

  可以参考 vscode 的插件书写方式、配置和设计

- [ 17、18 ｜兼容性问题：如何有效发现兼容性问题？ ](https://time.geekbang.org/column/article/545968)

  - 如何解决兼容性？

  1. 代码走查(code review)
  2. DevOps 流水线
     它主要采用形式多样的自动化检查脚本，来发现软件研发过程中包括兼容性问题在内的各种问题，从而提升软件研发效能和质量。
     尽量将已知的兼容性问题脚本化是很重要的，这样可以避免在同一个坑里掉两次。
  3. 利用实际用户数据

  - 如何解决破坏性？

  1. 每当出现一个破坏性变更的时候，我们都配套给它编写一个处理器(**Adapter**)，这个处理器的作用是消除掉这一个破坏性，将兼容性发生前的用户数据升级为兼容性发生之后的格式。
     当有新的破坏性出现的时候，我们重复这个过程，就可以实现从 V2 升级到 V3，V3 升级到 V4 了：
     **每一个处理器都只要关注处理一个破坏性，而无需关注其他破坏性，**一个破坏性的内容是确定的，因此处理逻辑也是确定的，因此很容易将一个处理器做得非常健壮。
  2. 升级大版本并对外宣布这个破坏性无解，需要手工处理
     对于无法解决的破坏性问题可以这样做
