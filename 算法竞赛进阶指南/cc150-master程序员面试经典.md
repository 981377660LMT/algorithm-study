1. 适当代码复用
2. 模块化

**StringBuilder**
假设你要将一组字符串拼接起来

```JAVA
String joinWords(String[] words) {
 String sentence = "";
 for (String w : words) {
 sentence = sentence + w;
 }
 return sentence;
 }
```

每次拼接都会新建一个字符串
第一次迭代要复制 x 个字符，第二次迭代要复制 2x 个字符，第三次要复制 3x 个
这段代码的用时为 O(x + 2x + … + nx)，可简化为 O(xn2)。
StringBuilder 可以避免上面的问题。**它会直接创建一个足以容纳所有字符串的可变长度数组，等到拼接完成才将这些字符串转成一个字符串**

```JAVA
String joinWords(String[] words) {
 StringBuilder sentence = new StringBuilder();
 for (String w : words) {
 sentence.append(w);
 }
 return sentence.toString();
 }
```

启示：使用 stringBuilder 数组来创建新的字符串
前 push:最后反转加 join
后 push:最后直接 join

**图的双向搜索**

在传统的广度优先搜索中，在搜索的第一层我们需要搜索至多 k 个节点。在第二层，对于第一层 k 个节点中的每个节点，我们需要搜索至多 k 个节点。所以，至此为止我们需
要总计搜索 k2 个节点。我们需要进行 d 次该操作，所以会搜索 O(kd)个节点。
在双向搜索中，我们会有两个相遇于约 d / 2 层处（最短路径的中点）的搜索。从 s 点和 t 点开始的搜索分别访问了大约 kd/2 个节点。总计大约 2kd/2 或 O(kd/2)个节点。
两者似乎差别不大，然而并非如此，实际上差别巨大。请回想一下如下公式：(kd/2)×(kd/2) =
kd。双向搜索事实上快了 kd/2 倍。
换句话说：如果我们的系统只支持在广度优先搜索中查找“朋友的朋友”这样的路径，现在则可以支持“朋友的朋友的朋友的朋友”这样的路径。我们可以支持长度为原来两倍的路径。

**二进制补码与负数**
计算机通常以**二进制补码**的表示形式存储整数。 正数表示为自身，而负数表示为其绝对值的二进制补码（其符号位为 1，表示负值）。N 位数（N 是数字的位数，不包括符号位）的二进制补码是相对于 2^N 的数字的补码。

**可以反转正数表达中的每个数位，然后再加 1**。3 表示为二
进制数是 011。翻转所有数位得到 100，加 1 后得到 101，然后加上符号位（1）可以得到 1101。

**数学与逻辑题**
九球称重
给定 N 个球，其中 N 能被 3 整除，称量一次便能找到包含重球的那一组球。

扔鸡蛋

较重的药丸
有 20 瓶药丸，其中 19 瓶装有 1.0 克的药丸，余下 1 瓶装有 1.1 克的药丸。
给你一台称重精准的天平，怎么找出比较重的那瓶药丸？天平只能用一次。
从药瓶#1 取出一粒药丸，从药瓶#2 取出两粒，从药瓶#3 取出三粒，以此类推。如果每粒药丸均重 1 克，则称得总重量为 210 克（1 + 2 + … + 20 = 20×21 / 2 = 210），“多出来的”重量必定来自每粒多 0.1 克的药丸。

三角形上的蚂蚁
在 n 个顶点的多边形上有 n 只蚂蚁，求出这些蚂蚁发生碰撞的概率
减去不撞的概率即可

蓝眸岛
所有蓝眼睛的人都必须尽快离开这个岛。每晚 8 点会有一个航班离岛。每个人都看得见别人眼睛的颜色，但不知道自己的（别人也不可以告知）。此外，他们不知道岛上到底有多少人有蓝眼睛，只知道至少有一个人的眼睛是蓝色的。所有蓝眼睛的人要花几天才能离开这个岛？
只有一人眼睛是蓝色的
假设岛上所有人都智力超群，蓝眼睛的人四处观察之后，发现没有人的眼睛是蓝色的。但
他知道至少有一人眼睛是蓝色的，于是就推导出自己的眼睛一定是蓝色的。因此，他会搭乘当晚的飞机离开。
只有两人眼睛是蓝色的
两个蓝眼睛的人看到对方，并不确定 c 是 1 还是 2，但是由上一种情况得知，如果 c = 1，那个蓝眼睛的人第一晚就会离岛。因此，发现另一个蓝眼睛的人仍在岛上，他一定能推断出 c = 2，也就意味着他自己的眼睛也是蓝色的。于是，两个蓝眼睛的人都会在第二晚离岛。
如果有 c 人有蓝眼睛，则所有蓝眼睛的人要用 c 晚才能离岛，且都在同一晚离开

大灾难
所有家庭在得到一个女孩之前不断生育，生了女孩之后立即停止生育——那么新一代的性别比例是多少
1:1 对称

100 个储物柜

**OOP**
参考极客时间
需要说明的是，很多人不喜欢使用单例设计模式，甚至称其为“反模式”。原因之一是该模式会干扰单元测试。

扑克牌
请设计用于通用扑克牌的数据结构

**如何分析递归的复杂度**
把代码执行路径画成一棵树
画递归调用树可以很好地用来计算递归算法运行时间。
不优化的斐波那契 O(2^n)
记忆化的斐波那契 O(n)

卡特兰数
1, 1, 2, 5, 14, 42, 132, 429, 1430...

**系统设计**

1. 社交网络。
   你会如何设计诸如 Facebook 或 LinkedIn 的超大型社交网站的数据结构？
   请设计一种算法，展示两人之间最短的社交路径（比如，我 → 鲍勃 → 苏珊 → 杰森 → 你）。
   - 双向广度优先搜索
   - 处理数百万的用户
2. 网络爬虫。如果要设计一个网络爬虫，该怎样避免陷入死循环呢
   布隆过滤器

**java**

1. TreeMap、HashMap、LinkedHashMap。解释一下 TreeMap、HashMap、LinkedHashMap 三者的不同之处。举例说明各自最适合的情况。
   HashMap 提供了 O(1)的查找和插入。如果你要遍历 key 时，要清楚 key 其实是无序的。它是用**节点为链表的数组**实现的。(类比 js 对象)
   TreeMap 提供了 O(log N)的查找和插入。但 key 是有序的，如果你想要按顺序遍历 key，那么它刚好满足。这也意味着 key 必须实现了 Comparable 接口。**TreeMap 是用红黑树实现的。**(Java 独有)
   LinkedHashMap 提供了 O(1)的查找和插入。key 是按照插入顺序排序的。它是用**双向链表桶实**现的。(类比 js Map)
   一般来说，如果没有明确要求，Hashmap 将是不二之选。换言之，如果你需要按插入顺序排序的 key，就用 LinkedHashMap； 如果需要按实际和自然顺序排序的 key，就用 TreeMap；在其他情况下，最好用 HashMap，其通常运行较快且操作不太烦琐。
2. try 中存在 return 时,是否还会执行 finally 代码块
   **会**

**锁**

1. 哲学家问题
   解决方法：
   - 全部或无：如有哲学家拿不到右手边的筷子，就
     让他放下已拿到的左手边的筷子。
   - 区分筷子优先级
