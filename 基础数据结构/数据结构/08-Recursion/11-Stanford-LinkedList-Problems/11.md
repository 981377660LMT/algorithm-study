## 斯坦福大学的 18 个链表问题

在这一小节，我将把上一小节视频中，我推荐的斯坦福大学的链表相关文档的 18 个问题进行简单的翻译。

1\. ``Count`` : 计算链表的节点个数；

2\. ``GetNth`` : 获得链表第 n 个节点的值；

3\. ``CreateList`` : 根据数组（或者标准输入）创建链表；``DeleteList`` : 释放一个链表的所有节点空间；

注意：由于 Java 语言不需要释放空间，所以在 Java 语言中，不需要完成这个任务。如果有同学使用 C/C++，可以参考）；

4\. ``Push`` : 向链表头插入一个新节点；``Pop`` : 删除链表的第一个节点并返回；

注意：我们可以将链表看做是一个队列，此时，向链表的头或者尾插入或者删除元素，就可以衍生出两个 ``Push`` 实现和两个 ``Pop`` 实现。大家也可以显示地将这四个方法命名为 ``addFirst``, ``addLast``, ``removeFirst``, ``removeLast``（参考 Java 中的命名方式），并据此封装底层基于链表的栈，队列，双向队列等等线性数据结构：）

5\. ``InsertNth`` : 在链表的第 n 个位置插入一个新节点；

6\. ``SortedInsert`` : 给定一个有序链表，将一个新节点插入到有序链表的正确位置；

7\. ``InsertSort`` : 使用插入排序法为链表排序；

提示：之前实现的 ``SortedInsert`` 有用了：）

8\. ``Append`` : 挂接两个链表；

9\. ``FrontBackSplit`` : 将一个链表分割成大小相等的两个链表（对于原链表大小为奇数的情况，分割为大小只相差 1 的两个链表）；

10\. ``RemoveDuplicates`` : 给定一个有序链表，其中含有重复节点，删除链表中的重复节点，使得每个不同值的节点只有一个；

11\. ``MoveNode`` : 给定两个链表，``Pop`` 出第二个链表的元素，``Push`` 进第一个链表；

注意：这里的 ``Pop`` 和 ``Push`` 可以根据实际场景使用 4. 中的任意一组定义

12\. ``AlternatingSplit`` : 给定一个链表，将他分割成两个链表，其中奇数位置的节点在一个链表，偶数位置的节点在另一个链表；

提示：之前实现的 ``MoveNode`` 有用了：）

13\. ``ShuffleMerge`` : 给定两个链表，将这两个链表合并成一个链表，其中一个链表的元素在奇数位，另一个链表的元素在偶数位；

提示：之前实现的 ``MoveNode`` 有用了：）

14\. ``SortedMerge`` : 给定两个有序链表，将他们合并成为一个有序链表；

提示：之前实现的 ``MoveNode`` 有用了：）

注意，对于这个需求，看完下一章归并排序后再回头来做，可能更有感觉：）

15\. ``MergeSort`` : 对链表进行归并排序

注意：关于归并排序，下一章会进行详细介绍。看完下一章后，可以再回头来解决这个问题：）

提示：实现了 ``FrontBackSplit`` 和 ``SortedMerge`` 后，应该觉得这个问题并不难：）

16\. ``SortedIntersect`` : 给定两个有序链表，返回一个新链表，新链表中的元素是给定两个链表的公共元素。

提示：以这个方法为基础，可以封装基于链表的集合类。关于集合的介绍，大家在后续讲解二分搜索树的时候，会详细了解。可以届时再回头来看这个问题：）

17\. ``Reverse`` : 反转一个链表

18\. ``RecursiveReverse`` : 使用递归的方式反转一个链表

最后特意将递归方式翻转链表列出来，是因为这个问题实在是太经典了，充分体现了和链表相关算法的美丽。在下一章，是关于链表问题的一个习题章节，届时，我会仔细介绍一下反转链表这个经典问题：）

<br/>

**大家加油！：）**
