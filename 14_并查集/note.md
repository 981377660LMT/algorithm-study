并查集关键词：连通分量、无向图、分组、距离的`传递性`、给定一个无向图可能是不连通的(暗示需要找到所有的连通分量)

<!-- 解决连接问题于路径问题 -->
<!-- 两点之间是否可以通过路径连接起来？ -->
<!-- 哪些点属于同一个集合？ -->
<!-- 网络中node的连接状态 -->

“是否存在一条从入口到出口的路径”，那么这就是一个简单的联通问题
并查集还可以在人工智能中用作图像人脸识别。比如将同一个人的不同角度，不同表情的面部数据进行联通。这样就可以很容易地回答两张图片是否是同一个人，无论拍摄角度和面部表情如何。
并查集只能回答“联通与否”，而不能回答诸如“具体的联通路径是什么”

并查集（Union-find Algorithm）定义了两个用于此数据结构的操作：
Find：确定元素属于哪一个子集。它可以被用来确定两个元素是否属于同一子集。
Union：将两个子集合并成同一个集合。

```Python
检测无向图中是否有环
uf = UF()
for a, b in edges:
    if uf.connected(a, b): return False
    uf.union(a, b)
return True
```

主要 API connected 和 union 中的复杂度都是 find 函数造成的，所以说它们的**复杂度和 find 一样**。
find 主要功能就是从某个节点向上遍历到树根，其时间复杂度就是树的高度
问题的关键在于，如何想办法避免树的不平衡

优化:

1. 平衡性优化:rank 优化(小一些的树接到大一些的树下面，这样就能避免头重脚轻，更平衡一些)
   加一个权重数组：通过比较树的重量，就可以保证树的生长相对平衡而不会退化成链表，树的高度大致在 logN 这个数量级

2. 路径压缩(**非常关键!!!**)：进一步压缩每棵树的高度，使树高始终保持为常数,使得 union 和 connected API 时间复杂度接近 O(1)。
   ```JS
   const find = (val: number) => {
   while (parent[val] !== val) {
     parent[val] = parent[parent[val]] // 这一句进行路径压缩
     val = parent[val]
   }
   return val
   }
   ```
   优化后高度不超过 3

---

并查集是一棵树
如果需要定向合并(即 union(a,b)要保证 a 是 b 的父结点,`不能使用按秩合并(会swap)`,此时必须使用路径压缩)

---

https://github.com/EndlessCheng/codeforces-go/blob/ff168d8e767e1d09ce47b4107d5c2e511b8bf41d/copypasta/union_find.go#L1
只有路径压缩的并查集复杂度是 O(nlogn) 的，这也是大多数情况下的实现方案
只有启发式合并（按深度合并）的并查集的复杂度也是 O(nlogn) 的，适用于可持久化的场景
