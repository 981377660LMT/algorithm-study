Bloom Filter 通过允许少量的错误来节省大量的存储空间
`典型的时间换空间`

1. 什么是布隆过滤器？
   我们可以把它看作由二进制向量（或者说位数组）和一系列随机映射函数（哈希函数）两部分组成的数据结构。
   位数组中的每个元素都只占用 `1 bit` ，并且每个元素只能是 0 或者 1。这样申请一个 100w 个元素的位数组只占用 1000000Bit / 8 = 125000 Byte = 125000/1024 kb ≈ 122kb 的空间。
   总结：**一个名叫 Bloom 的人提出了一种来检索元素是否在给定大集合中的数据结构，这种数据结构是高效且性能很好的，但缺点是具有一定的错误识别率和删除难度。并且，理论情况下，添加到集合中的元素越多，误报的可能性就越大。**
2. 布隆过滤器的原理介绍。
   `当一个元素加入布隆过滤器中的时候，会进行如下操作：`

   1. 使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。
   2. 根据得到的哈希值，在位数组中把对应下标的值置为 1。

   `当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行如下操作：`

   1. 对给定元素再次进行相同的哈希计算；
   2. 得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。

   综上，我们可以得出：`布隆过滤器说某个元素存在，小概率会误判,即他不一定存在。布隆过滤器说某个元素不在，那么这个元素一定不在。`

3. 布隆过滤器使用场景。
   1. 判断给定数据是否存在：比如判断一个数字是否存在于包含大量数字的数字集中（数字集很大，5 亿以上！,`不能用集合`）、 防止缓存穿透（判断请求的数据是否有效避免直接绕过缓存请求数据库）等等、`邮箱的垃圾邮件过滤`、黑名单功能等等。
   2. 去重：比如爬给定网址的时候对已经爬取过的 URL 去重。(`只会少爬，不会多爬`)
4. 通过 Java 编程手动实现布隆过滤器。
5. 利用 Google 开源的 Guava 中自带的布隆过滤器。
6. Redis 中的布隆过滤器。
7. 为什么需要多个 hash 函数映射？为什么不能使用一个 hash 函数映射就好？
   hash 函数作用中有一个作用：把无限的数据映射到元素有限的集合中来，这里面就存在`多个元素映射到集合中的同一个元素的可能性`。为了避免这种情况的发生，所以使用多个 hash 函数进行映射`降低这种可能性的发生概率`，但不能绝对避免此问题，因为避免不了。
   (一次偶然容易发生,k 次偶然几乎不可能同时发生)
   哈希函数选择:
   `k=m/n*Ln2`
