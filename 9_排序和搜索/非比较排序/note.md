https://zhuanlan.zhihu.com/p/75575670

主要应用于字符串排序
非比较排序只要确定每个元素之前的已有的元素个数即可，遍历一次就能求解。算法时间复杂度 O(n)

计数排序需要占用大量空间，它仅适用于数据比较集中的情况。比如 [0~100]，[10000~19999] 这样的数据。
稳定性:**计数排序是稳定的**
计数排序其实是桶排序的一种特殊情况。
当要排序的 n 个数据，**所处的范围并不大**的时候，比如最大值是 k，我们就可以把数据划分成 k 个桶。每个桶内的数据值都是相同的，省掉了桶内排序的时间。

如何根据年龄给 100 万用户排序(桶排序) ？
**桶排序**是计数排序的升级版，也采用了分治思想。
最佳情况：当输入的数据可以均匀的分配到每一个桶中。 最差情况：当输入的数据被分配到了同一个桶中。
桶排序比较适合用在外部排序中
外部排序就是数据存储在外部磁盘且数据量大，但内存有限，无法将整个数据全部加载到内存中

假设我们有 10 万个手机号码，希望将这 10 万个手机号码从小到大排序
**基数排序**是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较
按照优先从高位或低位来排序有两种实现方案:
MSD：由高位为基底从高位开始进行排序
LSD：由低位为基底从低位开始进行排序

这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：
基数排序：根据键值的每位数字来分配桶
计数排序：每个桶只存储单一键值
桶排序：每个桶存储一定范围的数值

| 排序     | 平均复杂度 | 稳定性               |
| -------- | ---------- | -------------------- |
| 计数排序 | O(n+k)     | 是                   |
| 桶排序   | O(n+k)     | 取决于桶排序内部算法 |
| 基数排序 | O(n\*k)    | 是                   |

如果有海量的手机号数据需要保存，但机器的性能有限，如何才能尽可能少的`占用内存？`

1. 大文本去重最优的数据结构应该是使用 Bitmap，
   Bitset 一个号码对应 1bit
   中国的手机号全部是 1 开头，目前启用了 18、17、15、14、13 几个号码段，甚至可以细分到 3 位，但为了简便，以及考虑到未来号码扩展，我们简略的直接只忽略 1 的开头，用 Bitmap 来表示全部号码是否存在只需要占用 9,999,999,999 个 bit 位也就是 1,249,999,999.875 约等于 1,250,000,000 个字节 = 1.164g 的空间！

2. 通过对号码进行`基数排序`，然后使每一个手机号减去最小的手机号得到一个差值，作为偏移，这样的话我们只需要记住最小的手机号和后面每个手机的偏移就可以了，
