# 更快的 SortedlistPlus

https://leetcode.cn/circle/discuss/cHbHhG/

## 问题、目标

一般的 SortedList 一言不合就重构线段树(树状数组)，重构复杂度较大，为 $O(n/load^2)$。
SortedListPlus 优化了重构过程。

## 1. 整体思路：在“块”与“树状数组”之间再次分层

### 1.1 为什么需要“分块 + 树状数组”？

- 一个**SortedList**（如 Python `sortedcontainers` 中的 `SortedList`）通常基于“分块”+“平衡树”/“树状数组（Fenwick Tree）”等结构来维持有序序列，以支持以下操作：
  1. **在有序序列中插入/删除**元素；
  2. **按值查找 rank**（即元素的有序排名）；
  3. **按 rank 找到元素**（即找第 k 大元素）。
- 若仅简单地把所有元素打散到“块”中，而块的合并/分裂涉及大规模移动，就容易导致在极端场景下开销变大。
- 为此，文中在“块”之上再增加一层“树状数组”来管理块的分布，并引入两级负载因子 \(\text{load}\_1\) 和 \(\text{load}\_2\)，以**分层分段**地管理块的增删、移动与合并/分裂，从而**摊薄**了复杂度。

### 1.2 核心结构示意

- **小块**：每个小块最多容纳 \(\text{load}\_1\) 个元素；若超过 \(2\text{load}\_1\)，就分裂为两个大小为 \(\text{load}\_1\) 的小块。
- **段（小段）**：在“树状数组”层面，每个节点对应一个“小段”，它包含若干个小块（最多 \(\text{load}\_2\) 个非空小块）。若一个小段超过 \(2\text{load}\_2\) 个非空小块，就分裂成两个小段。
- **树状数组（Fenwick Tree）**：用来维护“每个小段中小块数量的前缀和”或“每个小段中元素总数的前缀和”等信息，方便做 rank 查询和分段二分。

这样，大规模的重构只会在“需要时”才触发（如段分裂或全局重构），并且由于增加了空白小块、小段的预留空间，可以让大部分插入只发生在“当前小块/小段内部”的局部区域内，不影响其它块/段，从而把分裂、合并等操作的摊销降到较低水平。

---

## 2. 关键参数：\(\text{load}\_1\) 与 \(\text{load}\_2\)

1. \(\text{load}\_1\)：**每个小块的负载因子**，控制单个小块能容纳多少元素。

   - 如果块内元素数超过 \(2\text{load}\_1\)，就进行分裂（分成两个大小各为 \(\text{load}\_1\) 的小块）。
   - 若块内元素数降为 0，则删除这个块。

2. \(\text{load}\_2\)：**每个“小段”所能容纳的小块数的负载因子**。

   - 如果一个小段内的非空小块数超过 \(2\text{load}\_2\)，就分裂成两个小段；
   - 如果小段内的非空小块数降为 0，则删除小段。

3. 在最外层，所有小段一起由一个 Fenwick Tree（或者说树状数组）管理，这个树状数组本身也有“分段”、“重构”的机制，以保证访问与更新不退化到线性时间。

文中最终取  
\[
\text{load}\_1 = n^{1/5}, \quad \text{load}\_2 = n^{2/5},
\]  
从而达成  
\[
O\bigl(n^{1/5} + \log n\bigr)
\]  
的综合复杂度。

---

## 3. 数据结构的几个核心操作

### 3.1 在块内进行插入/删除

- **块内平移**：若要在块内的某个位置插入元素，需要将插入位置右侧的若干元素向后平移；删除元素时则需要向前平移。
- 若一个块大小上限为 \(\text{load}\_1\)，在最坏情况下，一次插入/删除也仅平移 \(\text{O}(\text{load}\_1)\) 的元素。

### 3.2 块的分裂/合并

- 当块内元素个数超过 \(2 \times \text{load}\_1\) 时，分裂成两个块，各含 \(\text{load}\_1\) 元素；
- 当块内元素数目降为 0，则删除这个块；
- 由于只有在块“极度超载”或“极度空置”时才触发分裂或删除，平时大部分插入/删除都不会波及到块分裂。

### 3.3 小段重构

- 在 Fenwick Tree 的某一个段（小段）中，如果小块数超过 \(2\text{load}\_2\)（或变为 0），就会将该小段一分为二（或删除）。这需要：
  1. 收集本段内所有非空小块；
  2. 平分到两个小段或完全删除该段；
  3. 更新 Fenwick Tree 对应节点的信息（前缀和等）。
- **每个段的重构成本**主要是 \(\text{O}(\text{load}\_2)\) 量级，因为重构只需对段内的小块做重新分配和 Fenwick Tree 的局部更新。

### 3.4 全局 Fenwick Tree 重构

- 当有小段分裂，可能引起 Fenwick Tree 上对段节点的索引结构调整，甚至会触发**全局重构**。
- 全局重构时，会把所有非空小块收集起来，按照每 \(\text{load}\_2\) 个小块分配给一个小段，并在每个小段后面预留一些空块位置，方便局部插入。
- 虽然一次全局重构的代价可以是 \(\text{O}(n/\text{load}\_1)\) 级别（因为有 \(n/\text{load}\_1\) 个小块），但它并不会频繁触发，从而在均摊意义下依然保持较低的摊销。

---

## 4. 复杂度分析核心

在文中，作者对几个关键操作进行了详细的均摊分析。我们摘取重点如下：

1. **块内插入/删除**的平移：

   - 一次操作 \(\text{O}(\text{load}\_1)\)。
   - 不会大范围发生，只在单个块内。

2. **分裂/合并块**导致的小段重构：

   - 一次分裂会引发一次段的重构，其代价 \(\text{O}(\text{load}\_2)\)。
   - 每当块的元素数目增加到 \(2\text{load}\_1\)，才会分裂一次；所以在**平均每插入 \(\text{load}\_1\) 个元素**的过程中，会发生一次这样的分裂，对应一次 \(\text{O}(\text{load}\_2)\) 的段重构，均摊到每次插入就变为  
     \[
     O\Bigl(\frac{\text{load}\_2}{\text{load}\_1}\Bigr).
     \]

3. **段的分裂/合并导致的全局重构**：

   - 当某小段超载（达到 \(2\text{load}\_2\) 个非空块）或变空，就对Fenwick Tree做局部更新，若导致 Fenwick Tree 超过阈值，再进行全局重构。
   - 全局重构成本为 \(\text{O}(\frac{n}{\text{load}\_1})\)，但只有当小段分裂到无法容纳新的段节点时才会出现，频率很低。
   - 由于每次段分裂都需要**累计** \(\text{load}\_2\) 次块分裂才会发生，进一步摊销后得到一个  
     \[
     O\Bigl(\frac{n}{\text{load}\_1} \cdot \frac{1}{\text{load}\_2}\Bigr)
     \]
     的均摊代价（原文更具体地推导出 \(\text{O}\bigl(\frac{n}{\text{load}\_1} \cdot \text{load}\_1 \cdot \text{load}\_1 \cdot \text{load}\_2\bigr)\) 等式，最终在合适选取 \(\text{load}\_1, \text{load}\_2\) 时约化为所需量级）。

4. **查找与二分**：
   - 为了查找“某元素 x 在哪个块”，或者“块内哪个下标”，需要先在段层面做二分，确定所在段，再在段内的非空块之间二分，最后在块内做二分。
   - 若段数目约为 \(\frac{n}{\text{load}\_1\cdot \text{load}\_2}\)，段间二分是 \(\log\bigl(\tfrac{n}{\text{load}\_1\cdot \text{load}\_2}\bigr)\)；小段内小块最多 \(\text{load}\_2\) 个，块大小最多 \(\text{load}\_1\)。在合理选取 \(\text{load}\_1\) 与 \(\text{load}\_2\) 后，总体上仍是 \(\text{O}(\log n)\)。
   - 或者利用“最大元素的 Fenwick Tree”（即 `blockMax`）再做二分，也能达到 \(\text{O}(\log n)\)。

综合起来，当取  
\[
\text{load}\_1 = n^{1/5}, \quad
\text{load}\_2 = n^{2/5},
\]  
那么各项加和得到  
\[
O\bigl(\text{load}\_1\bigr)

- O\Bigl(\tfrac{\text{load}\_2}{\text{load}\_1}\Bigr)
- O\Bigl(\tfrac{n}{\text{load}\_1}\cdot \dots \Bigr)
- O(\log n)
  \quad\approx\quad
  O\bigl(n^{1/5} + \log n\bigr).
  \]  
  最终证明插入、删除、rank 查询等操作能够在**平均**（均摊）意义下实现  
  \[
  O\bigl(n^{1/5} + \log n\bigr).
  \]

---

## 5. 关键细节与直观理解

1. **“留空”小块、小段以摊销重构：**

   - 每次分裂小段时，系统会额外留出一些空小块，让后续插入在本段内即可完成，不需要立刻影响别的段。
   - 这类似常见“分块”结构中的“分裂时额外留空间”思想，避免频繁的块合并/分裂。

2. **Fenwick Tree（树状数组）管理小段**：

   - Fenwick Tree 可快速维护“前缀和”，从而在 \(\text{O}(\log(\text{段数}))\) 时间内定位某个 rank 对应的段或小块，也能快速更新小段的元素数量变化。
   - Fenwick Tree 本身也可能在极少数情况做全局重构，但在大 \(n\) 下能被摊销到很低。

3. **均摊思想**：
   - 以上各种分裂/合并/重构都不是“每次操作都会发生”，而是**当块或段的负载极度超标/不足**时才触发；
   - 通过分层管理（\(\text{load}\_1\) 与 \(\text{load}\_2\)）+ 预留空间的做法，把重构操作的触发频率大幅降低，故平均下来复杂度更好。

---

## 6. 与传统数据结构的对比

- **简单分块**：若只对序列分块，每块大小 \(\approx \text{B}\) 而无额外 Fenwick Tree 层，插入/删除均摊 \(\text{O}(\text{B})\)，查找可在块间二分到 \(\text{O}(\log(\tfrac{n}{B}))\)。但当要维护 rank 查询/更新前缀和等时，往往需要昂贵的全局移动或复杂的辅助索引。
- **平衡树（如 AVL、红黑树等）**：每次插入或删除 \(\text{O}(\log n)\)，能很快做 rank 查询。但常数因子较大，实际工程中有时不及分块结构对于顺序局部操作的效率。
- **sortedcontainers.SortedList**：内部也采用“分块+树”模式，其核心维护类似带**分块的平衡树**，分裂/合并在工程实现中比较精巧，实际常数因子可能更大，但可保证较好的最坏情况 \(\log n\)（或 \(\log^2 n\)）级别。

“sortedlistPlus”则在分块结构上加入 Fenwick Tree，多一层分块管理（\(\text{load}\_2\)）和**分段留空**策略，使得整体能够以**较好的摊销代价**应对大规模插入/删除。在理论上达成  
\[
O\bigl(n^{1/5} + \log n\bigr),
\]  
在工程实践中若实现得当，也可获得不俗的性能表现。

---

## 7. 小结

1. **核心思路**：

   - 将序列分成若干“小块”，再将“小块”按组划为“小段”，最后用 Fenwick Tree 维护每个小段的统计信息（块数 / 元素数）。
   - 使用双层负载因子 \(\text{load}\_1, \text{load}\_2\) 来控制块和段的分裂/合并时机，并在分裂时留出空余位置，以摊薄重构的频率。

2. **复杂度源头**：

   - 块内插入/删除平移：\(\text{O}(\text{load}\_1)\)。
   - 块分裂时段重构：\(\text{O}(\text{load}\_2)\) 摊销后 \(\text{O}(\text{load}\_2 / \text{load}\_1)\)。
   - 全局重构：\(\text{O}(n/\text{load}\_1)\) 但不常触发，继续摊销后降低影响。
   - 查找/二分：\(\text{O}(\log n)\)，在层次化后仍可保持对数级访问。

3. **最终收敛**：
   - 通过在不同层面分配合适的负载因子，令 \(\text{load}\_1 = n^{1/5}, \text{load}\_2 = n^{2/5}\)，综合各项摊销复杂度后，得到  
     \[
     O\bigl(n^{1/5} + \log n\bigr).
     \]

因此，“sortedlistPlus” 在理论上能以较优的平均复杂度完成插入、删除、查找等操作，为在 Python `sortedcontainers` 或类似库的基础上进一步优化提供了一种**可行的思路**。这其中的**关键**就在于利用多层次的“块+段+树状数组”管理，并**分级预留空间**使得大规模重构不会频繁触发，从而实现低摊销的时间复杂度。
