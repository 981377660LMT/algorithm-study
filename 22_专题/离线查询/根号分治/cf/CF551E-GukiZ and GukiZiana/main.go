// https://codeforces.com/problemset/problem/551/E
//
// 输入 n(1≤n≤5e5) q(1≤q≤5e4) 和长为 n 的数组 a(1≤a[i]≤1e9)。
//
// 然后输入 q 个询问，格式如下：
// "1 L R x"：把下标在闭区间 [L,R] 中的 a[i] 都增加 x(0≤x≤1e9)。注：a 的下标从 1 开始。
// "2 y"：设 i 和 j 为元素 y(1≤y≤1e9) 在 a 中的最左下标和最右下标，输出 j-i。如果 a 中没有 y，输出 -1。
//
// 注：本题时间限制为 10s。
//
// 这种涉及精确元素位置+带修的题目，很难用线段树维护。由于本题给了 10s 时限，考虑分块。
// 把 a 分成若干段（块）。
//
// 每一块需要维护哪些信息？
// 有区间加，需要一个 lazy tag，表示这个块整体增加的值。（类似线段树）
// 需要知道区间中的每个数的最左位置和最右位置，用哈希表维护。
//
// 区间加：
// 块被 [L,R] 完全覆盖时，只把 lazy tag 增加 x。
// !块被 [L,R] 部分覆盖时（最多有两个这样的块），暴力更新区间中的每个数（注意应用 lazy tag），然后重置 lazy tag = 0，重新计算块中每个数的最左位置和最右位置。
//
// 查询：
// 正着遍历块，找最左位置。找到就退出循环。
// 倒着遍历块，找最右位置。找到就退出循环。
//
// 注：Go1.22 推荐块大小为 sqrt(n/5)，比 sqrt(n) 快一倍。

package main

func main() {

}
