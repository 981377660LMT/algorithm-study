https://www.cnblogs.com/IzayoiMiku/p/14691521.html
https://www.luogu.com.cn/blog/gxy001/shu-fen-kuai-xue-xi-bi-ji
https://www.cnblogs.com/hua-dong/p/8275227.html

大部分时候，树上问题是由树剖，LCT，树分治来解决。但在某些情况下(比如你根本想不到这玩意该怎么搞的时候，或者有时数据宽松)，树分块也是一种选择。
和序列分块一样，树分块也是一种暴力。大致思想仍是将将树按“某种思路”划分进数个块中，然后维护块内整体信息的算法。
根据不同的题目，“某种思路”各不相同。一般情况下，树分块**在处理树的路径等具有联通性质问题**的时候表现强劲。

树上的有些问题是可以用树剖或者动态树解决的，但是他们有一个动同点就是：**不连通。**
比如求 u 到 v 的路径权值和，或者最大值：
u 到 v 可能对应了多个链，这多个链在对应的数据结构（假设是线段树）上面对应不同的区间。但是线段树上这几个区间的不连续并不影响我们得到答案。(当然求子树的信息话是连续区间)
那么如果我们遇到的问题要求区间连续呢，`比如求 u 到 v 的路径上点的权值有多少种`？如果不连续就得处理链与链之间的关系。**显然这些点得待在一起，如果树剖很难维护链与链之间的关系。**

---

`王室联邦树分块法(基于连通性的树分块)`：
分块方式:满足每块大小在 [B,3B]，块内每个点到核心点路径上的所有点都在块内(`除开核心点`，核心点可以在块内也可以在块外).
**但是不保证每个块都是连通的.**这样分块是为了莫队的排序，而不是预处理保存信息。

`树上撒点树分块法`：
设置一个阈值 S，随机找 n/S 个关键点，使得每个关键点到离它最近的祖先关键点的距离不超过 S。对于所有点找到它的第一个关键祖先，将它和关键祖先分为一块。
**可以保证块联通，期望直径长度为 S，块大小为 n/S，但是常数较大。**

`基于深度的树分块`
![https://www.zhihu.com/question/60674478/answer/178873326](image.png)

在 2013 年的某篇有关分块介绍了这样一种：**设 H=int(sqrt(n))，如果 i 的深度是 H 的倍数且 i 子树大小不小于 H，那么就把 i 标记为关键点。可以证明这样也有总数 sqrt(n)和路径上 2sqrt(n)就至少碰到一个的性质。**

`clj的按dfs序添加的块状树`
TODO:hqrture
按 dfs 序添加的块状树，那个好处是每块都不大，可以每次整块修改/重构/合并拆分之类的

---

树分块

考虑每个节点，让它有 1/ sqrt n 的概率成为“关键点”。
那么就有下面两条性质：

1. 树上期望有 sqrt n 个关键点。
2. 一个点往上跳 sqrt n 步，期望有一个关键点。（推广：长度为 sqrt n 的路径上期望有一个关键点）

那么便有：一个点跳到根节点，最多期望走过 sqrt(n)个关键点。
这个方法的意义是，使得序列上的分块也可以推广到树上。
给定一棵树，初始时所有的边权都是 1。要求处理下面的操作：把某条边的边权改为 0（每条边只会被改一次）求根到某个点的路径的边权和。定义 top[x]为距 x 最近的祖先关键点。我们记录 blo[x]，表示 x 号关键点到 top[x]这一段区间的权值和。
另外，预处理出 att[x][i]。如果 att[x][i]==1，则表示修改 i 会影响到 blo[x]的答案。这一步复杂度 O(nn)O(n \sqrt n)O(n \sqrt n) 。修改操作：考虑所有的关键点，如果修改的点对关键点 x 造成影响，则修改 blo[x]。期望 O(n)O(\sqrt n)O(\sqrt n) 。询问操作：先暴力往上跳，跳到关键点后不停地往 top 跳。 期望 O(n)O(\sqrt n)O(\sqrt n) 。这样，整个题就 O(nn)O(n\sqrt n)O(n\sqrt n) 解决了。这个分块方法也可以处理路径权值和之类的各种问题。一般来说序列上可分块做的，
