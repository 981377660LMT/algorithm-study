# 一类撤销问题

https://taodaling.github.io/blog/2020/10/11/%E4%B8%80%E7%B1%BB%E6%92%A4%E9%94%80%E9%97%AE%E9%A2%98/

## 撤销的实现方式

如果一个操作对整体的改动很小，那么我们可以记录这个操作执行后的修改，并记录在案，之后就可以很方便的撤销这些修改。
比如所我们某个操作将 x 改变为 x+1，那么我们只需要**记录这个操作**信息，之后在撤销的时候将 x 改变为 x−1 即可。
但是不是所有操作都可以通过仅记录操作信息就能撤销的，比如 chmin 操作，将某个变量 x 修改为 min(x,5)，这样我们就不能简单的撤销这样的操作了。
更加好用的方式是**记录变量被修改前的状态**，比如 x=x0，这样就能保证对任何操作都能执行撤销。

## 栈式撤销(StackAggregation，在线)

撤销操作一般都需要栈式操作，即先完成的操作后撤销。
这是非常重要的，因为后完成的操作可能**依赖于**先完成的操作带来的修改。
比如创建对象，我们先创建一个对象 A，之后创建一个对象 B，并且 B 持有 A。
如果我们先撤销创建 A 这个操作，即销毁 A，那么会导致销毁 B 的时候 A 已经不可用了。
**栈式撤销是非常自然的，比如在树上进行 DFS 操作。**
于是在操作的时候我们每次函数返回后，所有的**局部变量都会被销毁，而调用者的变量会恢复**。

## 队列撤销 (QueueAggregation，在线)

[[Tutorial] Supporting Queue-like Undoing on DS](https://codeforces.com/blog/entry/83467)
最自然的撤销方式是栈式的，但是题目要求你**先撤销最旧的操作**.例如定长滑动窗口.可以通过栈式撤销来实现队列撤销。如果操作满足交换性（即操作的执行顺序不影响结果），那么答案是可以的。

https://codeforces.com/contest/1386/problem/C
https://codeforces.com/contest/1423/problem/H

## 优先队列撤销 (PriorityQueueAggregation，在线)

[[Tutorial] Supporting Priority-Queue-like Undoing on DS](https://codeforces.com/blog/entry/111117)
在实际情况下队列撤销并不是很使用，因为大部分情况，撤销操作都是乱序的。
如果我们能**提前知道撤销操作的发生的顺序**，那么就可以利用优先队列撤销来解决。

优先队列撤销是指我们要维护一个优先队列，所有的操作都带有优先级。优先队列支持两类行为：

- 应用某个操作
- 撤销优先级最高的操作

## 非顺序撤销(线段树分治，离线)

一组操作，如果它既不是栈式，也不是队列撤销的话该怎么办。
线段树分治.

给定 n 个物品，第 i 件物品的价值为 vi，重量为 wi。之后考虑 q
个请求。每个请求要么新增一个物品，要么删除一个物品，要么查询容量为 k 的背包最大能装走的物品总价值。其中 1≤n,1≤k≤103。
https://codeforces.com/contest/601/problem/E
