事实上，我们能从「边」的角度来确定一个子矩阵，通过枚举三条边，然后加速找第四条边的过程，这样可以将复杂度降到 O(n^3)

这个分析思路在 （题解）363. 矩形区域不超过 K 的最大数值和 详细讲过，没有印象的同学可以翻翻。这道题一定程度上是那道题的简化版，在本题我们只需要找到矩阵和为 target 的值，因此只需要使用「哈希表」来记录出现过的值即可，而在 （原题）363. 矩形区域不超过 K 的最大数值和 中，我们需要找到和不超过 kk 的最大子矩阵，因此还涉及「有序集合 + 二分」。

具体的，我们仍然需要先预处理出一个二维前缀和。然后通过枚举确定「子矩阵的上下边界」，在将「子矩阵右边界」不断右移的过程中，把「子矩阵右边界」到「原矩阵左边界」行程的矩阵和存入哈希表（因为要统计数量，存储格式为 {"面积”:"出现次数"} ），然后通过容斥原理来找到目标的「子矩阵左边界」。

时间复杂度
进阶：如果行数远大于列数，该如何设计解决方案？
我们可以将行列兑换 复杂度为 O(m\*n^2)
空间复杂度
我们可以将计算前缀和的逻辑下放到搜索子矩阵的循环里去做，
从而将 O(m \_ n)O(m∗n) 的空间复杂度下降到 O(\max(m,n))O(max(m,n))。

模板

```JS
  const m = matrix.length
  const n = matrix[0].length
  const pre = Array.from<any, number[]>({ length: m + 1 }, () => Array(n + 1).fill(0))
  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      pre[i][j] = matrix[i - 1][j - 1] + pre[i - 1][j] + pre[i][j - 1] - pre[i - 1][j - 1]
    }
  }

  // 固定上下
  for (let top = 1; top <= m; top++) {
    for (let bottom = top; bottom <= m; bottom++) {
      // ...准备工作，思路与一维时相同
      // 遍历子矩阵的右边界
      for (let right = 1; right <= n; right++) {
        const sum = pre[bottom][right] - pre[top - 1][right]
        // ...主要逻辑
      }
    }
  }

  return res
```
