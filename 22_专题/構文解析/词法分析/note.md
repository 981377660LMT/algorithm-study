# 聊聊编译原理（一） - 词法分析

https://www.nosuchfield.com/2017/07/16/Talk-about-compilation-principles-1/

> 编译器（Compiler），是一种计算机程序，它会将用某种编程语言写成的源代码（原始语言），转换成另一种编程语言（目标语言）。—— 维基百科

把实现编译器过程中所用到的策略与方法总结起来，这就是编译原理，其主要包含了编译器的构造与优化。

一般来说编译器的内部包含了如下的工作步骤：

- 编译器前端：

1. 词法分析；

把输入的程序源代码字符流转化为记号（Token）流

词法分析的实现主要有两种方式：

- 使用词法分析器生成器（JavaCC、Lex 等）-> 根据给定的规则把输入构建成 Token 并输出
- 手工编码构造词法分析器(手写词法分析器)

词法分析阶段会用到以下几个数学工具：

- 正则表达式（Regular Expression, RE）
- 非确定性有限状态自动机（NFA）
- 确定性有限状态自动机（DFA）
  ![Alt text](image.png)
  正则表达式 ->(Thompson 构造算法)-> NFA ->(子集构造算法)-> DFA ->(Hopcroft 算法)-> DFA 最小化 -> (DFA 结构解析)-> 词法分析器代码&读入字符流(利用二维数组对 DFA 结构进行描述,左侧表示当前状态，上方表示输入，框中表示转移结果,可以 bitset 节省空间) -> Token
  https://blog.51cto.com/lilongsy/5454692
  ![Thompson 构造算法三个规则：连接/选择/重复，中间需要添加虚拟节点](image-1.png)
  ![子集构造算法 bfs1](image-3.png)
  ![子集构造算法 bfs2](image-2.png)
  第一列第一行 I 的意思是从 NFA 的起始节点经过任意个 ε 所能到达的结点集合。Ia 表示从该集合开始经过一个 a 所能到达的集合，经过一个 a 的意思是可以略过前后的 ε。同样 Ib 也就是经过一个 b，可以略过前后任意个 ε。
  至于第二行以及后面的 I 是怎么确定的。我参考了一些题目才明白，原来就是看上面的 Ia 和 Ib 哪个还没出现在 I 列，就拿下来进行运算，该列对应的 Ia 和 Ib 就是前面我说的那样推导。
  ![最后的DFA,双圈的表示终态](image-4.png)
  ![最小化DFA:没有多余状态（死状态），没有冗余状态（没有两个状态互相等价）](image-5.png)

2. 语法分析；
3. 语义分析；
4. 生成中间表示（intermediate representation，IR）；
   IR 的目的在于保证编译器的跨平台，对于不同的平台，它们的 IR 表示是一样的，区别只在于代码生成和优化阶段。

- 编译器后端：

1. 代码生成；
2. 优化；

---

正则表达式可视化
https://regexper.com/#%28.%29

# 聊聊编译原理（二） - 语法分析

https://www.nosuchfield.com/2017/07/30/Talk-about-compilation-principles-2/
![语法分析流程](image-6.png)

# 聊聊编译原理（三） - 语义分析

符号表
