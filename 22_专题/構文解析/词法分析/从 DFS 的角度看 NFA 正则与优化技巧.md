# 从 DFS 视角看正则匹配

https://blog.rexskz.info/use-dfs-to-understand-nfa-regex-optimization.html
正则表达式可以高效的匹配字符串，正则会先被转换成 NFA，再被确定化为 DFA（这算法我现在还是能记住的），然后就可以用一个“与输入长度相关的线性时间复杂度”的算法来匹配了。
绝大部分语言自带的正则表达式引擎都是 NFA 而不是 DFA，因为它们都支持了 **Lookaround 之类的高级特性**，回溯也就成了绕不过去的一道坎。

## 总结

基于 NFA 的正则引擎由于支持了多种高级特性（非贪婪匹配、环视）而使用了**回溯**，也就造成了与 DFA 引擎相比性能的急剧下降。我们从深度优先搜索（DFS）的角度分析了回溯所需的时间复杂度，以及一些常见的优化方法在 DFS 中代表的技术。
CloudFlare 博客中引用的“线性时间的 NFA 匹配”，**看起来感觉就是 NFA 的确定化（DFA 化）**，但那些高级特性该如何确定化呢？甚至“环视”这个特性我都不确定能否在 DFA 中体现，因为可能会使用到之前输入的字符，这在 DFA 看来是不可能的。

## 一个暴力的正则

以一个简单但很暴力的正则为例：`.*.*=.*?`;，是不是感觉这个正则很眼熟？被你发现了，这就是导致 CloudFlare 宕机的元凶（的修改版本）。我们先将它分割为基本的元素：
`.*、.*、=、.*?、;`
对于 NFA 的正则引擎来说，如果发现了 `*` 这样的可以匹配“零次或多次”的量词，会优先匹配最长的模式，当失败时才会回退；但如果后面接了 ?（忽略优先量词），则会优先匹配最短的模式。

假设`字符串长度为 N，正则表达式中一共有 M 个 .*`，那么我们可以整理出一个匹配彻底失败（穷尽了所有可能性）时的递归式：

```py
dp[i][j] = dp[i+1][j] + dp[i][j+1] # (i是sIndex,j是ruleIndex)
```

相当于从棋盘的右下角开始，每次只能向左或向上移动，问有多少种走法可以到达左上角。这个问题的答案是组合数：

```py
dp[i][j] = C(i+j, i)
```

**当 M = 3 的时候，时间复杂度是输入字符串长度的三次方。**

## 一个惨绝人寰的正则

`(.*)*;`
时间复杂度 `(2^n)`

有个正则表达式可以用来判断一个全是 "1" 的字符串的长度是否是质数，它的其中一部分是 ^(11+?)\1+$，请分析一下这部分的时间复杂度。

提示一：括号后面的 \1 的意思是“匹配左起第一个括号匹配到的内容”；
提示二：这段正则的原理是经典的“试除法”，通过枚举除数来试除；
提示三：最终的答案不是指数级别，而是多项式级别。

## 优化方法

### 正则引擎自身的优化

1. 如果正则的开头是 ^，引擎会只从字符串开始进行尝试，`而不去尝试其它的位置`；
2. 如果正则的结尾是 `$` 并且没有 `+、*` 这种可以无限重复的量词，正则引擎会尝试从末尾的倒数若干字符进行尝试，例如 `rex(-zeng)?$` 最多匹配 8 个字符，因此引擎会从倒数第八个字符开始尝试；
3. 如果当前剩余的正则可以成功匹配的最小长度大于字符串的剩余长度，引擎会直接报告本次匹配失败；
4. 把连续的确定字符当作一个元素，例如 \srex\d 只有三个元素：\s、rex、\d；
5. 特判一些简单量词，例如 ._ 可以不用每次尝试匹配，而是直接使用倒序循环，每次用 O(1) 的时间匹配一定长度的字符串，._? 则可以使用正序循环；
6. 消除不必要的括号，例如 (?:a+)$ 可以被转换为 a+$，[a]+ 可以被转换为 a+。

站在 DFS 的角度来看，这几个优化中，1、2 属于减少搜索的初始状态，3 属于利用矛盾来提前剪枝，4 和 5 则是减少递归层数，6 则是一点常数优化。

### 开发者还是要从自身做起，多对正则本身进行优化

1. 使用更精确的元素和量词(针对某一节点的剪枝)
   毕竟 . 跟 \d 相比，后者只有十种情况能匹配，前者可能需要浪费非常多的尝试次数
2. 优化多选分支
   例如这个用来匹配域名的正则 \.(?:com|org|net|cn|me|info)\b，因为更多的域名是 .com 的，引擎在更多的情况下第一次尝试就可以匹配到结果。
   DFS 本身很少有类似的优化，但“为每个备选状态计算权重”正是 A\* 搜索的核心思想。与其不同的是，这儿的“权重”是人为指定的。
