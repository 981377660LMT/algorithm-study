https://swtch.com/~rsc/regexp/regexp1.html
好的，这是对《正则表达式匹配可以又简单又快》这篇文章的分析和讲解。

[一个数据团灭各种语言的正则表达式](https://leetcode.cn/problems/regular-expression-matching/solutions/2048018/huan-zai-tou-lan-yong-zheng-ze-biao-da-s-oe2a/)
主流编程语言(Python, Java) 用的是回溯算法，而 go 是 Thompson 算法，所以不会被卡，但是缺点是不支持反向引用。

### 核心论点

这篇文章的核心论点是：目前许多主流编程语言（如 Perl, Python, Java, Ruby）所使用的正则表达式引擎基于**回溯（Backtracking）**算法，这种算法在某些“病态”情况下性能极差，呈指数级下降。与之相对，存在一种基于**有穷自动机（Finite Automata）**的经典算法（Thompson NFA 模拟），其性能稳定且高效，在任何情况下都能保证线性时间复杂度。作者认为，现代语言应该采用或至少在不涉及`反向引用（backreferences）`时优先使用这种理论上更优的算法。

### 关键概念解析

1.  **正则表达式 (Regular Expression)**

    - 一种描述字符串集合的简洁表示法。
    - 基本操作符包括：连接（`ab`）、交替（`a|b`）和重复（`*`, `+`, `?`）。
    - 文章区分了“传统”正则表达式和带有**反向引用**（如 `\1`）的“现代”正则表达式。反向引用允许匹配前面捕获组完全相同的内容，这使得表达式不再是“正则”的，也是导致回溯算法难以被替代的主要原因。

2.  **有穷自动机 (Finite Automata, FA)**
    - 一种数学模型，也称为状态机，用于识别字符串。
    - **确定性有穷自动机 (DFA)**：在任何状态下，对于一个给定的输入字符，最多只有一个确定的转移状态。执行效率高，但从正则表达式直接构造 DFA 可能导致状态数量爆炸。
    - **非确定性有穷自动机 (NFA)**：在某个状态下，对于一个输入字符，可能存在多个转移状态，甚至允许不消耗字符的“空”转移。它能更紧凑地表示正则表达式。

### 两种匹配算法的对比

#### 1. 回溯法 (Backtracking)

- **工作原理**：当遇到选择（如 `|` 或 `?`）时，引擎会选择其中一条路径进行尝试。如果这条路最终无法匹配，引擎会“回溯”到上一个选择点，并尝试另一条路径。这本质上是对所有可能匹配路径的深度优先搜索。
- **优点**：
  - 实现相对简单。
  - 天然支持反向引用等高级功能。
- **缺点**：
  - **性能不稳定**：在最坏情况下，需要尝试的路径数量会随输入字符串长度呈指数级增长（`O(2^n)`）。文章中的 `a?ⁿaⁿ` 例子就是典型，引擎为了匹配，会尝试 `a?` 的所有 `2ⁿ` 种组合，导致灾难性的性能问题。

#### 2. Thompson NFA 模拟法

- **工作原理**：该算法不选择单一路径，而是同时维护一个“当前可能状态”的集合。每读入一个字符，它会计算出所有当前状态在接收该字符后能够到达的“下一组可能状态”。这本质上是对匹配状态的广度优先搜索。
- **优点**：
  - **性能稳定且高效**：无论正则表达式和输入字符串是什么，其运行时间都与输入字符串长度成正比（对于长度为 `m` 的正则和长度为 `n` 的文本，时间复杂度为 `O(m*n)`）。它只遍历输入字符串一次。
- **缺点**：
  - 实现比简单的回溯要复杂。
  - 处理子匹配（捕获组）和反向引用等高级功能需要更复杂的扩展。

### 算法实现与优化

文章通过 C 代码示例，清晰地展示了如何实现 Thompson 算法：

1.  **编译 (Parsing & Compiling)**：首先将中缀表示的正则表达式转换为后缀表示（逆波兰表达式），然后遍历后缀表达式，逐步构建出 NFA 的状态机结构。
2.  **模拟 (Simulation)**：通过维护两个列表（当前状态集 `clist` 和下一状态集 `nlist`），逐个字符地在输入串上“运行”NFA，不断更新状态集。
3.  **DFA 缓存优化**：NFA 模拟的每一步计算出的“状态集”本身就可以看作是一个 DFA 的状态。通过缓存这个“状态集 -> 下一状态集”的计算结果，可以实现一个“按需构建（on-the-fly）”的 DFA。这结合了 NFA 构造的简便性和 DFA 运行的高效性。

### 结论与启示

- **理论指导实践**：正则表达式是计算机科学理论（自动机理论）成功应用于实践的典范。然而，现代工具在某种程度上忽视了这些经典理论，导致了性能问题。
- **权衡与选择**：回溯引擎的流行很大程度上是因为它易于实现且能支持反向引用等强大功能。但作者指出，对于绝大多数不使用反向引用的场景，NFA/DFA 引擎是明显更优的选择。一个理想的引擎可以在检测到反向引用时切换到回溯模式，而在其他情况下使用高效的 NFA 算法。
- **不要被“病态”用例绑架**：虽然 `a?ⁿaⁿ` 这样的例子在日常工作中不常见，但它暴露了回溯算法固有的缺陷。类似的性能问题可能在更复杂的、不易察觉的正则表达式中出现，导致程序响应缓慢。而 NFA/DFA 算法则完全没有这种后顾之忧。

总而言之，这篇文章是一篇经典的檄文，它通过清晰的理论阐述、直观的性能对比和可运行的代码实现，有力地论证了基于有穷自动机的正则表达式引擎在性能和稳定性上的巨大优势，并呼吁业界重新审视和采纳这一经典技术。

---

好的，我们来进一步深入探讨这篇文章的几个关键方面。

### 1. 深入实现细节：Thompson 算法的精髓

文章中的 C 代码是理解其核心思想的关键。我们来剖析两个最重要的部分：NFA 的构建和模拟。

#### NFA 的构建：`Frag` 结构体与 `patch` 函数的魔力

回溯算法是一边解释正则表达式一边匹配，而 Thompson 算法是先将正则表达式**编译**成一个状态机，再用状态机去匹配。这个编译过程非常巧妙。

- **核心概念：片段 (`Frag`)**
  `Frag` 结构体代表一个不完整的 NFA 片段。它包含：

  1.  `State *start`: 片段的入口状态。
  2.  `Ptrlist *out`: 一个“悬空指针”列表。这些指针指向片段中尚未连接到任何后续状态的箭头。它们是片段的“出口”。

- **构建过程：像搭积木一样**
  编译器从左到右读取后缀表达式，利用一个栈来操作这些 `Frag` 片段：
  - **字符 `a`**：创建一个新的 `Frag`，包含一个表示 `a` 的状态，其悬空指针就是这个状态的出箭头。然后压入栈。
  - **连接 `.`** (例如 `ab`)：从栈中弹出 `b` 的 `Frag` (`e2`) 和 `a` 的 `Frag` (`e1`)。现在，关键的一步来了：使用 `patch(e1.out, e2.start)` 函数，将 `a` 的所有悬空箭头指向 `b` 的入口状态。这样 `a` 和 `b` 就连接起来了。新的 `Frag` 入口是 `a` 的入口，悬空指针列表则是 `b` 的悬空指针列表。
  - **交替 `|`** (例如 `a|b`)：弹出 `e2` 和 `e1`。创建一个新的 `Split` 状态。这个新状态有两个不消耗字符的出箭头，分别指向 `e1` 和 `e2` 的入口。新的 `Frag` 入口就是这个 `Split` 状态，其悬空指针列表是 `e1` 和 `e2` 悬空指针列表的**并集**。

这个过程优雅地将一个线性的正则表达式字符串，转换成了一个图状的状态机结构。

#### NFA 的模拟：`listid` 的巧妙优化

在模拟 NFA 时，我们需要维护一个当前可能状态的集合 `clist`。当从 `clist` 计算 `nlist`（下一状态集）时，一个核心操作是 `addstate`，它需要避免重复添加同一个状态到 `nlist` 中。

- **朴素方法**：每次添加状态前，遍历 `nlist` 检查它是否已存在。这会导致 `O(N²)` 的复杂度。
- **`listid` 优化**：文章中的实现非常聪明。
  1.  全局有一个 `listid` 计数器，每次 `step` (即处理一个输入字符) 开始时，`listid++`。
  2.  每个 `State` 结构体有一个 `lastlist` 字段。
  3.  当 `addstate(s)` 被调用时，它首先检查 `s->lastlist == listid`。
      - 如果相等，说明状态 `s` 在**当前这次 `step`** 中已经被添加过了，直接返回。
      - 如果不相等，说明是这次 `step` 中第一次遇到状态 `s`。于是，它将 `s->lastlist` 更新为当前的 `listid`，然后将 `s` 添加到列表中。

这个技巧将“检查状态是否已在列表中”这个操作的时间复杂度从线性扫描的 `O(N)` 降到了 `O(1)`，极大地提升了模拟效率。

### 2. 现实世界的挑战：为什么 NFA 方案未被广泛采纳？

文章提到，尽管 NFA 算法性能优越，但现实中的引擎（Perl, PCRE, Python 等）大多基于回溯。这背后有深刻的历史和技术原因。

#### 最大的障碍：子匹配（捕获组）提取

这是回溯法最引以为傲的优势。当使用 `/(...)(...)/` 这样的表达式时，我们不仅想知道整个字符串是否匹配，还想知道每个括号内具体匹配了哪部分子串。

- **回溯法如何实现**：非常简单。因为回溯法本质上是在尝试一条确定的路径，引擎只需要在进入和离开括号时，记录下当前在输入字符串中的位置（索引）即可。当找到一个完整的匹配后，这些记录下来的索引对就构成了所有捕获组的结果。

- **NFA 法的困境**：NFA 算法同时追踪所有可能的路径，它只知道“在处理到输入串的第 `k` 个字符时，我们可能处于状态集合 `{S1, S2, S5}` 中”，但它**丢失了到达这些状态的具体路径信息**。因此，它不知道状态 `S5` 是通过哪条路径、匹配了哪些字符才到达的，也就无法确定捕获组的边界。

- **NFA 法的解决方案（高级）**：虽然困难，但并非不可能。Rob Pike（文章中提到）和 Ville Laurikari 后来独立地提出了解决方案，通常被称为“带标签的 NFA (Tagged NFA)”。其思想是在 NFA 的状态转换中加入“标签”，用于记录捕获组的开始和结束。模拟过程变得更复杂，需要为每个并行的“路径”维护一个标签寄存器集合，但这仍然可以在不牺牲线性时间性能的前提下完成。只是其实现复杂度远高于简单的回溯法。

#### 其次的障碍：反向引用 (`Backreferences`)

- **什么是反向引用**：如 `(cat|dog)\1`，它要求 `\1` 匹配的内容必须和第一个捕获组 `(cat|dog)` **完全一样**。如果第一个组匹配了 "cat"，`\1` 就必须匹配 "cat"。
- **为什么 NFA 做不到**：这破坏了正则表达式的“正则”性。常规状态机是“无记忆”的，一个状态只关心下一个输入字符是什么，而不关心之前匹配了什么具体内容。反向引用要求引擎记住之前匹配的**具体字符串**，这超出了有穷自动机的能力范围。这个问题被证明是 NP 完全的，意味着不存在已知的多项式时间算法（像 NFA 那样）。
- **回溯法的天然支持**：回溯法因为记录了子匹配的具体内容，所以实现反向引用非常自然：当遇到 `\1` 时，只需将当前输入位置的子串与之前记录的第一个捕 over 组的内容进行比较即可。

### 3. 历史的偶然与必然

文章最后一部分的历史回顾揭示了一个有趣的故事：

1.  **正确的算法诞生很早**：Ken Thompson 在 1968 年就发表了 NFA 算法。`egrep` 等早期 Unix 工具也使用了高效的 DFA 算法。
2.  **“够用”的慢算法广为流传**：Henry Spencer 实现了一个回溯式的正则库并将其开源。由于其易于使用和移植，被大量项目采用，包括 Perl 的早期版本。
3.  **Perl 的巨大影响**：Perl 将正则表达式的能力（特别是反向引用和各种便捷写法）发扬光大，使其成为一门“艺术”。由于 Perl 的巨大成功，其基于回溯的引擎模型也随之成为事实上的标准，被 Python, PHP, Ruby, Java 等语言模仿。
4.  **高效算法被“遗忘”**：Rob Pike 在 80 年代为 `sam` 编辑器实现的高效带子匹配的 NFA 算法，在很长一段时间内没有引起广泛关注。

因此，当前众多语言采用回溯引擎，并非是不知道 NFA 算法的存在，而是历史、易用性、功能强大性（特别是反向引用）等多方面因素共同作用下的结果。

**总结**：深入理解这篇文章，我们不仅能学到两种算法的优劣，更能体会到理论与实践之间的鸿沟、历史的惯性以及工程上的权衡。一个“理论最优”的方案，可能因为实现复杂、无法支持某个“杀手级”功能（如反向引用）等原因，而在现实世界的竞争中输给一个“理论有缺陷但实践中够用且灵活”的方案。

---

## `golang的正则表达式是怎样的`

Golang 的正则表达式实现是一个非常有趣且典型的例子，因为它**直接采用了你刚刚阅读的文章中所倡导的理念和算法**。

Go 语言标准库 `regexp` 的主要作者正是那篇文章的作者 Russ Cox。因此，Go 的正则表达式引擎在设计上完全贯彻了他的思想，选择了性能优先的道路。

### 核心特点

总的来说，Golang 的正则表达式引擎具有以下几个鲜明的特点：

1.  **基于 RE2 语法标准**：它实现的不是 PCRE (Perl Compatible Regular Expressions)，而是 Google 开发的 **RE2** 引擎的语法。

2.  **算法：Thompson NFA / DFA**：底层实现正是基于文章中详细介绍的**非确定性有穷自动机 (NFA)**，并结合了 DFA 的缓存优化。

3.  **性能保证：线性时间复杂度**：这是它最核心的优势。无论你写的正则表达式多么复杂，其匹配时间都与输入文本的长度成线性关系。这意味着它**从根本上杜绝了回溯法可能导致的“灾难性回溯”和指数级性能爆炸**。你可以放心地将用户输入的正则表达式用于生产环境，而不必担心服务被一个“病态”的正则表达式拖垮。

4.  **功能上的权衡：不支持反向引用和环视**：为了保证线性的时间复杂度和避免 NP-Complete 问题，Go 的正则表达式引擎做出了一个关键的权衡：**不支持反向引用 (backreferences)**（如 `\1`）和**环视 (lookaround)**（如 `(?=...)`）。这正是文章中提到的，为了效率而放弃的“非正则”功能。

5.  **并发安全**：通过 `regexp.Compile()` 编译后得到的 `*regexp.Regexp` 对象是并发安全的，可以在多个 goroutine 中被安全地共享和使用，无需加锁。

### 与其他语言（如 Perl, Python）的对比

| 特性         | Golang (`regexp`)                    | Perl / Python / Java (`PCRE-like`)                |
| :----------- | :----------------------------------- | :------------------------------------------------ |
| **核心算法** | Thompson NFA / DFA                   | 回溯法 (Backtracking)                             |
| **性能**     | **稳定**，线性时间 `O(m*n)`          | **不稳定**，通常很快，但最坏情况为指数级 `O(2^n)` |
| **反向引用** | **不支持**                           | 支持                                              |
| **环视**     | **不支持**                           | 支持                                              |
| **安全性**   | **高**，可安全处理不可信的正则表达式 | **低**，恶意构造的表达式可导致 ReDoS 攻击         |
| **语法标准** | RE2                                  | PCRE                                              |

### 基本使用示例

下面是一个简单的 Go 代码示例，展示了如何使用 `regexp` 包。

```go
package main

import (
	"fmt"
	"regexp"
)

func main() {
	// 1. 编译正则表达式。推荐使用 MustCompile，如果表达式非法会直接 panic。
	// 匹配一个或多个数字
	re := regexp.MustCompile(`\d+`)

	text := "hello 123 world 456"

	// 2. 检查字符串是否包含匹配项
	matched := re.MatchString(text)
	fmt.Printf("Text contains numbers? %v\n", matched) // 输出: Text contains numbers? true

	// 3. 查找第一个匹配的子串
	firstMatch := re.FindString(text)
	fmt.Printf("First number found: %s\n", firstMatch) // 输出: First number found: 123

	// 4. 查找所有匹配的子串
	allMatches := re.FindAllString(text, -1) // -1 表示查找所有
	fmt.Printf("All numbers found: %v\n", allMatches) // 输出: All numbers found: [123 456]

	// 5. 查找子匹配（捕获组）
	// 匹配 "key=value" 格式
	reSubmatch := regexp.MustCompile(`(\w+)=(\w+)`)
	textSubmatch := "user=admin role=guest"

	// FindStringSubmatch 返回一个切片：
	// 第一个元素是整个匹配的字符串
	// 后续元素是每个捕获组匹配的内容
	submatches := reSubmatch.FindStringSubmatch(textSubmatch)
	fmt.Printf("Full match: %s, Key: %s, Value: %s\n", submatches[0], submatches[1], submatches[2])
	// 输出: Full match: user=admin, Key: user, Value: admin

	// 查找所有的子匹配
	allSubmatches := reSubmatch.FindAllStringSubmatch(textSubmatch, -1)
	for _, match := range allSubmatches {
		fmt.Printf("Found: %s (Key: %s, Value: %s)\n", match[0], match[1], match[2])
	}
	// 输出:
	// Found: user=admin (Key: user, Value: admin)
	// Found: role=guest (Key: role, Value: guest)
}
```

### 总结

Golang 的正则表达式引擎是其工程实用主义哲学的完美体现：**为了获得稳定、可预测的性能和安全性，果断舍弃了那些虽然强大但会带来理论和性能问题的复杂功能**。对于绝大多数日常的文本处理和验证任务，它的功能完全足够，并且性能让人非常放心。
